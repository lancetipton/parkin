System.register(["./wait-26c5e7c6-2112d3c7.js","./globalScope-fc1eb958.js"],(function(e){"use strict";var t,r,n,s,i,o,a,c,u,l,h,p,d,g,m,f,$,x;return{setters:[function(e){t=e.i,r=e.a,n=e.b,s=e.c,i=e.n,o=e.d,a=e.e,c=e._,u=e.f,l=e.g,h=e.h,p=e.j},function(e){d=e.h,g=e.r,m=e.a,f=e.b,$=e.c,x=e.d}],execute:function(){const equalsNaN=e=>"number"==typeof e&&e!=e,exists=e=>e==e&&null!=e,eitherArr=(e,r)=>t(e)?e:r,isColl=e=>"object"==typeof e&&null!==e,get=(e,r,s)=>((e,r,s,i)=>{const o=e;if(!isColl(e)||!e||!r)return"set"!==s&&i||void 0;const a=t(r)?Array.from(r):r.split("."),c=a.pop();let u,l;for(;u=a.shift();){const t=e[u];if(isColl(t)||n(t)?e=t:("set"===s?e[u]={}:l=!0,e=e[u]),l)return i}return"get"===s?c in e?e[c]:i:"unset"===s?delete e[c]:(e[c]=i)&&o||o})(e,r,"get",s),getRegexSource=e=>{return t=e,Boolean(t&&t instanceof RegExp)?e.source:r(e)?e:null;var t},joinRegex=(...e)=>{const[n,s]=(e=>{if(t(e[0]))return[e[0],e[1]];const n=e[e.length-1],s=r(n)?n:void 0;return[s?e.splice(0,e.length-1):e,s]})(e),i=n.reduce(((e,t)=>{const r=getRegexSource(t);return r?""===e?r:`${e}|${r}`:e}),"");return new RegExp(`(${i})`,s)},capitalize=(e,t=!0)=>{if(!r(e)||!e[0])return e;const n=t?e.slice(1).toLowerCase():e.slice(1);return`${e[0].toUpperCase()}${n}`},w=['"',"'"],isQuoted=(e,t=w)=>r(e)&&t.some((t=>e.startsWith(t)&&e.endsWith(t))),reverseStr=e=>{if(!r(e))return;let t="";for(let r of e)t=r+t;return t},getRXMatch=(e,t,r)=>{const n=e.match(t)[r];return n?n.trim():" "},sanitizeForId=(e,t)=>{const r=e&&e.trim()&&e.trim().toLowerCase().replace(/[\s\/\\\(\)\+=_&%\$#@!\*~`\|\?:;"'<>,.{}]/g,"-");return r?`${r}-${e.length}`:`${t}-${t.length}`},removeQuotes=e=>e.trim().replace(/^("|')/,"").replace(/("|')$/,""),y=/\w*\([^)]*?\)/,E=/\s*\S*\/\S*\s*/,b=/\s*{(.*?)}\s*/,S=joinRegex(b,y,"g"),R=/(.*)/,k=/{|}/g,_=/^["]?\$world\.\S+["]?/,A=/(\$:world|\$world)+\.[^"'\s]*/gm,checkWorldValue=(e,t)=>(r,n)=>{const i=r.match(_);if(!s(n)||!i)return matchType(e(r),t);const o=get(n,removeQuotes(r).replace("$world.",""));return exists(o)?matchType(o,t):((e,t)=>{throw new Error(`Can not replace ${e} with value from $world, it does not exist on the world object`,t,e)})(r,n)},matchType=(e,t)=>typeof e===t?e:null,T={name:"",regex:"",type:"string",useForSnippets:!0,preferForRegexpMatch:!1,transformer:checkWorldValue((e=>e),"string")},v={any:{...T,name:"any",regex:R},word:{...T,name:"word",regex:R,transformer:checkWorldValue((e=>{return isQuoted(e)?void 0:null==(t=e)?"":r(t)?t:JSON.stringify(t);var t}),T.type)},float:{...T,name:"float",type:"number",regex:/-?[0-9]+[.][0-9]+/,transformer:checkWorldValue((e=>{const t=parseFloat(e);return equalsNaN(t)?void 0:t}),"number")},int:{...T,name:"int",type:"number",regex:/-?[0-9]+/,transformer:checkWorldValue((e=>{const t=parseInt(e);return equalsNaN(t)||e.includes(".")?void 0:t}),"number")},string:{...T,name:"string",regex:joinRegex(/"[^"]+"/,/'[^']+'/),transformer:checkWorldValue((e=>isQuoted(e)?removeQuotes(e):void 0),T.type)}},getParamTypes=()=>v,registerParamType=(e=i,t=e.name)=>v[t]?(()=>{throw new Error(`Cannot register param type "${name}". It already exists!`)})():(v[t]={...T,...e},v[t].transformer=checkWorldValue(v[t].transformer,v[t].type),v),matchRegex=(e,t)=>{const r=t.match(new RegExp(e.match));return r?{definition:e,match:r.slice(1,r.length).filter(Boolean)}:i},toAlternateRegex=e=>{const t=e.split(/(\(|\))/),[r,,n,,s]=t;return""===r&&""===s?e+"?":""===r?`(${n}|${n}${s})`:""===s?`(${r}|${r}${n})`:`(${r}${s}|${r}${n}${s})`},getFullOptionalText=e=>((e,t,r=[" "])=>{const n=reverseStr(e),s=e.length-t;return reverseStr(((e,t,r=[" "])=>{const n=((e,t,r)=>r.map((r=>e.indexOf(r,t))).sort().find((e=>e>=0)))(e,t,r);return e.substring(t,-1===n?e.length:n)})(n,s,r))})(e.input,e.index)+e[0],getParamRegex=e=>{const t=getParamTypes();return(t[e]||t.any).regex.source},getAlternateRegex=e=>`(${e.trim().replace(/\//g,"|")})`,getMatchRegex=(e,t)=>{const[r,n]=t;switch(e){case"parameter":return new RegExp(getParamRegex(n));case"optional":return new RegExp((e=>{const t=getFullOptionalText(e);return toAlternateRegex(t)})(t));case"alternate":return new RegExp(getAlternateRegex(r));default:return null}},parseMatch=(e,t="other")=>{const r=e[0];return{text:r.trim(),index:e.index,input:e.input,regex:getMatchRegex(t,e),type:t,..."parameter"===t&&{paramType:r.trim().replace(k,"")}}},P=a({REGEX_VARIANT:"regex",WORLD_AT_RUNTIME:"$:",EXPRESSION_VARIANT:"expression",STEP_TYPES:["given","when","then","and","but"],HOOK_TYPES:["beforeAll","afterAll","beforeEach","afterEach"],FEATURE_META:["feature","perspective","desire","reason","comments"],LOG_JEST_SPEC_ENV:"PARKIN_LOG_JEST_SPEC",SPEC_RESULT_LOG:"------- PARKIN SPEC RESULT LOG -------"}),runRegexCheck=(e,t,r)=>{if(!t.test(e))return e;let s=e;return e.replace(t,((...e)=>{const t=e[0].trim(),[i,...o]=s.split(t),a=n(r)?r(...e):r;s=`${i}${a}${o.join(t)}`})),s},extractParameters=(e,t,r)=>{const n=[...[...(s=t).matchAll(new RegExp(b,"gi"))].map((e=>parseMatch(e,"parameter"))),...[...s.matchAll(new RegExp(y,"gi"))].map((e=>parseMatch(e,"optional"))),...[...s.matchAll(new RegExp(E,"gi"))].map((e=>parseMatch(e,"alternate")))].sort(((e,t)=>e.index-t.index));var s;const i=n.filter((e=>"parameter"===e.type)).length,o=n.reduce(((t,n)=>{const{params:s,textIndex:i,wordMatchIndex:o}=t,a=e.substring(i),c="word"===n.paramType,u=a.match(n.regex),l={0:r[o],index:a.indexOf(r[o])},h=c?l:u;return h?("parameter"===n.type&&h&&s.push(h[0]),{params:s,textIndex:i+(h&&h.index+h[0].length),wordMatchIndex:o+(c&&1)}):t}),{params:[],textIndex:0,wordMatchIndex:0});return i===o.params.length?o.params:null},matchExpression=(e,t,r)=>{if(e.match===t)return{definition:e,match:[]};const n=(s=e.match,d?s.replace(/[|\\[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d"):s.replace(/[|\\[\]^$+*?.]/g,"\\$&"));var s;const{regex:a}=(e=>({regex:runRegexCheck(e,new RegExp(E,"g"),getAlternateRegex),altIndexes:[]}))(n),{regex:c,transformers:u}=(e=>{const t=getParamTypes(),r=[];return{regex:runRegexCheck(e,S,((e,...n)=>{const s=e.trim().replace(k,""),i=e.match(b),o=e.match(y);return i&&r.push(t[s]||t.any),i?getParamRegex(s):o?toAlternateRegex(e):e})),transformers:r}})(a),{regex:l}=(e=>{let t=e;return e.startsWith("^")||(t="^"+t),e.endsWith("$")||(t+="$"),{regex:t}})(c),h=matchRegex({...e,match:l},t);if(!h||!h.definition||!h.match)return i;const p=extractParameters(t,e.match,h.match);if(!p)return i;const g=((e,t,r)=>e.map(((e,n)=>{const s=t[n]||v.any;return o(s.transformer,e,r)})).filter(exists))(p,u,r);return g.length!==p.length?i:{definition:e,match:g}},{REGEX_VARIANT:I}=P,{REGEX_VARIANT:O,EXPRESSION_VARIANT:j,STEP_TYPES:N}=P,registerFromCall=function(e,t,r,n,s=i){const o={type:t,meta:s,match:r,method:n,tokens:[],variant:0===r.toString().indexOf("/")?O:j};o.name=(e=>{let t=e.match.toString();return"/"===t[0]&&(t=t.substr(1)),"^"===t[0]&&(t=t.substr(1)),"/"===t.charAt(t.length-1)&&(t=t.slice(0,-1)),"$"===t.charAt(t.length-1)&&(t=t.slice(0,-1)),t.replace(/\(\?:([^\|]+)+\|+([^\)]+)?\)/,"$1")})(o),o.uuid=sanitizeForId(`${t}-${o.name}`),o.content=(e=>{const t=e.variant===O?e.match.toString():`"${e.match}"`;return`${capitalize(e.type)}(${t}, ${e.method.toString()})`})(o);const a=((e,t)=>t.reduce(((e,t)=>!(!e||t.content===e.content)&&(t.uuid===e.uuid&&(e.uuid=`${e.uuid}-${e.content.length}`),e)),{...e}))(o,this.list());return a&&this[e].push(a),a},registerFromParse=function(e){const t=this.types.map((e=>capitalize(e))),r=t.reduce(((e,t)=>(e[t]=[],e)),{});return eitherArr(e,[e]).map((e=>{Function(`return (global, require, module, ${t.join(",")}) => {\n          return (function(global) { ${e} }).call(global, global)\n        }`)()(g(),m(),f(),...t.map((e=>((e,t,r)=>(...n)=>{const s=e[t](...n);return r[t].push(s),s})(this,e,r))))})),r};class Steps{constructor(e){c(this,"types",N),c(this,"list",(()=>{return(e=this).types.reduce(((t,r)=>t.concat(e[`_${r}`])),[]);var e})),c(this,"typeList",(()=>this.types.reduce(((e,t)=>{const r=`_${t}`;return e[r]=[...this[r]],e}),{}))),c(this,"match",(e=>{const t=((e,t,r)=>e.reduce(((e,n)=>e.match||!n.match?e:n.variant!==I?matchExpression(n,t,r):matchRegex(n,t)),i))(this.list(),e,this._world);return!(!t.match||!t.definition)&&(t.match.push(this._world),t)})),c(this,"resolve",(e=>{const t=this.match(e);return t?t.definition.method(...t.match):(e=>{throw new ReferenceError(e)})(`Matching definition could not be found for step: "${e}"`)})),c(this,"register",((...e)=>r(e[0])?registerFromCall.apply(this,e):registerFromParse.apply(this,e))),c(this,"clear",(()=>{this.types.map((e=>this[`_${e}`]=[]))})),this._world=e||{};const t=this;this.types.map((e=>{const r=`_${e}`;this[r]=[],this[capitalize(e)]=(n,s,i)=>t.register(r,e,n,s,i)}))}}const{HOOK_TYPES:F}=P;class Hooks{constructor(){c(this,"types",F),c(this,"getRegistered",(e=>this.types.includes(e)?this._registeredHooks[e]||u:((e,t)=>{throw new Error([`Expected client hook type to be one of ', ${e}.`,`Found: ${t}`].join("\n"))})(F.join(", "),e))),this._registeredHooks={},this.types.map((e=>{this[e]=t=>{n(t)&&(this._registeredHooks[e]=t)}}))}}const L=/^\s*?"""\s*?/,C=/^\s*?```\s*?/,M=/^\s*?\|/,W=[{regex:/^\s*Given (.*)$/,type:"given"},{regex:/^\s*When(.*)$/,type:"when"},{regex:/^\s*Then (.*)$/,type:"then"},{regex:/^\s*And (.*)$/,type:"and"},{regex:/^\s*But (.*)$/,type:"but"},{regex:/^\s*\* (.*)$/,type:"and"}],stepFactory=(e,t,r,n)=>{let s={type:e,index:n,step:t,uuid:sanitizeForId(`${e}-${t}`)};const i=n+1,o=r[i],a=r.slice(i);return s=((e,t,r,n)=>{if(!M.test(r))return e;let s;return e.table={index:n,content:t.reduce(((e,t)=>(s=s||!M.test(t),!s&&e.push(t.split("|").reduce(((e,t)=>{const r=t.trim();return r&&e.push(r),e}),[])),e)),[])},e})(s,a,o,i),s=((e,t,r,n)=>{let s=L.test(r)&&'"""';if(s=s||C.test(r)&&"```",!s)return e;const i=r.split(s)[0],o=new Array(i.length).fill("\\s").join(""),a=new RegExp(`^${o}`);return e.doc={index:n,whiteSpace:i,type:'"""'===s?"quote":"tick",content:t.split(s).slice(1).shift().trim().split("\n").reduce(((e,t)=>(e.push(t.replace(a,"").trim()),e)),[]).join("\n")},e})(s,a.join("\n"),o,i),s},{WORLD_AT_RUNTIME:G}=P,worldReplace=(e,t)=>{let r;try{return e.replace(A,(e=>{r=e;const s=e.trim();if(0===s.indexOf(G))return s.replace(G,"$");const i=s.replace(/^\$world\./,""),o=get(t,i);return n(o)?o(t,path):exists(o)?o:e}))}catch(e){((e,t)=>{throw console.log(`Error in $world replace of text content. Current match was ${t}`),e})(e,r)}},H=/\r?\n/g,U=/^\s*@(.*)$/,B=/^\s*#(.*)$/,V=/^\s*Feature:(.*)$/,D=/^\s*Rule:(.*)$/,K=/^\s*Scenario:(.*)$/,q=/^\s*Example:(.*)$/,J=/^\s*Background:(.*)$/,X=[{regex:/^\s*As (.*)$/,key:"perspective"},{regex:/^\s*I want (.*)$/,key:"desire"},{regex:/^\s*So that (.*)$/,key:"reason"},{regex:/^\s*In order (.*)$/,key:"reason"}],featureFactory=(e,t,r)=>({index:r,content:t,feature:e,tags:[],rules:[],reason:[],comments:[],scenarios:[],...e&&{uuid:sanitizeForId(e,r)}}),ruleFactory=(e,t)=>({index:t,rule:e,tags:[],scenarios:[],...e&&{uuid:sanitizeForId(e,t)}}),scenarioFactory=(e,t)=>({index:t,scenario:e,tags:[],steps:[],...e&&{uuid:sanitizeForId(e,t)}}),backgroundFactory=(e,t)=>({index:t,steps:[],background:e,...e&&{uuid:sanitizeForId(e,t)}}),parseFeature=function(e,t){t=t||this&&this.world||i;const r=worldReplace((e||"").toString(),t).split(H);let n=ruleFactory(!1),s=scenarioFactory(!1),o=backgroundFactory(!1),a=featureFactory(!1,e),c=a;return r.reduce(((t,i,u)=>(a=((e,t,r,n,s)=>{if(!V.test(r))return t;const i=getRXMatch(r,V,1);if(!t.feature)return t.feature=i,t.index||(t.index=s),t.uuid||(t.uuid=sanitizeForId(t.feature,s)),!e.includes(t)&&e.push(t),t;const o=featureFactory(i,n,s);return e.push(o),o})(t,a,i,e,u),((e,t,r)=>{if(!B.test(t))return!1;const n=t.match(B)[0];return e.comments.push({content:n,index:r}),!0})(a,i,u)||((e,t,r)=>{let n=!1;return X.reduce(((s,i)=>{if(s)return s;const o=i.regex.test(t);return!n&&o&&(n=!0),o?"reason"===i.key?((e,t,r)=>{t&&e.reason.push({content:t,index:r})})(e,getRXMatch(t,i.regex,0),r):e[i.key]={content:getRXMatch(t,i.regex,0),index:r}:o}),!1),n})(a,i,u)?t:(n=((e,t,r,n)=>{if(!D.test(r))return t;let s=getRXMatch(r,D,1);return t.rule?t=ruleFactory(s,n):t.rule=s,!t.index&&(t.index=n),!t.uuid&&(t.uuid=sanitizeForId(t.rule,n)),!e.rules.includes(t)&&e.rules.push(t),t})(a,n,i,u),s=((e,t,r,n,s)=>{const i=K.test(n);if(!i&&!q.test(n))return r;let o=i&&getRXMatch(n,K,1);o=o||getRXMatch(n,q,1),r.scenario?r=scenarioFactory(o,s):r.scenario=o,!r.index&&(r.index=s),!r.uuid&&(r.uuid=sanitizeForId(r.scenario,s));const a=t.uuid?t:e;return!a.scenarios.includes(r)&&a.scenarios.push(r),r})(a,n,s,i,u),o=((e,t,r,n,s)=>{if(!J.test(n))return r;const i=t.uuid?t:e,o=`${i.uuid}-background`;return r.background?r=backgroundFactory(o,s):r.background=o||"",!r.index&&(r.index=s),!r.uuid&&(r.uuid=sanitizeForId(r.background,s)),i.background=r,r})(a,n,o,i,u),((e,t,r,n)=>W.reduce(((s,i)=>{if(s)return s;const o=i.regex.test(r);return o&&e.steps.push(stepFactory(i.type,getRXMatch(r,i.regex,1),t,n)),o}),!1))(c,r,i,u)||(c=((e,t,r,n,s,i)=>K.test(i)||q.test(i)?n:V.test(i)?t:D.test(i)?r:J.test(i)?s:e)(c,a,n,s,o,i),((e,t,r,n)=>{if(!U.test(r))return!1;const s=e.background?t:e,i=getRXMatch(r,U,0);s.tags=(s.tags||[]).concat(i.split(" "))})(c,a,i)),t))),[])},parseDefinition=function(e){return this.steps.register([e])},{SPEC_RESULT_LOG:Y,LOG_JEST_SPEC_ENV:z}=P,logResultToTerminal=e=>{const t=(new Date).getTime();get(process,`env.${z}`)&&process.stdout.write([Y,JSON.stringify({...e,timestamp:t}),Y].join(""))},getSuiteData=e=>{const t=get(e,"description"),r=t?t.startsWith("Scenario >")?"Scenario":t.startsWith("Background >")?"Background":t.startsWith("Rule >")?"Rule":"Feature":"Feature";return{type:r.toLowerCase(),..."Feature"!==r&&{description:t.replace(`${r} >`,`${r}:`)}}},getTestMethod=(e,t)=>t?u:global[e]||(e=>()=>{throw new Error(`Test method ${e} does not exist on the global scope.\nPlease ensure ${e} exists before calling the run method!\n`)})(e),skipTestsOnFail=e=>{if(!$)return;const t=x().getEnv();t&&t.describe&&t.addReporter((e=>{const t=[],r=e.describe;return e.describe=(...e)=>{const n=r.apply(null,e);return t.push(n),n},{suiteStarted:e=>{logResultToTerminal({...e,...getSuiteData(e),action:"start"})},specStarted:e=>{logResultToTerminal({...e,type:"step",action:"start"})},specDone:e=>{if(logResultToTerminal({...e,type:"step",action:"end"}),"failed"!==e.status)return;const r=t.find((t=>t.children.find((t=>t.result===e))));r&&r.children.map((e=>e.disable()))},suiteDone:e=>{logResultToTerminal({...e,...getSuiteData(e),action:"end"})}}})(t))},buildTitle=(e,t)=>`${capitalize(t)} > ${e}`,resolveFeatures=(e,n)=>r(e)?parseFeature(e,n):s(e)?[e]:t(e)?e.reduce(((e,t)=>e.concat(resolveFeatures(t,n))),[]):(()=>{throw new Error("Runner class requires feature text when calling the run method")})(),loopSteps=(e,t,r,n)=>(getTestMethod("describe",n)(t,(()=>{const t=e.steps.map((e=>(async(e,t,r)=>{getTestMethod("test",r)(`${capitalize(t.type)} ${t.step}`,(async()=>await e.resolve(t.step)))})(r,e,n)));Promise.all(t)})),[]),runScenario=(e,t,r,n)=>(r&&loopSteps(r,buildTitle(t.scenario,"Background"),e,n),loopSteps(t,buildTitle(t.scenario,"Scenario"),e,n)),runRule=(e,t,r,n)=>{let s=[];return describe(`Rule > ${t.rule}`,(()=>{s=t.scenarios.map((s=>runScenario(e,s,r||t.background,n))),Promise.all(s)})),s},itemMatch=(e="",t=[],n={})=>{const{name:s,tags:i}=n,o=r(i)?(e=>r(e)&&e.match(/[@]\w*/g))(i):eitherArr(i,[]),a=!s||e.includes(s),c=!o.length||o.every((e=>t.includes(e)));return a&&c};class Runner{constructor(e,t,r){c(this,"getFeatures",((e,t)=>((e,t={})=>e.reduce(((e,r)=>{if(itemMatch(r.feature,r.tags,t))return e.push(r),e;const n=r.scenarios.filter((e=>itemMatch(e.scenario,[...e.tags||[],...r.tags||[]],t)));return n.length&&e.push({...r,scenarios:n}),e}),[]))(resolveFeatures(e,this._world),t))),c(this,"run",(async(e,t=i)=>{const r=this.run.PARKIN_TEST_MODE;skipTestsOnFail();const n=getTestMethod("describe",r),s=getTestMethod("beforeAll",r),o=getTestMethod("afterAll",r),a=getTestMethod("beforeEach",r),c=getTestMethod("afterEach",r),u=this.getFeatures(e,t);if(!u.length)return!1;const l=await u.map((async e=>{let t=[];return s(this.hooks.getRegistered("beforeAll")),o(this.hooks.getRegistered("afterAll")),a(this.hooks.getRegistered("beforeEach")),c(this.hooks.getRegistered("afterEach")),n(buildTitle(e.feature,"Feature"),(()=>{t=e.rules.map((t=>runRule(this.steps,t,e.background,r))),t.concat(e.scenarios.map((t=>runScenario(this.steps,t,e.background,r)))),Promise.all(t)})),t}));return await Promise.all(l),!0})),!e&&(()=>{throw new Error("Runner class constructor requires an instance of the Steps class")})(),!t&&throwMissingHooks(),this.steps=e,this.hooks=t,this._world=r}}const{FEATURE_META:Q}=P,addContent=(e,t,r)=>{exists(r)?exists(e[r])?e.splice(r,0,t):e[r]=t:e.push(t)},addTags=(e,r,n="")=>{t(r)&&r.length&&addContent(e,`${n}${r.join(" ")}`)},addScenarios=(e,r)=>{r.scenarios&&r.scenarios.map((r=>{addTags(e,r.tags,"  "),addContent(e,`  Scenario: ${r.scenario}`,r.index),((e,r)=>{t(r.steps)&&r.steps.length&&r.steps.map((t=>addContent(e,`    ${capitalize(t.type)} ${t.step}`,t.index)))})(e,r)}))},formatAssembled=e=>Array.from(e,((t,r)=>exists(t)?t.startsWith("#")?((e,t,r)=>{const n=e[r+1],s=e[r-1];let i=exists(n)?n:s;if(!i)return`${t}\n`;const o=t.split("#").pop();return`${Array(i.length-i.trimStart().length).join(" ")} # ${o}\n`})(e,t,r):`${t}\n`:"\n")).join("").trim(),Z={feature:e=>eitherArr(e,[e]).map((e=>{let r=[];return!s(e)&&(e=>{throw new Error("Assemble feature requires an object matching the feature model spec!",e)})(e),addTags(r,e.tags),((e,r)=>{Q.map((n=>{switch(n){case"feature":addContent(e,`Feature: ${r[n]}`,r.index);break;case"comments":t(r[n])&&r[n].map((t=>addContent(e,t.content,t.index)));break;case"reason":t(r[n])&&r[n].map((t=>addContent(e,`  ${t.content}`,t.index)));break;case"desire":case"perspective":r[n]&&addContent(e,`  ${r[n].content}`,r[n].index)}}))})(r,e),addScenarios(r,e),formatAssembled(r)}))};var ee=new WeakMap;class Parkin{constructor(e,t){l(this,ee,{writable:!0,value:!1}),c(this,"init",((e=i,t)=>{if(h(this,ee))return console.warn("This instance of parkin has already been initialized!");p(this,ee,!0),this.world=e,this.steps=new Steps(this.world),this.hooks=new Hooks(this.world),this.runner=new Runner(this.steps,this.hooks,this.world),this.run=this.runner.run,this.parse={feature:parseFeature.bind(this),definition:parseDefinition.bind(this)},this.assemble=Z,this.paramTypes={register:registerParamType},s(t)&&this.registerSteps(t),this.steps.types.map((e=>{this[capitalize(e)]=(t,r,n)=>this.steps.register(`_${e}`,e,t,r,n)}))})),c(this,"registerSteps",(e=>{Object.entries(e).map(((e,t)=>Object.entries(t).map(((t,r)=>this.steps[capitalize(e)](t,...eitherArr(r,[r]))))))})),s(e)&&this.init(e,t)}}e("Parkin",Parkin);e("PKInstance",new Parkin)}}}));
