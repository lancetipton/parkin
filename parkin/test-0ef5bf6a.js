System.register(["./wait-26c5e7c6-2112d3c7.js"],(function(t){"use strict";var e,s,i,a,r,o,n,h,c,d,l;return{setters:[function(t){e=t.i,s=t.a,i=t.n,a=t.b,r=t.c,o=t._,n=t.g,h=t.h,c=t.j,d=t.f,l=t.d}],execute:function(){const keyMap=(t,i)=>e(t)&&t.reduce(((t,e)=>{if(!s(e))return t;const a=i&&e.toUpperCase()||e;return t[a]=a,t}),{})||{},p=keyMap(["beforeAll","beforeEach","afterAll","afterEach"]),u={...t("g",{...keyMap(["test","it","xtest","xit","describe"]),...p}),...keyMap(["root"])},throwError=t=>{throw new Error(t)},createItem=(t,e=i,r=!0)=>{const{description:o,action:n}=e;return r&&((t,e,i)=>{!s(t)&&throwError("Test item type is required as a string"),!a(i)&&throwError(`The ${t} method requires a "function" as the second argument`),!s(e)&&throwError(`The ${t} method requires a "string" as the first argument`)})(t,o,n),{...e,type:t}},createRoot=()=>createItem(u.root,{describes:[],...Object.values(p).reduce(((t,e)=>(t[e]=[],t)),{})},!1),runResult=(t,{id:e,fullName:s,action:i,failed:a,passed:o,testPath:n})=>{const h={id:e,action:i,testPath:n,fullName:s,type:t.type,failedExpectations:[],passedExpectations:[],failed:Boolean(a),passed:Boolean(o),description:t.description,timestamp:(new Date).getTime()};return r(a)&&h.failedExpectations.push(a),r(o)&&h.passedExpectations.push(o),(o||a)&&(h.status=o?"passed":"failed"),h},loopHooks=async t=>{const{type:e,test:s,specId:i,suiteId:a,describe:r,root:o}=t;let n;const h=o||r,c=o?o.description:s?`${null==r?void 0:r.description} > ${null==s?void 0:s.description} > ${e}`:`${null==r?void 0:r.description} > ${e}`;try{h[e].length&&await Promise.all(h[e].map(((t,e)=>(n=e,t()))))}catch(t){return runResult(h,{fullName:c,action:e,status:"failed",id:s?i:a,failed:{name:t.name,message:t.message},testPath:s?`/${a}/${i}/${e}${n}`:`/${a}/${e}${n}`})}},loopTests=async t=>{const{suiteId:e,describe:s,testOnly:i,specDone:a,specStarted:r}=t;let o=!1;const n=[];for(let t=0;t<s.tests.length;t++){const h=s.tests[t],c=`spec${t}`,d=`/${e}/${c}`,l=`${s.description} > ${h.description}`;let p=runResult(h,{fullName:l,testPath:d,id:c,action:"start"});if(i&&!h.only||h.skip){r({...p,skipped:!0,action:"skipped",status:"skipped"});continue}r(p);const b=await loopHooks({test:h,specId:c,suiteId:e,describe:s,type:u.beforeEach});if(b){o=!0,n.push(b),a(b);break}try{const t=await h.action();p=runResult(h,{fullName:l,id:c,testPath:d,action:u.test,passed:t||!0})}catch(t){p=runResult(h,{fullName:l,id:c,action:u.test,testPath:d,failed:{name:t.name,message:t.message}}),o=!0}const f=await loopHooks({test:h,specId:c,suiteId:e,describe:s,type:u.afterEach});if(f){o=!0,n.push(f),a(f);break}n.push(p),a({...p,action:"end"})}return{tests:n,failed:o}},callBeforeHooks=async({root:t,suiteId:e,describe:s})=>{const i=await loopHooks({root:t,suiteId:u.root,type:u.beforeEach}),a=!i&&await loopHooks({suiteId:e,describe:s,type:u.beforeAll});return i||a},callAfterHooks=async({root:t,suiteId:e,describe:s})=>{const i=await loopHooks({root:t,suiteId:u.root,type:u.afterEach}),a=!i&&await loopHooks({suiteId:e,describe:s,type:u.afterAll});return i||a},loopDescribes=async t=>{const{root:e,testOnly:s,specDone:i,suiteDone:a,specStarted:r,parentIdx:o="",suiteStarted:n,describeOnly:h}=t;let c=!1;const d=[];for(let l=0;l<e.describes.length;l++){const p=e.describes[l],u=`suite-${o}${l}`;let b=runResult(p,{id:u,action:"start",testPath:`/${u}`,fullName:p.description});if(p.skip||h&&!p.only&&!p.onlyChild||s&&!p.onlyChild){n({...b,skipped:!0,action:"skipped",status:"skipped"});continue}n(b);const f=await callBeforeHooks({root:e,suiteId:u,describe:p});if(f){c=!0,b={...b,...f},a(b),d.push(b);continue}const w=await loopTests({suiteId:u,describe:p,testOnly:s,specDone:i,specStarted:r}),y=p.describes&&p.describes.length&&await loopDescribes({...t,root:p,parentIdx:`${l}-`});b={...b,...y,action:"end",tests:w.tests},w.failed||y.failed?(c=!0,b.failed=!0):b.passed=!0;const m=await callAfterHooks({root:e,suiteId:u,describe:p});m?(c=!0,b={...b,...m},a(b),d.push(b)):(a(b),d.push(b))}return{describes:d,failed:c}},run=async t=>{var e;(e=t.root).type!==u.root&&throwError(`Invalid root type "${e.type}" set for root object`),!e.describes||!e.describes.length&&throwError("No tests have been registered to this ParkinTest instance");const s=await loopHooks({root:t.root,suiteId:u.root,type:u.beforeAll});if(s)return[s];const{describes:i}=await loopDescribes(t),a=await loopHooks({root:t.root,suiteId:u.root,type:u.afterAll});return a&&i.push(a),i};var b=new WeakMap,f=new WeakMap,w=new WeakMap,y=new WeakMap,m=new WeakMap,k=new WeakMap,$=new WeakMap,v=new WeakMap,g=new WeakMap,I=new WeakMap,M=new WeakMap,W=new WeakMap,x=new WeakMap,O=new WeakMap;t("P",class ParkinTest{constructor(t=i){o(this,"timeout",6e3),n(this,b,{writable:!0,value:d}),n(this,f,{writable:!0,value:d}),n(this,w,{writable:!0,value:d}),n(this,y,{writable:!0,value:d}),n(this,m,{writable:!0,value:void 0}),n(this,k,{writable:!0,value:!1}),n(this,$,{writable:!0,value:!1}),n(this,v,{writable:!0,value:!0}),n(this,g,{writable:!0,value:createRoot()}),o(this,"run",((t=i)=>{t.description&&(h(this,g).description=t.description),h(this,I).call(this,t);const e=run({root:h(this,g),testOnly:h(this,k),specDone:h(this,b),suiteDone:h(this,f),specStarted:h(this,w),describeOnly:h(this,$),suiteStarted:h(this,y)});return h(this,v)&&this.clean(),e})),o(this,"clean",(()=>{this.timeout=6e3,c(this,v,!0),c(this,k,!1),c(this,$,!1),c(this,m,void 0),c(this,g,void 0),c(this,g,createRoot()),c(this,m,h(this,g))})),o(this,"getActiveParent",(()=>h(this,m))),n(this,I,{writable:!0,value:({timeout:t,autoClean:e,specDone:s,suiteDone:i,specStarted:a,suiteStarted:r})=>{t&&(this.timeout=t),s&&c(this,b,s),i&&c(this,f,i),a&&c(this,w,a),r&&c(this,y,r),!1===e&&c(this,v,e)}}),n(this,M,{writable:!0,value:()=>{this.describe.only=(...t)=>{this.describe(...t);h(this,m).describes[h(this,m).describes.length-1].only=!0,c(this,$,!0),l(h(this,m).hasOnlyChild)},this.test.only=(...t)=>{this.test(...t);h(this,m).tests[h(this,m).tests.length-1].only=!0,c(this,k,!0),l(h(this,m).hasOnlyChild)}}}),n(this,W,{writable:!0,value:()=>{this.describe.skip=(...t)=>{this.describe(...t);h(this,m).describes[h(this,m).describes.length-1].skip=!0},this.test.skip=(...t)=>{this.test(...t);h(this,m).tests[h(this,m).tests.length-1].skip=!0}}}),n(this,x,{writable:!0,value:()=>{}}),n(this,O,{writable:!0,value:()=>{Object.values(p).map((t=>{this[t]=e=>{((t,e,s)=>{!a(e)&&throwError(`The ${t} method requires a "function" as the first argument`)(!s||s.type===u.root)&&throwError(`The ${t} method must be called within a ${u.describe} method`)})(t,e,h(this,m)),h(this,m)[t].push(e)}}))}}),o(this,"describe",((t,e)=>{const s=((t,e)=>{const s=createItem(u.describe,{...createRoot(),action:e,tests:[],description:t});return s.disabled=()=>s.skip=!0,s})(t,e);h(this,m).describes.push(s);const i=h(this,m);s.hasOnlyChild=()=>{s.onlyChild=!0,l(i.hasOnlyChild)},c(this,m,s),e(),c(this,m,i)})),o(this,"test",((t,e,s)=>{h(this,m)&&h(this,m).type!==u.root||throwError(`All ${u.test} method calls must be called within a ${u.describe} method`);const i=createItem(u.test,{action:e,timeout:s,description:t});i.disabled=()=>i.skip=!0,h(this,m).tests.push(i)})),o(this,"xtest",(t=>{h(this,m)&&h(this,m).type!==u.root||throwError(`All ${u.test} method calls must be called within a ${u.describe} method`),!s(t)&&throwError(`The ${u.test} method requires a "string" as the first argument`);const e=createItem(u.test,{description:t,skip:!0},!1);e.disabled=()=>e.skip=!0,h(this,m).tests.push(e)})),h(this,g).description=t.description||"root",h(this,M).call(this),h(this,W).call(this),h(this,O).call(this),this.it=this.test,this.xit=this.xtest,c(this,m,h(this,g)),h(this,I).call(this,t)}})}}}));
