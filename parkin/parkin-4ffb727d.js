System.register(["./wait-26c5e7c6-fdf32dc0.js","./globalScope-9788190d.js"],(function(e){"use strict";var t,r,n,s,i,a,o,c,u,l,h,p,d,g,m,$,f,x,w;return{setters:[function(e){t=e.i,r=e.a,n=e.b,s=e.d,i=e.c,a=e.n,o=e.e,c=e._,u=e.f,l=e.g,h=e.h,p=e.j,d=e.k},function(e){g=e.h,m=e.r,$=e.a,f=e.b,x=e.c,w=e.d}],execute:function(){const equalsNaN=e=>"number"==typeof e&&e!=e,exists=e=>e==e&&null!=e,eitherArr=(e,r)=>t(e)?e:r,isColl=e=>"object"==typeof e&&null!==e,get=(e,r,s)=>((e,r,s,i)=>{const a=e;if(!isColl(e)||!e||!r)return"set"!==s&&i||void 0;const o=t(r)?Array.from(r):r.split("."),c=o.pop();let u,l;for(;u=o.shift();){const t=e[u];if(isColl(t)||n(t)?e=t:("set"===s?e[u]={}:l=!0,e=e[u]),l)return i}return"get"===s?c in e?e[c]:i:"unset"===s?delete e[c]:(e[c]=i)&&a||a})(e,r,"get",s),getRegexSource=e=>{return t=e,Boolean(t&&t instanceof RegExp)?e.source:r(e)?e:null;var t},joinRegex=(...e)=>{const[n,s]=(e=>{if(t(e[0]))return[e[0],e[1]];const n=e[e.length-1],s=r(n)?n:void 0;return[s?e.splice(0,e.length-1):e,s]})(e),i=n.reduce(((e,t)=>{const r=getRegexSource(t);return r?""===e?r:`${e}|${r}`:e}),"");return new RegExp(`(${i})`,s)},capitalize=(e,t=!0)=>{if(!r(e)||!e[0])return e;const n=t?e.slice(1).toLowerCase():e.slice(1);return`${e[0].toUpperCase()}${n}`},E=['"',"'"],isQuoted=(e,t=E)=>r(e)&&t.some((t=>e.startsWith(t)&&e.endsWith(t))),reverseStr=e=>{if(!r(e))return;let t="";for(let r of e)t=r+t;return t},y=s({ALIAS_REF:"$$",ALIAS_WORLD_KEY:"$alias",ALIAS_REF_AT_RUNTIME:"$$:",REGEX_VARIANT:"regex",WORLD_REF:"$",WORLD_KEY:"$world",WORLD_AT_RUNTIME:"$:",EXPRESSION_VARIANT:"expression",STEP_TYPES:["given","when","then","and","but"],HOOK_TYPES:["beforeAll","afterAll","beforeEach","afterEach"],FEATURE_META:["feature","perspective","desire","reason","comments"],LOG_JEST_SPEC_ENV:"PARKIN_LOG_JEST_SPEC",SPEC_RESULT_LOG:"------- PARKIN SPEC RESULT LOG -------"}),getRXMatch=(e,t,r)=>{const n=e.match(t)[r];return n?n.trim():" "},sanitizeForId=(e,t)=>{const r=e&&e.trim()&&e.trim().toLowerCase().replace(/[\s\/\\\(\)\+=_&%\$#@!\*~`\|\?:;"'<>,.{}]/g,"-");return r?`${r}-${e.length}`:`${t}-${t.length}`},removeQuotes=e=>e.trim().replace(/^("|')/,"").replace(/("|')$/,""),_=/\w*\([^)]*?\)/,R=/\s*\S*\/\S*\s*/,b=/\s*{(.*?)}\s*/,S=joinRegex(b,_,"g"),A=/(.*)/,k=/{|}/g,T=/^["]?\$world\.\S+["]?/,I=/^\$world\./,v=/(\$:world|\$world)+\.[^"'\s]*/gm,O=/^["]?\$\$\S+["]?/,L=/^\$\$/,P=/(\$\$:\w+|\$\$\w+)[^"'\s]*/gm,{WORLD_KEY:F,ALIAS_WORLD_KEY:j,ALIAS_REF:W}=y,checkWorldValue=(e,t)=>(r,n)=>{const s=r.match(T),a=r.match(O);if(!i(n)||!s&&!a)return matchType(e(r),t);const o=get(n,s?removeQuotes(r).replace(`${F}.`,""):removeQuotes(r).replace(`${W}`,`${j}.`));return exists(o)?matchType(o,t):s?((e,t)=>{throw new Error(`Can not replace ${e} with value from $world, it does not exist on the world object`,t,e)})(r,n):matchType(e(r),t)},matchType=(e,t)=>typeof e===t?e:null,N={name:"",regex:"",type:"string",useForSnippets:!0,preferForRegexpMatch:!1,transformer:checkWorldValue((e=>e),"string")},C={any:{...N,name:"any",regex:A},word:{...N,name:"word",regex:A,transformer:checkWorldValue((e=>{return isQuoted(e)?void 0:null==(t=e)?"":r(t)?t:JSON.stringify(t);var t}),N.type)},float:{...N,name:"float",type:"number",regex:/-?[0-9]+[.][0-9]+/,transformer:checkWorldValue((e=>{const t=parseFloat(e);return equalsNaN(t)?void 0:t}),"number")},int:{...N,name:"int",type:"number",regex:/-?[0-9]+/,transformer:checkWorldValue((e=>{const t=parseInt(e);return equalsNaN(t)||e.includes(".")?void 0:t}),"number")},string:{...N,name:"string",regex:joinRegex(/"[^"]+"/,/'[^']+'/),transformer:checkWorldValue((e=>isQuoted(e)?removeQuotes(e):void 0),N.type)}},getParamTypes=()=>C,registerParamType=(e=a,t=e.name)=>C[t]?(()=>{throw new Error(`Cannot register param type "${name}". It already exists!`)})():(C[t]={...N,...e},C[t].transformer=checkWorldValue(C[t].transformer,C[t].type),C),matchRegex=(e,t)=>{const r=t.match(new RegExp(e.match));return r?{definition:e,match:r.slice(1,r.length).filter(Boolean)}:a},toAlternateRegex=e=>{const t=e.split(/(\(|\))/),[r,,n,,s]=t;return""===r&&""===s?e+"?":""===r?`(${n}|${n}${s})`:""===s?`(${r}|${r}${n})`:`(${r}${s}|${r}${n}${s})`},getFullOptionalText=e=>((e,t,r=[" "])=>{const n=reverseStr(e),s=e.length-t;return reverseStr(((e,t,r=[" "])=>{const n=((e,t,r)=>r.map((r=>e.indexOf(r,t))).sort().find((e=>e>=0)))(e,t,r);return e.substring(t,-1===n?e.length:n)})(n,s,r))})(e.input,e.index)+e[0],getParamRegex=e=>{const t=getParamTypes();return(t[e]||t.any).regex.source},getAlternateRegex=e=>`(${e.trim().replace(/\//g,"|")})`,getMatchRegex=(e,t)=>{const[r,n]=t;switch(e){case"parameter":return new RegExp(getParamRegex(n));case"optional":return new RegExp((e=>{const t=getFullOptionalText(e);return toAlternateRegex(t)})(t));case"alternate":return new RegExp(getAlternateRegex(r));default:return null}},parseMatch=(e,t="other")=>{const r=e[0];return{text:r.trim(),index:e.index,input:e.input,regex:getMatchRegex(t,e),type:t,..."parameter"===t&&{paramType:r.trim().replace(k,"")}}},runRegexCheck=(e,t,r)=>{if(!t.test(e))return e;let s=e;return e.replace(t,((...e)=>{const t=e[0].trim(),[i,...a]=s.split(t),o=n(r)?r(...e):r;s=`${i}${o}${a.join(t)}`})),s},extractParameters=(e,t,r)=>{const n=[...[...(s=t).matchAll(new RegExp(b,"gi"))].map((e=>parseMatch(e,"parameter"))),...[...s.matchAll(new RegExp(_,"gi"))].map((e=>parseMatch(e,"optional"))),...[...s.matchAll(new RegExp(R,"gi"))].map((e=>parseMatch(e,"alternate")))].sort(((e,t)=>e.index-t.index));var s;const i=n.filter((e=>"parameter"===e.type)).length,a=n.reduce(((t,n)=>{const{params:s,textIndex:i,wordMatchIndex:a}=t,o=e.substring(i),c="word"===n.paramType,u=o.match(n.regex),l={0:r[a],index:o.indexOf(r[a])},h=c?l:u;return h?("parameter"===n.type&&h&&s.push(h[0]),{params:s,textIndex:i+(h&&h.index+h[0].length),wordMatchIndex:a+(c&&1)}):t}),{params:[],textIndex:0,wordMatchIndex:0});return i===a.params.length?a.params:null},matchExpression=(e,t,r)=>{if(e.match===t)return{definition:e,match:[]};const n=(s=e.match,g?s.replace(/[|\\[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d"):s.replace(/[|\\[\]^$+*?.]/g,"\\$&"));var s;const{regex:i}=(e=>({regex:runRegexCheck(e,new RegExp(R,"g"),getAlternateRegex),altIndexes:[]}))(n),{regex:c,transformers:u}=(e=>{const t=getParamTypes(),r=[];return{regex:runRegexCheck(e,S,((e,...n)=>{const s=e.trim().replace(k,""),i=e.match(b),a=e.match(_);return i&&r.push(t[s]||t.any),i?getParamRegex(s):a?toAlternateRegex(e):e})),transformers:r}})(i),{regex:l}=(e=>{let t=e;return e.startsWith("^")||(t="^"+t),e.endsWith("$")||(t+="$"),{regex:t}})(c),h=matchRegex({...e,match:l},t);if(!h||!h.definition||!h.match)return a;const p=extractParameters(t,e.match,h.match);if(!p)return a;const d=((e,t,r)=>e.map(((e,n)=>{const s=t[n]||C.any;return o(s.transformer,e,r)})).filter(exists))(p,u,r);return d.length!==p.length?a:{definition:e,match:d}},{REGEX_VARIANT:M}=y,{REGEX_VARIANT:D,EXPRESSION_VARIANT:G,STEP_TYPES:H}=y,registerFromCall=function(e,t,r,n,s=a){const i={type:t,meta:s,match:r,method:n,tokens:[],variant:0===r.toString().indexOf("/")?D:G};i.name=(e=>{let t=e.match.toString();return"/"===t[0]&&(t=t.substr(1)),"^"===t[0]&&(t=t.substr(1)),"/"===t.charAt(t.length-1)&&(t=t.slice(0,-1)),"$"===t.charAt(t.length-1)&&(t=t.slice(0,-1)),t.replace(/\(\?:([^\|]+)+\|+([^\)]+)?\)/,"$1")})(i),i.uuid=sanitizeForId(`${t}-${i.name}`),i.content=(e=>{const t=e.variant===D?e.match.toString():`"${e.match}"`;return`${capitalize(e.type)}(${t}, ${e.method.toString()})`})(i);const o=((e,t)=>t.reduce(((e,t)=>!(!e||t.content===e.content)&&(t.uuid===e.uuid&&(e.uuid=`${e.uuid}-${e.content.length}`),e)),{...e}))(i,this.list());return o&&this[e].push(o),o},registerFromParse=function(e){const t=this.types.map((e=>capitalize(e))),r=t.reduce(((e,t)=>(e[t]=[],e)),{});return eitherArr(e,[e]).map((e=>{Function(`return (global, require, module, ${t.join(",")}) => {\n          return (function(global) { ${e} }).call(global, global)\n        }`)()(m(),$(),f(),...t.map((e=>((e,t,r)=>(...n)=>{const s=e[t](...n);return r[t].push(s),s})(this,e,r))))})),r};class Steps{constructor(e){c(this,"types",H),c(this,"list",(()=>{return(e=this).types.reduce(((t,r)=>t.concat(e[`_${r}`])),[]);var e})),c(this,"typeList",(()=>this.types.reduce(((e,t)=>{const r=`_${t}`;return e[r]=[...this[r]],e}),{}))),c(this,"match",(e=>{const t=((e,t,r)=>e.reduce(((e,n)=>e.match||!n.match?e:n.variant!==M?matchExpression(n,t,r):matchRegex(n,t)),a))(this.list(),e,this._world);return!(!t.match||!t.definition)&&(t.match.push(this._world),t)})),c(this,"resolve",(e=>{const t=this.match(e);return t?t.definition.method(...t.match):(e=>{throw new ReferenceError(e)})(`Matching definition could not be found for step: "${e}"`)})),c(this,"register",((...e)=>r(e[0])?registerFromCall.apply(this,e):registerFromParse.apply(this,e))),c(this,"clear",(()=>{this.types.map((e=>this[`_${e}`]=[]))})),this._world=e||{};const t=this;this.types.map((e=>{const r=`_${e}`;this[r]=[],this[capitalize(e)]=(n,s,i)=>t.register(r,e,n,s,i)}))}}const{HOOK_TYPES:K}=y;class Hooks{constructor(e,t){c(this,"types",K),c(this,"instance",void 0),c(this,"getRegistered",(e=>{const t=this.types.includes(e)?this._registeredHooks[e]||u:((e,t)=>{throw new Error([`Expected client hook type to be one of ', ${e}.`,`Found: ${t}`].join("\n"))})(K.join(", "),e);return t.length?async()=>t.reduce((async(e,t)=>(await e,await t(this.instance))),Promise.resolve()):l})),this._registeredHooks={},this.instance=t,this.types.map((e=>{this[e]=t=>{n(t)&&(this._registeredHooks[e]=this._registeredHooks[e]||[],this._registeredHooks[e].push(t))}}))}}const U=/^\s*?"""\s*?/,Y=/^\s*?```\s*?/,B=/^\s*?\|/,V=[{regex:/^\s*Given (.*)$/,type:"given"},{regex:/^\s*When(.*)$/,type:"when"},{regex:/^\s*Then (.*)$/,type:"then"},{regex:/^\s*And (.*)$/,type:"and"},{regex:/^\s*But (.*)$/,type:"but"},{regex:/^\s*\* (.*)$/,type:"and"}],stepFactory=(e,t,r,n)=>{let s={type:e,index:n,step:t,uuid:sanitizeForId(`${e}-${t}`)};const i=n+1,a=r[i],o=r.slice(i);return s=((e,t,r,n)=>{if(!B.test(r))return e;let s;return e.table={index:n,content:t.reduce(((e,t)=>(s=s||!B.test(t),!s&&e.push(t.split("|").reduce(((e,t)=>{const r=t.trim();return r&&e.push(r),e}),[])),e)),[])},e})(s,o,a,i),s=((e,t,r,n)=>{let s=U.test(r)&&'"""';if(s=s||Y.test(r)&&"```",!s)return e;const i=r.split(s)[0],a=new Array(i.length).fill("\\s").join(""),o=new RegExp(`^${a}`);return e.doc={index:n,whiteSpace:i,type:'"""'===s?"quote":"tick",content:t.split(s).slice(1).shift().trim().split("\n").reduce(((e,t)=>(e.push(t.replace(o,"").trim()),e)),[]).join("\n")},e})(s,o.join("\n"),a,i),s},{ALIAS_REF:q,WORLD_REF:J,ALIAS_WORLD_KEY:X,WORLD_AT_RUNTIME:z,ALIAS_REF_AT_RUNTIME:Q}=y,attemptReplace=(e,t,r)=>{const s=get(t,r);return n(s)?s(t,r):exists(s)?s:e},aliasReplace=(e,t)=>{let r;try{return e.replace(P,(e=>{r=e;const n=e.trim();return 0===n.indexOf(Q)?n.replace(Q,`$${q}`):attemptReplace(e,t,n.replace(L,`${X}.`))}))}catch(e){((e,t)=>{throw console.error(`Error replacing $$alias ( $world.$alias ) in feature text. Current match was ${t}`),e})(e,r)}},worldReplace=(e,t)=>{let r;try{return e.replace(v,(e=>{r=e;const n=e.trim();return 0===n.indexOf(z)?n.replace(z,J):attemptReplace(e,t,n.replace(I,""))}))}catch(e){((e,t)=>{throw console.error(`Error replacing $world value in feature text. Current match was ${t}`),e})(e,r)}},Z=/\r?\n/g,ee=/^\s*@(.*)$/,te=/^\s*#(.*)$/,re=/^\s*Feature:(.*)$/,ne=/^\s*Rule:(.*)$/,se=/^\s*Scenario:(.*)$/,ie=/^\s*Example:(.*)$/,ae=/^\s*Background:(.*)$/,oe=[{regex:/^\s*As (.*)$/,key:"perspective"},{regex:/^\s*I want (.*)$/,key:"desire"},{regex:/^\s*So that (.*)$/,key:"reason"},{regex:/^\s*In order (.*)$/,key:"reason"}],featureFactory=(e,t,r)=>({index:r,content:t,feature:e,tags:[],rules:[],reason:[],comments:[],scenarios:[],...e&&{uuid:sanitizeForId(e,r)}}),ruleFactory=(e,t)=>({index:t,rule:e,tags:[],scenarios:[],...e&&{uuid:sanitizeForId(e,t)}}),scenarioFactory=(e,t)=>({index:t,scenario:e,tags:[],steps:[],...e&&{uuid:sanitizeForId(e,t)}}),backgroundFactory=(e,t)=>({index:t,steps:[],background:e,...e&&{uuid:sanitizeForId(e,t)}}),parseFeature=function(e,t){t=t||this&&this.world||a;const r=((e,t)=>worldReplace(aliasReplace(e,t),t))((e||"").toString(),t).split(Z);let n=ruleFactory(!1),s=scenarioFactory(!1),i=backgroundFactory(!1),o=featureFactory(!1,e),c=o;return r.reduce(((t,a,u)=>(o=((e,t,r,n,s)=>{if(!re.test(r))return t;const i=getRXMatch(r,re,1);if(!t.feature)return t.feature=i,t.index||(t.index=s),t.uuid||(t.uuid=sanitizeForId(t.feature,s)),!e.includes(t)&&e.push(t),t;const a=featureFactory(i,n,s);return e.push(a),a})(t,o,a,e,u),((e,t,r)=>{if(!te.test(t))return!1;const n=t.match(te)[0];return e.comments.push({content:n,index:r}),!0})(o,a,u)||((e,t,r)=>{let n=!1;return oe.reduce(((s,i)=>{if(s)return s;const a=i.regex.test(t);return!n&&a&&(n=!0),a?"reason"===i.key?((e,t,r)=>{t&&e.reason.push({content:t,index:r})})(e,getRXMatch(t,i.regex,0),r):e[i.key]={content:getRXMatch(t,i.regex,0),index:r}:a}),!1),n})(o,a,u)?t:(n=((e,t,r,n)=>{if(!ne.test(r))return t;let s=getRXMatch(r,ne,1);return t.rule?t=ruleFactory(s,n):t.rule=s,!t.index&&(t.index=n),!t.uuid&&(t.uuid=sanitizeForId(t.rule,n)),!e.rules.includes(t)&&e.rules.push(t),t})(o,n,a,u),s=((e,t,r,n,s)=>{const i=se.test(n);if(!i&&!ie.test(n))return r;let a=i&&getRXMatch(n,se,1);a=a||getRXMatch(n,ie,1),r.scenario?r=scenarioFactory(a,s):r.scenario=a,!r.index&&(r.index=s),!r.uuid&&(r.uuid=sanitizeForId(r.scenario,s));const o=t.uuid?t:e;return!o.scenarios.includes(r)&&o.scenarios.push(r),r})(o,n,s,a,u),i=((e,t,r,n,s)=>{if(!ae.test(n))return r;const i=t.uuid?t:e,a=`${i.uuid}-background`;return r.background?r=backgroundFactory(a,s):r.background=a||"",!r.index&&(r.index=s),!r.uuid&&(r.uuid=sanitizeForId(r.background,s)),i.background=r,r})(o,n,i,a,u),!c.feature&&((e,t,r,n)=>V.reduce(((s,i)=>{if(s)return s;const a=i.regex.test(r);return a&&e.steps.push(stepFactory(i.type,getRXMatch(r,i.regex,1),t,n)),a}),!1))(c,r,a,u)||(c=((e,t,r,n,s,i)=>se.test(i)||ie.test(i)?n:re.test(i)?t:ne.test(i)?r:ae.test(i)?s:e)(c,o,n,s,i,a),((e,t,r,n)=>{if(!ee.test(r))return!1;const s=e.background?t:e,i=getRXMatch(r,ee,0);s.tags=(s.tags||[]).concat(i.split(" "))})(c,o,a)),t))),[])},parseDefinition=function(e){return this.steps.register([e])},{SPEC_RESULT_LOG:ce,LOG_JEST_SPEC_ENV:ue}=y,logResultToTerminal=e=>{const t=(new Date).getTime();get(process,`env.${ue}`)&&process.stdout.write([ce,JSON.stringify({...e,timestamp:t}),ce].join(""))},getSuiteData=e=>{const t=get(e,"description"),r=t?t.startsWith("Scenario >")?"Scenario":t.startsWith("Background >")?"Background":t.startsWith("Rule >")?"Rule":"Feature":"Feature";return{type:r.toLowerCase(),..."Feature"!==r&&{description:t.replace(`${r} >`,`${r}:`)}}},getTestMethod=(e,t)=>t?l:global[e]||(e=>()=>{throw new Error(`Test method ${e} does not exist on the global scope.\nPlease ensure ${e} exists before calling the run method!\n`)})(e),skipTestsOnFail=e=>{if(!x)return;const t=w().getEnv();t&&t.describe&&t.addReporter((e=>{const t=[],r=e.describe;return e.describe=(...e)=>{const n=r.apply(null,e);return t.push(n),n},{suiteStarted:e=>{logResultToTerminal({...e,...getSuiteData(e),action:"start"})},specStarted:e=>{logResultToTerminal({...e,type:"step",action:"start"})},specDone:e=>{if(logResultToTerminal({...e,type:"step",action:"end"}),"failed"!==e.status)return;const r=t.find((t=>t.children.find((t=>t.result===e))));r&&r.children.map((e=>e.disable()))},suiteDone:e=>{logResultToTerminal({...e,...getSuiteData(e),action:"end"})}}})(t))},buildTitle=(e,t)=>`${capitalize(t)} > ${e}`,resolveFeatures=(e,n)=>r(e)?parseFeature(e,n):i(e)?[e]:t(e)?e.reduce(((e,t)=>e.concat(resolveFeatures(t,n))),[]):(()=>{throw new Error("Runner class requires feature text when calling the run method")})(),loopSteps=(e,t,r,n)=>(getTestMethod("describe",n)(t,(()=>{const t=e.steps.map((e=>(async(e,t,r)=>{getTestMethod("test",r)(`${capitalize(t.type)} ${t.step}`,(async()=>await e.resolve(t.step)))})(r,e,n)));Promise.all(t)})),[]),runScenario=(e,t,r,n)=>(r&&loopSteps(r,buildTitle(t.scenario,"Background"),e,n),loopSteps(t,buildTitle(t.scenario,"Scenario"),e,n)),runRule=(e,t,r,n)=>{let s=[];return describe(`Rule > ${t.rule}`,(()=>{s=t.scenarios.map((s=>runScenario(e,s,r||t.background,n))),Promise.all(s)})),s},itemMatch=(e="",t=[],n={})=>{const{name:s,tags:i}=n,a=r(i)?(e=>r(e)&&e.match(/[@]\w*/g))(i):eitherArr(i,[]),o=!s||e.includes(s),c=!a.length||a.every((e=>t.includes(e)));return o&&c};class Runner{constructor(e,t,r){c(this,"getFeatures",((e,t)=>((e,t={})=>e.reduce(((e,r)=>{if(itemMatch(r.feature,r.tags,t))return e.push(r),e;const n=r.scenarios.filter((e=>itemMatch(e.scenario,[...e.tags||[],...r.tags||[]],t)));return n.length&&e.push({...r,scenarios:n}),e}),[]))(resolveFeatures(e,this._world),t))),c(this,"run",(async(e,t=a)=>{const r=this.run.PARKIN_TEST_MODE;skipTestsOnFail();const n=getTestMethod("describe",r),s=getTestMethod("beforeAll",r),i=getTestMethod("afterAll",r),o=getTestMethod("beforeEach",r),c=getTestMethod("afterEach",r),u=this.getFeatures(e,t);if(!u.length)return!1;const l=await u.map((async e=>{let t=[];return s(this.hooks.getRegistered("beforeAll")),i(this.hooks.getRegistered("afterAll")),o(this.hooks.getRegistered("beforeEach")),c(this.hooks.getRegistered("afterEach")),n(buildTitle(e.feature,"Feature"),(()=>{t=e.rules.map((t=>runRule(this.steps,t,e.background,r))),t.concat(e.scenarios.map((t=>runScenario(this.steps,t,e.background,r)))),Promise.all(t)})),t}));return await Promise.all(l),!0})),!e&&(()=>{throw new Error("Runner class constructor requires an instance of the Steps class")})(),!t&&throwMissingHooks(),this.steps=e,this.hooks=t,this._world=r}}const{FEATURE_META:le}=y,addContent=(e,t,r)=>{exists(r)?exists(e[r])?e.splice(r,0,t):e[r]=t:e.push(t)},addTags=(e,r,n="")=>{t(r)&&r.length&&addContent(e,`${n}${r.join(" ")}`)},addScenarios=(e,r)=>{r.scenarios&&r.scenarios.map((r=>{addTags(e,r.tags,"  "),addContent(e,`  Scenario: ${r.scenario}`,r.index),((e,r)=>{t(r.steps)&&r.steps.length&&r.steps.map((t=>addContent(e,`    ${capitalize(t.type)} ${t.step}`,t.index)))})(e,r)}))},formatAssembled=e=>Array.from(e,((t,r)=>exists(t)?t.startsWith("#")?((e,t,r)=>{const n=e[r+1],s=e[r-1];let i=exists(n)?n:s;if(!i)return`${t}\n`;const a=t.split("#").pop();return`${Array(i.length-i.trimStart().length).join(" ")} # ${a}\n`})(e,t,r):`${t}\n`:"\n")).join("").trim(),he={feature:e=>eitherArr(e,[e]).map((e=>{let r=[];return!i(e)&&(e=>{throw new Error("Assemble feature requires an object matching the feature model spec!",e)})(e),addTags(r,e.tags),((e,r)=>{le.map((n=>{switch(n){case"feature":addContent(e,`Feature: ${r[n]}`,r.index);break;case"comments":t(r[n])&&r[n].map((t=>addContent(e,t.content,t.index)));break;case"reason":t(r[n])&&r[n].map((t=>addContent(e,`  ${t.content}`,t.index)));break;case"desire":case"perspective":r[n]&&addContent(e,`  ${r[n].content}`,r[n].index)}}))})(r,e),addScenarios(r,e),formatAssembled(r)}))};var pe=new WeakMap;class Parkin{constructor(e,t){h(this,pe,{writable:!0,value:!1}),c(this,"init",((e=a,t)=>{if(p(this,pe))return console.warn("This instance of parkin has already been initialized!");i(e.$alias)||(e.$alias={}),d(this,pe,!0),this.world=e,this.steps=new Steps(this.world),this.hooks=new Hooks(this.world),this.runner=new Runner(this.steps,this.hooks,this.world),this.run=this.runner.run,this.parse={feature:parseFeature.bind(this),definition:parseDefinition.bind(this)},this.assemble=he,this.paramTypes={register:registerParamType},i(t)&&this.registerSteps(t),this.steps.types.map((e=>{this[capitalize(e)]=(t,r,n)=>this.steps.register(`_${e}`,e,t,r,n)}))})),c(this,"registerSteps",(e=>{Object.entries(e).map(((e,t)=>Object.entries(t).map(((t,r)=>this.steps[capitalize(e)](t,...eitherArr(r,[r]))))))})),i(e)&&this.init(e,t)}}e("P",Parkin);e("a",new Parkin)}}}));
