{"version":3,"file":"index.js","sources":["../../node_modules/@keg-hub/jsutils/build/esm/isArr-a4420764.js","../../node_modules/@keg-hub/jsutils/build/esm/isObj-2a71d1af.js","../../node_modules/@keg-hub/jsutils/build/esm/isFunc-40ceeef8.js","../../node_modules/@keg-hub/jsutils/build/esm/deepFreeze-0437aacd.js","../../node_modules/@keg-hub/jsutils/build/esm/isStr-481ce69b.js","../../node_modules/@keg-hub/jsutils/build/esm/isNum-cc6ad9ca.js","../../node_modules/@keg-hub/jsutils/build/esm/match-312736a1.js","../../node_modules/@keg-hub/jsutils/build/esm/exists-bf542cb8.js","../../node_modules/@keg-hub/jsutils/build/esm/parseErrorMessage-54936a66.js","../../node_modules/@keg-hub/jsutils/build/esm/toStr-0e5fe94c.js","../../node_modules/@keg-hub/jsutils/build/esm/toNum-db57d125.js","../../src/matcher/regex.js","../../src/constants.js","../../src/errors.js","../../src/matcher/paramTypes.js","../../src/matcher/expression.js","../../src/matcher/matcher.js","../../src/steps.js","../../src/parse/feature.js","../../src/parse/definition.js","../../src/parse/parse.js","../../src/runner.js","../../src/parkin.js"],"sourcesContent":["const isArr = value => Array.isArray(value);\n\nexport { isArr as i };\n//# sourceMappingURL=isArr-a4420764.js.map\n","const isObj = obj => typeof obj === 'object' && !Array.isArray(obj) && obj !== null;\n\nexport { isObj as i };\n//# sourceMappingURL=isObj-2a71d1af.js.map\n","const isFunc = func => typeof func === 'function';\n\nexport { isFunc as i };\n//# sourceMappingURL=isFunc-40ceeef8.js.map\n","import { i as isFunc } from './isFunc-40ceeef8.js';\n\nconst deepFreeze = obj => {\n  Object.freeze(obj);\n  Object.getOwnPropertyNames(obj).map(prop => {\n    obj.hasOwnProperty(prop) && obj[prop] !== null && (typeof obj[prop] === 'object' || isFunc(obj[prop])) && !Object.isFrozen(obj[prop]) && deepFreeze(obj[prop]);\n  });\n  return obj;\n};\n\nexport { deepFreeze as d };\n//# sourceMappingURL=deepFreeze-0437aacd.js.map\n","const isStr = str => typeof str === 'string';\n\nexport { isStr as i };\n//# sourceMappingURL=isStr-481ce69b.js.map\n","const equalsNaN = val => typeof val === 'number' && val != val;\n\nconst isNum = val => typeof val === 'number' && !equalsNaN(val);\n\nexport { equalsNaN as e, isNum as i };\n//# sourceMappingURL=isNum-cc6ad9ca.js.map\n","import { v as validate } from './validate-0eec5ac6.js';\nimport { i as isArr } from './isArr-a4420764.js';\nimport { i as isFunc } from './isFunc-40ceeef8.js';\nimport { d as deepFreeze } from './deepFreeze-0437aacd.js';\nimport { i as isStr } from './isStr-481ce69b.js';\nimport { i as isNum } from './isNum-cc6ad9ca.js';\nimport { i as isBool } from './isBool-4d844d9e.js';\nimport { t as typeOf } from './typeOf-8c86a991.js';\n\nconst noOp = () => {};\nconst noOpObj = Object.freeze({});\nconst noPropObj = deepFreeze({\n  content: {}\n});\nconst noPropArr = deepFreeze([]);\n\nconst isOrderable = x => isStr(x) || isNum(x) || isBool(x);\n\nconst compareTo = (x, y) => {\n  const [valid] = validate({\n    x,\n    y\n  }, {\n    $default: isOrderable\n  });\n  if (!valid) return null;\n  return isStr(x) ? x.localeCompare(y) : x - y;\n};\n\nconst identity = x => x;\n\nconst match = (matchArg, ...args) => {\n  if (!args.length) return null;\n  for (let entry of args) {\n    if (!isArr(entry)) {\n      console.error(`Matching case must be an entry (a 2-element array). Found: ${typeOf(entry)}`, entry);\n      break;\n    }\n    const [caseValueOrPredicate, valueOnMatch] = entry;\n    if (isFunc(caseValueOrPredicate) && caseValueOrPredicate(matchArg)) return valueOnMatch;\n    if (caseValueOrPredicate === matchArg) return valueOnMatch;\n  }\n  return null;\n};\nmatch.default = () => true;\n\nexport { identity as a, noOpObj as b, compareTo as c, noPropObj as d, noPropArr as e, isOrderable as i, match as m, noOp as n };\n//# sourceMappingURL=match-312736a1.js.map\n","const exists = value => value === value && value !== undefined && value !== null;\n\nexport { exists as e };\n//# sourceMappingURL=exists-bf542cb8.js.map\n","import { v as validate } from './validate-0eec5ac6.js';\nimport { i as isObj } from './isObj-2a71d1af.js';\nimport { i as isFunc } from './isFunc-40ceeef8.js';\nimport { h as hasOwn } from './hasOwn-deb5bbb8.js';\nimport { i as isStr } from './isStr-481ce69b.js';\nimport { i as isNum } from './isNum-cc6ad9ca.js';\nimport { i as isEmpty } from './isEmpty-324adee6.js';\n\nconst checkCall = (method, ...params) => isFunc(method) && method(...params) || undefined;\n\nconst complement = predicate => {\n  const [valid] = validate({\n    predicate\n  }, {\n    predicate: isFunc\n  });\n  return valid ? (...args) => !predicate(...args) : null;\n};\n\nconst eitherFunc = (func1, func2) => isFunc(func1) && func1 || func2;\n\nconst debounce = (func, wait = 250, immediate = false) => {\n  let timeout;\n  function wrapFunc(...args) {\n    if (!isFunc(func)) return null;\n    const context = this;\n    const later = () => {\n      timeout = null;\n      !immediate && func.apply(context, args);\n    };\n    const callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) return isFunc(func) && func.apply(context, args);\n  }\n  return wrapFunc;\n};\n\nconst doIt = (...args) => {\n  const params = args.slice();\n  const num = params.shift();\n  const bindTo = params.shift();\n  const cb = params.pop();\n  if (!isNum(num) || !isFunc(cb)) return [];\n  const doItAmount = new Array(num);\n  const responses = [];\n  for (let i = 0; i < doItAmount.length; i++) {\n    const data = cb.call(bindTo, i, ...params);\n    if (data === false) break;\n    responses.push(data);\n  }\n  return responses;\n};\n\nconst hasDomAccess = () => {\n  try {\n    return !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n  } catch (error) {\n    return false;\n  }\n};\n\nconst memorize = (func, getCacheKey, limit = 1) => {\n  if (!isFunc(func) || getCacheKey && !isFunc(getCacheKey)) return console.error('Error: Expected a function', func, getCacheKey);\n  let memorized = function () {\n    const cache = memorized.cache;\n    const key = getCacheKey ? getCacheKey.apply(this, arguments) : arguments[0];\n    if (hasOwn(cache, key)) return cache[key];\n    const result = func.apply(this, arguments);\n    isNum(limit) && Object.keys(cache).length < limit ? cache[key] = result : memorized.cache = {\n      [key]: result\n    };\n    return result;\n  };\n  memorized.cache = {};\n  memorized.destroy = () => {\n    getCacheKey = undefined;\n    memorized.cache = undefined;\n    memorized.destroy = undefined;\n    memorized = undefined;\n  };\n  return memorized;\n};\n\nconst throttle = (func, wait = 100) => {\n  let waiting = false;\n  return function (...args) {\n    if (waiting) return;\n    waiting = true;\n    func.apply(this, args);\n    return setTimeout(() => {\n      waiting = false;\n    }, wait);\n  };\n};\n\nconst throttleLast = (func, cb, wait = 100) => {\n  let throttleTimeout;\n  return function (...args) {\n    if (throttleTimeout) clearTimeout(throttleTimeout);\n    throttleTimeout = setTimeout(() => {\n      func.apply(this, args);\n      clearTimeout(throttleTimeout);\n    }, wait);\n    typeof cb === 'function' && cb();\n  };\n};\n\nconst limbo = promise => {\n  return !promise || !isFunc(promise.then) ? [new Error(`A promise or thenable is required as the first argument!`), null] : promise.then(data => [null, data]).catch(err => [err, undefined]);\n};\n\nconst uuid = a => a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid);\n\nconst parseErrorMessage = exception => {\n  return isStr(exception) && !isEmpty(exception) ? exception : isObj(exception) ? exception.message : null;\n};\n\nexport { complement as a, doIt as b, checkCall as c, debounce as d, eitherFunc as e, throttleLast as f, hasDomAccess as h, limbo as l, memorize as m, parseErrorMessage as p, throttle as t, uuid as u };\n//# sourceMappingURL=parseErrorMessage-54936a66.js.map\n","import { i as isStr } from './isStr-481ce69b.js';\n\nconst toStr = val => val === null || val === undefined ? '' : isStr(val) ? val : JSON.stringify(val);\n\nexport { toStr as t };\n//# sourceMappingURL=toStr-0e5fe94c.js.map\n","import { t as toStr } from './toStr-0e5fe94c.js';\nimport { i as isNum, e as equalsNaN } from './isNum-cc6ad9ca.js';\n\nconst getNums = val => toStr(val).replace(/([^.\\d])/gm, '');\n\nconst toNum = val => isNum(val) ? val : val && !equalsNaN(val) && Number(getNums(val)) || 0;\n\nexport { getNums as g, toNum as t };\n//# sourceMappingURL=toNum-db57d125.js.map\n","import { noOpObj } from '@keg-hub/jsutils'\n\n/**\n * Finds a matching step definition from passed in regex\n * Then extracts the variables from the text to pass to the step definitions method\n * @function\n * @public\n * @export\n * @param {Object} step - Registered step definition\n * @param {string} text - Feature step text to compare with step definition text\n *\n * @returns {Object} Found matching step definition and matched arguments\n */\nexport const matchRegex = (step, text) => {\n  const match = text.match(new RegExp(step.match))\n\n  // If there is a match, get all matching items except for the first one\n  // Which is the original string\n  return match ? { step, match: match.slice(1, match.length) } : noOpObj\n}\n","import { deepFreeze } from '@keg-hub/jsutils'\n\nexport const constants = deepFreeze({\n  REGEX_VARIANT: 'regex',\n  EXPRESSION_VARIANT: 'expression',\n  STEP_TYPES: [ 'given', 'when', 'then', 'and', 'but' ],\n})\n","/*\n * Helper method to use the a test method can not be found on the global scope\n * @function\n * @public\n * @export\n * @param {string} type - Name of test method to get from the global scope\n *\n * @returns {function} - Test method\n */\nexport const testMethodFill = type => {\n  /*\n   * Internal method that throws an error when a test method does not exist on the global scope\n   * @function\n   * @private\n   * @inner\n   *\n   * @returns {void}\n   */\n  return () => {\n    throw new Error(\n      `` +\n        `Test method ${type} does not exist on the global scope.\\n` +\n        `Please ensure ${type} exists before calling the run method!\\n`\n    )\n  }\n}\n\n/**\n * Throws an error when a Steps class instance is not passed to the runner class constructor\n * @function\n * @public\n * @export\n *\n * @returns {void}\n */\nexport const throwMissingSteps = () => {\n  throw new Error(\n    `Runner class constructor requires an instance of the Steps class`\n  )\n}\n\n/**\n * Throws an error when a feature text is not passed to the Runner class instance\n * @function\n * @public\n * @export\n *\n * @returns {void}\n */\nexport const throwMissingFeatureText = () => {\n  throw new Error(\n    `Runner class requires feature text when calling the run method`\n  )\n}\n\n/**\n * Throws an error when a feature step does not match a step definition\n * @function\n * @public\n * @export\n * @param {string} text - Text that does not match a registered step definition\n *\n * @returns {void}\n */\nexport const throwNoMatchingStep = text => {\n  throw new ReferenceError(text)\n}\n\n/**\n * Throws an error when a registering a param type that already exists\n * @function\n * @public\n * @export\n * @param {string} name - Name of the param type that is being registered\n *\n * @returns {void}\n */\nexport const throwParamTypeExists = () => {\n  throw new Error(`Cannot register param type \"${name}\". It already exists!`)\n}\n","import {\n  noOpObj,\n  toStr,\n  toInt,\n  toFloat,\n  checkCall,\n  exists,\n} from '@keg-hub/jsutils'\nimport { throwParamTypeExists } from '../errors'\n\n/**\n * Default param type model used when registering param types\n * @type {Object}\n */\nconst typeModel = {\n  name: '',\n  regexp: '',\n  type: 'string',\n  useForSnippets: true,\n  transformer: arg => arg,\n  preferForRegexpMatch: false,\n}\n\n/**\n * Maps param types to function, for type conversion\n * Follows the default conversions for cucumber expressions\n * See https://cucumber.io/docs/cucumber/cucumber-expressions/\n * @type {Object}\n */\nconst __paramTypes = {\n  any: {\n    ...typeModel,\n    name: 'any',\n  },\n  word: {\n    ...typeModel,\n    name: 'word',\n    transformer: arg => toStr(arg),\n  },\n  float: {\n    ...typeModel,\n    name: 'float',\n    type: 'number',\n    transformer: arg => toFloat(arg),\n  },\n  int: {\n    ...typeModel,\n    name: 'int',\n    type: 'number',\n    transformer: arg => !arg.includes('.') && toInt(arg),\n  },\n  string: {\n    ...typeModel,\n    name: 'string',\n    transformer: arg =>\n      arg\n        .trim()\n        .replace(/^(\"|')/, '')\n        .replace(/(\"|')$/, ''),\n  },\n}\n\n/**\n * Get the registered __paramTypes\n * @function\n * @public\n * @export\n *\n * @return {Object} Registered param types\n */\nexport const getParamTypes = () => __paramTypes\n\n/**\n * Register custom types following the typeModel object\n * See https://cucumber.io/docs/cucumber/cucumber-expressions/ for more info\n * @function\n * @public\n * @export\n *\n * @return {Object} Registered param types\n */\nexport const registerParamType = (model = noOpObj, key = model.name) => {\n  __paramTypes[key]\n    ? throwParamTypeExists(key)\n    : (__paramTypes[key] = { ...typeModel, ...model })\n}\n\n/**\n * Converts the found matching values into the correct types\n * Using transformer methods of the matched paramType names\n * @function\n * @public\n * @export\n * @param {Array<string>} matches - All found dynamic arguments\n * @param {Array<function>} transformers - Matching paramTypes by index\n *\n * @returns {Array<*>} Matches converted into the correct type\n */\nexport const convertTypes = (matches, transformers) => {\n  return matches\n    .map((item, i) => {\n      const paramType = transformers[i]\n      const asType = checkCall(paramType.transformer, item)\n\n      return typeof asType === paramType.type ? asType : null\n    })\n    .filter(item => exists(item) && item)\n}\n","import { matchRegex } from './regex'\nimport { noOpObj, isFunc } from '@keg-hub/jsutils'\nimport { getParamTypes, convertTypes } from './paramTypes'\n\nconst RX_OPTIONAL = /\\s*\\S*\\(s\\)\\s*/g\nconst RX_ALT = /\\s*\\S*\\/\\S*\\s*/g\nconst RX_EXPRESSION = /\\s*{(.*?)}\\s*/g\nconst RX_EXP_REPLACE = `(.*)`\nconst RX_MATCH_REPLACE = /{|}/g\nconst inBrowser = Boolean(typeof window !== 'undefined')\n\n/**\n * Escapes a string so it can be converted into a regular expression\n * @function\n * @private\n * @param {string} str - Step match text to be escaped\n *\n * @return {string} Escaped string to allow converting into a regular expression\n */\nconst escapeStr = str => {\n  return inBrowser ? str.replace(/[.*+?^$()|[\\]\\\\]/g, '\\\\$&') : str\n}\n\n/**\n * Replace the passed in matcher string with the passed in replaceWith data based on the testRx\n * @function\n * @private\n * @param {string} match - Step match text from feature scenario\n * @param {string} testRx - Regular expression to find matching text within the matcher text\n * @param {string|function} replaceWith - Data to replace the matched data with\n *                                        Automatically called when it's function\n *\n * @return {string} match string with matched content replaced with regex\n */\nconst runRegexCheck = (matcher, testRx, replaceWith) => {\n  if (!testRx.test(matcher)) return matcher\n\n  // Set the default regex match\n  let regexStr = matcher\n  // Replace any expressions with regex, and convert the param types\n  matcher.replace(testRx, (...args) => {\n    const match = args[0].trim()\n    const [ start, ...end ] = regexStr.split(match)\n    const replace = isFunc(replaceWith) ? replaceWith(...args) : replaceWith\n\n    regexStr = `${start}${replace}${end.join(match)}`\n  })\n\n  return regexStr\n}\n\n/**\n * Find all expressions in the match string, and convert them into into regex\n * @function\n * @private\n * @param {string} match - Step match text from feature scenario\n *\n * @return {string} match string with expression replaced\n */\nconst convertToRegex = match => {\n  const paramTypes = getParamTypes()\n  const transformers = []\n  const regex = runRegexCheck(match, RX_EXPRESSION, (val, ...args) => {\n    // Get the expression type\n    const type = val.trim().replace(RX_MATCH_REPLACE, '')\n    // Add the transformer for the type to the transformers array\n    transformers.push(paramTypes[type] || paramTypes.any)\n\n    // Return the regex\n    return RX_EXP_REPLACE\n  })\n\n  return { regex, transformers }\n}\n\n/**\n * Find all optional syntax in the match string, and convert them into into regex\n * @function\n * @private\n * @param {string} match - Step match text from feature scenario\n *\n * @return {string} match string with optional syntax replaced\n */\nconst checkOptional = match => {\n  const regex = runRegexCheck(\n    match,\n    RX_OPTIONAL,\n    (val, ...args) => `${val.trim().replace('(s)', '')}s*`\n  )\n\n  return { regex }\n}\n\n/**\n * Find all alternate syntax in the match string, and convert them into into regex\n * @function\n * @private\n * @param {string} match - Step match text from feature scenario\n *\n * @return {string} match string with alternate syntax replaced\n */\nconst checkAlternative = match => {\n  const altIndexes = []\n  const regex = runRegexCheck(\n    match,\n    RX_ALT,\n    // Use a non-capture group to allow matching, but don't include in the results (?:)\n    (val, ...args) => `(?:${val.trim().replace('/', '|')})`\n  )\n\n  return { regex, altIndexes }\n}\n\n/**\n * Finds a matching step definition from passed in expression text\n * Then extracts the variables from the text to pass to the step definitions method\n * Converts expression strings into regex then calls the matchRegex method\n * @function\n * @public\n * @export\n * @param {Object} step - Registered step definition\n * @param {string} text - Feature step text to compare with step definition text\n *\n * @returns {Object} Found matching step definition and matched arguments\n */\nexport const matchExpression = (step, text) => {\n  // TODO: This needs move investigation\n  // Need to ensure correct chars are escaped for all edge cases\n  const escaped = escapeStr(step.match)\n\n  const { regex } = checkOptional(escaped)\n  const { regex: regexAlts } = checkAlternative(regex)\n  const { regex: match, transformers } = convertToRegex(regexAlts)\n\n  // Then call the regex matcher to get the content\n  const found = matchRegex({ ...step, match }, text)\n\n  // If no found step definition of match, return an empty object\n  if (!found || !found.step || !found.match) return noOpObj\n\n  // Convert the found variables into their type based on the mapped transformers\n  const converted = convertTypes(found.match, transformers)\n\n  // If the conversion fails, and no type is returned\n  // Then assume the type does not match, so the step does not match\n  // Otherwise return the matched step definition, and the converted variables\n  return converted.length !== found.match.length\n    ? noOpObj\n    : { step, match: converted }\n}\n","import { matchRegex } from './regex'\nimport { constants } from '../constants'\nimport { noOpObj } from '@keg-hub/jsutils'\nimport { matchExpression } from './expression'\n\nconst { REGEX_VARIANT } = constants\n\n/**\n * Finds a matching registered step definition from the passed in stepDefs and text\n * Treats all non-regex step variants as expressions\n * @function\n * @public\n * @export\n * @param {Array<Object>} stepDefs - All Registered step definitions\n * @param {string} text - Feature step text to compare with step definition text\n *\n * @returns {Object} Found matching step definition and matched arguments\n */\nexport const matcher = (stepDefs, text) => {\n  return stepDefs.reduce((found, step) => {\n    return found.match || !step.match\n      ? found\n      : step.variant !== REGEX_VARIANT\n        ? matchExpression(step, text)\n        : matchRegex(step, text)\n  }, noOpObj)\n}\n","import { matcher } from './matcher'\nimport { constants } from './constants'\nimport { throwNoMatchingStep } from './errors'\nimport { capitalize, eitherArr, isStr } from '@keg-hub/jsutils'\nconst { REGEX_VARIANT, EXPRESSION_VARIANT, STEP_TYPES } = constants\n\n/**\n * Sanitize the step definition text to be used as the name\n * @function\n * @private\n * @param {Object} step - Parsed step definition object\n *\n * @returns {string} Sanitized string version of the step definition text\n */\nconst sanitize = step => {\n  let name = step.match.toString()\n  if (name[0] === '^') name = name.substr(1)\n  if (name.charAt(name.length - 1) === '$') name = name.slice(0, -1)\n\n  return name.replace(/\\(\\?:([^\\|]+)+\\|+([^\\)]+)?\\)/, '$1')\n}\n\n/**\n * Builds the text content of a step definition call\n * @function\n * @private\n * @param {Object} step - Parsed step definition object\n * @param {string} step.type - Type of step definition this step belongs to\n * @param {string} step.match - Text used to match with a features step\n * @param {function} step.method - Called when a features step matches match property\n * @param {string} step.variant - Syntax used in the match property\n *\n * @returns {string} - Built text content of the step definition\n */\nconst getContent = step => {\n  const match =\n    step.variant === REGEX_VARIANT ? step.match.toString() : `\"${step.match}\"`\n\n  return `${capitalize(step.type)}(${match}, ${step.method.toString()})`\n}\n\n/**\n * Registers a step definition by type\n * @function\n * @private\n * @param {string} internalType - Internal references to the step definition type\n * @param {string} type - Type of step definition to search when matching\n * @param {string} match - Text used to match with a features step\n * @param {function} method - Called when a features step matches match property\n *\n * @returns {void}\n */\nconst registerFromCall = function (internalType, type, match, method) {\n  const step = {\n    type,\n    match,\n    method,\n    variant:\n      match.toString().indexOf('/') === 0 ? REGEX_VARIANT : EXPRESSION_VARIANT,\n  }\n\n  step.name = sanitize(step)\n  step.content = getContent(step)\n\n  this[internalType].push(step)\n\n  return step\n}\n\n/**\n * Registers a parsed step definition object\n * @function\n * @private\n * @param {Array|Object} definitions - Array of parsed definition objects\n *                                    Or a single parsed definition object\n *\n * @returns {void}\n */\nconst registerFromParse = function (definitions) {\n  // Loop over the passed in definitions\n  return eitherArr(definitions, [definitions]).map(definition => {\n    // Create a dynamic function calling the definition.content\n    // The definition.content should be a call to a global Given, When, Then method\n    // Which is injected from the Steps class instance ( this )\n    const step = Function(`return (Given, When, Then, And, But) => {\n        return ${definition.content}\n      }`)()(this.Given, this.When, this.Then, this.And, this.But)\n\n    // Merge the returned step with the initial definition\n    return { ...step, ...definition }\n  })\n}\n\n/**\n * Allows registering step definition matchs and functions\n * Which are used to map to steps of a parsed feature file\n * @class\n * @public\n * @param {Object} world - Holds configuration for the running test environment\n *\n * @returns {Object} Instance of the Steps class\n */\nexport class Steps {\n  /**\n   * Allowed step definition types\n   * @memberof Steps\n   * @type {Array}\n   * @private\n   */\n  types = STEP_TYPES\n\n  constructor(world) {\n    this._world = world || {}\n    const self = this\n    /**\n     * Creates helpers for registering step definitions by type\n     * @memberof Steps\n     * @function\n     * @public\n     * @param {string} match - Text used to matched with a features step\n     * @param {function} method - Function called when a features step text matches the text param\n     * @example\n     * const steps = new Steps({})\n     * steps.Given(`text`, ()=> {})\n     *\n     * @returns {void}\n     */\n    this.types.map(type => {\n      const internalType = `_${type}`\n      this[internalType] = []\n      this[capitalize(type)] = (match, method) => {\n        return self.register(internalType, type, match, method)\n      }\n    })\n  }\n\n  /**\n   * Finds a matching step definition from the passed in list and text can calls it\n   * This is the method the actually calls a step definition function\n   * @memberof Steps\n   * @function\n   * @public\n   * @param {Array<Object>} list - Group of registered step definition\n   * @param {string} text - Feature step text to compare with step definition text\n   *\n   * @returns {*} - Response from the step definition function\n   */\n  resolve = text => {\n    // Join all step types together when finding a match\n    // Cucumber treats all step definition types as the same when matching to step text\n    const list = this.types.reduce(\n      (stepDefs, type) => stepDefs.concat(this[`_${type}`]),\n      []\n    )\n\n    // Call the matcher to find a matching step definition\n    const { match, step } = matcher(list, text)\n\n    // If not step of match, then throw\n    // No matching step definition exists\n    if (!match || !step) return throwNoMatchingStep(text)\n\n    // Add the steps world to the match arguments\n    match.push(this._world)\n\n    // Call the step function passing the match array as arguments\n    return step.method(...match)\n  }\n\n  /**\n   * Registers a step definition by type based on passed in args\n   * @memberof Steps\n   * @function\n   * @public\n   * @param {Array} args - All arguments passed to the method\n   * @param {string|Array|Object} args.0 - Type of step definition to search when matching\n   *                                        Or an array of parsed definition objects\n   *                                        Or a single parsed definition object\n   * @param {string} args.1 - Text used to matched with a features step\n   * @param {function} args.2 - Function called when a features step text matches the text param\n   *\n   * @returns {void}\n   */\n  register = (...args) => {\n    return isStr(args[0])\n      ? registerFromCall.apply(this, args)\n      : registerFromParse.apply(this, args)\n  }\n\n  /**\n   * Clears out all registered step definitions for all types\n   * @memberof Steps\n   * @function\n   * @public\n   *\n   * @returns {void}\n   */\n  clear = () => {\n    this.types.map(type => (this[`_${type}`] = []))\n  }\n}\n","import { uuid } from '@keg-hub/jsutils'\n\n/**\n * Regular expressions for matching feature file keywords\n * @type {object}\n */\nconst RX_NEWLINE = /\\r?\\n/g\nconst RX_TAG = /^\\s*@(.*)$/\nconst RX_COMMENT = /^\\s*#(.*)$/\nconst RX_FEATURE = /^\\s*Feature:(.*)$/\nconst RX_AS = /^\\s*As (.*)$/\nconst RX_I_WANT = /^\\s*I want (.*)$/\nconst RX_SO_THAT = /^\\s*So that (.*)$/\nconst RX_IN_ORDER = /^\\s*In order (.*)$/\nconst RX_SCENARIO = /^\\s*Scenario:(.*)$/\nconst RX_EXAMPLE = /^\\s*Example:(.*)$/\nconst RX_BACKGROUND = /^\\s*Background:(.*)$/\nconst RX_GIVEN = /^\\s*Given (.*)$/\nconst RX_WHEN = /^\\s*When(.*)$/\nconst RX_THEN = /^\\s*Then (.*)$/\nconst RX_AND = /^\\s*And (.*)$/\nconst RX_BUT = /^\\s*But (.*)$/\nconst RX_ASTERISK = /^\\s*\\* (.*)$/\nconst RX_DOCQUOTES = /^\\s*\"\"\"\\s*(.*)$/\nconst RX_DOCTICKS = /^\\s*```\\s*(.*)$/\nconst RX_DATATABLE = /^\\s*\\|\\s*(.*)\\|\\s*$/\n\n/**\n * Regular expressions and types for matching step keywords\n * @type {Array}\n * @private\n */\nconst RegStepTags = [\n  { regex: RX_GIVEN, type: 'given' },\n  { regex: RX_WHEN, type: 'when' },\n  { regex: RX_THEN, type: 'then' },\n  { regex: RX_AND, type: 'and', alt: 'when' },\n  { regex: RX_BUT, type: 'but', alt: 'when' },\n  { regex: RX_ASTERISK, type: 'and', alt: 'when' },\n]\n\n/**\n * Regular expressions and types for matching feature meta data keywords\n * @type {Array}\n * @private\n */\nconst featureMetaTags = [\n  { regex: RX_AS, key: 'perspective' },\n  { regex: RX_I_WANT, key: 'desire' },\n  { regex: RX_SO_THAT, key: 'reason' },\n  { regex: RX_IN_ORDER, key: 'reason' },\n]\n\n/*\n * Extracts keywords from a text string\n * @function\n * @private\n * @param {string} line - Text content to extract the keyword from\n * @param {Object} regex - Regex object used for finding a keyword\n * @param {number} index - Current inject of the line being parsed\n *\n * @returns {string} - Found keyword text from the line argument\n */\nconst getRXMatch = (line, regex, index) => line.match(regex)[index].trim()\n\n/*\n * Helper factory function to build a feature object\n * @function\n * @private\n * @param {string} feature - Text containing the feature keyword and text\n * @param {number} text - The entire text of a feature file\n *\n * @returns {Object} - Parsed feature object\n */\nconst featureFactory = (feature, text) => {\n  return { feature, uuid: uuid(), tags: [], comments: {}, scenarios: [], text }\n}\n\n/*\n * Helper factory function to build a scenario object\n * @function\n * @private\n * @param {string} scenario - Text containing the scenario keyword and text\n *\n * @returns {Object} - Parsed scenario object\n */\nconst scenarioFactory = scenario => {\n  return { scenario, uuid: uuid(), steps: [] }\n}\n\n/*\n * Helper factory function to build a step object\n * @function\n * @private\n * @param {string} type - The type of step definition\n * @param {string} step - Text containing the step text\n * @param {string} altType - The alternate type of the step definition ( And || But )\n *\n * @returns {Object} - Parsed step object\n */\nconst stepFactory = (type, step, altType) => {\n  const built = { step, type, uuid: uuid() }\n  altType && (built.altType = altType)\n\n  // TODO: Investigate calling checkDocString and checkDataTable here\n  // For doc string and data table variables of steps\n  // Will need to pass in the full text\n  // Then pase from the current line down to the end of the doc string or data table\n\n  return built\n}\n\n/*\n * Helper function to add reason text to a feature when it exists\n * @function\n * @private\n * @param {Object} feature - Parse feature object\n * @param {string} reason - Text containing the reason from the parsed feature file\n *\n * @returns {void}\n */\nconst addReason = (feature, reason) => {\n  reason\n    ? !feature.reason\n        ? (feature.reason = reason)\n        : (feature.reason += `\\n${reason}`)\n    : null\n}\n\n/**\n * Check for doc strings in the steps\n * The string should be passed to the step def as the last argument\n * Space inside the doc string should be left as is\n * @function\n * @private\n * @param {Object} step - Current step being parsed into an object\n * @param {string} line - Current line being parsed\n * @param {string} text - Full text content of the feature file\n *\n * @todo Implement doc string parsing\n *\n * @return {Object} Current step being parsed with the doc string added\n */\nconst checkDocString = (step, line, text) => {\n  // TODO: doc string parsing\n  // if(!RX_DOCQUOTES.test(line) || !RX_DOCTICKS.test(line)) return step\n\n  return step\n}\n\n/**\n * Check for a data table in the in the steps content\n * The string should be passed to the step def as the last argument\n * Each line of the data stable should be split in to arguments seperated by |\n * @function\n * @private\n * @param {Object} step - Current step being parsed into an object\n * @param {string} line - Current line being parsed\n * @param {string} text - Full text content of the feature file\n *\n * @todo Implement data table parsing\n *\n * @return {Object} Current step being parsed with the doc string added\n */\nconst checkDataTable = (step, line, text) => {\n  // TODO: data table parsing\n  // if(!RX_DATATABLE.test(line)) return step\n\n  return step\n}\n\n/**\n * Checks each step tag type, and adds it to current scenario when it exists\n * @function\n * @private\n * @param {Object} scenario - Parsed scenario object of the current scenario\n * @param {string} line - Current line being parsed\n *\n * @return {boolean} - True if a line was added to the current scenario object\n */\nconst checkStepTag = (scenario, line) => {\n  return RegStepTags.reduce((added, regTag) => {\n    // If the line was already added, just return\n    if (added) return added\n\n    // Check if the line is a step tag\n    const hasTag = regTag.regex.test(line)\n    // If if is, add the extracted line to the steps of the current scenario\n    hasTag &&\n      scenario.steps.push(\n        stepFactory(regTag.type, getRXMatch(line, regTag.regex, 1), regTag.alt)\n      )\n\n    // Return if the line was added to the steps\n    return hasTag\n  }, false)\n}\n\n/**\n * Checks for feature descriptive content\n * @function\n * @private\n * @param {Object} feature - Current feature being parsed into an object\n * @param {string} line - Current line being parsed\n *\n * @return {boolean} - True if a line was added to the current feature object\n */\nconst featureMeta = (feature, line) => {\n  return featureMetaTags.reduce((added, regTag) => {\n    if (added) return added\n\n    const hasTag = regTag.regex.test(line)\n\n    return hasTag\n      ? regTag.key === 'reason'\n          ? addReason(feature, getRXMatch(line, regTag.regex, 0))\n          : (feature[regTag.key] = getRXMatch(line, regTag.regex, 0))\n      : hasTag\n  }, false)\n}\n\n/*\n * Checks for feature file meta-data\n * @function\n * @private\n * @param {Object} feature - Current feature being parsed into an object\n * @param {string} line - Current line being parsed\n *\n * @return {boolean} - True if a line was added to the current feature object\n */\nconst featureTag = (feature, line) => {\n  if (!RX_TAG.test(line)) return false\n\n  const tags = getRXMatch(line, RX_TAG, 0)\n  feature.tags = feature.tags.concat(tags.split(' '))\n\n  return true\n}\n\n/*\n * Checks for feature file comments\n * @function\n * @private\n * @param {Object} feature - Current feature being parsed into an object\n * @param {string} line - Current line being parsed\n * @param {number} index - Location of the current feature in the features group array\n *\n * @return {boolean} - True if a line was added to the current feature object\n */\nconst featureComment = (feature, line, index) => {\n  if (!RX_COMMENT.test(line)) return false\n\n  const comment = getRXMatch(line, RX_COMMENT, 1)\n  feature.comments[index] = comment\n\n  return true\n}\n\n/**\n * Check for new feature, or add feature text to current feature\n * @function\n * @private\n * @param {Array} featuresGroup - All Parsed features as an array\n * @param {Object} feature - Current feature being parsed into an object\n * @param {string} line - Current line being parsed\n * @param {string} text - Full text content of the feature file\n *\n * @return {Object} Current feature being parsed\n */\nconst ensureFeature = (featuresGroup, feature, line, text) => {\n  // Check for Feature: keyword text\n  if (!RX_FEATURE.test(line)) return feature\n\n  // Get the text from the line\n  const featureText = getRXMatch(line, RX_FEATURE, 1)\n\n  // If the text was not yet added, then add it\n  // Then ensure the feature was added to the full group\n  if (!feature.feature) {\n    feature.feature = featureText\n    !featuresGroup.includes(feature) && featuresGroup.push(feature)\n\n    return feature\n  }\n\n  // Otherwise create a new feature, with the feature text\n  return featureFactory(featureText, text)\n}\n\n/**\n * Check for new feature scenario, and add scenario to feature object\n * @function\n * @private\n * @param {Object} feature - Current feature being parsed into an object\n * @param {Object} scenario - Current scenario being parsed into an object\n * @param {string} line - Current line being parsed\n *\n * @return {Object} Current scenario being parsed\n */\nconst ensureScenario = (feature, scenario, line) => {\n  // Check for \"Scenario:\" or \"Example:\" keywords\n  if (!RX_SCENARIO.test(line) && !RX_EXAMPLE.test(line)) return scenario\n\n  // Check for \"Scenario:\", if not found then check for \"Example:\"\n  let scenarioText = getRXMatch(line, RX_SCENARIO, 1)\n  scenarioText = scenarioText || getRXMatch(line, RX_EXAMPLE, 1)\n\n  // Check if the scenario text was already added, and add it if needed\n  // Otherwise create a new scenario with the scenario text\n  !scenario.scenario\n    ? (scenario.scenario = scenarioText)\n    : (scenario = scenarioFactory(scenarioText))\n\n  // Add the scenario if needed to the current feature\n  !feature.scenarios.includes(scenario) && feature.scenarios.push(scenario)\n\n  return scenario\n}\n\n/**\n * Check for background in a feature, These steps should run before all steps of a scenario\n * Should be added to each scenario, where a background exists in the feature\n * @function\n * @private\n * @param {Object} feature - Current feature being parsed into an object\n * @param {Object} scenario - Current scenario being parsed into an object\n * @param {string} line - Current line being parsed\n *\n * @todo Implement background parsing\n *\n * @return {Object} Current background being parsed\n */\nconst checkBackground = (feature, scenario, background, line) => {\n  // TODO: Implement background parsing\n  // if(!RX_BACKGROUND.test(line)) return background\n\n  return background\n}\n\n/*\n * Parses a feature files text content into an object\n * @function\n * @public\n * @export\n * @param {string} text - Text content of a feature file\n *\n * @returns {Object} - Parsed feature file as an object\n */\nexport const feature = text => {\n  const features = []\n  const lines = (text || '').toString().split(RX_NEWLINE)\n  let scenario = scenarioFactory(false)\n  let feature = featureFactory(false, text)\n\n  /*\n   * Loop over each line of text, and compose the line with corresponding regex to find a match\n   */\n  return lines.reduce((featuresGroup, line, index) => {\n    /*\n     * Check for new feature, or parse the current features text\n     */\n    feature = ensureFeature(featuresGroup, feature, line, text)\n\n    /*\n     * Check for new feature scenario, and add scenario to feature object\n     */\n    scenario = ensureScenario(feature, scenario, line)\n\n    /*\n     * Check for new feature scenario, and add scenario to feature object\n     */\n    // background = checkBackground(feature, scenario, background, line)\n\n    /*\n     * Check for feature and scenario content and parse the line when matched\n     */\n    featureTag(feature, line) ||\n      featureComment(feature, line, index) ||\n      featureMeta(feature, line) ||\n      checkStepTag(scenario, line)\n\n    return featuresGroup\n  }, features)\n}\n","import { constants } from '../constants'\nconst { REGEX_VARIANT, EXPRESSION_VARIANT } = constants\n\nconst NEWLINES_MATCH = /\\n|\\r|\\r\\n/\nconst COMMENT_MATCH = /\\/\\/.*/g\nconst MULTI_LINE_MATCH = /\\/\\*(.*\\n)*\\*\\//\nconst FIND_DEFINITION = new RegExp(\n  /(Given|When|Then)\\(('|\"|`|\\/)(.*)('|\"|`|\\/),/,\n  'gm'\n)\nconst NEXT_DEFINITION = new RegExp(/(Given|When|Then|And|But)\\(/, 'g')\n\n/*\n * Parses the definition.input, to extract out a definitions method content\n * @function\n * @private\n * @param {Array} definition - Matching response from FIND_DEFINITION regex\n *\n * @return {string} - Valid Javascript definition call as text\n */\nconst getContent = definition => {\n  // Get all content after the definition call\n  // Example => Given('some description', () => { ... })\n  //   * Removed => \"Given('some description',\"\n  //   * content === \"() => { ... })\"\n  //     * NOTE - This is a NON-VALID javascript due to the trailing )\n  const content = definition.input.split(definition[0]).pop()\n\n  // Use regex to look for other definition calls (Given,When,Then)\n  // in the remaining content after the definition call is removed\n  const found = NEXT_DEFINITION.exec(content)\n\n  // If another definition call\n  //   * Is not found - Join the content with the removed definition call from above\n  //   * Is found - Split content at the next definition call\n  //                Then return the first item from the split array\n  //                This gives us all the content of the method for a definition\n  // * NOTE - returns VALID javascript as text\n  const parsedContent = !found\n    ? `${definition[0].trim()} ${content.trim()}`\n    : `${definition[0].trim()}${content.split(found[0].trim()).shift()}`\n\n  // Removed any empty lines from the parsedContent\n  return parsedContent\n    .split(`\\n`)\n    .filter(line => line)\n    .join(`\\n`)\n}\n\n/*\n * @todo - Improve comment stripping\n * Very simple comment stripper, that only gets rid of `//` and /* ... *\\/\n * Does not cover all used cases, and most likely will fail on edge cases\n * @function\n * @private\n * @param {string} text - Definition text to strip comments from\n *\n * @return {string} - Passed in text with comments stripped\n */\nconst stripComments = text => {\n  return text\n    .trim()\n    .split(NEWLINES_MATCH)\n    .filter(line => !COMMENT_MATCH.test(line.trim()))\n    .join(`\\n`)\n    .replace(MULTI_LINE_MATCH, '')\n}\n\n/*\n * Parses a step definition file, and converts it into an object\n * Extracts each definition in a file into its own object\n * @function\n * @public\n * @export\n * @param {string} text - Full Definition file text\n *\n * @return {Array} - All parsed definition calls as objects\n */\nexport const definition = text => {\n  return Array.from(\n    // Strip all comments from the text, and find all matching definition calls\n    stripComments(text).matchAll(FIND_DEFINITION),\n    // For each found definition call, build the parsed definition object\n    definition => {\n      // Extract the content from the matching definition\n      const [ _, type, identifier, match ] = definition\n\n      // All regex variants start with /, so use that to set the variant to regex of expression\n      const variant = identifier === `/` ? REGEX_VARIANT : EXPRESSION_VARIANT\n\n      // Build and return the parsed definition object\n      return {\n        match,\n        variant,\n        type: type.toLowerCase(),\n        content: getContent(definition),\n      }\n    }\n  )\n}\n","import { feature } from './feature'\nimport { definition } from './definition'\n\nexport const parse = {\n  feature,\n  definition,\n}\n","import { parse } from './parse'\nimport { constants } from './constants'\nimport { isArr, capitalize, isObj, isStr } from '@keg-hub/jsutils'\nimport {\n  throwMissingSteps,\n  throwMissingFeatureText,\n  testMethodFill,\n} from './errors'\nconst { STEP_TYPES } = constants\n\n/*\n * Resolves a test method from the global scope\n * @function\n * @private\n * @param {string} type - Name of test method to get from the global scope\n *\n * @returns {function} - Test method\n */\nconst getTestMethod = type => global[type] || testMethodFill(type)\n\n/*\n * Calls the `it` global passing in a registered step function based on the step text\n * @function\n * @private\n * @param {Object} stepsInstance - Instance of the Steps class\n * @param {string} type - Type of step being run\n * @param {string} text - Text of the step from the parsed feature text\n *\n * @returns {Void}\n */\nconst runStep = (stepsInstance, step) => {\n  const test = getTestMethod('test')\n  return test(\n    `${capitalize(step.type)} ${step.step}`,\n    stepsInstance.resolve(step.step)\n  )\n}\n\n/*\n * Loops through the passed in scenarios steps and calls runStep for each\n * @function\n * @private\n * @param {Object} stepsInstance - Instance of the Steps class\n * @param {Object} scenario - Parsed feature scenario object containing the steps to run\n *\n * @returns {Void}\n */\nconst runScenario = (stepsInstance, scenario) => {\n  const describe = getTestMethod('describe')\n\n  return describe(`Scenario: ${scenario.scenario}`, () => {\n    scenario.steps.map(step => runStep(stepsInstance, step))\n  })\n}\n\n/*\n * Parses and runs the steps of a feature text string\n * Uses the registered steps of the passed in Steps class instance to evaluate the feature steps\n * @class\n * @public\n * @param {Object} stepsInstance - Instance of the Steps class\n *\n * @returns {Object} Instance of the Runner class\n */\nexport class Runner {\n  constructor(steps) {\n    !steps && throwMissingSteps()\n\n    this.steps = steps\n  }\n\n  /*\n   * Parses and runs the steps of a feature text string\n   * Matches each step to a registered steps of the Steps class instance\n   * @memberof Runner\n   * @function\n   * @public\n   * @param {string|Array<Object>|Object} data - Feature data as a string or parsed Feature model\n   *\n   * @returns {void}\n   */\n  run = data => {\n    const features = isStr(data)\n      ? parse(data)\n      : isObj(data)\n        ? [data]\n        : isArr(data)\n          ? data\n          : throwMissingFeatureText()\n\n    const describe = getTestMethod('describe')\n\n    features.map(feature => {\n      describe(`Feature: ${feature.feature}`, () => {\n        feature.scenarios.map(scenario => runScenario(this.steps, scenario))\n      })\n    })\n  }\n}\n","import { Steps } from './steps'\nimport { parse } from './parse'\nimport { Runner } from './runner'\nimport { registerParamType } from './matcher'\nimport { isObj, capitalize } from '@keg-hub/jsutils'\n\n/**\n * @typedef\n * Parkin#Given - Register Given step definitions\n * Parkin#When - Register When step definitions\n * Parkin#Then - Register Then step definitions\n * Parkin#And - Register And step definitions\n * Parkin#But - Register But step definitions\n * Parkin#run - Run step definitions against feature\n * Parkin#parse - Object containing parse helper methods\n * Parkin#parse#feature - Parse feature file text into a feature object\n * Parkin#parse#definition - Parse definition file text into a step definition objects\n * Parkin#registerSteps - Register step definitions to be accessible when running features\n * Parkin#paramTypes - Object containing param type helper methods\n * Parkin#paramTypes#register - Register custom paramTypes for step definitions\n */\n\n/**\n * Main class for handling feature files in the browser\n * Use the Steps, Runner and parser to allow executing feature file tests\n * @class\n * @public\n * @param {Object} world - Holds configuration for the running test environment\n * @param {Object} steps - Object with step type keys containing step definitions\n *\n * @returns {Object} Instance of the Parkin class\n */\nexport class Parkin {\n  constructor(world, steps) {\n    this.steps = new Steps(world)\n    this.runner = new Runner(this.steps)\n\n    /**\n     * Runs the step definition methods matching the steps of a feature\n     * @memberof Parkin\n     * @alias instance&period;run\n     * @function\n     * @public\n     *\n     * @returns {function} - Run tests method for executing a features steps\n     */\n    this.run = this.runner.run\n\n    /**\n     * Access parse object containing feature and definition parse methods\n     * @memberof Parkin\n     * @alias instance&period;parse\n     * @function\n     * @public\n     *\n     * @returns {Object} - parse object container `feature` and `definition` parse methods\n     */\n    this.parse = parse\n\n    /**\n     * Access paramTypes object containing the paramTypes register method\n     * <br>Allows registering custom paramTypes within registered step definitions\n     * @memberof Parkin\n     * @alias instance&period;paramTypes\n     * @function\n     * @public\n     * @example\n     * const PK = new Parkin()\n     * PK.paramTypes.register({ ...paramType model })\n     *\n     * @returns {Object} - paramTypes object container `register` param types method\n     */\n    this.paramTypes = { register: registerParamType }\n\n    // Register in steps passed in on initialization\n    isObj(steps) && this.registerSteps(steps)\n\n    /**\n     * Step Definition Register methods\n     * @memberof Parkin\n     * @alias instance&period;When\n     * @function\n     * @public\n     * @param {string} match - Text used to matched with a features step\n     * @param {function} method - Function called when a features step text matches the text param\n     * @example\n     *\n     * @example\n     * const PK = new Parkin()\n     * PK.Given(`Given step definition matching string || regex`, ()=> {})\n     * PK.When(`When step definition matching string || regex`, ()=> {})\n     * PK.Then(`Then step definition matching string || regex`, ()=> {})\n     * PK.And(`And step definition matching string || regex`, ()=> {})\n     * PK.But(`But tep definition matching string || regex`, ()=> {})\n     *\n     * @returns {void}\n     */\n    this.steps.types.map(type => {\n      this[capitalize(type)] = (matcher, method) =>\n        this.steps.register(`_${type}`, type, matcher, method)\n    })\n  }\n\n  /**\n   * Helper for registering step definitions after the Parkin class instance has ben created\n   * @memberof Parkin\n   * @alias instance&period;registerSteps\n   * @function\n   * @public\n   * @param {Object} steps - Object with step type keys containing step definitions\n   * @example\n   *   // Example steps object passed in as the first argument\n   *   const steps = {\n   *     given: {\n   *       // Key / Value pair of matcher text and corresponding function\n   *       `I goto page {url}`: () => {},\n   *     },\n   *     when: { ... },\n   *     then: { ... }\n   *   }\n   *\n   * @returns {void}\n   */\n  registerSteps = steps => {\n    // Loop the steps object\n    Object.entries(steps).map((type, typedSteps) =>\n      // Loop each step type ( Given, When, Then )\n      Object.entries(typedSteps).map((matcher, method) =>\n        // Register the step based by type with the Step class instance\n        this.steps[capitalize(type)](matcher, method)\n      )\n    )\n  }\n}\n"],"names":["isArr","value","Array","isObj","obj","isFunc","func","deepFreeze","Object","prop","isStr","str","equalsNaN","val","noOpObj","noPropObj","content","noPropArr","exists","checkCall","method","undefined","toStr","JSON","getNums","matchRegex","step","text","match","RegExp","slice","length","constants","REGEX_VARIANT","EXPRESSION_VARIANT","STEP_TYPES","testMethodFill","type","Error","throwMissingSteps","throwMissingFeatureText","throwNoMatchingStep","ReferenceError","throwParamTypeExists","name","typeModel","regexp","useForSnippets","transformer","arg","preferForRegexpMatch","__paramTypes","any","word","float","toFloat","int","includes","toInt","string","trim","replace","getParamTypes","registerParamType","model","key","convertTypes","matches","transformers","map","item","i","paramType","asType","filter","RX_OPTIONAL","RX_ALT","RX_EXPRESSION","RX_EXP_REPLACE","RX_MATCH_REPLACE","inBrowser","Boolean","window","escapeStr","runRegexCheck","matcher","testRx","replaceWith","test","regexStr","args","start","end","split","join","convertToRegex","paramTypes","regex","push","checkOptional","checkAlternative","altIndexes","matchExpression","escaped","regexAlts","found","converted","stepDefs","reduce","variant","sanitize","toString","substr","charAt","getContent","capitalize","registerFromCall","internalType","indexOf","registerFromParse","definitions","eitherArr","definition","Function","Given","When","Then","And","But","Steps","constructor","world","list","types","concat","_world","apply","self","register","RX_NEWLINE","RX_TAG","RX_COMMENT","RX_FEATURE","RX_AS","RX_I_WANT","RX_SO_THAT","RX_IN_ORDER","RX_SCENARIO","RX_EXAMPLE","RX_GIVEN","RX_WHEN","RX_THEN","RX_AND","RX_BUT","RX_ASTERISK","RegStepTags","alt","featureMetaTags","getRXMatch","line","index","featureFactory","feature","uuid","tags","comments","scenarios","scenarioFactory","scenario","steps","stepFactory","altType","built","addReason","reason","checkStepTag","added","regTag","hasTag","featureMeta","featureTag","featureComment","comment","ensureFeature","featuresGroup","featureText","ensureScenario","scenarioText","features","lines","NEWLINES_MATCH","COMMENT_MATCH","MULTI_LINE_MATCH","FIND_DEFINITION","NEXT_DEFINITION","input","pop","exec","parsedContent","shift","stripComments","from","matchAll","_","identifier","toLowerCase","parse","getTestMethod","global","runStep","stepsInstance","resolve","runScenario","describe","Runner","data","Parkin","entries","typedSteps","runner","run","registerSteps"],"mappings":"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"}