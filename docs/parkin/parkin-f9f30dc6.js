System.register(["./wait-26c5e7c6-fdf32dc0.js","./globalScope-9788190d.js"],(function(e){"use strict";var t,r,s,n,i,a,o,c,u,l,h,p,d,g,m,$,f,x,w;return{setters:[function(e){t=e.i,r=e.a,s=e.b,n=e.d,i=e.c,a=e.n,o=e.e,c=e._,u=e.f,l=e.g,h=e.h,p=e.j,d=e.k},function(e){g=e.h,m=e.r,$=e.a,f=e.b,x=e.c,w=e.d}],execute:function(){const equalsNaN=e=>"number"==typeof e&&e!=e,exists=e=>e==e&&null!=e,eitherArr=(e,r)=>t(e)?e:r,isColl=e=>"object"==typeof e&&null!==e,get=(e,r,n)=>((e,r,n,i)=>{const a=e;if(!isColl(e)||!e||!r)return"set"!==n&&i||void 0;const o=t(r)?Array.from(r):r.split("."),c=o.pop();let u,l;for(;u=o.shift();){const t=e[u];if(isColl(t)||s(t)?e=t:("set"===n?e[u]={}:l=!0,e=e[u]),l)return i}return"get"===n?c in e?e[c]:i:"unset"===n?delete e[c]:(e[c]=i)&&a||a})(e,r,"get",n),getRegexSource=e=>{return t=e,Boolean(t&&t instanceof RegExp)?e.source:r(e)?e:null;var t},joinRegex=(...e)=>{const[s,n]=(e=>{if(t(e[0]))return[e[0],e[1]];const s=e[e.length-1],n=r(s)?s:void 0;return[n?e.splice(0,e.length-1):e,n]})(e),i=s.reduce(((e,t)=>{const r=getRegexSource(t);return r?""===e?r:`${e}|${r}`:e}),"");return new RegExp(`(${i})`,n)},capitalize=(e,t=!0)=>{if(!r(e)||!e[0])return e;const s=t?e.slice(1).toLowerCase():e.slice(1);return`${e[0].toUpperCase()}${s}`},E=['"',"'"],isQuoted=(e,t=E)=>r(e)&&t.some((t=>e.startsWith(t)&&e.endsWith(t))),reverseStr=e=>{if(!r(e))return;let t="";for(let r of e)t=r+t;return t},y=n({ALIAS_REF:"$$",ALIAS_WORLD_KEY:"$alias",ALIAS_REF_AT_RUNTIME:"$$:",REGEX_VARIANT:"regex",WORLD_REF:"$",WORLD_KEY:"$world",WORLD_AT_RUNTIME:"$:",EXPRESSION_VARIANT:"expression",STEP_TYPES:["given","when","then","and","but"],HOOK_TYPES:["beforeAll","afterAll","beforeEach","afterEach"],FEATURE_META:["feature","perspective","desire","reason","comments"],LOG_JEST_SPEC_ENV:"PARKIN_LOG_JEST_SPEC",SPEC_RESULT_LOG:"------- PARKIN SPEC RESULT LOG -------"}),getRXMatch=(e,t,r)=>{const s=e.match(t)[r];return s?s.trim():" "},sanitizeForId=(e,t)=>{const r=e&&e.trim()&&e.trim().toLowerCase().replace(/[\s\/\\\(\)\+=_&%\$#@!\*~`\|\?:;"'<>,.{}]/g,"-");return r?`${r}-${e.length}`:`${t}-${t.length}`},removeQuotes=e=>e.trim().replace(/^("|')/,"").replace(/("|')$/,""),_=/\w*\([^)]*?\)/,R=/\s*\S*\/\S*\s*/,b=/\s*{(.*?)}\s*/,S=joinRegex(b,_,"g"),A=/(.*)/,k=/{|}/g,T=/^["]?\$world\.\S+["]?/,I=/^\$world\./,v=/(\$:world|\$world)+\.[^"'\s]*/gm,O=/^["]?\$\$\S+["]?/,L=/^\$\$/,P=/(\$\$:\w+|\$\$\w+)[^"'\s]*/gm,{WORLD_KEY:F,ALIAS_WORLD_KEY:j,ALIAS_REF:W}=y,checkWorldValue=(e,t)=>(r,s)=>{const n=r.match(T),a=r.match(O);if(!i(s)||!n&&!a)return matchType(e(r),t);const o=get(s,n?removeQuotes(r).replace(`${F}.`,""):removeQuotes(r).replace(`${W}`,`${j}.`));return exists(o)?matchType(o,t):n?((e,t)=>{throw new Error(`Can not replace ${e} with value from $world, it does not exist on the world object`,t,e)})(r,s):matchType(e(r),t)},matchType=(e,t)=>typeof e===t?e:null,N={name:"",regex:"",type:"string",useForSnippets:!0,preferForRegexpMatch:!1,transformer:checkWorldValue((e=>e),"string")},M={any:{...N,name:"any",regex:A},word:{...N,name:"word",regex:A,transformer:checkWorldValue((e=>{return isQuoted(e)?void 0:null==(t=e)?"":r(t)?t:JSON.stringify(t);var t}),N.type)},float:{...N,name:"float",type:"number",regex:/-?[0-9]+[.][0-9]+/,transformer:checkWorldValue((e=>{const t=parseFloat(e);return equalsNaN(t)?void 0:t}),"number")},int:{...N,name:"int",type:"number",regex:/-?[0-9]+/,transformer:checkWorldValue((e=>{const t=parseInt(e);return equalsNaN(t)||e.includes(".")?void 0:t}),"number")},string:{...N,name:"string",regex:joinRegex(/"[^"]+"/,/'[^']+'/),transformer:checkWorldValue((e=>isQuoted(e)?removeQuotes(e):void 0),N.type)}},getParamTypes=()=>M,registerParamType=(e=a,t=e.name)=>M[t]?(()=>{throw new Error(`Cannot register param type "${name}". It already exists!`)})():(M[t]={...N,...e},M[t].transformer=checkWorldValue(M[t].transformer,M[t].type),M),matchRegex=(e,t)=>{const r=t.match(new RegExp(e.match));return r?{definition:e,match:r.slice(1,r.length).filter(Boolean)}:a},toAlternateRegex=e=>{const t=e.split(/(\(|\))/),[r,,s,,n]=t;return""===r&&""===n?e+"?":""===r?`(${s}|${s}${n})`:""===n?`(${r}|${r}${s})`:`(${r}${n}|${r}${s}${n})`},getFullOptionalText=e=>((e,t,r=[" "])=>{const s=reverseStr(e),n=e.length-t;return reverseStr(((e,t,r=[" "])=>{const s=((e,t,r)=>r.map((r=>e.indexOf(r,t))).sort().find((e=>e>=0)))(e,t,r);return e.substring(t,-1===s?e.length:s)})(s,n,r))})(e.input,e.index)+e[0],getParamRegex=e=>{const t=getParamTypes();return(t[e]||t.any).regex.source},getAlternateRegex=e=>`(${e.trim().replace(/\//g,"|")})`,getMatchRegex=(e,t)=>{const[r,s]=t;switch(e){case"parameter":return new RegExp(getParamRegex(s));case"optional":return new RegExp((e=>{const t=getFullOptionalText(e);return toAlternateRegex(t)})(t));case"alternate":return new RegExp(getAlternateRegex(r));default:return null}},parseMatch=(e,t="other")=>{const r=e[0];return{text:r.trim(),index:e.index,input:e.input,regex:getMatchRegex(t,e),type:t,..."parameter"===t&&{paramType:r.trim().replace(k,"")}}},getRegexParts=e=>[...[...e.matchAll(new RegExp(b,"gi"))].map((e=>parseMatch(e,"parameter"))),...[...e.matchAll(new RegExp(_,"gi"))].map((e=>parseMatch(e,"optional"))),...[...e.matchAll(new RegExp(R,"gi"))].map((e=>parseMatch(e,"alternate")))].sort(((e,t)=>e.index-t.index)),runRegexCheck=(e,t,r)=>{if(!t.test(e))return e;let n=e;return e.replace(t,((...e)=>{const t=e[0].trim(),[i,...a]=n.split(t),o=s(r)?r(...e):r;n=`${i}${o}${a.join(t)}`})),n},extractParameters=(e,t,r)=>{const s=getRegexParts(t),n=s.filter((e=>"parameter"===e.type)).length,i=s.reduce(((t,s)=>{const{params:n,textIndex:i,wordMatchIndex:a}=t,o=e.substring(i),c="word"===s.paramType,u=o.match(s.regex),l={0:r[a],index:o.indexOf(r[a])},h=c?l:u;return h?("parameter"===s.type&&h&&n.push(h[0]),{params:n,textIndex:i+(h&&h.index+h[0].length),wordMatchIndex:a+(c&&1)}):t}),{params:[],textIndex:0,wordMatchIndex:0});return n===i.params.length?i.params:null},matchExpression=(e,t,r)=>{if(e.match===t)return{definition:e,match:[]};const s=(n=e.match,g?n.replace(/[|\\[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d"):n.replace(/[|\\[\]^$+*?.]/g,"\\$&"));var n;const{regex:i}=(e=>({regex:runRegexCheck(e,new RegExp(R,"g"),getAlternateRegex),altIndexes:[]}))(s),{regex:c,transformers:u}=(e=>{const t=getParamTypes(),r=[];return{regex:runRegexCheck(e,S,((e,...s)=>{const n=e.trim().replace(k,""),i=e.match(b),a=e.match(_);return i&&r.push(t[n]||t.any),i?getParamRegex(n):a?toAlternateRegex(e):e})),transformers:r}})(i),{regex:l}=(e=>{let t=e;return e.startsWith("^")||(t="^"+t),e.endsWith("$")||(t+="$"),{regex:t}})(c),h=matchRegex({...e,match:l},t);if(!h||!h.definition||!h.match)return a;const p=extractParameters(t,e.match,h.match);if(!p)return a;const d=((e,t,r)=>e.map(((e,s)=>{const n=t[s]||M.any;return o(n.transformer,e,r)})).filter(exists))(p,u,r);return d.length!==p.length?a:{definition:e,match:d}},{REGEX_VARIANT:C}=y;class Matcher{constructor(){c(this,"find",matcher),c(this,"regex",matchRegex),c(this,"parts",getRegexParts),c(this,"types",getParamTypes),c(this,"extract",extractParameters),c(this,"expression",matchExpression),c(this,"register",registerParamType)}}const matcher=(e,t,r)=>e.reduce(((e,s)=>e.match||!s.match?e:s.variant!==C?matchExpression(s,t,r):matchRegex(s,t)),a),{REGEX_VARIANT:D,EXPRESSION_VARIANT:G,STEP_TYPES:H}=y,registerFromCall=function(e,t,r,s,n=a){const i={type:t,meta:n,match:r,method:s,tokens:[],variant:0===r.toString().indexOf("/")?D:G};i.name=(e=>{let t=e.match.toString();return"/"===t[0]&&(t=t.substr(1)),"^"===t[0]&&(t=t.substr(1)),"/"===t.charAt(t.length-1)&&(t=t.slice(0,-1)),"$"===t.charAt(t.length-1)&&(t=t.slice(0,-1)),t.replace(/\(\?:([^\|]+)+\|+([^\)]+)?\)/,"$1")})(i),i.uuid=sanitizeForId(`${t}-${i.name}`),i.content=(e=>{const t=e.variant===D?e.match.toString():`"${e.match}"`;return`${capitalize(e.type)}(${t}, ${e.method.toString()})`})(i);const o=((e,t)=>t.reduce(((e,t)=>!(!e||t.content===e.content)&&(t.uuid===e.uuid&&(e.uuid=`${e.uuid}-${e.content.length}`),e)),{...e}))(i,this.list());return o&&this[e].push(o),o},registerFromParse=function(e){const t=this.types.map((e=>capitalize(e))),r=t.reduce(((e,t)=>(e[t]=[],e)),{});return eitherArr(e,[e]).map((e=>{Function(`return (global, require, module, ${t.join(",")}) => {\n          return (function(global) { ${e} }).call(global, global)\n        }`)()(m(),$(),f(),...t.map((e=>((e,t,r)=>(...s)=>{const n=e[t](...s);return r[t].push(n),n})(this,e,r))))})),r};class Steps{constructor(e){c(this,"types",H),c(this,"list",(()=>{return(e=this).types.reduce(((t,r)=>t.concat(e[`_${r}`])),[]);var e})),c(this,"typeList",(()=>this.types.reduce(((e,t)=>{const r=`_${t}`;return e[r]=[...this[r]],e}),{}))),c(this,"match",(e=>{const t=this.list(),r=matcher(t,e,this._world);return!(!r.match||!r.definition)&&(r.match.push(this._world),r)})),c(this,"resolve",(e=>{const t=this.match(e);return t?t.definition.method(...t.match):(e=>{throw new ReferenceError(e)})(`Matching definition could not be found for step: "${e}"`)})),c(this,"register",((...e)=>r(e[0])?registerFromCall.apply(this,e):registerFromParse.apply(this,e))),c(this,"clear",(()=>{this.types.map((e=>this[`_${e}`]=[]))})),this._world=e||{};const t=this;this.types.map((e=>{const r=`_${e}`;this[r]=[],this[capitalize(e)]=(s,n,i)=>t.register(r,e,s,n,i)}))}}const{HOOK_TYPES:K}=y;class Hooks{constructor(e,t){c(this,"types",K),c(this,"instance",void 0),c(this,"getRegistered",(e=>{const t=this.types.includes(e)?this._registeredHooks[e]||u:((e,t)=>{throw new Error([`Expected client hook type to be one of ', ${e}.`,`Found: ${t}`].join("\n"))})(K.join(", "),e);return t.length?async()=>t.reduce((async(e,t)=>(await e,await t(this.instance))),Promise.resolve()):l})),this._registeredHooks={},this.instance=t,this.types.map((e=>{this[e]=t=>{s(t)&&(this._registeredHooks[e]=this._registeredHooks[e]||[],this._registeredHooks[e].push(t))}}))}}const U=/^\s*?"""\s*?/,Y=/^\s*?```\s*?/,B=/^\s*?\|/,V=[{regex:/^\s*Given (.*)$/,type:"given"},{regex:/^\s*When(.*)$/,type:"when"},{regex:/^\s*Then (.*)$/,type:"then"},{regex:/^\s*And (.*)$/,type:"and"},{regex:/^\s*But (.*)$/,type:"but"},{regex:/^\s*\* (.*)$/,type:"and"}],stepFactory=(e,t,r,s)=>{let n={type:e,index:s,step:t,uuid:sanitizeForId(`${e}-${t}`)};const i=s+1,a=r[i],o=r.slice(i);return n=((e,t,r,s)=>{if(!B.test(r))return e;let n;return e.table={index:s,content:t.reduce(((e,t)=>(n=n||!B.test(t),!n&&e.push(t.split("|").reduce(((e,t)=>{const r=t.trim();return r&&e.push(r),e}),[])),e)),[])},e})(n,o,a,i),n=((e,t,r,s)=>{let n=U.test(r)&&'"""';if(n=n||Y.test(r)&&"```",!n)return e;const i=r.split(n)[0],a=new Array(i.length).fill("\\s").join(""),o=new RegExp(`^${a}`);return e.doc={index:s,whiteSpace:i,type:'"""'===n?"quote":"tick",content:t.split(n).slice(1).shift().trim().split("\n").reduce(((e,t)=>(e.push(t.replace(o,"").trim()),e)),[]).join("\n")},e})(n,o.join("\n"),a,i),n},{ALIAS_REF:q,WORLD_REF:J,ALIAS_WORLD_KEY:X,WORLD_AT_RUNTIME:z,ALIAS_REF_AT_RUNTIME:Q}=y,attemptReplace=(e,t,r)=>{const n=get(t,r);return s(n)?n(t,r):exists(n)?n:e},aliasReplace=(e,t)=>{let r;try{return e.replace(P,(e=>{r=e;const s=e.trim();return 0===s.indexOf(Q)?s.replace(Q,`$${q}`):attemptReplace(e,t,s.replace(L,`${X}.`))}))}catch(e){((e,t)=>{throw console.error(`Error replacing $$alias ( $world.$alias ) in feature text. Current match was ${t}`),e})(e,r)}},worldReplace=(e,t)=>{let r;try{return e.replace(v,(e=>{r=e;const s=e.trim();return 0===s.indexOf(z)?s.replace(z,J):attemptReplace(e,t,s.replace(I,""))}))}catch(e){((e,t)=>{throw console.error(`Error replacing $world value in feature text. Current match was ${t}`),e})(e,r)}},Z=/\r?\n/g,ee=/^\s*@(.*)$/,te=/^\s*#(.*)$/,re=/^\s*Feature:(.*)$/,se=/^\s*Rule:(.*)$/,ne=/^\s*Scenario:(.*)$/,ie=/^\s*Example:(.*)$/,ae=/^\s*Background:(.*)$/,oe=[{regex:/^\s*As (.*)$/,key:"perspective"},{regex:/^\s*I want (.*)$/,key:"desire"},{regex:/^\s*So that (.*)$/,key:"reason"},{regex:/^\s*In order (.*)$/,key:"reason"}],featureFactory=(e,t,r)=>({index:r,content:t,feature:e,tags:[],rules:[],reason:[],comments:[],scenarios:[],...e&&{uuid:sanitizeForId(e,r)}}),ruleFactory=(e,t)=>({index:t,rule:e,tags:[],scenarios:[],...e&&{uuid:sanitizeForId(e,t)}}),scenarioFactory=(e,t)=>({index:t,scenario:e,tags:[],steps:[],...e&&{uuid:sanitizeForId(e,t)}}),backgroundFactory=(e,t)=>({index:t,steps:[],background:e,...e&&{uuid:sanitizeForId(e,t)}}),parseFeature=function(e,t){t=t||this&&this.world||a;const r=((e,t)=>worldReplace(aliasReplace(e,t),t))((e||"").toString(),t).split(Z);let s=ruleFactory(!1),n=scenarioFactory(!1),i=backgroundFactory(!1),o=featureFactory(!1,e),c=o;return r.reduce(((t,a,u)=>(o=((e,t,r,s,n)=>{if(!re.test(r))return t;const i=getRXMatch(r,re,1);if(!t.feature)return t.feature=i,t.index||(t.index=n),t.uuid||(t.uuid=sanitizeForId(t.feature,n)),!e.includes(t)&&e.push(t),t;const a=featureFactory(i,s,n);return e.push(a),a})(t,o,a,e,u),((e,t,r)=>{if(!te.test(t))return!1;const s=t.match(te)[0];return e.comments.push({content:s,index:r}),!0})(o,a,u)||((e,t,r)=>{let s=!1;return oe.reduce(((n,i)=>{if(n)return n;const a=i.regex.test(t);return!s&&a&&(s=!0),a?"reason"===i.key?((e,t,r)=>{t&&e.reason.push({content:t,index:r})})(e,getRXMatch(t,i.regex,0),r):e[i.key]={content:getRXMatch(t,i.regex,0),index:r}:a}),!1),s})(o,a,u)?t:(s=((e,t,r,s)=>{if(!se.test(r))return t;let n=getRXMatch(r,se,1);return t.rule?t=ruleFactory(n,s):t.rule=n,!t.index&&(t.index=s),!t.uuid&&(t.uuid=sanitizeForId(t.rule,s)),!e.rules.includes(t)&&e.rules.push(t),t})(o,s,a,u),n=((e,t,r,s,n)=>{const i=ne.test(s);if(!i&&!ie.test(s))return r;let a=i&&getRXMatch(s,ne,1);a=a||getRXMatch(s,ie,1),r.scenario?r=scenarioFactory(a,n):r.scenario=a,!r.index&&(r.index=n),!r.uuid&&(r.uuid=sanitizeForId(r.scenario,n));const o=t.uuid?t:e;return!o.scenarios.includes(r)&&o.scenarios.push(r),r})(o,s,n,a,u),i=((e,t,r,s,n)=>{if(!ae.test(s))return r;const i=t.uuid?t:e,a=`${i.uuid}-background`;return r.background?r=backgroundFactory(a,n):r.background=a||"",!r.index&&(r.index=n),!r.uuid&&(r.uuid=sanitizeForId(r.background,n)),i.background=r,r})(o,s,i,a,u),!c.feature&&((e,t,r,s)=>V.reduce(((n,i)=>{if(n)return n;const a=i.regex.test(r);return a&&e.steps.push(stepFactory(i.type,getRXMatch(r,i.regex,1),t,s)),a}),!1))(c,r,a,u)||(c=((e,t,r,s,n,i)=>ne.test(i)||ie.test(i)?s:re.test(i)?t:se.test(i)?r:ae.test(i)?n:e)(c,o,s,n,i,a),((e,t,r,s)=>{if(!ee.test(r))return!1;const n=e.background?t:e,i=getRXMatch(r,ee,0);n.tags=(n.tags||[]).concat(i.split(" "))})(c,o,a)),t))),[])},parseDefinition=function(e){return this.steps.register([e])},{SPEC_RESULT_LOG:ce,LOG_JEST_SPEC_ENV:ue}=y,logResultToTerminal=e=>{const t=(new Date).getTime();get(process,`env.${ue}`)&&process.stdout.write([ce,JSON.stringify({...e,timestamp:t}),ce].join(""))},getSuiteData=e=>{const t=get(e,"description"),r=t?t.startsWith("Scenario >")?"Scenario":t.startsWith("Background >")?"Background":t.startsWith("Rule >")?"Rule":"Feature":"Feature";return{type:r.toLowerCase(),..."Feature"!==r&&{description:t.replace(`${r} >`,`${r}:`)}}},getTestMethod=(e,t)=>t?l:global[e]||(e=>()=>{throw new Error(`Test method ${e} does not exist on the global scope.\nPlease ensure ${e} exists before calling the run method!\n`)})(e),skipTestsOnFail=e=>{if(!x)return;const t=w().getEnv();t&&t.describe&&t.addReporter((e=>{const t=[],r=e.describe;return e.describe=(...e)=>{const s=r.apply(null,e);return t.push(s),s},{suiteStarted:e=>{logResultToTerminal({...e,...getSuiteData(e),action:"start"})},specStarted:e=>{logResultToTerminal({...e,type:"step",action:"start"})},specDone:e=>{if(logResultToTerminal({...e,type:"step",action:"end"}),"failed"!==e.status)return;const r=t.find((t=>t.children.find((t=>t.result===e))));r&&r.children.map((e=>e.disable()))},suiteDone:e=>{logResultToTerminal({...e,...getSuiteData(e),action:"end"})}}})(t))},buildTitle=(e,t)=>`${capitalize(t)} > ${e}`,resolveFeatures=(e,s)=>r(e)?parseFeature(e,s):i(e)?[e]:t(e)?e.reduce(((e,t)=>e.concat(resolveFeatures(t,s))),[]):(()=>{throw new Error("Runner class requires feature text when calling the run method")})(),loopSteps=(e,t,r,s)=>(getTestMethod("describe",s)(t,(()=>{const t=e.steps.map((e=>(async(e,t,r)=>{getTestMethod("test",r)(`${capitalize(t.type)} ${t.step}`,(async()=>await e.resolve(t.step)))})(r,e,s)));Promise.all(t)})),[]),runScenario=(e,t,r,s)=>(r&&loopSteps(r,buildTitle(t.scenario,"Background"),e,s),loopSteps(t,buildTitle(t.scenario,"Scenario"),e,s)),runRule=(e,t,r,s)=>{let n=[];return describe(`Rule > ${t.rule}`,(()=>{n=t.scenarios.map((n=>runScenario(e,n,r||t.background,s))),Promise.all(n)})),n},itemMatch=(e="",t=[],s={})=>{const{name:n,tags:i}=s,a=r(i)?(e=>r(e)&&e.match(/[@]\w*/g))(i):eitherArr(i,[]),o=!n||e.includes(n),c=!a.length||a.every((e=>t.includes(e)));return o&&c};class Runner{constructor(e,t,r){c(this,"getFeatures",((e,t)=>((e,t={})=>e.reduce(((e,r)=>{if(itemMatch(r.feature,r.tags,t))return e.push(r),e;const s=r.scenarios.filter((e=>itemMatch(e.scenario,[...e.tags||[],...r.tags||[]],t)));return s.length&&e.push({...r,scenarios:s}),e}),[]))(resolveFeatures(e,this._world),t))),c(this,"run",(async(e,t=a)=>{const r=this.run.PARKIN_TEST_MODE;skipTestsOnFail();const s=getTestMethod("describe",r),n=getTestMethod("beforeAll",r),i=getTestMethod("afterAll",r),o=getTestMethod("beforeEach",r),c=getTestMethod("afterEach",r),u=this.getFeatures(e,t);if(!u.length)return!1;const l=await u.map((async e=>{let t=[];return n(this.hooks.getRegistered("beforeAll")),i(this.hooks.getRegistered("afterAll")),o(this.hooks.getRegistered("beforeEach")),c(this.hooks.getRegistered("afterEach")),s(buildTitle(e.feature,"Feature"),(()=>{t=e.rules.map((t=>runRule(this.steps,t,e.background,r))),t.concat(e.scenarios.map((t=>runScenario(this.steps,t,e.background,r)))),Promise.all(t)})),t}));return await Promise.all(l),!0})),!e&&(()=>{throw new Error("Runner class constructor requires an instance of the Steps class")})(),!t&&throwMissingHooks(),this.steps=e,this.hooks=t,this._world=r}}const{FEATURE_META:le}=y,addContent=(e,t,r)=>{exists(r)?exists(e[r])?e.splice(r,0,t):e[r]=t:e.push(t)},addTags=(e,r,s="")=>{t(r)&&r.length&&addContent(e,`${s}${r.join(" ")}`)},addScenarios=(e,r)=>{r.scenarios&&r.scenarios.map((r=>{addTags(e,r.tags,"  "),addContent(e,`  Scenario: ${r.scenario}`,r.index),((e,r)=>{t(r.steps)&&r.steps.length&&r.steps.map((t=>addContent(e,`    ${capitalize(t.type)} ${t.step}`,t.index)))})(e,r)}))},formatAssembled=e=>Array.from(e,((t,r)=>exists(t)?t.startsWith("#")?((e,t,r)=>{const s=e[r+1],n=e[r-1];let i=exists(s)?s:n;if(!i)return`${t}\n`;const a=t.split("#").pop();return`${Array(i.length-i.trimStart().length).join(" ")} # ${a}\n`})(e,t,r):`${t}\n`:"\n")).join("").trim(),he={feature:e=>eitherArr(e,[e]).map((e=>{let r=[];return!i(e)&&(e=>{throw new Error("Assemble feature requires an object matching the feature model spec!",e)})(e),addTags(r,e.tags),((e,r)=>{le.map((s=>{switch(s){case"feature":addContent(e,`Feature: ${r[s]}`,r.index);break;case"comments":t(r[s])&&r[s].map((t=>addContent(e,t.content,t.index)));break;case"reason":t(r[s])&&r[s].map((t=>addContent(e,`  ${t.content}`,t.index)));break;case"desire":case"perspective":r[s]&&addContent(e,`  ${r[s].content}`,r[s].index)}}))})(r,e),addScenarios(r,e),formatAssembled(r)}))};var pe=new WeakMap;class Parkin{constructor(e,t){h(this,pe,{writable:!0,value:!1}),c(this,"init",((e=a,t)=>{if(p(this,pe))return console.warn("This instance of parkin has already been initialized!");i(e.$alias)||(e.$alias={}),d(this,pe,!0),this.world=e,this.steps=new Steps(this.world),this.hooks=new Hooks(this.world),this.runner=new Runner(this.steps,this.hooks,this.world),this.run=this.runner.run,this.parse={feature:parseFeature.bind(this),definition:parseDefinition.bind(this)},this.assemble=he,this.paramTypes={register:registerParamType},this.matcher=new Matcher,i(t)&&this.registerSteps(t),this.steps.types.map((e=>{this[capitalize(e)]=(t,r,s)=>this.steps.register(`_${e}`,e,t,r,s)}))})),c(this,"registerSteps",(e=>{Object.entries(e).map(((e,t)=>Object.entries(t).map(((t,r)=>this.steps[capitalize(e)](t,...eitherArr(r,[r]))))))})),i(e)&&this.init(e,t)}}e("P",Parkin);e("a",new Parkin)}}}));
