{
  "version": 3,
  "sources": ["../../../node_modules/.pnpm/@keg-hub+jsutils@9.10.0/node_modules/@keg-hub/jsutils/build/cjs/chunk-NAVY3LVQ.js", "../../../node_modules/.pnpm/@keg-hub+jsutils@9.10.0/node_modules/@keg-hub/jsutils/build/cjs/isStr.js", "../../../node_modules/.pnpm/@keg-hub+jsutils@9.10.0/node_modules/@keg-hub/jsutils/temp/deepFreeze.ts", "../../../node_modules/.pnpm/@keg-hub+jsutils@9.10.0/node_modules/@keg-hub/jsutils/build/cjs/deepFreeze.js", "../../../node_modules/.pnpm/@keg-hub+jsutils@9.10.0/node_modules/@keg-hub/jsutils/build/cjs/isFunc.js", "../../../node_modules/.pnpm/@keg-hub+jsutils@9.10.0/node_modules/@keg-hub/jsutils/temp/keyMap.ts", "../../../node_modules/.pnpm/@keg-hub+jsutils@9.10.0/node_modules/@keg-hub/jsutils/build/cjs/keyMap.js", "../../../node_modules/.pnpm/@keg-hub+jsutils@9.10.0/node_modules/@keg-hub/jsutils/temp/emptyObj.ts", "../../../node_modules/.pnpm/@keg-hub+jsutils@9.10.0/node_modules/@keg-hub/jsutils/build/cjs/emptyObj.js", "../../../node_modules/.pnpm/@keg-hub+jsutils@9.10.0/node_modules/@keg-hub/jsutils/build/cjs/isObj.js", "../../../node_modules/.pnpm/@keg-hub+jsutils@9.10.0/node_modules/@keg-hub/jsutils/build/cjs/wait.js", "../../../node_modules/.pnpm/@keg-hub+jsutils@9.10.0/node_modules/@keg-hub/jsutils/build/cjs/noOp.js", "../../../node_modules/.pnpm/@keg-hub+jsutils@9.10.0/node_modules/@keg-hub/jsutils/temp/isNum.ts", "../../../node_modules/.pnpm/@keg-hub+jsutils@9.10.0/node_modules/@keg-hub/jsutils/build/cjs/isNum.js", "../../../node_modules/.pnpm/@keg-hub+jsutils@9.10.0/node_modules/@keg-hub/jsutils/build/cjs/exists.js", "../../../node_modules/.pnpm/@keg-hub+jsutils@9.10.0/node_modules/@keg-hub/jsutils/temp/checkCall.ts", "../../../node_modules/.pnpm/@keg-hub+jsutils@9.10.0/node_modules/@keg-hub/jsutils/build/cjs/checkCall.js", "../../../src/test/index.ts", "../../../src/utils/errors.ts", "../../../src/types/helpers.types.ts", "../../../src/constants.ts", "../../../src/test/utils.ts", "../../../src/test/runResult.ts", "../../../src/test/hooks.ts", "../../../src/utils/promiseRetry.ts", "../../../src/utils/promiseTimeout.ts", "../../../src/test/runTest.ts", "../../../src/test/runHelpers.ts", "../../../src/test/loopTests.ts", "../../../src/test/loopDescribes.ts", "../../../src/test/run.ts", "../../../src/test/test.ts"],
  "sourcesContent": ["'use strict';\n\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\")\n    return require.apply(this, arguments);\n  throw Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\nexports.__require = __require;\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=chunk-NAVY3LVQ.js.map", "'use strict';\n\nvar chunkEZUOWDJH_js = require('./chunk-EZUOWDJH.js');\nrequire('./chunk-NAVY3LVQ.js');\n\n\n\nObject.defineProperty(exports, 'isStr', {\n  enumerable: true,\n  get: function () { return chunkEZUOWDJH_js.isStr; }\n});\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=isStr.js.map", "/** @module Object */\n\nimport { isFunc } from '@method/isFunc'\n\n/**\n * Recursively freezes and object.\n * @function\n * @param {Object} obj\n * @return {Object} - frozen Object\n */\nexport const deepFreeze = <T = Record<any, any>>(obj: Record<any, any>): T => {\n  Object.freeze(obj)\n  Object.getOwnPropertyNames(obj).map(prop => {\n    obj.hasOwnProperty(prop) &&\n      obj[prop] !== null &&\n      (typeof obj[prop] === 'object' || isFunc(obj[prop])) &&\n      !Object.isFrozen(obj[prop]) &&\n      deepFreeze(obj[prop])\n  })\n\n  return obj\n}\n", "'use strict';\n\nvar chunkADLVKC77_js = require('./chunk-ADLVKC77.js');\nrequire('./chunk-JUTNCG4G.js');\nrequire('./chunk-NAVY3LVQ.js');\n\n\n\nObject.defineProperty(exports, 'deepFreeze', {\n  enumerable: true,\n  get: function () { return chunkADLVKC77_js.deepFreeze; }\n});\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=deepFreeze.js.map", "'use strict';\n\nvar chunkTUQXM63H_js = require('./chunk-TUQXM63H.js');\nrequire('./chunk-NAVY3LVQ.js');\n\n\n\nObject.defineProperty(exports, 'isFunc', {\n  enumerable: true,\n  get: function () { return chunkTUQXM63H_js.isFunc; }\n});\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=isFunc.js.map", "/** @module Object */\n\nimport { isStr } from '@string/isStr'\nimport { isArr } from '@array/isArr'\n\n/**\n * Converts an array of strings to a matching key/value pair object.\n * @function\n * @param {Array} arr - to be converted to object\n * @param {Boolean} toUpperCase - converts the key and value to uppercase\n * @return {Object} built object\n */\nexport const keyMap = <T = Record<string, string>>(\n  arr: string[],\n  toUpperCase?: boolean\n): T =>\n  (isArr(arr) &&\n    arr.reduce((obj, key) => {\n      if (!isStr(key)) return obj\n\n      const use = (toUpperCase && key.toUpperCase()) || key\n      obj[use] = use\n\n      return obj\n    }, {} as T)) ||\n  ({} as T)\n", "'use strict';\n\nvar chunkHUDFDFCA_js = require('./chunk-HUDFDFCA.js');\nrequire('./chunk-M2P3KESR.js');\nrequire('./chunk-YKZGBM46.js');\nrequire('./chunk-NAVY3LVQ.js');\n\n\n\nObject.defineProperty(exports, 'keyMap', {\n  enumerable: true,\n  get: function () { return chunkHUDFDFCA_js.keyMap; }\n});\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=keyMap.js.map", "/** @module Extra */\n\nimport { noOpObj } from './noOpObj'\n\n/**\n * Reuseable empty, frozen object\n * @object\n * @type {Object}\n */\nexport const emptyObj = noOpObj\n", "'use strict';\n\nvar chunkHU3OFCD6_js = require('./chunk-HU3OFCD6.js');\nrequire('./chunk-3VOW2J5N.js');\nrequire('./chunk-NAVY3LVQ.js');\n\n\n\nObject.defineProperty(exports, 'emptyObj', {\n  enumerable: true,\n  get: function () { return chunkHU3OFCD6_js.emptyObj; }\n});\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=emptyObj.js.map", "'use strict';\n\nvar chunk55VOPQRW_js = require('./chunk-55VOPQRW.js');\nrequire('./chunk-NAVY3LVQ.js');\n\n\n\nObject.defineProperty(exports, 'isObj', {\n  enumerable: true,\n  get: function () { return chunk55VOPQRW_js.isObj; }\n});\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=isObj.js.map", "'use strict';\n\nvar chunk22XNUJ2Z_js = require('./chunk-22XNUJ2Z.js');\nrequire('./chunk-NAVY3LVQ.js');\n\n\n\nObject.defineProperty(exports, 'wait', {\n  enumerable: true,\n  get: function () { return chunk22XNUJ2Z_js.wait; }\n});\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=wait.js.map", "'use strict';\n\nvar chunkKGAFRANE_js = require('./chunk-KGAFRANE.js');\nrequire('./chunk-NAVY3LVQ.js');\n\n\n\nObject.defineProperty(exports, 'noOp', {\n  enumerable: true,\n  get: function () { return chunkKGAFRANE_js.noOp; }\n});\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=noOp.js.map", "/** @module Number */\n\nimport { equalsNaN } from './equalsNaN'\n\n/**\n * Checks is value is a number.\n * @example\n * isInt(1)\n * // Returns true\n * @example\n * isInt(NaN)\n * // Returns false\n * @example\n * isInt('1')\n * // Returns false ( because it's a string )\n * @function\n * @param {*} val - value to check if is a number\n * @return {Boolean} T/F - if value is a number\n */\nexport const isNum = <T = number>(val: any): val is T =>\n  typeof val === 'number' && !equalsNaN(val)\n", "'use strict';\n\nvar chunkHLCV3VHS_js = require('./chunk-HLCV3VHS.js');\nrequire('./chunk-EULM2VZV.js');\nrequire('./chunk-NAVY3LVQ.js');\n\n\n\nObject.defineProperty(exports, 'isNum', {\n  enumerable: true,\n  get: function () { return chunkHLCV3VHS_js.isNum; }\n});\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=isNum.js.map", "'use strict';\n\nvar chunk64FECTQT_js = require('./chunk-64FECTQT.js');\nrequire('./chunk-NAVY3LVQ.js');\n\n\n\nObject.defineProperty(exports, 'exists', {\n  enumerable: true,\n  get: function () { return chunk64FECTQT_js.exists; }\n});\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=exists.js.map", "/** @module Function */\n\nimport { isFunc } from './isFunc'\n\n/**\n * Check if the passed in method is a function, and calls it\n * @example\n * checkCall((param1) => { return param1 }, 'foo')\n * // Returns 'foo'\n * @function\n * @param {Function} method - function to call\n * @param {Object} params - params to pass to the method on call\n * @return {*} - whatever the passed in method returns\n */\nexport function checkCall<P = unknown, T = unknown>(\n  method: (param?: P, ...params: any[]) => T,\n  param?: P,\n  ...params: any[]\n): T\nexport function checkCall<T = any>(\n  method: <M = any>(...params: any[]) => M,\n  ...params: any[]\n): T\nexport function checkCall<T = any, M = any>(\n  method: (...params: any[]) => M,\n  ...params: any[]\n): T\nexport function checkCall<T = any>(\n  method: (...params: any[]) => any,\n  ...params: any[]\n): T\nexport function checkCall(\n  method: (...params: any[]) => any,\n  ...params: any[]\n): any {\n  return isFunc(method) ? method(...params) : undefined\n}\n", "'use strict';\n\nvar chunk6QOPPP35_js = require('./chunk-6QOPPP35.js');\nrequire('./chunk-TUQXM63H.js');\nrequire('./chunk-NAVY3LVQ.js');\n\n\n\nObject.defineProperty(exports, 'checkCall', {\n  enumerable: true,\n  get: function () { return chunk6QOPPP35_js.checkCall; }\n});\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=checkCall.js.map", "export * from './test'\n", "import {isStr} from '@keg-hub/jsutils/isStr'\nimport { ParkinAbortErrName, ParkinBailErrName } from '../constants'\nimport { EHookType, TRunResults } from '../types'\n\nconst resolveErrMsg = (error?:string|Error, maybe?:Error|string):[string, Error] => {\n  return isStr(error)\n    ? [error as string, maybe as Error]\n    : [((error || maybe) as Error)?.message, (error || maybe) as Error]\n}\n\nconst replaceStackMsg = (err:Error, msg:string) => {\n  const split = err.stack.split(`\\n`)\n  split[0] = msg\n\n  return split.join(`\\n`)\n}\n\nexport class ParkinError extends Error {\n  name = `ParkinError`\n  results?:TRunResults\n  testResults?:TRunResults\n\n  constructor(msg:string|Error, error?:string|Error|ParkinError, replaceStack:boolean=true){\n    const [message, err] = resolveErrMsg(msg, error)\n    const { stackTraceLimit } = Error\n    if(err && replaceStack){\n      // Create a new error without a stacktrace\n      Error.stackTraceLimit = 0\n    }\n\n    // Set the error cause if it's different form the message\n    const opts = err && message !== err?.message\n      ? { cause: err?.message }\n      : undefined\n\n    super(message, opts)\n\n    this.results = (err as ParkinError)?.results || []\n    this.testResults = (err as ParkinError)?.testResults || []\n\n    if((err as any)?.result && !this.results.includes((err as any).result))\n      this.results.push((err as any).result)\n\n    // Reset the original stacktrace limit\n    Error.stackTraceLimit = stackTraceLimit\n    this.name = this.constructor.name\n    \n    if(replaceStack){\n      if(err?.stack) this.stack = replaceStackMsg(err, message)\n      err && Error.captureStackTrace(err, this.constructor)\n    }\n  }\n}\n\nexport class ParkinBailError extends ParkinError {\n  name = ParkinBailErrName\n  constructor(msg:string|Error, error?:string|Error, replaceStack:boolean=true){\n    super(msg, error, replaceStack)\n  }\n}\n\nexport class ParkinAbortError extends ParkinError {\n  name = ParkinAbortErrName\n  constructor(msg:string|Error, error?:string|Error, replaceStack:boolean=true){\n    super(msg, error, replaceStack)\n  }\n}\n\nexport class RetryError extends Error {\n  results?:TRunResults\n  constructor(err:Error, message?:string, retry?:number) {\n    super(message || err.message)\n    this.stack = err.stack\n    // Only overwrite the default Error name when retry was actually set\n    // Keep custom named errors incase they are depended on\n    this.name = !retry ? err.name : this.constructor.name\n\n    if(message) this.cause = err.message\n    if((err as RetryError).results) this.results = (err as RetryError).results\n  }\n}\n\n/*\n * Helper method to use throw a Parkin Bail error\n * @function\n * @public\n * @throws\n *\n */\nexport const throwAbortError = (err?:Error) => {\n  throw new ParkinAbortError(\n    `Test execution \\x1b[33m\"aborted\"\\x1b[0m`,\n    err,\n    true\n  )\n}\n\n/*\n * Helper method to use throw a Parkin Bail error\n * @function\n * @public\n * @throws\n *\n */\nexport const throwBailError = (err:Error, bail?:number) => {\n  const colored = `\\x1b[33m${bail}\\x1b[0m`\n  throw new ParkinBailError(\n    `Stopping test execution. Max allowed failed${bail ? ` ${colored} ` : ` `}tests has been reached`,\n    err,\n    true\n  )\n}\n\nexport const throwExitOnFailed = (err:Error) => {\n  throw new ParkinBailError(\n    `Stopping test execution. A test failed and \\x1b[33m\"exitOnFailed\"\\x1b[0m is active`,\n    err,\n    true\n  )\n}\n\n/*\n * Helper method to use the a test method can not be found on the global scope\n * @function\n * @public\n * @throws\n *\n */\nexport const testMethodFill = (type:string) => {\n  /*\n   * Internal method that throws an error when a test method does not exist on the global scope\n   * @function\n   * @private\n   * @inner\n   *\n   */\n  return () => {\n    throw new ParkinError(\n      `` +\n        `Test method ${type} does not exist on the global scope.\\n` +\n        `Please ensure ${type} exists before calling the run method!\\n`\n    )\n  }\n}\n\n/**\n * Throws an error when a Steps class instance is not passed to the runner class constructor\n * @function\n * @public\n * @throws\n *\n */\nexport const throwMissingSteps = () => {\n  throw new ParkinError(\n    `Runner class constructor requires an instance of the Steps class`\n  )\n}\n\n/**\n * Throws an error when a Hooks class instance is not passed to the runner class constructor\n * @function\n * @public\n * @throws\n *\n */\nexport const throwMissingHooks = (found:any) => {\n  throw new ParkinError(\n    `Runner class constructor requires an instance of the Hooks class. Found: ${found}`\n  )\n}\n\n/**\n * Throws an error when a feature text is not passed to the Runner class instance\n * @function\n * @public\n * @throws\n *\n */\nexport const throwMissingFeatureText = () => {\n  throw new ParkinError(\n    `Runner class requires feature text when calling the run method`\n  )\n}\n\n/**\n * Throws an error when a feature text is not passed to the Runner class instance\n * @function\n * @public\n * @throws\n *\n */\nexport const throwInvalidDefParams = (msg:string=``) => {\n  throw new ParkinError(\n    `Malformed step text, could not extract the expected step definition parameters. ${msg}`.trim()\n  )\n}\n\n\n/**\n * Throws an error when a feature step does not match a step definition's text\n * @function\n * @public\n * @throws\n *\n */\nexport const throwMissingDef = (step:string) => {\n  throw new ParkinError(`Matching definition could not be found for step: \"${step}\"`)\n}\n\n/**\n * Throws an error when a feature step does not match a step definition\n * @function\n * @public\n * @throws\n *\n */\nexport const throwNoMatchingStep = (text:string) => {\n  throw new ParkinError(text)\n}\n\n/**\n * Throws an error when a registering a param type that already exists\n * @function\n * @public\n * @throws\n *\n */\nexport const throwParamTypeExists = (name:string) => {\n  throw new ParkinError(`Cannot register param type \"${name}\". It already exists!`)\n}\n\n/**\n * Throws an error when a assembling a parsed feature, and no parsed feature object exists\n * @function\n * @public\n * @throws\n * \n */\nexport const throwFeatureNotAnObj = (feature:any) => {\n  throw new ParkinError(`Assemble feature requires an object matching the feature model spec!`)\n}\n\n/**\n * Throws an error when a registering a param type that already exists\n * @function\n * @public\n * @throws\n *\n */\nexport const throwMissingWorldValue = (arg:string) => {\n  throw new ParkinError(\n    `Can not replace ${arg} with value from $world, it does not exist on the world object`,\n  )\n}\n\n/**\n * Throws an error when a registering an invalid hook type\n * @function\n * @public\n * @throws\n *\n */\nexport const throwInvalidHookType = (hookTypes:EHookType, type:string) => {\n  throw new ParkinError(\n    [\n      `Expected client hook type to be one of ', ${hookTypes}.`,\n      `Found: ${type}`,\n    ].join('\\n')\n  )\n}\n\n/**\n * Throws an error when running world replace on feature text content\n * @function\n * @public\n * @throws\n *\n */\nexport const throwWorldReplace = (err:Error, currentMatch:string) => {\n  throw new ParkinError(`Error replacing $world value in feature text. Current match was ${currentMatch}`, err)\n}\n\n/**\n * Throws an error when running world.alias replace on feature text content\n * @function\n * @public\n * @throws\n *\n */\nexport const throwAliasReplace = (err:Error, currentMatch:string) => {\n  throw new ParkinError(\n    `Error replacing $$alias ( $world.$alias ) in feature text. Current match was ${currentMatch}`,\n    err\n  )\n}\n", "export enum EHookType {\n  beforeAll=`beforeAll`,\n  afterAll=`afterAll`,\n  beforeEach=`beforeEach`,\n  afterEach=`afterEach`\n}\n\nexport enum EStepType {\n  step=`step`,\n  given=`given`,\n  when=`when`,\n  then=`then`,\n  and=`and`,\n  but=`but`,\n  \"*\"=`*`,\n}\n\nexport enum EStepMethodType {\n  Given=`Given`,\n  When=`When`,\n  Then=`Then`,\n  And=`And`,\n  But=`But`,\n  \"*\"=`*`,\n}\n\nexport enum EAstObject {\n  error=`error`,\n  tags=`tags`,\n  rule=`rule`,\n  rules=`rules`,\n  step=`step`,\n  steps=`steps`,\n  block=`block`,\n  blocks=`blocks`,\n  empty=`empty`,\n  reason=`reason`,\n  desire=`desire`,\n  comment=`comment`,\n  comments=`comments`,\n  feature=`feature`,\n  scenario=`scenario`,\n  scenarios=`scenarios`,\n  background=`background`,\n  perspective=`perspective`,\n\n  given=`given`,\n  when=`when`,\n  then=`then`,\n  and=`and`,\n  but=`but`,\n  \"*\"=`*`,\n  \n  expression=`expression`,\n  expressions=`expressions`,\n}\n\nexport enum EFeatureTypes {\n  feature = `Feature`,\n  Feature = `Feature`,\n  FEATURE = `Feature`,\n  rule = `Rule`,\n  Rule = `Rule`,\n  background = `Background`,\n  Background = `Background`,\n  BACKGROUND = `Background`,\n  scenario = `Scenario`,\n  Scenario = `Scenario`,\n  SCENARIO = `Scenario`,\n  example = `Example`,\n  Example = `Example`,\n  EXAMPLE = `Example`,\n  step = `Step`,\n  Step = `Step`,\n  RULE = `Rule`,\n  STEP = `Step`\n}\n\nexport type TAnyFunc = (...args:any[]) => any\n", "import { EAstObject, EStepType, EHookType } from './types'\nimport { deepFreeze } from '@keg-hub/jsutils/deepFreeze'\n\nconst ignoreTypes = [\n  `*`,\n  ``,\n]\n\nexport const constants = deepFreeze({\n  ALIAS_REF: `$$`,\n  WORLD_REF: `$`,\n  WORLD_KEY: `$world`,\n  WORLD_AT_RUNTIME: `$:`,\n  REGEX_VARIANT: `regex`,\n  ALIAS_WORLD_KEY: `$alias`,\n  ALIAS_REF_AT_RUNTIME: `$$:`,\n  EXPRESSION_VARIANT: `expression`,\n  HOOK_TYPES: Object.keys(EHookType),\n  LOG_JEST_SPEC_ENV: `PARKIN_LOG_JEST_SPEC`,\n  SPEC_RESULT_LOG: `------- PARKIN SPEC RESULT LOG -------`,\n  STEP_TYPES: Object.keys(EStepType).filter(type => !ignoreTypes.includes(type)),\n  FEATURE_META: [ `feature`, `perspective`, `desire`, `reason`, `comments` ],\n})\n\nexport const ParentTypes = [\n  EAstObject.rule,\n  EAstObject.scenario,\n  EAstObject.background,\n]\n\nexport const StepTypes = [\n  EAstObject.given,\n  EAstObject.when,\n  EAstObject.then,\n  EAstObject.and,\n  EAstObject.but,\n  EAstObject[`*`],\n  EAstObject.step,\n  EAstObject.steps,\n]\n\nexport const ParkinBailErrName = `ParkinBailError`\nexport const ParkinAbortErrName = `ParkinAbortError`", "import type {\n  TType,\n  TTestObj,\n  THookTypes,\n  TTestAction,\n  TRootTestObj,\n  TGlobalTypes,\n  TTestHookMethod,\n  TDescribeAction,\n  TDescribeTestObj,\n} from '../types'\n\nimport { ParkinError } from '../utils/errors'\nimport { isStr } from '@keg-hub/jsutils/isStr'\nimport { isFunc } from '@keg-hub/jsutils/isFunc'\nimport { keyMap } from '@keg-hub/jsutils/keyMap'\nimport { emptyObj } from '@keg-hub/jsutils/emptyObj'\n\n/**\n * @type {Object}\n * Key value pair of all helper method names for the ParkinTest Class\n */\nexport const hookTypes = keyMap<THookTypes>([\n  `beforeAll`,\n  `beforeEach`,\n  `afterAll`,\n  `afterEach`,\n])\n\n/**\n * @type {Object}\n * Key value pair of all methods added to the global scope\n */\nexport const globalTypes:TGlobalTypes = {\n  ...keyMap([ `test`, `it`, `xtest`, `xit`, `describe` ]),\n  ...hookTypes,\n}\n\n/**\n * @type {Object}\n * Key value pair of allowed Types for the ParkinTest Class\n */\nexport const Types:TType = {\n  ...globalTypes,\n  ...keyMap([`root`]),\n}\n\n/**\n * Adds the class instance methods to the global scope\n * @param {Object} instance - An instance of the ParkinTest Class\n *\n * @returns void\n */\nexport const addToGlobal = (instance:TTestObj) => {}\n\n/**\n * Throws an Error from the passed in error\n * @param {string} error - The Error message or Object to throw\n *\n * @throws\n */\nexport const throwError = (error:string) => {\n  throw new ParkinError(error)\n}\n\n/**\n * Validates the required arguments were passed in of a helper method\n * @throws\n *\n */\nexport const validateHook = (\n  type:keyof typeof Types,\n  action:TTestHookMethod,\n) => {\n  !isFunc(action) &&\n    throwError(\n      `The ${type} method requires a \"function\" as the first argument`\n    )\n}\n\nexport const validateRootRun = (root:TRootTestObj) => {\n  root.type !== Types.root &&\n    throwError(`Invalid root type \"${root.type}\" set for root object`)\n  !root.describes ||\n    (!root.describes.length &&\n      throwError(`No tests have been registered to this ParkinTest instance`))\n}\n\n/**\n * Validates the required arguments were passed in\n * @throws\n *\n */\nexport const validateItem = (\n  type:string,\n  description:string,\n  action:TTestAction|TDescribeAction\n) => {\n  !isStr(type) && throwError(`Test item type is required as a string`)\n  !isFunc(action) &&\n    throwError(\n      `The ${type} method requires a \"function\" as the second argument`\n    )\n  !isStr(description) &&\n    throwError(`The ${type} method requires a \"string\" as the first argument`)\n}\n\n/**\n * Creates an object with meta data of an item of the ParkinTest instance\n *\n */\nexport const createItem = <T=TTestObj>(\n  type:string,\n  metadata:Partial<TTestObj> = emptyObj as TTestObj,\n  validate = true\n) => {\n  const { description, action } = metadata\n  validate && validateItem(type, description, action)\n\n  return { ...metadata, type } as T\n}\n\n/**\n * Creates a describe object for the passed in description and action\n *\n */\nexport const createDescribe = (\n  description:string,\n  action:TDescribeAction\n) => {\n  const item = createItem(Types.describe, {\n    ...createRoot(),\n    action,\n    tests: [],\n    description,\n  }) as TDescribeTestObj\n\n  item.disabled = () => (item.skip = true)\n\n  return item\n}\n\n/**\n * Creates a root object\n *\n */\nexport const createRoot = () => {\n  return createItem(\n    Types.root,\n    {\n      describes: [],\n      ...Object.values(hookTypes).reduce((acc, type) => {\n        acc[type] = []\n        return acc\n      }, {}),\n    },\n    false\n  ) as TRootTestObj\n}\n", "import type {\n  TTestObj,\n  TRunResult,\n  TRunResultTestMeta\n} from '../types'\nimport { EResultStatus } from '../types'\nimport { isObj } from '@keg-hub/jsutils/isObj'\n\n\n/**\n * Builds a test run result base on the passed in arguments\n *\n */\nexport const runResult = (\n  item:TTestObj,\n  {\n    id,\n    tests,\n    stats,\n    action,\n    failed,\n    passed,\n    testPath,\n    fullName,\n    describes,\n  }:TRunResultTestMeta\n) => {\n\n  const result:TRunResult = {\n    id,\n    stats,\n    action,\n    testPath,\n    fullName,\n    type: item.type,\n    failedExpectations: [],\n    passedExpectations: [],\n    failed: Boolean(failed),\n    passed: Boolean(passed),\n    description: item.description,\n    timestamp: new Date().getTime(),\n  }\n\n  if(tests?.length) result.tests = tests\n  if(describes?.length) result.describes = describes\n\n  isObj(failed) && result.failedExpectations.push(failed)\n  isObj(passed) && result.passedExpectations.push(passed)\n\n  isObj(item?.action?.ParkinMetaData)\n    ? (result.metaData = item?.action?.ParkinMetaData)\n    : isObj(item?.action?.metaData)\n        && (result.metaData = item?.action?.metaData)\n\n  if (passed || failed)\n    result.status = passed\n      ? EResultStatus.passed\n      : result?.metaData?.warnOnFailed\n        ? EResultStatus.warning\n        : EResultStatus.failed\n\n  return result\n}\n", "import type {\n  TType,\n  TTestStats,\n  TRunResult,\n  TRootTestObj,\n  TTestTestObj,\n  TParkinHookCB,\n  TDescribeTestObj,\n} from '../types'\n\n\nimport { Types } from './utils'\nimport { runResult } from './runResult'\nimport { EResultStatus, EResultAction } from '../types'\n\ntype TLoopHooks = {\n  test?:TTestTestObj\n  type: keyof TType\n  stats:TTestStats\n  describe?:TDescribeTestObj\n  specId?:keyof TType|string\n  suiteId?:keyof TType|string\n  root?: TRootTestObj|TDescribeTestObj\n}\n\nexport type TDescribeHooks = {\n  suiteId:string\n  stats:TTestStats\n  type:`before`|`after`\n  describe:TDescribeTestObj\n  describeResult:TRunResult\n  root:TDescribeTestObj | TRootTestObj\n  onSuiteDone:(result: TRunResult) => void\n}\n\n/**\n * Helper to loop over hooks and call them\n * @param {Object} args - Data for calling the passed in hook by type\n *\n * @returns {Object} - Built run result object if a hook fails\n */\nexport const loopHooks = async (args:TLoopHooks) => {\n  const {\n    type,\n    test,\n    root,\n    stats,\n    specId,\n    suiteId,\n    describe,\n  } = args\n\n  let hookResults:TRunResult[] = []\n\n  let hookIdx\n  const activeItem = root || describe\n  const fullName = root\n    ? root.description\n    : test\n      ? `${describe?.description} > ${test?.description} > ${type}`\n      : `${describe?.description} > ${type}`\n\n\n  activeItem[type].length &&\n    await Promise.all(\n      activeItem[type].map(async (fn:TParkinHookCB, idx:number) => {\n        hookIdx = idx\n        return await Promise.resolve()\n          .then(() => fn?.())\n          .catch((error:Error) => {\n            hookResults.push(\n              runResult(activeItem, {\n                stats,\n                fullName,\n                action: type as EResultAction,\n                id: test ? specId : suiteId,\n                status: EResultStatus.failed,\n                failed: {\n                  error,\n                  fullName,\n                  description: error.message,\n                  status: EResultStatus.failed,\n                },\n                testPath: test\n                  ? `/${suiteId}/${specId}/${type}${hookIdx}`\n                  : `/${suiteId}/${type}${hookIdx}`,\n              })\n            )\n          })\n      })\n    )\n\n  return hookResults\n}\n\n\n/**\n * Helper to call the before hooks from the root and current describe\n * @param {Object} args - Arguments needed to call the before hooks\n *\n * @returns {Object} - Built results if a hook throws an error\n */\nconst callBeforeHooks = async ({ root, suiteId, describe, stats }) => {\n  const beforeEachResult = await loopHooks({\n    root,\n    stats,\n    suiteId: Types.root,\n    type: Types.beforeEach,\n  })\n\n  const beforeAllResult = await loopHooks({\n    stats,\n    suiteId,\n    describe,\n    type: Types.beforeAll,\n  })\n\n  return [...beforeEachResult, ...beforeAllResult]\n}\n\n/**\n * Helper to call the after hooks from the root and current describe\n * @param {Object} args - Arguments needed to call the after hooks\n *\n * @returns {Object} - Built results if a hook throws an error\n */\nconst callAfterHooks = async ({ root, suiteId, describe, stats }) => {\n  const afterEachResult = await loopHooks({\n    root,\n    stats,\n    suiteId: Types.root,\n    type: Types.afterEach,\n  })\n\n  const afterAllResult = await loopHooks({\n      stats,\n      suiteId,\n      describe,\n      type: Types.afterAll,\n    })\n\n  return [...afterEachResult, ...afterAllResult]\n}\n\n\n/**\n * Helper to call the before and after hooks for describe methods\n * @param {Object} args - Arguments needed to call the after hooks\n *\n * @returns {Object} - Built results if a hook throws an error\n */\nexport const callDescribeHooks = async (args:TDescribeHooks) => {\n  const {\n    root,\n    type,\n    stats,\n    suiteId,\n    describe,\n    onSuiteDone,\n    describeResult\n  } = args\n\n  const results:TRunResult[] = []\n\n  const hooksResults = type === `before`\n    ? await callBeforeHooks({root, suiteId, describe, stats })\n    : await callAfterHooks({root, suiteId, describe, stats })\n  \n  if(!hooksResults?.length) return results\n  \n  if (hooksResults?.length) {\n    const describeResults = await Promise.all(\n      hooksResults.map(async (result) => {\n        const joined = {...describeResult, ...result, failed: true, passed: false }\n        await onSuiteDone(joined)\n\n        return joined\n      })\n    )\n\n    results.push(...describeResults)\n  }\n\n  return results\n}", "import { wait } from \"@keg-hub/jsutils/wait\"\nimport { TPromiseRetry } from \"../types\"\nimport { RetryError, throwAbortError } from './errors'\n\n// import { TAbortPromise } from \"../types\"\n// import { PromiseAbort } from './promiseAbort'\n// ----- Uncomment to add a PromiseAbort wrapper -----\n// Still working out how to do this properly, needs some work\n// export const PromiseRetry = <T=any>(opts:TPromiseRetry<T>): TAbortPromise<T> => {\n//   return PromiseAbort({\n//     promise: (args) => loopRetry({...opts, ...args}, opts?.retry || 0)\n//   })\n// }\n\nconst loopRetry = async <T=any>(opts:TPromiseRetry<T>, orgRetry?:number): Promise<T> => {\n  const {\n    delay=0,\n    retry=0,\n    onRetry,\n    controller,\n    promise:fn,\n    shouldAbort,\n  } = opts\n\n  const signal = controller?.signal\n\n  try {\n    const resp = await fn(opts)\n    return signal?.aborted || shouldAbort?.()\n      ?  throwAbortError()\n      : resp\n  }\n  catch (err) {\n    if(signal?.aborted || shouldAbort?.()) return throwAbortError()\n\n    if (retry <= 0) throw new RetryError(err, opts?.error, orgRetry)\n\n    const next = {...opts, retry: retry - 1}\n    onRetry && await onRetry?.(next)\n    delay && await wait(delay)\n\n    return loopRetry(next, orgRetry)\n  }\n}\n\nexport const PromiseRetry = async <T=any>(opts:TPromiseRetry<T>): Promise<T> => loopRetry(\n  opts,\n  opts?.retry || 0\n)\n\n", "import { TPromiseTimeout } from \"../types\"\n\nclass TimeoutError extends Error {\n  constructor(message:string, name?:string) {\n    super(message)\n    this.name = name || this.constructor.name\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\n\nexport const PromiseTimeout = async <T=any>({\n  name,\n  error,\n  promise,\n  timeout=5000,\n}:TPromiseTimeout<T>):Promise<T> => {\n  const method = name ? `${name} method` : `method`\n\n  let timer:NodeJS.Timeout\n  const timePromise = new Promise((res, rej) => {\n    timer = setTimeout(() => rej(\n      new TimeoutError(\n        error || `The ${method} timed out after ${timeout} ms.`,\n        `TimeoutError`\n      )\n    ), timeout)\n  })\n\n  return await Promise.race([promise, timePromise] as [Promise<T>, Promise<any>])\n    .finally(() => clearTimeout(timer))\n}\n", "import type { TPromiseRetry, TRunResult, TTestTestObj } from \"src/types\"\n\nimport { throwAbortError } from '../utils/errors'\nimport { PromiseRetry } from '../utils/promiseRetry'\nimport { PromiseTimeout } from '../utils/promiseTimeout'\n\nexport type TRunTest = Omit<TPromiseRetry<TRunResult>, `promise`> & {\n  test:TTestTestObj\n  shouldAbort:() => boolean\n}\n\n/**\n * Wraps the test.action in a Promise timeout and a Promise retry\n * Promise retry wraps the timeout, so each retry gets the same amount of time to resolve\n */\nexport const runTest = async (args:TRunTest) => {\n  const {test, shouldAbort, ...rest} = args\n\n  return PromiseRetry({\n    ...rest,\n    retry: test.retry || rest.retry || 0,\n    promise: async () => {\n      const promise = test.action()\n      shouldAbort() && throwAbortError()\n\n      /**\n        * If there is a timeout, Use the PromiseTimeout to race it against the test action\n        * If the timeout wins, it will reject the promise\n        * Which then gets picked up in the catch below\n        */\n      return test.timeout\n        ? await PromiseTimeout<TRunResult>({\n            promise,\n            timeout: test.timeout,\n            name: test.description,\n            error: `Test failed, the timeout ${test.timeout}ms was exceeded`\n          })\n        : await promise\n    }\n  })\n\n}", "import type {\n  TTestTestObj,\n  TDescribeTestObj,\n} from \"../types\"\n\nexport type TShouldSkipTest = {\n  testOnly?:boolean\n  test: TTestTestObj\n  hasFailed?:boolean\n  skipAfterFailed?:boolean\n}\n\nexport type TBuildTestArgs = {\n  suiteId:string\n  testIdx:number\n  describe:TDescribeTestObj\n}\n\nexport type TShouldSkipDescribe = {\n  testOnly?:boolean\n  describeOnly?:boolean\n  describe: TDescribeTestObj\n}\n\n\nexport const shouldSkipTest = (params:TShouldSkipTest) => {\n  const {\n    test,\n    testOnly,\n    hasFailed,\n    skipAfterFailed\n  } = params\n\n  return test.skip\n    || (testOnly && !test.only)\n    || (hasFailed && skipAfterFailed)\n}\n\nexport const buildTestArgs = ({\n  suiteId,\n  testIdx,\n  describe\n}:TBuildTestArgs) => {\n  const test = describe.tests[testIdx]\n  const specId = `spec-${testIdx}`\n\n  return {\n    test,\n    specId,\n    testPath: `/${suiteId}/${specId}`,\n    fullName: `${describe.description} > ${test.description}`,\n  }\n}\n\n\nexport const shouldSkipDescribe = ({ describe, describeOnly, testOnly }:TShouldSkipDescribe) => {\n  return describe.skip ||\n    (describeOnly && !describe.only && !describe.onlyChild) ||\n    (testOnly && !describe.onlyChild)\n}", "import type { TLoopTests, TRunResult, TRunResults } from '../types'\n\nimport { Types } from './utils'\n\nimport { runTest } from './runTest'\nimport { loopHooks } from './hooks'\nimport { runResult } from './runResult'\nimport { ParkinAbortErrName } from '../constants'\nimport { throwAbortError } from '../utils/errors'\nimport { EResultStatus, EResultAction } from '../types'\nimport { throwBailError, throwExitOnFailed } from '../utils/errors'\n\nimport {\n  buildTestArgs,\n  shouldSkipTest,\n} from './runHelpers'\n\n\n/**\n * Helper to loop over tests and call their test method\n *\n * @returns {Object} - Built run result object of the test results\n */\nexport const loopTests = async (args:TLoopTests) => {\n  const {\n    bail,\n    stats,\n    suiteId,\n    describe,\n    testOnly,\n    onSpecDone,\n    testRetry,\n    onTestRetry,\n    shouldAbort,\n    onSpecStart,\n    exitOnFailed,\n    skipAfterFailed,\n  } = args\n\n  let testsFailed = false\n  const results:TRunResults = []\n\n  // ------ describe - loop tests ------ //\n  for (let testIdx = 0; testIdx < describe.tests.length; testIdx++) {\n\n    shouldAbort() && throwAbortError()\n\n    const {\n      test,\n      specId,\n      testPath,\n      fullName,\n    } = buildTestArgs({ suiteId, testIdx, describe })\n\n    let testResult = runResult(test, {\n      stats,\n      fullName,\n      testPath,\n      id: specId,\n      action: EResultAction.start,\n    })\n\n    const shouldSkip = shouldSkipTest({\n      test,\n      testOnly,\n      skipAfterFailed,\n      hasFailed: testsFailed\n    })\n\n    if(shouldSkip){\n      const skipped = {\n        ...testResult,\n        skipped: true,\n        action: EResultAction.skipped,\n        status: EResultStatus.skipped,\n      }\n\n      await onSpecStart(skipped)\n      results.push(skipped)\n      continue\n    }\n    else await onSpecStart(testResult)\n\n    shouldAbort() && throwAbortError()\n\n    const beforeEachResults = await loopHooks({\n      test,\n      stats,\n      specId,\n      suiteId,\n      describe,\n      type: Types.beforeEach,\n    })\n\n    if (beforeEachResults?.length) {\n      testsFailed = true\n      results.push(...beforeEachResults)\n      beforeEachResults.forEach(onSpecDone)\n      break\n    }\n\n    // ------ execute test ------ //\n    try {\n\n      /**\n       * If there is a timeout, Use the PromiseTimeout to race it against the test action\n       * If the timeout wins, it will reject the promise\n       * Which then gets picked up in the catch below\n       */\n      const result = await runTest({\n        test,\n        shouldAbort,\n        retry: testRetry,\n        onRetry: onTestRetry,\n      })\n      \n      shouldAbort() && throwAbortError()\n\n      // If we get to here, the test passed, so up the passed spec count\n      stats.passedSpecs += 1\n\n      testResult = runResult(test, {\n        stats,\n        fullName,\n        id: specId,\n        testPath: testPath,\n        passed: result || true,\n        action: EResultAction.test,\n      })\n\n    }\n    catch (error) {\n\n      if(error.name === ParkinAbortErrName) throw error\n\n      testsFailed = true\n      stats.failedSpecs += 1\n\n      testResult = runResult(test, {\n        stats,\n        fullName,\n        id: specId,\n        testPath: testPath,\n        action: EResultAction.test,\n        failed: {\n          error,\n          fullName,\n          description: error.message,\n          status: EResultStatus.failed,\n        },\n      })\n\n      const shouldBail = Boolean(bail && stats.failedSpecs >= bail)\n      if(exitOnFailed || shouldBail){\n        results.push(testResult)\n        error.testResults = results\n        await onSpecDone(testResult)\n\n        exitOnFailed && throwExitOnFailed(error)\n        shouldBail && throwBailError(error, bail)\n        break\n      }\n\n    }\n    \n    shouldAbort() && throwAbortError()\n\n    const afterEachResults = await loopHooks({\n      test,\n      stats,\n      specId,\n      suiteId,\n      describe,\n      type: Types.afterEach,\n    })\n    if (afterEachResults?.length) {\n      testsFailed = true\n      results.push(...afterEachResults)\n      afterEachResults.forEach(onSpecDone)\n      break\n    }\n\n    results.push(testResult)\n\n    await onSpecDone({\n      ...testResult,\n      action: EResultAction.end\n    })\n\n  }\n\n  shouldAbort() && throwAbortError()\n\n  return { tests: results, failed: testsFailed }\n\n}\n", "import type {\n  TRun,\n  TRunResult,\n  TTestStats,\n  TRunResults,\n  TParkinTestCB,\n  TDescribeTestObj,\n} from '../types'\n\nimport { runResult } from './runResult'\nimport { loopTests } from './loopTests'\nimport { callDescribeHooks } from './hooks'\nimport { ParkinAbortErrName } from '../constants'\nimport { shouldSkipDescribe } from './runHelpers'\nimport { EResultStatus, EResultAction } from '../types'\n\nexport type TLoopChildren<T=any> = {\n  stats:TTestStats\n  describeResult:TRunResult\n  onSuiteDone:TParkinTestCB\n  describe:TDescribeTestObj\n  loopFun:() => Promise<{tests?: TRunResults, describes?: TRunResults, failed: boolean }>\n}\n\n/**\n * Helper method to loop over children of a describe test object\n */\nconst loopChildren = async (args:TLoopChildren) => {\n  const {\n    stats,\n    describe,\n    onSuiteDone,\n    describeResult,\n    loopFun,\n  } = args\n\n  try {\n    const results = await loopFun()\n    const failed = results?.failed || describeResult?.failed\n\n    const joined = {\n      ...describeResult,\n      ...results,\n      action: EResultAction.end,\n    }\n    if(failed) joined.failed = failed\n\n    return joined\n  }\n  /**\n    * This will catch if an error is thrown by something other then a test or a hook\n    * For example Parkin Bail Error, or Parkin abort error is thrown, then it will show up here\n    * For abort errors we just rethrow the error, but for Bail errors\n    * We capture it so we can still call the onSuiteEnd callback, then rethrow the error\n    */\n  catch(err){\n    if(err.name === ParkinAbortErrName) throw err\n\n    stats.failedSuites += 1\n    const errorResult = runResult(describe, {\n      ...describeResult,\n      stats,\n      action: EResultAction.end,\n      failed: {\n        error: err,\n        description: err.message,\n        status: EResultStatus.failed,\n        fullName: describe.description,\n      }\n    })\n\n    // If there's testsResults\n    // Store them in the describe result, and remove them from the error\n    if(err.testResults){\n      errorResult.tests = err.testResults\n      err.testResults = undefined\n    }\n\n    await onSuiteDone(errorResult)\n\n    err.results = err.results || []\n    err.results.push(errorResult)\n\n    throw err\n  }\n\n}\n\n/**\n * Helper to loop over describe methods and call child tests\n * @param {Object} args - Config to overwrite the initial test config object\n *\n * @returns {Object} - Built run results of the test results\n */\nexport const loopDescribes = async (args:TRun) => {\n  const {\n    root,\n    bail,\n    stats,\n    testOnly,\n    testRetry,\n    onSpecDone,\n    onSuiteDone,\n    shouldAbort,\n    onTestRetry,\n    onSpecStart,\n    onSuiteStart,\n    describeOnly,\n    parentIdx = ``,\n    exitOnFailed,\n    skipAfterFailed,\n  } = args\n\n  let describeFailed = false\n  const results:TRunResults = []\n\n\n  // ------ loop describes ------ //\n  for (let idx = 0; idx < root.describes.length; idx++) {\n\n    if(shouldAbort()) break\n\n    const describe = root.describes[idx]\n    const suiteId = `suite-${parentIdx}${idx}`\n\n    // Create a runResult with general information that can be reused below\n    let describeResult = runResult(describe, {\n      stats,\n      id: suiteId,\n      testPath: `/${suiteId}`,\n      action: EResultAction.start,\n      fullName: describe.description,\n    })\n\n\n    if (shouldSkipDescribe({ describe, describeOnly, testOnly })) {\n      await onSuiteStart({\n        ...describeResult,\n        skipped: true,\n        action: EResultAction.skipped,\n        status: EResultStatus.skipped,\n      })\n      continue\n    }\n    else await onSuiteStart(describeResult)\n\n    const beforeResults = await callDescribeHooks({\n      root,\n      stats,\n      suiteId,\n      describe,\n      onSuiteDone,\n      describeResult,\n      type: `before`,\n    })\n\n    if (beforeResults?.length) {\n      describeFailed = true\n      results.push(...beforeResults)\n      continue\n    }\n\n    if(shouldAbort()) break\n\n    // Loop over any test children\n    describeResult = describe?.tests?.length\n      ? await loopChildren({\n          stats,\n          describe,\n          onSuiteDone,\n          describeResult,\n          loopFun: async () => await loopTests({\n            bail,\n            stats,\n            suiteId,\n            describe,\n            testOnly,\n            onSpecDone,\n            testRetry,\n            onTestRetry,\n            shouldAbort,\n            onSpecStart,\n            exitOnFailed,\n            skipAfterFailed,\n          })\n        })\n      : describeResult\n\n    if(exitOnFailed && describeResult.failed){\n      describeFailed = true\n      stats.failedSuites += 1\n      await onSuiteDone(describeResult)\n      results.push(describeResult)\n      break\n    }\n\n    // Loop over any describe children\n    describeResult = describe?.describes?.length\n      ? await loopChildren({\n          stats,\n          describe,\n          onSuiteDone,\n          describeResult,\n          loopFun: async () => await loopDescribes({\n            ...args,\n            root: describe,\n            parentIdx: `${idx}-`,\n          })\n        })\n      : describeResult\n\n    describeResult.failed\n      ? (stats.failedSuites += 1)\n      : (stats.passedSuites += 1)\n\n    if(exitOnFailed && describeResult.failed){\n      describeFailed = true\n      await onSuiteDone(describeResult)\n      results.push(describeResult)\n      break\n    }\n\n    if(shouldAbort()) break\n\n    if (describeResult.failed) {\n      describeFailed = true\n      describeResult.failed = true\n      describeResult.status = EResultStatus.failed\n    }\n    else {\n      describeResult.passed = true\n      describeResult.status = EResultStatus.passed\n    }\n\n    const afterResults = await callDescribeHooks({\n      root,\n      stats,\n      suiteId,\n      describe,\n      onSuiteDone,\n      describeResult,\n      type: `after`,\n    })\n\n    if (afterResults?.length) {\n      describeFailed = true\n      results.push(...afterResults)\n      continue\n    }\n\n    if(shouldAbort()) break\n\n    await onSuiteDone(describeResult)\n    results.push(describeResult)\n  }\n\n  return shouldAbort()\n    ? { describes: [], failed: describeFailed }\n    : { describes: results, failed: describeFailed }\n\n}\n", "import type {\n  TRun,\n  TRunResults,\n  TRootTestObj,\n} from '../types'\n\nimport { loopHooks } from './hooks'\nimport { runResult } from './runResult'\n\nimport { ParkinError } from '../utils/errors'\nimport { ParkinBailErrName, ParkinAbortErrName } from '../constants'\nimport { loopDescribes } from './loopDescribes'\nimport { Types, validateRootRun } from './utils'\nimport { EResultStatus, EResultAction } from '../types'\n\n/**\n * Executes all methods registered to the ParkinTest instance\n * @param {Object} args - Config to overwrite the initial test config object\n *\n * @returns {Object} - Results of the test run\n */\nexport const run = async (args:TRun):Promise<TRunResults> => {\n  const {\n    root,\n    stats,\n    onAbort,\n    onRunDone,\n    shouldAbort,\n    onRunStart,\n  } = args\n\n  let bailError:ParkinError\n  let describesFailed:boolean\n  let describes:TRunResults = []\n\n\n  validateRootRun(root as TRootTestObj)\n  // Create a runResult with general information that can be reused below\n  let rootResult = runResult(root, {\n    stats,\n    id: Types.root,\n    fullName: root.description,\n    testPath: `/${Types.root}`,\n  })\n\n  await onRunStart({\n    ...rootResult,\n    stats,\n    action: EResultAction.start,\n    description: `Starting test execution`,\n  })\n\n  const beforeAllResults = await loopHooks({\n    root,\n    stats,\n    suiteId: Types.root,\n    type: Types.beforeAll,\n  })\n\n  if(shouldAbort()){\n    await onAbort?.()\n    stats.runEnd = new Date().getTime()\n    await onRunDone({\n      ...rootResult,\n      stats,\n      action: EResultAction.abort,\n      description: `Test execution aborted`,\n    })\n\n    describes.aborted = true\n    return Object.assign(describes, stats)\n  }\n\n  // If a before all throws an error, we don't want to run the rest of the tests, so just return\n  if (beforeAllResults?.length) return Object.assign(beforeAllResults, stats)\n\n  // Ensure the afterAll hooks are always called\n  // Wrap the loopDescribes in a ty/catch/finally to ensure they are called at the end\n  try {\n    const resp = await loopDescribes(args)\n    describes = resp.describes\n    describesFailed = resp.failed\n\n    if(shouldAbort()){\n      await onAbort?.()\n      stats.runEnd = new Date().getTime()\n      await onRunDone({\n        ...rootResult,\n        stats,\n        action: EResultAction.abort,\n        description: `Test execution aborted`,\n      })\n      describes.aborted = true\n    }\n  }\n  catch(err){\n    describesFailed = true\n    const isBailErr = err.name === ParkinBailErrName\n    const isAbortErr = err.name === ParkinAbortErrName\n\n    bailError = isBailErr || isAbortErr ? err : undefined\n\n    if(isBailErr) describes.bailed = true\n    if(isAbortErr) describes.aborted = true\n\n    err.results\n      ? describes.push(...err.results)\n      : describes.push(runResult(root, {\n            stats,\n            describes,\n            id: Types.root,\n            fullName: root.description,\n            testPath: `/${Types.root}`,\n            action: EResultAction.end,\n            status: EResultStatus.failed,\n            failed: {\n              error: err,\n              description: err.message,\n              fullName: root.description,\n              status: EResultStatus.failed,\n            }\n        })\n      )\n\n  }\n  finally {\n    const afterAllResult = await loopHooks({\n      root,\n      stats,\n      suiteId: Types.root,\n      type: Types.afterAll,\n    })\n    afterAllResult?.length && describes.push(...afterAllResult)\n    stats.runEnd = stats.runEnd || new Date().getTime()\n\n    await onRunDone({\n      ...rootResult,\n      stats,\n      describes,\n      failed: describesFailed,\n      passed: !describesFailed,\n      action: EResultAction.end,\n      description: `Test execution complete`,\n      status: describesFailed ? EResultStatus.failed : EResultStatus.passed\n    })\n\n    if(bailError){\n      // After joining the error results with the already captured results\n      // Ensure the stats object is added as well\n      bailError.results = Object.assign(describes, stats)\n      throw bailError\n    }\n  }\n\n  return Object.assign(describes, stats)\n}\n", "import type {\n  TRunResult,\n  TRunResults,\n  TTestAction,\n  TTestTestObj,\n  TParkinTestCB,\n  TParentTestObj,\n  TTestHookMethod,\n  TPromiseRetryCB,\n  TDescribeAction,\n  TParkinTestAbort,\n  TParkinTestConfig,\n  TParkinTestFactory,\n  TRunResultActionMeta,\n  TParkinDescribeFactory,\n} from '../types'\n\nimport { run } from './run'\nimport { runResult } from './runResult'\nimport { noOp } from '@keg-hub/jsutils/noOp'\nimport { isStr } from '@keg-hub/jsutils/isStr'\nimport { isNum } from '@keg-hub/jsutils/isNum'\nimport { isObj } from '@keg-hub/jsutils/isObj'\nimport { exists } from '@keg-hub/jsutils/exists'\nimport { emptyObj } from '@keg-hub/jsutils/emptyObj'\nimport { PromiseRetry } from '../utils/promiseRetry'\nimport { checkCall } from '@keg-hub/jsutils/checkCall'\nimport { PromiseTimeout } from '../utils/promiseTimeout'\nimport {\n  Types,\n  createRoot,\n  createItem,\n  createDescribe,\n  throwError,\n  hookTypes,\n  validateHook,\n} from './utils'\n\n\n\ntype TTestSkipFactory = (description:string, action?:TTestAction, timeout?:number) => void\n\nexport class ParkinTest {\n  // Defaults set to 0, is the same as disabled\n  bail = 0\n  testRetry = 0\n  suiteRetry = 0\n  #onTestRetry:TPromiseRetryCB<TRunResult>\n  #onSuiteRetry:TPromiseRetryCB<TRunResults>\n\n  // Default test timeout to be 5 seconds\n  testTimeout = 5000\n  // Default suite test timeout is 1hr\n  suiteTimeout = 3600000\n  #autoClean = true\n  #testOnly = false\n  #abortRun = false\n  #describeOnly = false\n  #exitOnFailed = false\n  #skipAfterFailed = false\n  #root = createRoot()\n  xit:TTestSkipFactory\n  it:TParkinTestFactory\n  #onRunDone:TParkinTestCB = noOp\n  #onRunStart:TParkinTestCB = noOp\n  #onSpecDone:TParkinTestCB = noOp\n  #onSuiteDone:TParkinTestCB = noOp\n  #onSpecStart:TParkinTestCB = noOp\n  #onSuiteStart:TParkinTestCB = noOp\n  #onAbort:TParkinTestAbort = noOp\n  afterAll:TTestHookMethod = noOp\n  afterEach:TTestHookMethod = noOp\n  beforeAll:TTestHookMethod = noOp\n  beforeEach:TTestHookMethod = noOp\n  #activeParent:TParentTestObj = undefined\n\n  constructor(config:TParkinTestConfig = emptyObj) {\n    this.#root.description = config.description || `root`\n\n    this.#addOnly()\n    this.#addSkip()\n    this.#addHelpers()\n    this.it = this.test\n    this.xit = this.xtest\n    this.#activeParent = this.#root\n    this.setConfig(config)\n  }\n\n  run = (config:TParkinTestConfig = emptyObj) => {\n\n    if (config.description) this.#root.description = config.description\n\n    this.setConfig(config)\n    const runSuite = async () => {\n      const promise = run({\n        bail: this.bail,\n        root: this.#root,\n        onAbort: this.#onAbort,\n        testOnly: this.#testOnly,\n        testRetry: this.testRetry,\n        onRunDone: this.#onRunDone,\n        onRunStart: this.#onRunStart,\n        onSpecDone: this.#onSpecDone,\n        onSpecStart: this.#onSpecStart,\n        onTestRetry: this.#onTestRetry,\n        shouldAbort: this.#shouldAbort,\n        onSuiteDone: this.#onSuiteDone,\n        onSuiteStart: this.#onSuiteStart,\n        exitOnFailed: this.#exitOnFailed,\n        describeOnly: this.#describeOnly,\n        skipAfterFailed: this.#skipAfterFailed,\n        stats: {\n          runEnd: 0,\n          failedSpecs: 0,\n          passedSpecs: 0,\n          passedSuites: 0,\n          failedSuites: 0,\n          runStart: new Date().getTime(),\n        },\n      })\n\n      const result = this.suiteTimeout\n        ? PromiseTimeout<TRunResults>({\n            promise,\n            timeout: this.suiteTimeout,\n            name: this.#root.description,\n            error: `Test Execution failed, the suite timeout ${this.suiteTimeout}ms was exceeded`\n          })\n        : promise\n\n      this.#autoClean && this.clean()\n\n      return result\n    }\n\n    return PromiseRetry({\n      promise: runSuite,\n      retry: this.suiteRetry,\n      onRetry: this.#onSuiteRetry\n    })\n  }\n\n  /**\n   * Expose the helper method to build a test result\n   * Helpful in cases where ParkinTest is wrapped by another tool\n   * Allows for a consistent iterface of events\n   */\n  buildResult = runResult\n\n  #shouldAbort = () => this.#abortRun\n\n  abort = () => {\n    this.#abortRun = true\n  }\n\n  /**\n   * Resets the instance to it's initial state\n   * Clears all previously loaded tests and describes\n   */\n  clean = () => {\n    this.testTimeout = 5000\n    this.suiteTimeout = 3600000\n    this.#autoClean = true\n    this.#abortRun = false\n    this.#testOnly = false\n    this.#describeOnly = false\n\n    this.#activeParent = undefined\n    this.#root = undefined\n    this.#root = createRoot()\n    this.#activeParent = this.#root\n  }\n\n  /**\n   * Gets the current activeParent, which should almost always be this.#root\n   */\n  getActiveParent = () => {\n    return this.#activeParent\n  }\n\n  /**\n   * Adds passed in framework hooks to the class instance\n   */\n  setConfig = ({\n    bail,\n    timeout,\n    testRetry,\n    suiteRetry,\n    testTimeout,\n    suiteTimeout,\n    onTestRetry,\n    onSuiteRetry,\n    exitOnFailed,\n    skipAfterFailed,\n    onAbort,\n    autoClean,\n    onSpecDone,\n    onSuiteDone,\n    onRunDone,\n    onRunStart,\n    onSpecStart,\n    onSuiteStart,\n  }:TParkinTestConfig=emptyObj) => {\n\n    if(onAbort) this.#onAbort = onAbort\n    \n    if(isNum(testTimeout)) this.testTimeout = testTimeout\n    else if(isNum(timeout)) this.testTimeout = timeout\n\n    if(isNum(suiteTimeout)) this.suiteTimeout = suiteTimeout\n    else if(isNum(timeout)) this.suiteTimeout = timeout\n\n    if (isNum(bail)) this.bail = bail\n    if (isNum(testRetry)) this.testRetry = testRetry\n    if (isNum(suiteRetry)) this.suiteRetry = suiteRetry\n\n    if (onTestRetry) this.#onTestRetry = onTestRetry\n    if (onSuiteRetry) this.#onSuiteRetry = onSuiteRetry\n\n    if (onSpecDone) this.#onSpecDone = onSpecDone\n    if (onSpecStart) this.#onSpecStart = onSpecStart\n\n    if (onSuiteDone) this.#onSuiteDone = onSuiteDone\n    if (onSuiteStart) this.#onSuiteStart = onSuiteStart\n\n    if (onRunDone) this.#onRunDone = onRunDone\n    if (onRunStart) this.#onRunStart = onRunStart\n\n    if (autoClean === false) this.#autoClean = autoClean\n\n    if(exitOnFailed) this.#exitOnFailed = exitOnFailed\n    if(skipAfterFailed) this.#skipAfterFailed = skipAfterFailed\n  }\n\n  /**\n   * Adds the only method to describe and test methods\n   * Ensures they are the only methods called when run\n   */\n  #addOnly = () => {\n\n    this.describe.only = (...args:[string, TDescribeAction]) => {\n      this.describe(...args)\n      // Get the last item just added to the this.#activeParent\n      const item =\n        this.#activeParent.describes[this.#activeParent.describes.length - 1]\n      item.only = true\n      this.#describeOnly = true\n      // Call the parent hasOnlyChild method to ensure it gets passed on the chain\n      checkCall(this.#activeParent.hasOnlyChild)\n    }\n\n    this.test.only = (...args:[description:string, action?:TTestAction, meta?:TRunResultActionMeta|number]) => {\n      this.test(...args)\n      // Get the last item just added to the this.#activeParent\n      const item = this.#activeParent.tests[this.#activeParent.tests.length - 1]\n      item.only = true\n      this.#testOnly = true\n      // Call the parent hasOnlyChild method to ensure it gets passed on the chain\n      checkCall(this.#activeParent.hasOnlyChild)\n    }\n  }\n\n  /**\n   * Adds the skip method to describe and test methods\n   * Ensures they are skipped run method is called\n   */\n  #addSkip = () => {\n\n    this.describe.skip = (...args:[string, TDescribeAction]) => {\n      this.describe(...args)\n      // Get the last item just added to the this.#activeParent\n      const item =\n        this.#activeParent.describes[this.#activeParent.describes.length - 1]\n      item.skip = true\n    }\n\n    this.test.skip = (...args:[description:string, action?:TTestAction, meta?:TRunResultActionMeta|number]) => {\n      this.test(...args)\n      // Get the last item just added to the this.#activeParent\n      const item = this.#activeParent.tests[this.#activeParent.tests.length - 1]\n      item.skip = true\n    }\n  }\n\n  /**\n   * TODO: @lance-Tipton\n   * Add each methods to describe and test\n   */\n  #addEach = () => {}\n\n  /**\n   * Adds the helper methods to the class instance\n   * Methods: beforeAll, beforeEach, afterAll, afterEach\n   */\n  #addHelpers = () => {\n    Object.values(hookTypes).map(type => {\n      this[type] = (action) => {\n        validateHook(type, action)\n        this.#activeParent[type].push(action)\n      }\n    })\n  }\n\n  /**\n   * Method the wraps test and helper methods\n   * Acts as a top level method for defining tests\n   *\n   * @returns {void}\n   */\n  describe = ((\n    description:string,\n    action:TDescribeAction\n  ) => {\n\n    // Build the describe item and add defaults\n    const item = createDescribe(description, action)\n    this.#activeParent.describes.push(item)\n\n    // Cache the lastParent, so we can reset it\n    const lastParent = this.#activeParent\n\n    item.hasOnlyChild = () => {\n      item.onlyChild = true\n      checkCall(lastParent.hasOnlyChild)\n    }\n\n    // Set the current activeParent to the item\n    this.#activeParent = item\n\n    // Call the action to register all test method calls while the items active\n    action()\n\n    // Reset the last activeParent\n    // Should end up with the #root being the final activeParent\n    this.#activeParent = lastParent\n  }) as TParkinDescribeFactory\n\n  /**\n   * Method that executes some test logic\n   * Must be called within a Test#describe method\n   *\n   * @returns {void}\n   */\n  test = ((\n    description:string,\n    action:TTestAction,\n    meta:TRunResultActionMeta|number\n  ) => {\n\n    let retry:number = this.testRetry || 0\n    let timeout:number = this.testTimeout\n\n    if(isObj(meta)){\n\n      if(!exists(action.metaData) && !exists(action.ParkinMetaData))\n        action.metaData = meta\n\n      if(meta?.retry) retry = meta.retry\n      if(meta?.timeout) timeout = meta.timeout\n    }\n    else if(isNum(meta)) timeout = meta\n\n    if (!this.#activeParent || this.#activeParent.type === Types.root)\n      throwError(`All ${Types.test} method calls must be called within a ${Types.describe} method`)\n\n    const item = createItem<TTestTestObj>(\n      Types.test,\n      {\n        retry,\n        action,\n        timeout,\n        description\n      }\n    )\n\n    item.disabled = () => (item.skip = true)\n\n    this.#activeParent.tests.push(item)\n  }) as TParkinTestFactory\n\n  /**\n   * Called when a test method should be skipped\n   * Must be called within a Test#describe method\n   *\n   * @returns {void}\n   */\n  xtest = (\n    description:string,\n    action?:TTestAction,\n    timeout?:number\n  ) => {\n    if (!this.#activeParent || this.#activeParent.type === Types.root)\n      throwError(\n        `All ${Types.test} method calls must be called within a ${Types.describe} method`\n      )\n\n    !isStr(description) &&\n      throwError(\n        `The ${Types.test} method requires a \"string\" as the first argument`\n      )\n    const item = createItem<TTestTestObj>(Types.test, { description, skip: true }, false)\n    item.disabled = () => (item.skip = true)\n\n    this.#activeParent.tests.push(item)\n  }\n\n}\n"],
  "mappings": "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",
  "names": ["deepFreeze", "keyMap", "emptyObj", "isNum", "checkCall", "EHookType", "EStepType", "import_isStr", "import_isStr", "import_isObj", "import_emptyObj"]
}
