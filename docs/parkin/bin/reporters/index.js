var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/validate-23297ec2.js
var require_validate_23297ec2 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/validate-23297ec2.js"(exports10) {
    "use strict";
    var OPTIONS = {
      SHOULD_LOG: true,
      SHOULD_THROW: false,
      LOG_PREFIX: null
    };
    var defaultValidator = () => true;
    var validate = (argObj, validators = {}, options = {}) => {
      const {
        logs = OPTIONS.SHOULD_LOG,
        throws: throws3 = OPTIONS.SHOULD_THROW,
        prefix = OPTIONS.LOG_PREFIX
      } = options;
      const validationCaseEntries = Object.entries(argObj);
      const validationResults = validationCaseEntries.map(([argName, argValue]) => validateArgument(argName, argValue, validators[argName] || validators.$default || defaultValidator));
      const reduceCases = (total, next) => validationReducer(total, next, {
        logs,
        throws: throws3,
        prefix
      });
      const {
        success,
        cases
      } = validationResults.reduce(reduceCases, {
        success: true,
        cases: {}
      });
      return [success, cases];
    };
    validate.setOptions = ({
      logs,
      throws: throws3,
      prefix
    }) => {
      if (logs !== void 0) {
        OPTIONS.SHOULD_LOG = logs;
      }
      if (throws3 !== void 0) {
        OPTIONS.SHOULD_THROW = throws3;
      }
      if (prefix !== void 0) {
        OPTIONS.LOG_PREFIX = prefix;
      }
    };
    validate.resetOptions = () => {
      OPTIONS.SHOULD_LOG = true;
      OPTIONS.SHOULD_THROW = false;
      OPTIONS.LOG_PREFIX = null;
    };
    var validateArgument = (key, value, validator) => {
      const success = validator(value);
      const shouldStringifyValidator = !validator.name || validator.name === key || validator.name === "$default";
      const validatorString = shouldStringifyValidator ? validator.toString() : validator.name;
      const reason = success ? null : [`Argument "${key}" with value `, value, ` failed validator: ${validatorString}.`];
      return {
        success,
        key,
        value,
        validator,
        reason
      };
    };
    var validationReducer = (finalResult, nextValidation, {
      logs,
      throws: throws3,
      prefix
    }) => {
      !nextValidation.success && handleFailure(nextValidation, logs, throws3, prefix);
      return {
        success: finalResult.success && nextValidation.success,
        cases: {
          ...finalResult.cases,
          [nextValidation.key]: nextValidation
        }
      };
    };
    var handleFailure = (validation, shouldLog, shouldThrow, prefix) => {
      const reason = prefix ? [prefix, ...validation.reason] : validation.reason;
      if (shouldThrow)
        throw new Error(reason.join());
      if (shouldLog)
        console.error(...reason);
    };
    exports10.validate = validate;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isArr-39234014.js
var require_isArr_39234014 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isArr-39234014.js"(exports10) {
    "use strict";
    var isArr = (value) => Array.isArray(value);
    exports10.isArr = isArr;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isObj-6b3aa807.js
var require_isObj_6b3aa807 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isObj-6b3aa807.js"(exports10) {
    "use strict";
    var isObj = (obj) => typeof obj === "object" && !Array.isArray(obj) && obj !== null;
    exports10.isObj = isObj;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isFunc-f93803cb.js
var require_isFunc_f93803cb = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isFunc-f93803cb.js"(exports10) {
    "use strict";
    var isFunc = (func) => typeof func === "function";
    exports10.isFunc = isFunc;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isStr-8a57710e.js
var require_isStr_8a57710e = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isStr-8a57710e.js"(exports10) {
    "use strict";
    var isStr = (str) => typeof str === "string";
    exports10.isStr = isStr;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isNum-c7164b50.js
var require_isNum_c7164b50 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isNum-c7164b50.js"(exports10) {
    "use strict";
    var equalsNaN = (val) => typeof val === "number" && val != val;
    var isNum = (val) => typeof val === "number" && !equalsNaN(val);
    exports10.equalsNaN = equalsNaN;
    exports10.isNum = isNum;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isValidDate-813b9419.js
var require_isValidDate_813b9419 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isValidDate-813b9419.js"(exports10) {
    "use strict";
    var isObj = require_isObj_6b3aa807();
    var isArr = require_isArr_39234014();
    var isStr = require_isStr_8a57710e();
    var isNum = require_isNum_c7164b50();
    var typeOf = (val) => Object.prototype.toString.call(val).slice(8, -1);
    var isEmpty = (val) => isObj.isObj(val) ? Object.keys(val).length === 0 : isArr.isArr(val) ? val.length === 0 : isStr.isStr(val) ? val.trim().length === 0 : isNum.isNum(val) ? val < 1 : false;
    var isSame = (val1, val2) => val1 === val2 ? val1 !== 0 || 1 / val1 === 1 / val2 : val1 !== val1 && val2 !== val2;
    var isValidDate = (date) => !isNaN((date instanceof Date && date || new Date(date)).getTime());
    exports10.isEmpty = isEmpty;
    exports10.isSame = isSame;
    exports10.isValidDate = isValidDate;
    exports10.typeOf = typeOf;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isBool-aa6af74e.js
var require_isBool_aa6af74e = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isBool-aa6af74e.js"(exports10) {
    "use strict";
    var isBool = (val) => typeof val === "boolean";
    exports10.isBool = isBool;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/toStr-8e499966.js
var require_toStr_8e499966 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/toStr-8e499966.js"(exports10) {
    "use strict";
    var isStr = require_isStr_8a57710e();
    var toStr2 = (val) => val === null || val === void 0 ? "" : isStr.isStr(val) ? val : JSON.stringify(val);
    exports10.toStr = toStr2;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/toBool-deb350e4.js
var require_toBool_deb350e4 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/toBool-deb350e4.js"(exports10) {
    "use strict";
    var toStr2 = require_toStr_8e499966();
    var isBool = require_isBool_aa6af74e();
    var isStrBool = (val) => val === "false" || val === "true";
    var convertToStrBool = (val) => isBool.isBool(val) ? toStr2.toStr(val) : !val || val === "false" || val === "0" ? "false" : "true";
    var toBool = (val) => isStrBool(val) ? val === "true" : convertToStrBool(val) === "true";
    exports10.convertToStrBool = convertToStrBool;
    exports10.isStrBool = isStrBool;
    exports10.toBool = toBool;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isColl-5757310a.js
var require_isColl_5757310a = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isColl-5757310a.js"(exports10) {
    "use strict";
    var isColl = (val) => typeof val === "object" && val !== null;
    exports10.isColl = isColl;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/deepEqual-adba847a.js
var require_deepEqual_adba847a = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/deepEqual-adba847a.js"(exports10) {
    "use strict";
    var isColl = require_isColl_5757310a();
    var isArr = require_isArr_39234014();
    var isEmptyColl = (obj) => isArr.isArr(obj) ? obj.length === 0 : isColl.isColl(obj) && Object.getOwnPropertyNames(obj).length === 0;
    var isArray6 = Array.isArray;
    var keyList = Object.keys;
    var hasProp = Object.prototype.hasOwnProperty;
    var deepEqual3 = (a13, b9) => {
      if (a13 === b9)
        return true;
      if (!a13 || !b9 || typeof a13 != "object" || typeof b9 != "object")
        return a13 !== a13 && b9 !== b9;
      const arrA = isArray6(a13);
      const arrB = isArray6(b9);
      let i13;
      let length;
      let key;
      if (arrA && arrB) {
        length = a13.length;
        if (length != b9.length)
          return false;
        for (i13 = length; i13-- !== 0; )
          if (!deepEqual3(a13[i13], b9[i13]))
            return false;
        return true;
      }
      if (arrA != arrB)
        return false;
      const dateA = a13 instanceof Date;
      const dateB = b9 instanceof Date;
      if (dateA != dateB)
        return false;
      if (dateA && dateB)
        return a13.getTime() == b9.getTime();
      const regexpA = a13 instanceof RegExp;
      const regexpB = b9 instanceof RegExp;
      if (regexpA != regexpB)
        return false;
      if (regexpA && regexpB)
        return a13.toString() == b9.toString();
      const keys = keyList(a13);
      length = keys.length;
      if (length !== keyList(b9).length)
        return false;
      for (i13 = length; i13-- !== 0; )
        if (!hasProp.call(b9, keys[i13]))
          return false;
      for (i13 = length; i13-- !== 0; ) {
        key = keys[i13];
        if (!deepEqual3(a13[key], b9[key]))
          return false;
      }
      return true;
    };
    exports10.deepEqual = deepEqual3;
    exports10.isEmptyColl = isEmptyColl;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/exists-c79204b1.js
var require_exists_c79204b1 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/exists-c79204b1.js"(exports10) {
    "use strict";
    var exists2 = (value) => value === value && value !== void 0 && value !== null;
    exports10.exists = exists2;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isInt-94ce4199.js
var require_isInt_94ce4199 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isInt-94ce4199.js"(exports10) {
    "use strict";
    var isNum = require_isNum_c7164b50();
    var isNegative = (x8) => isNum.isNum(x8) && x8 < 0;
    var isPositive = (x8) => isNum.isNum(x8) && x8 > 0;
    var isFloat = (val) => isNum.isNum(val) && val % 1 !== 0;
    var isInt = (val) => isNum.isNum(val) && val % 1 === 0;
    exports10.isFloat = isFloat;
    exports10.isInt = isInt;
    exports10.isNegative = isNegative;
    exports10.isPositive = isPositive;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/jsonEqual-7e69ef6a.js
var require_jsonEqual_7e69ef6a = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/jsonEqual-7e69ef6a.js"(exports10) {
    "use strict";
    var isStr = require_isStr_8a57710e();
    var isNum = require_isNum_c7164b50();
    var isArr = require_isArr_39234014();
    var isObj = require_isObj_6b3aa807();
    var toBool = require_toBool_deb350e4();
    var hasOwn = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    var isEntry = (maybeEntry) => isArr.isArr(maybeEntry) && maybeEntry.length === 2 && (isNum.isNum(maybeEntry[0]) || isStr.isStr(maybeEntry[0]));
    var isArrMap = (obj) => {
      if (!isObj.isObj(obj))
        return false;
      const values = Object.values(obj);
      return toBool.toBool(values.length && values.every(isArr.isArr));
    };
    var jsonEqual = (one, two) => {
      try {
        return JSON.stringify(one) === JSON.stringify(two);
      } catch (e14) {
        return false;
      }
    };
    exports10.hasOwn = hasOwn;
    exports10.isArrMap = isArrMap;
    exports10.isEntry = isEntry;
    exports10.jsonEqual = jsonEqual;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isQuoted-eb6994da.js
var require_isQuoted_eb6994da = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isQuoted-eb6994da.js"(exports10) {
    "use strict";
    var isStr = require_isStr_8a57710e();
    var isLowerCase = (str) => str === str.toLowerCase();
    var isUpperCase = (str) => str === str.toUpperCase();
    var isEmail = (str) => {
      if (!str || !isStr.isStr(str))
        return false;
      const regex2 = /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/;
      return Boolean(regex2.test(str));
    };
    var regex = {
      ipv4: /^(?:(?:\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\.){3}(?:\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])$/,
      ipv6: /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i
    };
    var isIp = (str) => {
      if (!str || !isStr.isStr(str))
        return false;
      const isIp42 = Boolean(regex.ipv4.test(str));
      return isIp42 || Boolean(regex.ipv6.test(str));
    };
    var isIp4 = (str) => {
      if (!str || !isStr.isStr(str))
        return false;
      return Boolean(regex.ipv4.test(str));
    };
    var isIp6 = (str) => {
      if (!str || !isStr.isStr(str))
        return false;
      return Boolean(regex.ipv6.test(str));
    };
    var isPhone = (str) => {
      if (!str || !isStr.isStr(str))
        return false;
      const regex2 = /^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6}$/im;
      return Boolean(regex2.test(str)) && str.replace(/\D/g, "").length < 11;
    };
    var isUrl = (str) => {
      const regex2 = /^(?:(?:https?|ftp):\/\/)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/\S*)?$/;
      return Boolean(regex2.test(str));
    };
    var isUuid = (str) => {
      if (!str || !isStr.isStr(str))
        return false;
      const regex2 = /^[0-9A-F]{8}-[0-9A-F]{4}-[4][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i;
      return Boolean(regex2.test(str));
    };
    var quoteSymbols = ['"', "'"];
    var isQuoted = (str, quotes = quoteSymbols) => {
      return isStr.isStr(str) && quotes.some((quote) => str.startsWith(quote) && str.endsWith(quote));
    };
    exports10.isEmail = isEmail;
    exports10.isIp = isIp;
    exports10.isIp4 = isIp4;
    exports10.isIp6 = isIp6;
    exports10.isLowerCase = isLowerCase;
    exports10.isPhone = isPhone;
    exports10.isQuoted = isQuoted;
    exports10.isUpperCase = isUpperCase;
    exports10.isUrl = isUrl;
    exports10.isUuid = isUuid;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isValidUrl-a77135f0.js
var require_isValidUrl_a77135f0 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isValidUrl-a77135f0.js"(exports10) {
    "use strict";
    var isValidUrl = (str) => {
      var regexp = /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-/]))?/;
      return regexp.test(str);
    };
    exports10.isValidUrl = isValidUrl;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/not-16fa9c85.js
var require_not_16fa9c85 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/not-16fa9c85.js"(exports10) {
    "use strict";
    var isArr = require_isArr_39234014();
    var isValidDate = require_isValidDate_813b9419();
    var isFunc = require_isFunc_f93803cb();
    var isBool = require_isBool_aa6af74e();
    var toBool = require_toBool_deb350e4();
    var isColl = require_isColl_5757310a();
    var deepEqual3 = require_deepEqual_adba847a();
    var exists2 = require_exists_c79204b1();
    var isStr = require_isStr_8a57710e();
    var isNum = require_isNum_c7164b50();
    var isInt = require_isInt_94ce4199();
    var jsonEqual = require_jsonEqual_7e69ef6a();
    var isObj = require_isObj_6b3aa807();
    var isQuoted = require_isQuoted_eb6994da();
    var isValidUrl = require_isValidUrl_a77135f0();
    var isOrderable = (x8) => isStr.isStr(x8) || isNum.isNum(x8) || isBool.isBool(x8);
    var identity = (x8) => x8;
    var match = (matchArg, ...args) => {
      if (!args.length)
        return null;
      for (let entry of args) {
        if (!isArr.isArr(entry)) {
          console.error(`Matching case must be an entry (a 2-element array). Found: ${isValidDate.typeOf(entry)}`, entry);
          break;
        }
        const [caseValueOrPredicate, valueOnMatch] = entry;
        if (isFunc.isFunc(caseValueOrPredicate) && caseValueOrPredicate(matchArg))
          return valueOnMatch;
        if (caseValueOrPredicate === matchArg)
          return valueOnMatch;
      }
      return null;
    };
    match.default = () => true;
    var hasDomAccess = () => {
      try {
        return !!(typeof window !== "undefined" && window.document && window.document.createElement);
      } catch (error) {
        return false;
      }
    };
    var isRegex = (val) => Boolean(val && val instanceof RegExp);
    var not = (func) => {
      return (...args) => !func.apply(null, args);
    };
    not.bool = not(isBool.isBool);
    not.strBool = not(toBool.isStrBool);
    not.coll = not(isColl.isColl);
    not.deepEqual = not(deepEqual3.deepEqual);
    not.emptyColl = not(deepEqual3.isEmptyColl);
    not.dom = not(hasDomAccess);
    not.exists = not(exists2.exists);
    not.empty = not(isValidDate.isEmpty);
    not.same = not(isValidDate.isSame);
    not.validDate = not(isValidDate.isValidDate);
    not.func = not(isFunc.isFunc);
    not.identity = not(identity);
    not.orderable = not(isOrderable);
    not.equalsNaN = not(isNum.equalsNaN);
    not.float = not(isInt.isFloat);
    not.int = not(isInt.isInt);
    not.num = not(isNum.isNum);
    not.negative = not(isInt.isNegative);
    not.positive = not(isInt.isPositive);
    not.hasOwn = not(jsonEqual.hasOwn);
    not.entry = not(jsonEqual.isEntry);
    not.arrMap = not(jsonEqual.isArrMap);
    not.obj = not(isObj.isObj);
    not.jsonEqual = not(jsonEqual.jsonEqual);
    not.regex = not(isRegex);
    not.email = not(isQuoted.isEmail);
    not.ip = not(isQuoted.isIp);
    not.lowerCase = not(isQuoted.isLowerCase);
    not.phone = not(isQuoted.isPhone);
    not.quoted = not(isQuoted.isQuoted);
    not.str = not(isStr.isStr);
    not.upperCase = not(isQuoted.isUpperCase);
    not.url = not(isQuoted.isUrl);
    not.uuid = not(isQuoted.isUuid);
    not.validUrl = not(isValidUrl.isValidUrl);
    exports10.hasDomAccess = hasDomAccess;
    exports10.identity = identity;
    exports10.isOrderable = isOrderable;
    exports10.isRegex = isRegex;
    exports10.match = match;
    exports10.not = not;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/compareTo-d69e4abf.js
var require_compareTo_d69e4abf = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/compareTo-d69e4abf.js"(exports10) {
    "use strict";
    var isStr = require_isStr_8a57710e();
    var not = require_not_16fa9c85();
    var validate = require_validate_23297ec2();
    var compareTo = (x8, y11) => {
      const [valid] = validate.validate({
        x: x8,
        y: y11
      }, {
        $default: not.isOrderable
      });
      if (!valid)
        return null;
      return isStr.isStr(x8) ? x8.localeCompare(y11) : x8 - y11;
    };
    exports10.compareTo = compareTo;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/noOps-b5f3c7e4.js
var require_noOps_b5f3c7e4 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/noOps-b5f3c7e4.js"(exports10) {
    "use strict";
    var isFunc = require_isFunc_f93803cb();
    var deepFreeze = (obj) => {
      Object.freeze(obj);
      Object.getOwnPropertyNames(obj).map((prop) => {
        obj.hasOwnProperty(prop) && obj[prop] !== null && (typeof obj[prop] === "object" || isFunc.isFunc(obj[prop])) && !Object.isFrozen(obj[prop]) && deepFreeze(obj[prop]);
      });
      return obj;
    };
    var noOpObj = Object.freeze({});
    var emptyObj2 = noOpObj;
    var noPropObj = deepFreeze({
      content: {}
    });
    var noPropArr = deepFreeze([]);
    var noOpArr = noPropArr;
    var emptyArr = noPropArr;
    exports10.deepFreeze = deepFreeze;
    exports10.emptyArr = emptyArr;
    exports10.emptyObj = emptyObj2;
    exports10.noOpArr = noOpArr;
    exports10.noOpObj = noOpObj;
    exports10.noPropArr = noPropArr;
    exports10.noPropObj = noPropObj;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isNonNegative-9959647c.js
var require_isNonNegative_9959647c = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/isNonNegative-9959647c.js"(exports10) {
    "use strict";
    var isNum = require_isNum_c7164b50();
    var isNonNegative = (val) => isNum.isNum(val) && val >= 0;
    exports10.isNonNegative = isNonNegative;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/intersect-6fe7b944.js
var require_intersect_6fe7b944 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/intersect-6fe7b944.js"(exports10) {
    "use strict";
    var validate = require_validate_23297ec2();
    var isArr = require_isArr_39234014();
    var isObj = require_isObj_6b3aa807();
    var isFunc = require_isFunc_f93803cb();
    var compareTo = require_compareTo_d69e4abf();
    var not = require_not_16fa9c85();
    var noOps = require_noOps_b5f3c7e4();
    var isNonNegative = require_isNonNegative_9959647c();
    var exists2 = require_exists_c79204b1();
    var buildElementCountMap = (arr) => {
      const counts = /* @__PURE__ */ new Map();
      for (let i13 = 0; i13 < arr.length; i13++) {
        var _counts$get;
        const element = arr[i13];
        const count = (_counts$get = counts.get(element)) !== null && _counts$get !== void 0 ? _counts$get : 0;
        counts.set(element, count + 1);
      }
      return counts;
    };
    var areCountMapsEqual = (mapA, mapB) => {
      if (mapA.size !== mapB.size)
        return false;
      for (let [key, count] of mapA) {
        const otherCount = mapB.get(key);
        if (otherCount !== count)
          return false;
      }
      return true;
    };
    var areFrequencyEqual = (arr, otherArr) => {
      const [valid] = validate.validate({
        arr,
        otherArr
      }, {
        $default: isArr.isArr
      });
      if (!valid)
        return null;
      if (arr === otherArr)
        return true;
      if (arr.length !== otherArr.length)
        return false;
      const arrCounts = buildElementCountMap(arr);
      const otherCounts = buildElementCountMap(otherArr);
      return areCountMapsEqual(arrCounts, otherCounts);
    };
    var areSetEqual = (arr, otherArr) => {
      const [valid] = validate.validate({
        arr,
        otherArr
      }, {
        $default: isArr.isArr
      });
      if (!valid)
        return null;
      if (arr === otherArr)
        return true;
      const [longest, shortest] = arr.length > otherArr.length ? [arr, otherArr] : [otherArr, arr];
      const arrSet = new Set(shortest);
      for (let i13 = 0; i13 < longest.length; i13++) {
        const element = longest[i13];
        if (!arrSet.has(element))
          return false;
      }
      return true;
    };
    var cloneArr = (arr) => Array.from([
      ...isArr.isArr(arr) && arr || isObj.isObj(arr) && Object.entries(arr) || []
    ]);
    var eitherArr = (a13, b9) => isArr.isArr(a13) ? a13 : b9;
    var flatten = (arr, result, opts2) => {
      for (let i13 = 0; i13 < arr.length; i13++) {
        const value = arr[i13];
        isArr.isArr(value) ? flatten(value, result, opts2) : opts2.exists && !exists2.exists(value) || opts2.truthy && !value ? result : result.push(value);
      }
      if (!opts2.mutate)
        return result;
      Object.assign(arr, result).splice(result.length);
      return arr;
    };
    var flatArr = (arr, opts2) => flatten(arr, [], isObj.isObj(opts2) ? opts2 : noOps.noOpObj);
    var flatMap = (arr, mapFn) => {
      const [inputIsValid] = validate.validate({
        arr,
        mapFn
      }, {
        arr: isArr.isArr,
        mapFn: isFunc.isFunc
      });
      if (!inputIsValid)
        return arr;
      return arr.reduce((finalArr, current) => {
        const result = mapFn(current);
        isArr.isArr(result) ? result.map((el) => finalArr.push(el)) : finalArr.push(result);
        return finalArr;
      }, []);
    };
    var findExtrema = (arr, comparator) => {
      const [valid] = validate.validate({
        arr,
        comparator
      }, {
        arr: isArr.isArr,
        $default: isFunc.isFunc
      });
      if (!valid)
        return null;
      return arr.length ? arr.reduce((extremaSoFar, next) => comparator(extremaSoFar, next) > 0 ? extremaSoFar : next) : null;
    };
    var findMax = (arr = [], propSelector = not.identity) => findExtrema(arr, (x8, y11) => compareTo.compareTo(propSelector(x8), propSelector(y11)));
    var findMin = (arr = [], propSelector = not.identity) => findExtrema(arr, (x8, y11) => compareTo.compareTo(propSelector(y11), propSelector(x8)));
    var omitRange = (arr, startIndex, count) => {
      const [inputIsValid] = validate.validate({
        arr,
        startIndex,
        count
      }, {
        arr: isArr.isArr,
        $default: isNonNegative.isNonNegative
      });
      if (!inputIsValid)
        return arr;
      const nextArr = [...arr];
      nextArr.splice(startIndex, count);
      return nextArr;
    };
    var randomArr = (arr, amount) => {
      if (!isArr.isArr(arr))
        return arr;
      const useAmount = amount || 1;
      const randoms = [];
      for (let i13 = 0; i13 < useAmount; i13++) {
        randoms.push(arr[Math.floor(Math.random() * arr.length)]);
      }
      return !amount ? randoms[0] : randoms;
    };
    var randomizeArr = (arr) => !isArr.isArr(arr) && arr || arr.sort(() => 0.5 - Math.random());
    var uniqArrByReference = (arr) => {
      return !isArr.isArr(arr) ? arr : arr.filter((e14, i13, arr2) => arr2.indexOf(e14) == i13);
    };
    var uniqArr = (arr, selector) => {
      if (!selector)
        return uniqArrByReference(arr);
      const {
        unique
      } = arr.reduce((data, element, index) => {
        const id = selector(element, index);
        !data.set.has(id) && data.unique.push(element);
        data.set.add(id);
        return data;
      }, {
        unique: [],
        set: /* @__PURE__ */ new Set()
      });
      return unique;
    };
    var flatUnion = (...args) => {
      const last = args.pop();
      const opts2 = {
        exists: true
      };
      const compare = isFunc.isFunc(last) ? last : args.push(last) && void 0;
      return args.reduce((merged, arr) => {
        if (!isArr.isArr(arr))
          return merged;
        return uniqArr(flatArr([...merged, ...arr], opts2), compare);
      }, []);
    };
    var intersect = (arrA, arrB) => {
      if (!isArr.isArr(arrA) || !isArr.isArr(arrB))
        return [];
      const setB = new Set(arrB);
      return [...new Set(arrA)].filter((x8) => setB.has(x8));
    };
    exports10.areCountMapsEqual = areCountMapsEqual;
    exports10.areFrequencyEqual = areFrequencyEqual;
    exports10.areSetEqual = areSetEqual;
    exports10.buildElementCountMap = buildElementCountMap;
    exports10.cloneArr = cloneArr;
    exports10.eitherArr = eitherArr;
    exports10.findExtrema = findExtrema;
    exports10.findMax = findMax;
    exports10.findMin = findMin;
    exports10.flatArr = flatArr;
    exports10.flatMap = flatMap;
    exports10.flatUnion = flatUnion;
    exports10.intersect = intersect;
    exports10.omitRange = omitRange;
    exports10.randomArr = randomArr;
    exports10.randomizeArr = randomizeArr;
    exports10.uniqArr = uniqArr;
    exports10.uniqArrByReference = uniqArrByReference;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/ensureArr-ae68c041.js
var require_ensureArr_ae68c041 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/ensureArr-ae68c041.js"(exports10) {
    "use strict";
    var isArr = require_isArr_39234014();
    var ensureArr = (val) => isArr.isArr(val) ? val : [val];
    exports10.ensureArr = ensureArr;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/softFalsy-3d7ead1c.js
var require_softFalsy_3d7ead1c = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/softFalsy-3d7ead1c.js"(exports10) {
    "use strict";
    var softFalsy = (val) => Boolean(val || val === "" || val === 0);
    exports10.softFalsy = softFalsy;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/set-c0a98b21.js
var require_set_c0a98b21 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/set-c0a98b21.js"(exports10) {
    "use strict";
    var isFunc = require_isFunc_f93803cb();
    var isArr = require_isArr_39234014();
    var isColl = require_isColl_5757310a();
    var updateColl = (obj, path3, type2, val) => {
      const org = obj;
      if (!isColl.isColl(obj) || !obj || !path3)
        return type2 !== "set" && val || void 0;
      const parts = isArr.isArr(path3) ? Array.from(path3) : path3.split(".");
      const key = parts.pop();
      let prop;
      let breakPath;
      while (prop = parts.shift()) {
        const next = obj[prop];
        isColl.isColl(next) || isFunc.isFunc(next) ? obj = next : (() => {
          if (type2 === "set")
            obj[prop] = {};
          else
            breakPath = true;
          obj = obj[prop];
        })();
        if (breakPath)
          return val;
      }
      return type2 === "get" ? key in obj ? obj[key] : val : type2 === "unset" ? delete obj[key] : (obj[key] = val) && org || org;
    };
    var set = (obj, path3, val) => {
      updateColl(obj, path3, "set", val);
      return obj;
    };
    exports10.set = set;
    exports10.updateColl = updateColl;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/get-00626335.js
var require_get_00626335 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/get-00626335.js"(exports10) {
    "use strict";
    var exists2 = require_exists_c79204b1();
    var isArr = require_isArr_39234014();
    var isStr = require_isStr_8a57710e();
    var get2 = (obj, path3, fallback) => {
      const isPathArr = isArr.isArr(path3);
      if (!isStr.isStr(path3) && !isPathArr)
        return exists2.exists(fallback) ? fallback : void 0;
      const parts = isPathArr ? path3 : path3.split(".");
      const result = parts.reduce((obj2, prop) => {
        const type2 = typeof obj2;
        if (!exists2.exists(obj2) || type2 !== "object" && type2 !== "function")
          return void 0;
        prop = prop.startsWith("[") ? prop.replace(/\D/g, "") : prop;
        return obj2[prop];
      }, obj);
      return exists2.exists(result) ? result : fallback;
    };
    exports10.get = get2;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/deepClone-ae664a21.js
var require_deepClone_ae664a21 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/deepClone-ae664a21.js"(exports10) {
    "use strict";
    var isFunc = require_isFunc_f93803cb();
    var get2 = require_get_00626335();
    var isArr = require_isArr_39234014();
    var cloneFunc = (func) => {
      const funcClone = function(...args) {
        return func instanceof funcClone ? (() => {
          return new func(...args);
        })() : get2.get(func.prototype, "constructor.name") ? new func(...args) : func.apply(func, args);
      };
      for (let key in func)
        func.hasOwnProperty(key) && (funcClone[key] = func[key]);
      Object.defineProperty(funcClone, "name", {
        value: func.name,
        configurable: true
      });
      funcClone.toString = () => func.toString();
      return funcClone;
    };
    var deepClone = (obj, hash = /* @__PURE__ */ new WeakMap()) => {
      if (Object(obj) !== obj)
        return obj;
      if (obj instanceof Set)
        return new Set(obj);
      if (hash.has(obj))
        return hash.get(obj);
      if (isArr.isArr(obj))
        return obj.map((x8) => deepClone(x8));
      if (isFunc.isFunc(obj))
        return cloneFunc(obj);
      const result = obj instanceof Date ? new Date(obj) : obj instanceof RegExp ? new RegExp(obj.source, obj.flags) : !obj.constructor ? /* @__PURE__ */ Object.create(null) : null;
      if (result === null)
        return cloneObjWithPrototypeAndProperties(obj);
      hash.set(obj, result);
      if (obj instanceof Map)
        return Array.from(obj, ([key, val]) => result.set(key, deepClone(val, hash)));
      return Object.assign(result, ...Object.keys(obj).map((key) => ({
        [key]: deepClone(obj[key], hash)
      })));
    };
    var cloneObjWithPrototypeAndProperties = (objectWithPrototype) => {
      if (!objectWithPrototype)
        return objectWithPrototype;
      const prototype = Object.getPrototypeOf(objectWithPrototype);
      const sourceDescriptors = Object.getOwnPropertyDescriptors(objectWithPrototype);
      for (const [key, descriptor] of Object.entries(sourceDescriptors)) {
        descriptor.value && (sourceDescriptors[key].value = deepClone(descriptor.value));
      }
      const clone = Object.create(prototype, sourceDescriptors);
      if (Object.isFrozen(objectWithPrototype))
        Object.freeze(clone);
      if (Object.isSealed(objectWithPrototype))
        Object.seal(clone);
      return clone;
    };
    exports10.cloneFunc = cloneFunc;
    exports10.cloneObjWithPrototypeAndProperties = cloneObjWithPrototypeAndProperties;
    exports10.deepClone = deepClone;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/shallowEqual-eaf2262d.js
var require_shallowEqual_eaf2262d = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/shallowEqual-eaf2262d.js"(exports10) {
    "use strict";
    var isObj = require_isObj_6b3aa807();
    var isColl = require_isColl_5757310a();
    var isFunc = require_isFunc_f93803cb();
    var isArr = require_isArr_39234014();
    var exists2 = require_exists_c79204b1();
    var validate = require_validate_23297ec2();
    var set = require_set_c0a98b21();
    var deepClone = require_deepClone_ae664a21();
    var isNum = require_isNum_c7164b50();
    var get2 = require_get_00626335();
    var isStr = require_isStr_8a57710e();
    var cleanColl = (coll, recursive = true) => {
      return isColl.isColl(coll) ? Object.keys(coll).reduce((cleaned, key) => {
        const value = coll[key];
        if (value === null || value === void 0)
          return cleaned;
        cleaned[key] = recursive && isColl.isColl(value) ? cleanColl(value) : value;
        return cleaned;
      }, isObj.isObj(coll) && {} || []) : console.error(`cleanColl requires a collection as the first argument`) || coll;
    };
    var mapColl = (coll, cb) => isFunc.isFunc(cb) && isColl.isColl(coll) ? Object.keys(coll).map((key) => cb(key, coll[key], coll)) : isArr.isArr(coll) ? [] : {};
    var mapFindArr = (arr, mapper, testFunc) => {
      for (let i13 = 0; i13 < arr.length; i13++) {
        const mappedValue = mapper(arr[i13], i13, i13);
        if (testFunc(mappedValue, i13, i13))
          return mappedValue;
      }
      return null;
    };
    var mapFindObj = (obj, mapper, testFunc) => {
      let idx = 0;
      for (let key in obj) {
        if (!obj.hasOwnProperty(key))
          continue;
        const value = obj[key];
        const mappedValue = mapper(value, key, idx);
        if (testFunc(mappedValue, key, idx))
          return mappedValue;
        idx++;
      }
      return null;
    };
    var mapFind = (coll, mapper, testFunc = exists2.exists) => {
      const [valid] = validate.validate({
        coll,
        mapper,
        testFunc
      }, {
        coll: isColl.isColl,
        $default: isFunc.isFunc
      });
      if (!valid)
        return void 0;
      return isObj.isObj(coll) ? mapFindObj(coll, mapper, testFunc) : mapFindArr(coll, mapper, testFunc);
    };
    var reduceColl = (coll, cb, reduce) => isFunc.isFunc(cb) && isColl.isColl(coll) ? Object.keys(coll).reduce((data, key) => cb(key, coll[key], coll, data), reduce) : isArr.isArr(coll) ? [] : {};
    var unset = (obj, path3) => {
      set.updateColl(obj, path3, "unset");
      return obj;
    };
    var repeat = (element, times, cloneDeep = false) => {
      if (!times || times <= 0)
        return [];
      if (!isNum.isNum(times)) {
        console.error("Times argument must be a number");
        return [];
      }
      const arr = [];
      for (let i13 = 0; i13 < times; i13++) {
        const value = isFunc.isFunc(element) ? element() : cloneDeep ? deepClone.deepClone(element) : element;
        arr.push(value);
      }
      return arr;
    };
    var shallowEqual = (col1, col2, path3) => {
      if (path3 && (isArr.isArr(path3) || isStr.isStr(path3))) {
        col1 = get2.get(col1, path3);
        col2 = get2.get(col2, path3);
      }
      if (col1 === col2)
        return true;
      if (!col1 || !isColl.isColl(col1) || !col2 || !isColl.isColl(col2))
        return false;
      if (Object.keys(col1).length !== Object.keys(col2).length)
        return false;
      for (const key in col1)
        if (col1[key] !== col2[key])
          return false;
      return true;
    };
    exports10.cleanColl = cleanColl;
    exports10.mapColl = mapColl;
    exports10.mapFind = mapFind;
    exports10.reduceColl = reduceColl;
    exports10.repeat = repeat;
    exports10.shallowEqual = shallowEqual;
    exports10.unset = unset;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/either-81805472.js
var require_either_81805472 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/either-81805472.js"(exports10) {
    "use strict";
    var softFalsy = require_softFalsy_3d7ead1c();
    var isFunc = require_isFunc_f93803cb();
    var either = (val1, val2, check) => !isFunc.isFunc(check) ? softFalsy.softFalsy(val1) && val1 || val2 : check(val1, val2) && val1 || val2;
    exports10.either = either;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/toNum-eeb2e51e.js
var require_toNum_eeb2e51e = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/toNum-eeb2e51e.js"(exports10) {
    "use strict";
    var isNum = require_isNum_c7164b50();
    var toStr2 = require_toStr_8e499966();
    var getNums = (val) => toStr2.toStr(val).replace(/([^.\d])/gm, "");
    var toNum = (val) => isNum.isNum(val) ? val : val && !isNum.equalsNaN(val) && Number(getNums(val)) || 0;
    exports10.getNums = getNums;
    exports10.toNum = toNum;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/strToType-00c4481f.js
var require_strToType_00c4481f = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/strToType-00c4481f.js"(exports10) {
    "use strict";
    var isStr = require_isStr_8a57710e();
    var isNum = require_isNum_c7164b50();
    var toNum = require_toNum_eeb2e51e();
    var toBool = require_toBool_deb350e4();
    var strToType = (val) => {
      return !val || !isStr.isStr(val) ? val : toBool.isStrBool(val) ? toBool.toBool(val) : isNum.isNum(val) ? toNum.toNum(val) : (() => {
        try {
          return JSON.parse(val);
        } catch (e14) {
          return val;
        }
      })();
    };
    exports10.strToType = strToType;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/log-37bbfac6.js
var require_log_37bbfac6 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/log-37bbfac6.js"(exports10) {
    "use strict";
    var SHOW_LOGS;
    var METH_DEF = "dir";
    var PREFIX = "type";
    var LOG_TYPES = ["error", "info", "log", "dir", "warn"];
    var setLogs = (log6, methDef, prefix) => {
      SHOW_LOGS = log6;
      METH_DEF = methDef || METH_DEF || "log";
      PREFIX = prefix || PREFIX || "type";
    };
    var resetLogs = () => {
      SHOW_LOGS = void 0;
      METH_DEF = "log";
      PREFIX = "type";
    };
    var logData = (...args) => {
      if (!args.length)
        return;
      let type2 = args.length === 1 ? METH_DEF : args.pop();
      if (!SHOW_LOGS && type2 !== "error")
        return;
      else if (typeof args[0] === "string") {
        if (PREFIX === "type")
          args[0] = `[ ${type2.toUpperCase()} ] ${args[0]}`;
        else if (PREFIX)
          args[0] = `${PREFIX} ${args[0]}`;
      }
      LOG_TYPES.indexOf(type2) !== -1 ? console[type2](...args) : console[METH_DEF](...args, type2);
    };
    exports10.logData = logData;
    exports10.resetLogs = resetLogs;
    exports10.setLogs = setLogs;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/pipeline-e65bdaae.js
var require_pipeline_e65bdaae = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/pipeline-e65bdaae.js"(exports10) {
    "use strict";
    var isArr = require_isArr_39234014();
    var isFunc = require_isFunc_f93803cb();
    var applyToFunc = (item, expression) => {
      if (isArr.isArr(expression)) {
        const [func, ...args] = expression;
        return func(item, ...args);
      } else if (isFunc.isFunc(expression)) {
        return expression(item);
      } else {
        console.error(`Pipeline expected either a function or an array (for function expressions). Found ${typeof expression}`);
        return item;
      }
    };
    var pipeline3 = (item, ...functions) => {
      return functions.reduce((result, fn) => applyToFunc(result, fn), item);
    };
    exports10.applyToFunc = applyToFunc;
    exports10.pipeline = pipeline3;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/stackTracePaths-a7780a09.js
var require_stackTracePaths_a7780a09 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/stackTracePaths-a7780a09.js"(exports10) {
    "use strict";
    var isFunc = require_isFunc_f93803cb();
    var validate = require_validate_23297ec2();
    var isNum = require_isNum_c7164b50();
    var jsonEqual = require_jsonEqual_7e69ef6a();
    var isArr = require_isArr_39234014();
    var deepClone = require_deepClone_ae664a21();
    var noOps = require_noOps_b5f3c7e4();
    var isStr = require_isStr_8a57710e();
    var isObj = require_isObj_6b3aa807();
    var isValidDate = require_isValidDate_813b9419();
    var checkCall = (method, ...params) => {
      return isFunc.isFunc(method) ? method(...params) : void 0;
    };
    var complement = (predicate) => {
      const [valid] = validate.validate({
        predicate
      }, {
        predicate: isFunc.isFunc
      });
      return valid ? (...args) => !predicate(...args) : null;
    };
    var eitherFunc = (func1, func2) => isFunc.isFunc(func1) && func1 || func2;
    var debounce = (func, wait = 250, immediate = false) => {
      let timeout;
      function wrapFunc(...args) {
        if (!isFunc.isFunc(func))
          return null;
        const context = this;
        const later = () => {
          timeout = null;
          !immediate && func.apply(context, args);
        };
        const callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow)
          return isFunc.isFunc(func) && func.apply(context, args);
      }
      return wrapFunc;
    };
    var doIt = (...args) => {
      const params = args.slice();
      const num = params.shift();
      const bindTo = params.shift();
      const cb = params.pop();
      if (!isNum.isNum(num) || !isFunc.isFunc(cb))
        return [];
      const doItAmount = new Array(num);
      const responses = [];
      for (let i13 = 0; i13 < doItAmount.length; i13++) {
        const data = cb.call(bindTo, i13, ...params);
        if (data === false)
          break;
        responses.push(data);
      }
      return responses;
    };
    var memorize = (func, getCacheKey, limit = 1) => {
      if (!isFunc.isFunc(func) || getCacheKey && !isFunc.isFunc(getCacheKey))
        return console.error("Error: Expected a function", func, getCacheKey);
      let memorized = function() {
        const cache = memorized.cache;
        const key = getCacheKey ? getCacheKey.apply(this, arguments) : arguments[0];
        if (jsonEqual.hasOwn(cache, key))
          return cache[key];
        const result = func.apply(this, arguments);
        isNum.isNum(limit) && Object.keys(cache).length < limit ? cache[key] = result : memorized.cache = {
          [key]: result
        };
        return result;
      };
      memorized.cache = {};
      memorized.destroy = () => {
        getCacheKey = void 0;
        memorized.cache = void 0;
        memorized.destroy = void 0;
        memorized = void 0;
      };
      return memorized;
    };
    var runSeq = async (asyncFns = [], options = {}) => {
      const [valid] = validate.validate({
        asyncFns
      }, {
        asyncFns: isArr.isArr
      });
      if (!valid)
        return [];
      const {
        cloneResults = false,
        returnOriginal = true
      } = options;
      const results = [];
      for (const fn of asyncFns) {
        const result = isFunc.isFunc(fn) ? await fn(results.length, cloneResults ? deepClone.deepClone(results) : results) : returnOriginal ? fn : void 0;
        results.push(result);
      }
      return results;
    };
    var timedRun = async (fn, ...args) => {
      const [valid] = validate.validate({
        fn
      }, {
        fn: isFunc.isFunc
      });
      if (!valid)
        return [void 0, -1];
      const startTime = /* @__PURE__ */ new Date();
      const result = await fn(...args);
      return [result, /* @__PURE__ */ new Date() - startTime];
    };
    var throttle = (func, wait = 100) => {
      let waiting = false;
      return function(...args) {
        if (waiting)
          return;
        waiting = true;
        func.apply(this, args);
        return setTimeout(() => {
          waiting = false;
        }, wait);
      };
    };
    var throttleLast = (func, cb, wait = 100) => {
      let throttleTimeout;
      if (isNum.isNum(cb)) {
        wait = cb;
        cb = void 0;
      }
      return function(...args) {
        if (throttleTimeout)
          clearTimeout(throttleTimeout);
        throttleTimeout = setTimeout(() => {
          func.apply(this, args);
          clearTimeout(throttleTimeout);
        }, wait);
        typeof cb === "function" && cb();
      };
    };
    var limbo = (promise, asObject = false) => {
      return !promise || !isFunc.isFunc(promise.then) ? [new Error(`A promise or thenable is required as the first argument!`), asObject ? noOps.emptyObj : void 0] : promise.then((data) => [null, data]).catch((err) => [err, asObject ? noOps.emptyObj : void 0]);
    };
    var limboify = (cb, ...args) => {
      return limbo(new Promise((res, rej) => cb(...args, (err, success) => err ? rej(err) : res(success || true))));
    };
    var uuid = (a13) => a13 ? (a13 ^ Math.random() * 16 >> a13 / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid);
    var noOp = () => {
    };
    var parseErrorMessage = (exception) => {
      return isStr.isStr(exception) && !isValidDate.isEmpty(exception) ? exception : isObj.isObj(exception) ? exception.message : null;
    };
    var defFilters = [`node:internal`, `node_modules/jest`];
    var stackTracePaths = (filter = defFilters) => {
      const orgPreStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = (_8, stack2) => stack2;
      const stack = new Error().stack.slice(1);
      Error.prepareStackTrace = orgPreStackTrace;
      return stack.reduce((acc, cs) => {
        const loc = cs.getFileName();
        if (!loc)
          return acc;
        const ignore = isFunc.isFunc(filter) ? filter(loc, cs, stack) : Boolean(filter.length && filter.find((filterLoc) => loc.includes(filterLoc)));
        !ignore && acc.push(loc);
        return acc;
      }, []);
    };
    exports10.checkCall = checkCall;
    exports10.complement = complement;
    exports10.debounce = debounce;
    exports10.doIt = doIt;
    exports10.eitherFunc = eitherFunc;
    exports10.limbo = limbo;
    exports10.limboify = limboify;
    exports10.memorize = memorize;
    exports10.noOp = noOp;
    exports10.parseErrorMessage = parseErrorMessage;
    exports10.runSeq = runSeq;
    exports10.stackTracePaths = stackTracePaths;
    exports10.throttle = throttle;
    exports10.throttleLast = throttleLast;
    exports10.timedRun = timedRun;
    exports10.uuid = uuid;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/mod-31dfe732.js
var require_mod_31dfe732 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/mod-31dfe732.js"(exports10) {
    "use strict";
    var isNum = require_isNum_c7164b50();
    var toNum = require_toNum_eeb2e51e();
    var nth = (num) => {
      if (!isNum.isNum(num)) {
        num = toNum.getNums(num);
        if (!num)
          return "";
        num = toNum.toNum(num);
        if (isNum.equalsNaN(num))
          return "";
      }
      const mod2 = num % 100;
      if (mod2 >= 10 && mod2 <= 20)
        return "th";
      switch (num % 10) {
        case 1:
          return "st";
        case 2:
          return "nd";
        case 3:
          return "rd";
        default:
          return "th";
      }
    };
    var toFloat = (val) => val && !isNum.equalsNaN(val) && parseFloat(isNum.isNum(val) && val || toNum.getNums(val)) || 0;
    var toInt = (val) => val && !isNum.equalsNaN(val) && parseInt(isNum.isNum(val) && val || toNum.getNums(val)) || 0;
    var mod = (num, divisor) => {
      return (num % divisor + divisor) % divisor;
    };
    exports10.mod = mod;
    exports10.nth = nth;
    exports10.toFloat = toFloat;
    exports10.toInt = toInt;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/reduceObj-f41cbf8d.js
var require_reduceObj_f41cbf8d = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/reduceObj-f41cbf8d.js"(exports10) {
    "use strict";
    var isFunc = require_isFunc_f93803cb();
    var isObj = require_isObj_6b3aa807();
    var reduceObj = (obj, cb, start = {}) => isObj.isObj(obj) && isFunc.isFunc(cb) && Object.entries(obj).reduce((data, [key, value]) => cb(key, value, data), start) || start;
    exports10.reduceObj = reduceObj;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/sanitize-0a18302d.js
var require_sanitize_0a18302d = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/sanitize-0a18302d.js"(exports10) {
    "use strict";
    var isStr = require_isStr_8a57710e();
    var sanitize = (str) => isStr.isStr(str) && str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") || str;
    exports10.sanitize = sanitize;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/transformKeys-574f796c.js
var require_transformKeys_574f796c = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/transformKeys-574f796c.js"(exports10) {
    "use strict";
    var log6 = require_log_37bbfac6();
    var isObj = require_isObj_6b3aa807();
    var isFunc = require_isFunc_f93803cb();
    var deepClone = require_deepClone_ae664a21();
    var isArr = require_isArr_39234014();
    var isColl = require_isColl_5757310a();
    var set = require_set_c0a98b21();
    var jsonEqual = require_jsonEqual_7e69ef6a();
    var reduceObj = require_reduceObj_f41cbf8d();
    var sanitize = require_sanitize_0a18302d();
    var isStr = require_isStr_8a57710e();
    var strToType = require_strToType_00c4481f();
    var pipeline3 = require_pipeline_e65bdaae();
    var exists2 = require_exists_c79204b1();
    var toStr2 = require_toStr_8e499966();
    var ensureArr = require_ensureArr_ae68c041();
    var noOps = require_noOps_b5f3c7e4();
    var cloneJson = (obj) => {
      try {
        return JSON.parse(JSON.stringify(obj));
      } catch (e14) {
        log6.logData(e14.message, "error");
        return null;
      }
    };
    var clearObj = (obj, filter) => {
      obj && Object.entries(obj).map(([key, value]) => {
        if (filter && filter.indexOf(key) !== -1)
          return;
        if (typeof value === "object")
          clearObj(value);
        obj[key] = void 0;
        delete obj[key];
      });
    };
    var eitherObj = (obj1, obj2) => isObj.isObj(obj1) && obj1 || obj2;
    var deepMerge = (...sources) => {
      return sources.reduce((merged, source) => {
        const srcCopy = deepClone.deepClone(source);
        return isArr.isArr(srcCopy) ? [...isArr.isArr(merged) && merged || [], ...srcCopy] : isObj.isObj(srcCopy) ? Object.entries(srcCopy).reduce((joined, [key, value]) => ({
          ...joined,
          [key]: isFunc.isFunc(value) ? deepClone.cloneFunc(value) : isColl.isColl(value) && key in joined ? deepMerge(joined[key], value) : deepClone.deepClone(value)
        }), merged) : merged;
      }, isArr.isArr(sources[0]) && [] || {});
    };
    var applyToCloneOf = (obj, mutatorCb) => {
      let error;
      if (!obj)
        error = "object (Argument 1) in applyToCloneOf, must be defined!";
      if (!isObj.isObj(obj))
        error = "object (Argument 1) in applyToCloneOf, must be an object!";
      if (!mutatorCb)
        error = "mutator (Argument 2) in applyToCloneOf, must be defined!";
      if (!isFunc.isFunc(mutatorCb))
        error = "mutator (Argument 2) arg in applyToCloneOf, must be a function!";
      if (error) {
        console.warn(error);
        return obj;
      }
      const clone = deepClone.deepClone(obj);
      mutatorCb(clone);
      return clone;
    };
    var mapEntries = (obj, cb) => {
      if (!isArr.isArr(obj) && !isObj.isObj(obj)) {
        console.error(obj, `Expected array or object for obj. Found ${typeof obj}`);
        return obj;
      }
      if (!isFunc.isFunc(cb)) {
        console.error(`Expected function for cb. Found ${typeof cb}`);
        return obj;
      }
      const entries = Object.entries(obj);
      const initialValue = isArr.isArr(obj) ? [] : {};
      return entries.reduce((obj2, [key, value]) => {
        const result = cb(key, value);
        if (!jsonEqual.isEntry(result)) {
          console.error(`Callback function must return entry. Found: ${result}. Using current entry instead.`);
          return set.set(obj2, key, value);
        }
        return set.set(obj2, result[0], result[1]);
      }, initialValue);
    };
    var mapKeys = (obj, keyMapper) => {
      if (!isObj.isObj(obj) || !isFunc.isFunc(keyMapper))
        return obj;
      return mapEntries(obj, (key, value) => [keyMapper(key), value]);
    };
    var mapObj2 = (obj, cb) => {
      if (!isObj.isObj(obj))
        return [];
      const entries = Object.entries(obj);
      return isFunc.isFunc(cb) ? entries.map(([key, value]) => cb(key, value)) : entries;
    };
    var omitKeys = (obj = {}, keys = []) => isObj.isObj(obj) && reduceObj.reduceObj(obj, (key, _8, updated) => {
      keys.indexOf(key) === -1 && (updated[key] = obj[key]);
      return updated;
    }, {}) || {};
    var pickKeys = (obj = {}, keys = []) => isObj.isObj(obj) && keys.reduce((updated, key) => {
      key in obj && (updated[key] = obj[key]);
      return updated;
    }, {}) || {};
    var sanitizeCopy = (obj) => JSON.parse(sanitize.sanitize(JSON.stringify(obj)));
    var trimStringFields = (object) => Object.entries(object).reduce((cleaned, [key, value]) => {
      cleaned[key] = isStr.isStr(value) ? value.trim() : value;
      return cleaned;
    }, object);
    var toObj = (val, divider, split) => {
      if (isArr.isArr(val))
        return Object.keys(val).reduce((obj, key) => {
          obj[key] = val[key];
          return obj;
        }, {});
      if (!isStr.isStr(val))
        return {};
      divider = divider || "=";
      split = split || "&";
      return val.toString().split(split).reduce((obj, item) => {
        const sep3 = item.split(divider);
        obj[sep3[0].trim()] = strToType.strToType(sep3[1].trim());
        return obj;
      }, {});
    };
    var keyMap = (arr, toUpperCase) => isArr.isArr(arr) && arr.reduce((obj, key) => {
      if (!isStr.isStr(key))
        return obj;
      const use = toUpperCase && key.toUpperCase() || key;
      obj[use] = use;
      return obj;
    }, {}) || {};
    var everyEntry = (obj, predicate, logError = true) => {
      if (!isObj.isObj(obj)) {
        logError && console.error(`First argument ${obj} must be an object.`);
        return false;
      }
      if (!isFunc.isFunc(predicate)) {
        logError && console.error(`Second argument ${predicate}, must a function`);
        return false;
      }
      return pipeline3.pipeline(obj, Object.entries, (entries) => entries.every(([key, value]) => predicate(key, value)));
    };
    var someEntry = (obj, predicate, logError = true) => {
      if (!isObj.isObj(obj)) {
        logError && console.error(`First argument ${obj} must be an object.`);
        return false;
      }
      if (!isFunc.isFunc(predicate)) {
        logError && console.error(`Second argument ${predicate}, must a function`);
        return false;
      }
      return pipeline3.pipeline(obj, Object.entries, (entries) => entries.some(([key, value]) => predicate(key, value)));
    };
    var filterObj = (obj, predicate, logError = true) => {
      if (!isObj.isObj(obj)) {
        logError && console.error(`First argument ${obj} must be an object.`);
        return obj;
      }
      if (!isFunc.isFunc(predicate)) {
        logError && console.error(`Second argument ${predicate}, must a function`);
        return obj;
      }
      return reduceObj.reduceObj(obj, (key, value, data) => {
        if (predicate(key, value))
          data[key] = value;
        return data;
      }, {});
    };
    var pad = (hash, len) => {
      while (hash.length < len)
        hash = "0" + hash;
      return hash;
    };
    var fold = (hash, text) => {
      if (text.length === 0)
        return hash;
      let i13;
      let chr;
      let len;
      for (i13 = 0, len = text.length; i13 < len; i13++) {
        chr = text.charCodeAt(i13);
        hash = (hash << 5) - hash + chr;
        hash |= 0;
      }
      return hash < 0 ? hash * -2 : hash;
    };
    var foldObject = (hash, obj, seen) => {
      const foldKey = (hash2, key) => foldValue(hash2, obj[key], key, seen);
      return Object.keys(obj).sort().reduce(foldKey, hash);
    };
    var foldValue = (input, value, key, seen) => {
      const hash = fold(fold(fold(input, key), toString(value)), typeof value);
      if (value === null)
        return fold(hash, "null");
      if (value === void 0)
        return fold(hash, "undefined");
      if (typeof value === "object" || typeof value === "function") {
        if (seen.indexOf(value) !== -1)
          return fold(hash, "[Circular]" + key);
        seen.push(value);
        const objHash = foldObject(hash, value, seen);
        if (!("valueOf" in value) || typeof value.valueOf !== "function")
          ;
        try {
          return fold(objHash, String(value.valueOf()));
        } catch (err) {
          return fold(objHash, "[valueOf exception]" + (err.stack || err.message));
        }
      }
      return fold(hash, value.toString());
    };
    var toString = (obj) => Object.prototype.toString.call(obj);
    var hashObj = (obj) => pad(foldValue(0, obj, "", []).toString(16), 8);
    var splitByKeys = (obj = {}, keys) => {
      if (!keys)
        return [{}, {
          ...obj
        }];
      const intersect = [{}, {}];
      const compareKeys = ensureArr.ensureArr(keys);
      return isObj.isObj(obj) ? reduceObj.reduceObj(obj, (key, _8, updated) => {
        exists2.exists(compareKeys.find((k8) => exists2.exists(k8) && toStr2.toStr(k8) === key)) ? updated[0][key] = obj[key] : updated[1][key] = obj[key];
        return updated;
      }, intersect) : intersect;
    };
    var transformKeys = (obj = noOps.emptyObj, keyMap2 = noOps.emptyObj, opts2 = noOps.emptyObj) => {
      const {
        strict: strict3 = false
      } = opts2;
      return Object.entries(obj).reduce((acc, [key, value]) => {
        const ref = keyMap2[key] || (!strict3 ? key : void 0);
        ref && (acc[ref] = value);
        return acc;
      }, {});
    };
    exports10.applyToCloneOf = applyToCloneOf;
    exports10.clearObj = clearObj;
    exports10.cloneJson = cloneJson;
    exports10.deepMerge = deepMerge;
    exports10.eitherObj = eitherObj;
    exports10.everyEntry = everyEntry;
    exports10.filterObj = filterObj;
    exports10.hashObj = hashObj;
    exports10.keyMap = keyMap;
    exports10.mapEntries = mapEntries;
    exports10.mapKeys = mapKeys;
    exports10.mapObj = mapObj2;
    exports10.omitKeys = omitKeys;
    exports10.pickKeys = pickKeys;
    exports10.sanitizeCopy = sanitizeCopy;
    exports10.someEntry = someEntry;
    exports10.splitByKeys = splitByKeys;
    exports10.toObj = toObj;
    exports10.transformKeys = transformKeys;
    exports10.trimStringFields = trimStringFields;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/wait-8ca88995.js
var require_wait_8ca88995 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/wait-8ca88995.js"(exports10) {
    "use strict";
    var isObj = require_isObj_6b3aa807();
    var isFunc = require_isFunc_f93803cb();
    var promisify6 = (method) => {
      if (!isFunc.isFunc(method))
        throw `Argument must be a function`;
      return (...args) => {
        return new Promise((res, rej) => {
          if (!isFunc.isFunc(args[args.length - 1]))
            return res(method(...args));
          args.pop();
          args.push((...cbData) => {
            return cbData && cbData[0] ? rej(...cbData) : res(...cbData);
          });
          return method(...args);
        });
      };
    };
    var defObjProps = Array.from(["caller", "callee", "arguments", "apply", "bind", "call", "toString", "__proto__", "__defineGetter__", "__defineSetter__", "hasOwnProperty", "__lookupGetter__", "__lookupSetter__", "isPrototypeOf", "propertyIsEnumerable", "valueOf", "toLocaleString"]).concat(Object.getOwnPropertyNames(Object.prototype)).reduce((map, functionName) => {
      map[functionName] = true;
      return map;
    }, {});
    var addAsync = (object) => {
      if (!object.__IS_PROMISIFIED__) {
        for (const prop of Object.getOwnPropertyNames(object)) {
          const isAsync = prop.indexOf("Async") !== -1 || object[`${prop}Async`];
          if (isAsync || defObjProps[prop])
            continue;
          if (isFunc.isFunc(object[prop]))
            object[`${prop}Async`] = promisify6(object[prop]);
          else {
            const getValue = Object.getOwnPropertyDescriptor(object, prop).get;
            if (isFunc.isFunc(getValue))
              object[`${prop}Async`] = promisify6(getValue);
          }
        }
        object.__IS_PROMISIFIED__ = true;
      }
      return object;
    };
    var promisifyAll = (object) => {
      if (!isObj.isObj(object))
        return object;
      addAsync(object);
      const proto = Object.getPrototypeOf(object);
      proto && Object.getPrototypeOf(proto) !== null && addAsync(proto);
      return object;
    };
    var wait = (time) => new Promise((res) => setTimeout(() => res(true), time));
    exports10.promisify = promisify6;
    exports10.promisifyAll = promisifyAll;
    exports10.wait = wait;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/joinRegex-5320d139.js
var require_joinRegex_5320d139 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/joinRegex-5320d139.js"(exports10) {
    "use strict";
    var isStr = require_isStr_8a57710e();
    var isArr = require_isArr_39234014();
    require_validate_23297ec2();
    require_noOps_b5f3c7e4();
    var not = require_not_16fa9c85();
    var getRegexSource = (maybeRx) => not.isRegex(maybeRx) ? maybeRx.source : isStr.isStr(maybeRx) ? maybeRx : null;
    var parseArgs = (args) => {
      if (isArr.isArr(args[0]))
        return [args[0], args[1]];
      const last = args[args.length - 1];
      const options = isStr.isStr(last) ? last : void 0;
      const expressions = options ? args.splice(0, args.length - 1) : args;
      return [expressions, options];
    };
    var joinRegex = (...args) => {
      const [expressions, options] = parseArgs(args);
      const source = expressions.reduce((joined, next) => {
        const nextSource = getRegexSource(next);
        return !nextSource ? joined : joined === "" ? nextSource : `${joined}|${nextSource}`;
      }, "");
      return new RegExp(`(${source})`, options);
    };
    exports10.getRegexSource = getRegexSource;
    exports10.joinRegex = joinRegex;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/getWordEndingAt-63d038a5.js
var require_getWordEndingAt_63d038a5 = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/getWordEndingAt-63d038a5.js"(exports10) {
    "use strict";
    var isStr = require_isStr_8a57710e();
    var isFunc = require_isFunc_f93803cb();
    var isQuoted = require_isQuoted_eb6994da();
    var toStr$1 = require_toStr_8e499966();
    var isNonNegative = require_isNonNegative_9959647c();
    var isArr = require_isArr_39234014();
    var isColl = require_isColl_5757310a();
    var get2 = require_get_00626335();
    var buildPath = (...args) => {
      const built = args.reduce((path3, arg) => {
        let str = toStr(arg);
        return `${path3}${str && "/" + str || ""}`;
      }, "");
      return built.replace(/([^:\/]|^)\/{2,}/g, "$1/");
    };
    var mapString = (str, charMapper) => {
      if (!isStr.isStr(str))
        return str;
      if (!isFunc.isFunc(charMapper))
        return str;
      let result = "";
      for (const char of str) {
        result += charMapper(char);
      }
      return result;
    };
    var delimitString = (str, delimiter3, delimiters = ["-", "_", " "]) => {
      if (!isStr.isStr(str))
        return str;
      const isDelimiter = (c13) => delimiters.some((del) => del === c13);
      let prevChar = "_";
      return mapString(str, (char) => {
        if (isDelimiter(char)) {
          prevChar = delimiter3;
          return delimiter3;
        }
        if (isQuoted.isUpperCase(char) && isQuoted.isLowerCase(prevChar) && !isDelimiter(prevChar)) {
          prevChar = char;
          return delimiter3 + char;
        }
        prevChar = char;
        return char;
      });
    };
    var snakeCase = (str) => {
      const underscored = delimitString(str, "_");
      return underscored.toLowerCase();
    };
    var capitalize = (str, lowercaseTail = true) => {
      if (!isStr.isStr(str) || !str[0])
        return str;
      const tail = lowercaseTail ? str.slice(1).toLowerCase() : str.slice(1);
      return `${str[0].toUpperCase()}${tail}`;
    };
    var removeDot = (string) => {
      const noDot = string.indexOf(".") === 0 ? string.slice(1) : string;
      return noDot.indexOf(".") === noDot.length - 1 ? noDot.slice(0, -1) : noDot;
    };
    var cleanStr = (str) => {
      return str && removeDot(str).replace(/[-_]/gm, " ") || str;
    };
    var camelCase = (str, compCase) => {
      return str && cleanStr(str).split(/[\s_-]/gm).reduce((cased, word, index) => {
        if (!word)
          return cased;
        cased += (index > 0 || compCase) && capitalize(word) || word.toLowerCase();
        return cased;
      }, "") || str;
    };
    var camelCasePath = (path3) => {
      const split = path3.split(".");
      const camelCasedSplit = split.map((str, idx) => idx > 0 ? capitalize(str, false) : str);
      return camelCasedSplit.length > 1 ? camelCasedSplit.join("") : path3;
    };
    var containsStr = (str, substring, fromIndex) => {
      str = !isStr.isStr(str) && toStr$1.toStr(str) || str;
      substring = !isStr.isStr(substring) && toStr$1.toStr(substring) || substring;
      return str.indexOf(substring, fromIndex) !== -1;
    };
    var eitherStr = (str1, str2) => isStr.isStr(str1) && str1 || str2;
    var uppercasePattern = /[A-Z]/g;
    var msPattern = /^ms-/;
    var hyphenCache = {};
    var toHyphenLower = (match) => "-" + match.toLowerCase();
    var hyphenator = (rule) => {
      if (hyphenCache.hasOwnProperty(rule))
        return hyphenCache[rule];
      const hRule = rule.replace(uppercasePattern, toHyphenLower);
      return hyphenCache[rule] = msPattern.test(hRule) ? "-" + hRule : hRule;
    };
    var hashString = (str, maxLength) => {
      if (!isStr.isStr(str) || str.length == 0)
        return 0;
      str = str.split("").reverse().join("");
      let hash = 0;
      for (let i13 = 0; i13 < str.length; i13++) {
        const char = str.charCodeAt(i13);
        hash = (hash << 5) - hash + char;
        hash = `${Math.abs(hash & hash)}`;
      }
      return isNonNegative.isNonNegative(maxLength) ? hash.slice(0, maxLength) : hash;
    };
    var parseJSON = (str, logErr = true) => {
      try {
        return JSON.parse(str);
      } catch (e14) {
        logErr && console.error(e14.message);
        return null;
      }
    };
    var plural = (str) => {
      if (!str || !str.length)
        return str;
      return str[str.length - 1] !== "s" ? str + "s" : str;
    };
    var singular = (str) => {
      if (!str || !str.length)
        return str;
      return str[str.length - 1] === "s" ? str.slice(0, str.length - 1) : str;
    };
    var styleCase = (str) => {
      if (!isStr.isStr(str))
        return str;
      const cased = camelCase(str);
      return `${cased[0].toLowerCase()}${cased.slice(1)}`;
    };
    var trainCase = (str) => isStr.isStr(str) && str.split(/(?=[A-Z])|[\s_-]/gm).join("-").toLowerCase() || str;
    var wordCaps = (str) => {
      if (!isStr.isStr(str))
        return str;
      let cleaned = cleanStr(str);
      return cleaned.split(" ").map((word) => word && capitalize(word) || "").join(" ");
    };
    var spaceJoin = (original, toAdd) => {
      toAdd = isArr.isArr(toAdd) ? toAdd : [toAdd];
      return toAdd.reduce((joined, item) => {
        return isStr.isStr(item) ? `${joined ? joined + " " : ""}${item}`.trim() : joined;
      }, isStr.isStr(original) ? original : "");
    };
    var templateRx = (tempStr, data, fallback = "", rx) => {
      const orgRx = template.regex;
      template.regex = rx || /{{([^}]*)}}/g;
      const resp = template(tempStr, data, fallback);
      template.regex = orgRx;
      return resp;
    };
    var template = (tempStr, data, fallback = "") => {
      data = isColl.isColl(data) && data || {};
      const regex = template.regex || /\${(.*?)\}/g;
      return isStr.isStr(tempStr) ? tempStr.replace(regex, (match, exact) => {
        const path3 = (exact || match.substr(2, match.length - 3)).trim();
        const replaceWith = get2.get(data, path3, fallback);
        return isFunc.isFunc(replaceWith) ? replaceWith(data, path3, fallback) : replaceWith;
      }) : console.error(`template requires a string as the first argument`) || tempStr;
    };
    var validFilename = (fileName) => {
      if (!fileName)
        return false;
      const regex = /[<>:"/\\|?*\u0000-\u001F]/g;
      const windowsRegex = /^(con|prn|aux|nul|com\d|lpt\d)$/i;
      const periodRegex = /^\.\.?$/;
      return regex.test(fileName) || windowsRegex.test(fileName) || periodRegex.test(fileName) ? false : true;
    };
    var reverseStr = (str) => {
      if (!isStr.isStr(str))
        return void 0;
      let reversed = "";
      for (let char of str) {
        reversed = char + reversed;
      }
      return reversed;
    };
    var getNearestDelimiterIndex = (text, index, delimiters = [" "]) => {
      const indices = delimiters.map((str) => text.indexOf(str, index)).sort();
      return indices.find((idx) => idx >= 0);
    };
    var getWordStartingAt = (text, index, delimiters = [" "]) => {
      const endingSpaceIdx = getNearestDelimiterIndex(text, index, delimiters);
      return text.substring(index, endingSpaceIdx === -1 ? text.length : endingSpaceIdx);
    };
    var getWordEndingAt = (text, index, delimiters = [" "]) => {
      const reversed = reverseStr(text);
      const reversedIndex = text.length - index;
      return reverseStr(getWordStartingAt(reversed, reversedIndex, delimiters));
    };
    exports10.buildPath = buildPath;
    exports10.camelCase = camelCase;
    exports10.camelCasePath = camelCasePath;
    exports10.capitalize = capitalize;
    exports10.cleanStr = cleanStr;
    exports10.containsStr = containsStr;
    exports10.delimitString = delimitString;
    exports10.eitherStr = eitherStr;
    exports10.getNearestDelimiterIndex = getNearestDelimiterIndex;
    exports10.getWordEndingAt = getWordEndingAt;
    exports10.getWordStartingAt = getWordStartingAt;
    exports10.hashString = hashString;
    exports10.hyphenator = hyphenator;
    exports10.mapString = mapString;
    exports10.parseJSON = parseJSON;
    exports10.plural = plural;
    exports10.removeDot = removeDot;
    exports10.reverseStr = reverseStr;
    exports10.singular = singular;
    exports10.snakeCase = snakeCase;
    exports10.spaceJoin = spaceJoin;
    exports10.styleCase = styleCase;
    exports10.template = template;
    exports10.templateRx = templateRx;
    exports10.trainCase = trainCase;
    exports10.validFilename = validFilename;
    exports10.wordCaps = wordCaps;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/getURLParam-201ef5fe.js
var require_getURLParam_201ef5fe = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/getURLParam-201ef5fe.js"(exports10) {
    "use strict";
    var reduceObj = require_reduceObj_f41cbf8d();
    var isStr = require_isStr_8a57710e();
    var isNum = require_isNum_c7164b50();
    var isBool = require_isBool_aa6af74e();
    var isColl = require_isColl_5757310a();
    var isArr = require_isArr_39234014();
    var validate = require_validate_23297ec2();
    var queryToObj = (string) => {
      const currentQueryItems = {};
      const stringSplit = string.split("?");
      const querystring = stringSplit[stringSplit.length - 1];
      if (!querystring)
        return currentQueryItems;
      const split = querystring.split("&");
      split.length && split.map((item) => {
        const components = item.split("=");
        if (components.length <= 1)
          return currentQueryItems;
        const itemSplit = [components.shift(), components.join("=")];
        if (itemSplit.length === 2) {
          const array = decodeURIComponent(itemSplit[1]).split(",");
          if (array && array.length > 1)
            currentQueryItems[itemSplit[0]] = array;
          else if (itemSplit[0] in currentQueryItems) {
            const val = currentQueryItems[itemSplit[0]];
            currentQueryItems[itemSplit[0]] = isArr.isArr(val) ? val.push(decodeURIComponent(itemSplit[1])) : [val, decodeURIComponent(itemSplit[1])];
          } else
            currentQueryItems[itemSplit[0]] = decodeURIComponent(itemSplit[1]);
        }
      });
      return currentQueryItems;
    };
    var objToQuery = (obj) => {
      let firstSet;
      return reduceObj.reduceObj(obj, (key, value, urlStr) => {
        if (!value)
          return urlStr;
        const useVal = isStr.isStr(value) || isNum.isNum(value) || isBool.isBool(value) ? value : isColl.isColl(value) ? isArr.isArr(value) ? value.join(",") : JSON.stringify(value) : null;
        if (!useVal)
          return urlStr;
        urlStr = !firstSet ? `?${encodeURIComponent(key)}=${encodeURIComponent(useVal)}` : `${urlStr}&${encodeURIComponent(key)}=${encodeURIComponent(useVal)}`;
        firstSet = true;
        return urlStr;
      }, "");
    };
    var getURLParam = (paramKey) => {
      var _doc$location, _queryToObj$paramKey, _queryToObj;
      const [valid] = validate.validate({
        paramKey
      }, {
        paramKey: isStr.isStr
      });
      if (!valid)
        return null;
      const doc = typeof document !== "undefined" ? document : null;
      const search = doc === null || doc === void 0 ? void 0 : (_doc$location = doc.location) === null || _doc$location === void 0 ? void 0 : _doc$location.search;
      return isStr.isStr(search) ? (_queryToObj$paramKey = (_queryToObj = queryToObj(search)) === null || _queryToObj === void 0 ? void 0 : _queryToObj[paramKey]) !== null && _queryToObj$paramKey !== void 0 ? _queryToObj$paramKey : null : null;
    };
    exports10.getURLParam = getURLParam;
    exports10.objToQuery = objToQuery;
    exports10.queryToObj = queryToObj;
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/build/cjs/index.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    var intersect = require_intersect_6fe7b944();
    var ensureArr = require_ensureArr_ae68c041();
    var isArr = require_isArr_39234014();
    var isBool = require_isBool_aa6af74e();
    var toBool = require_toBool_deb350e4();
    var softFalsy = require_softFalsy_3d7ead1c();
    var shallowEqual = require_shallowEqual_eaf2262d();
    var get2 = require_get_00626335();
    var isColl = require_isColl_5757310a();
    var deepEqual3 = require_deepEqual_adba847a();
    var set = require_set_c0a98b21();
    var deepClone = require_deepClone_ae664a21();
    var not = require_not_16fa9c85();
    var either = require_either_81805472();
    var noOps = require_noOps_b5f3c7e4();
    var isValidDate = require_isValidDate_813b9419();
    var strToType = require_strToType_00c4481f();
    var exists2 = require_exists_c79204b1();
    var log6 = require_log_37bbfac6();
    var pipeline3 = require_pipeline_e65bdaae();
    var stackTracePaths = require_stackTracePaths_a7780a09();
    var compareTo = require_compareTo_d69e4abf();
    var isFunc = require_isFunc_f93803cb();
    var isNonNegative = require_isNonNegative_9959647c();
    var isInt = require_isInt_94ce4199();
    var isNum = require_isNum_c7164b50();
    var toNum = require_toNum_eeb2e51e();
    var mod = require_mod_31dfe732();
    var transformKeys = require_transformKeys_574f796c();
    var jsonEqual = require_jsonEqual_7e69ef6a();
    var isObj = require_isObj_6b3aa807();
    var reduceObj = require_reduceObj_f41cbf8d();
    var wait = require_wait_8ca88995();
    var joinRegex = require_joinRegex_5320d139();
    var getWordEndingAt = require_getWordEndingAt_63d038a5();
    var isQuoted = require_isQuoted_eb6994da();
    var isStr = require_isStr_8a57710e();
    var sanitize = require_sanitize_0a18302d();
    var toStr2 = require_toStr_8e499966();
    var validate = require_validate_23297ec2();
    var getURLParam = require_getURLParam_201ef5fe();
    var isValidUrl = require_isValidUrl_a77135f0();
    var formatCls = (classes) => classes.filter((item) => typeof item === "string" && Boolean(item)).join(` `).trim();
    var cls = (...classGroup) => {
      return formatCls(classGroup.map((classes) => {
        return Array.isArray(classes) ? cls(...classes) : typeof classes !== `object` ? formatCls([classes]) : formatCls(Object.entries(classes).map(([item, val]) => {
          return typeof val === "boolean" ? val && formatCls([item]) : cls(val);
        }));
      }));
    };
    exports10.areCountMapsEqual = intersect.areCountMapsEqual;
    exports10.areFrequencyEqual = intersect.areFrequencyEqual;
    exports10.areSetEqual = intersect.areSetEqual;
    exports10.buildElementCountMap = intersect.buildElementCountMap;
    exports10.cloneArr = intersect.cloneArr;
    exports10.eitherArr = intersect.eitherArr;
    exports10.findExtrema = intersect.findExtrema;
    exports10.findMax = intersect.findMax;
    exports10.findMin = intersect.findMin;
    exports10.flatArr = intersect.flatArr;
    exports10.flatMap = intersect.flatMap;
    exports10.flatUnion = intersect.flatUnion;
    exports10.intersect = intersect.intersect;
    exports10.omitRange = intersect.omitRange;
    exports10.randomArr = intersect.randomArr;
    exports10.randomizeArr = intersect.randomizeArr;
    exports10.uniqArr = intersect.uniqArr;
    exports10.uniqArrByReference = intersect.uniqArrByReference;
    exports10.ensureArr = ensureArr.ensureArr;
    exports10.isArr = isArr.isArr;
    exports10.isBool = isBool.isBool;
    exports10.convertToStrBool = toBool.convertToStrBool;
    exports10.isStrBool = toBool.isStrBool;
    exports10.toBool = toBool.toBool;
    exports10.softFalsy = softFalsy.softFalsy;
    exports10.cleanColl = shallowEqual.cleanColl;
    exports10.mapColl = shallowEqual.mapColl;
    exports10.mapFind = shallowEqual.mapFind;
    exports10.reduceColl = shallowEqual.reduceColl;
    exports10.repeat = shallowEqual.repeat;
    exports10.shallowEqual = shallowEqual.shallowEqual;
    exports10.unset = shallowEqual.unset;
    exports10.get = get2.get;
    exports10.isColl = isColl.isColl;
    exports10.deepEqual = deepEqual3.deepEqual;
    exports10.isEmptyColl = deepEqual3.isEmptyColl;
    exports10.set = set.set;
    exports10.cloneFunc = deepClone.cloneFunc;
    exports10.cloneObjWithPrototypeAndProperties = deepClone.cloneObjWithPrototypeAndProperties;
    exports10.deepClone = deepClone.deepClone;
    exports10.hasDomAccess = not.hasDomAccess;
    exports10.identity = not.identity;
    exports10.isDom = not.hasDomAccess;
    exports10.isOrderable = not.isOrderable;
    exports10.isRegex = not.isRegex;
    exports10.match = not.match;
    exports10.not = not.not;
    exports10.either = either.either;
    exports10.deepFreeze = noOps.deepFreeze;
    exports10.emptyArr = noOps.emptyArr;
    exports10.emptyObj = noOps.emptyObj;
    exports10.noOpArr = noOps.noOpArr;
    exports10.noOpObj = noOps.noOpObj;
    exports10.noPropArr = noOps.noPropArr;
    exports10.noPropObj = noOps.noPropObj;
    exports10.isEmpty = isValidDate.isEmpty;
    exports10.isSame = isValidDate.isSame;
    exports10.isValidDate = isValidDate.isValidDate;
    exports10.typeOf = isValidDate.typeOf;
    exports10.strToType = strToType.strToType;
    exports10.exists = exists2.exists;
    exports10.logData = log6.logData;
    exports10.resetLogs = log6.resetLogs;
    exports10.setLogs = log6.setLogs;
    exports10.applyToFunc = pipeline3.applyToFunc;
    exports10.pipeline = pipeline3.pipeline;
    exports10.checkCall = stackTracePaths.checkCall;
    exports10.complement = stackTracePaths.complement;
    exports10.debounce = stackTracePaths.debounce;
    exports10.doIt = stackTracePaths.doIt;
    exports10.eitherFunc = stackTracePaths.eitherFunc;
    exports10.ife = stackTracePaths.checkCall;
    exports10.iife = stackTracePaths.checkCall;
    exports10.limbo = stackTracePaths.limbo;
    exports10.limboify = stackTracePaths.limboify;
    exports10.memorize = stackTracePaths.memorize;
    exports10.noOp = stackTracePaths.noOp;
    exports10.parseErrorMessage = stackTracePaths.parseErrorMessage;
    exports10.runSeq = stackTracePaths.runSeq;
    exports10.stackTracePaths = stackTracePaths.stackTracePaths;
    exports10.throttle = stackTracePaths.throttle;
    exports10.throttleLast = stackTracePaths.throttleLast;
    exports10.timedRun = stackTracePaths.timedRun;
    exports10.uuid = stackTracePaths.uuid;
    exports10.compareTo = compareTo.compareTo;
    exports10.isFunc = isFunc.isFunc;
    exports10.isNonNegative = isNonNegative.isNonNegative;
    exports10.isFloat = isInt.isFloat;
    exports10.isInt = isInt.isInt;
    exports10.isNegative = isInt.isNegative;
    exports10.isPositive = isInt.isPositive;
    exports10.equalsNaN = isNum.equalsNaN;
    exports10.isNum = isNum.isNum;
    exports10.getNums = toNum.getNums;
    exports10.toNum = toNum.toNum;
    exports10.mod = mod.mod;
    exports10.nth = mod.nth;
    exports10.toFloat = mod.toFloat;
    exports10.toInt = mod.toInt;
    exports10.applyToCloneOf = transformKeys.applyToCloneOf;
    exports10.clearObj = transformKeys.clearObj;
    exports10.cloneJson = transformKeys.cloneJson;
    exports10.deepMerge = transformKeys.deepMerge;
    exports10.eitherObj = transformKeys.eitherObj;
    exports10.everyEntry = transformKeys.everyEntry;
    exports10.filterObj = transformKeys.filterObj;
    exports10.hashObj = transformKeys.hashObj;
    exports10.keyMap = transformKeys.keyMap;
    exports10.mapEntries = transformKeys.mapEntries;
    exports10.mapKeys = transformKeys.mapKeys;
    exports10.mapObj = transformKeys.mapObj;
    exports10.omitKeys = transformKeys.omitKeys;
    exports10.pickKeys = transformKeys.pickKeys;
    exports10.sanitizeCopy = transformKeys.sanitizeCopy;
    exports10.someEntry = transformKeys.someEntry;
    exports10.splitByKeys = transformKeys.splitByKeys;
    exports10.toObj = transformKeys.toObj;
    exports10.transformKeys = transformKeys.transformKeys;
    exports10.trimStringFields = transformKeys.trimStringFields;
    exports10.hasOwn = jsonEqual.hasOwn;
    exports10.isArrMap = jsonEqual.isArrMap;
    exports10.isEntry = jsonEqual.isEntry;
    exports10.jsonEqual = jsonEqual.jsonEqual;
    exports10.isObj = isObj.isObj;
    exports10.reduceObj = reduceObj.reduceObj;
    exports10.promisify = wait.promisify;
    exports10.promisifyAll = wait.promisifyAll;
    exports10.wait = wait.wait;
    exports10.getRegexSource = joinRegex.getRegexSource;
    exports10.joinRegex = joinRegex.joinRegex;
    exports10.buildPath = getWordEndingAt.buildPath;
    exports10.camelCase = getWordEndingAt.camelCase;
    exports10.camelCasePath = getWordEndingAt.camelCasePath;
    exports10.capitalize = getWordEndingAt.capitalize;
    exports10.cleanStr = getWordEndingAt.cleanStr;
    exports10.containsStr = getWordEndingAt.containsStr;
    exports10.delimitString = getWordEndingAt.delimitString;
    exports10.eitherStr = getWordEndingAt.eitherStr;
    exports10.getNearestDelimiterIndex = getWordEndingAt.getNearestDelimiterIndex;
    exports10.getWordEndingAt = getWordEndingAt.getWordEndingAt;
    exports10.getWordStartingAt = getWordEndingAt.getWordStartingAt;
    exports10.hashString = getWordEndingAt.hashString;
    exports10.hyphenator = getWordEndingAt.hyphenator;
    exports10.mapString = getWordEndingAt.mapString;
    exports10.parseJSON = getWordEndingAt.parseJSON;
    exports10.plural = getWordEndingAt.plural;
    exports10.removeDot = getWordEndingAt.removeDot;
    exports10.reverseStr = getWordEndingAt.reverseStr;
    exports10.singular = getWordEndingAt.singular;
    exports10.snakeCase = getWordEndingAt.snakeCase;
    exports10.spaceJoin = getWordEndingAt.spaceJoin;
    exports10.styleCase = getWordEndingAt.styleCase;
    exports10.template = getWordEndingAt.template;
    exports10.templateRx = getWordEndingAt.templateRx;
    exports10.trainCase = getWordEndingAt.trainCase;
    exports10.validFilename = getWordEndingAt.validFilename;
    exports10.wordCaps = getWordEndingAt.wordCaps;
    exports10.isEmail = isQuoted.isEmail;
    exports10.isIp = isQuoted.isIp;
    exports10.isIp4 = isQuoted.isIp4;
    exports10.isIp6 = isQuoted.isIp6;
    exports10.isLowerCase = isQuoted.isLowerCase;
    exports10.isPhone = isQuoted.isPhone;
    exports10.isQuoted = isQuoted.isQuoted;
    exports10.isUpperCase = isQuoted.isUpperCase;
    exports10.isUrl = isQuoted.isUrl;
    exports10.isUuid = isQuoted.isUuid;
    exports10.isStr = isStr.isStr;
    exports10.sanitize = sanitize.sanitize;
    exports10.toStr = toStr2.toStr;
    exports10.validate = validate.validate;
    exports10.getURLParam = getURLParam.getURLParam;
    exports10.objToQuery = getURLParam.objToQuery;
    exports10.queryToObj = getURLParam.queryToObj;
    exports10.isValidUrl = isValidUrl.isValidUrl;
    exports10.cls = cls;
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/logger/colors.js
var require_colors = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/logger/colors.js"(exports10, module2) {
    var colorMap = {
      black: `\x1B[30m`,
      red: `\x1B[31m`,
      green: `\x1B[32m`,
      yellow: `\x1B[33m`,
      blue: `\x1B[34m`,
      magenta: `\x1B[35m`,
      cyan: `\x1B[36m`,
      white: `\x1B[37m`,
      gray: `\x1B[90m`,
      crimson: `\x1B[38m`,
      reset: "\x1B[0m",
      bright: "\x1B[1m",
      dim: "\x1B[2m",
      underline: "\x1B[4m",
      blink: "\x1B[5m",
      reverse: "\x1B[7m",
      hidden: "\x1B[8m"
    };
    var addColor = (...args) => `${args.join("")}${colorMap.reset}`;
    var colors = {
      colorMap,
      red: (log6) => addColor(colorMap.red, log6),
      blue: (log6) => addColor(colorMap.blue, log6),
      gray: (log6) => addColor(colorMap.gray, log6),
      cyan: (log6) => addColor(colorMap.cyan, log6),
      green: (log6) => addColor(colorMap.green, log6),
      white: (log6) => addColor(colorMap.white, log6),
      yellow: (log6) => addColor(colorMap.yellow, log6),
      magenta: (log6) => addColor(colorMap.magenta, log6),
      brightRed: (log6) => addColor(colorMap.bright, colorMap.red, log6),
      brightCyan: (log6) => addColor(colorMap.bright, colorMap.cyan, log6),
      brightBlue: (log6) => addColor(colorMap.bright, colorMap.blue, log6),
      brightWhite: (log6) => addColor(colorMap.bright, colorMap.white, log6),
      brightGreen: (log6) => addColor(colorMap.bright, colorMap.green, log6),
      brightYellow: (log6) => addColor(colorMap.bright, colorMap.yellow, log6),
      brightMagenta: (log6) => addColor(colorMap.bright, colorMap.magenta, log6)
    };
    colors.underline = Object.keys(colors).reduce((acc, key) => {
      acc[key] = (log6) => addColor(colorMap.underline, colors[key](log6));
      return acc;
    }, {});
    module2.exports = {
      colors
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/logger/logger.js
var require_logger = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/logger/logger.js"(exports10, module2) {
    var { get: get2, isColl, isObj, isFunc } = require_cjs();
    var { colors } = require_colors();
    var TAG_DISABLED = false;
    var logData = (logger, type2) => {
      return (...args) => {
        const logColor = logger.colorMap[type2] || logger.colorMap[logger.default];
        const logMethod = console[type2] && type2 || logger.default;
        const toLog = args.map((data) => {
          return isColl(data) ? colors[logColor](JSON.stringify(data, null, 2)) : isFunc(data.toString) ? colors[logColor](data.toString()) : colors[logColor](data);
        });
        if (!TAG_DISABLED && logger.tag) {
          logMethod === "dir" || logMethod === "table" ? logger.stdout(`${logger.tag} `) : toLog.unshift(logger.tag);
        }
        console[logMethod](...toLog);
      };
    };
    var Log = class {
      tag = false;
      constructor(props) {
        this.colorMap = {
          data: "white",
          dir: "white",
          error: "red",
          fail: "red",
          info: "cyan",
          log: "white",
          success: "green",
          text: "white",
          warn: "yellow",
          green: "green",
          red: "red",
          yellow: "yellow",
          cyan: "cyan",
          magenta: "magenta",
          blue: "blue",
          gray: "gray"
        };
        this.default = get2(props, "default", "log");
        Object.keys(this.colorMap).map((key) => this[key] = logData(this, key));
        this.colors = colors;
        this.log = this.print;
      }
      /**
       * Set a tag value for all logged messages
       * @instance
       * @memberof Log
       * @function
       * @param {string} tag - Text that should be used as the tag
       * @param {string} color - Color of tag when logged
       */
      setTag = (tag, color) => {
        if (!tag)
          return this.warn(`Tag must be of type string`, tag);
        this.tag = color ? colors[this.colorMap[color] || color](tag) : tag;
      };
      /**
       * Removes the defined tag from the Log instance
       * @instance
       * @memberof Log
       * @function
       *
       */
      removeTag = () => {
        this.tag = void 0;
      };
      /**
       * Toggle the Log instance tag on or off
       * @instance
       * @memberof Log
       * @function
       *
       */
      toggleTag = () => {
        if (!TAG_DISABLED)
          TAG_DISABLED = true;
        else
          TAG_DISABLED = false;
      };
      /**
       * Helper to create a string in the passed in color
       * @instance
       * @memberof Log
       * @function
       * @param {string} colorName - name of the color to use
       * @param {string} data - data to set color for
       *
       * @returns {void}
       */
      color = (colorName, data) => colors[this.colorMap[colorName] || colorName](data);
      /**
       * Helper to print the passed in data
       * <br/>Similar to calling `console.log(...data)`
       * @instance
       * @memberof Log
       * @function
       *
       * @returns {void}
       */
      print = (...data) => {
        !TAG_DISABLED && this.tag && data.unshift(this.tag);
        console.log(...data);
      };
      /**
       * Helper to change the default colors
       * @instance
       * @memberof Log
       * @function
       *
       * @returns {void}
       */
      setColors = (colorMap) => isObj(colorMap) && (this.colorMap = { ...this.colorMap, ...colorMap });
      /**
       * Helper to log an empty line
       * @instance
       * @memberof Log
       * @function
       *
       * @returns {void}
       */
      empty = () => console.log("");
      /**
       * Helper to print out a table.
       * @instance
       * @memberof Log
       * @function
       * @see docs about params here: https://developer.mozilla.org/en-US/docs/Web/API/Console/table
       * @returns {void}
       */
      table = (...args) => {
        !TAG_DISABLED && this.tag && args.unshift(this.tag);
        console.table(...args);
      };
      /**
       * Helper to log out a CLI message header
       * @instance
       * @memberof Log
       * @function
       *
       * @param {string} title - Text to print as the header
       * @param {string} color - Color of the header text
       *
       * @returns {void}
       */
      header = (title, color) => {
        const tagState = TAG_DISABLED;
        TAG_DISABLED = true;
        const middle = `              ${title}              `;
        const line = middle.split("").reduce((line2, item, index) => line2 += " ");
        color = color || "green";
        this.empty(``);
        this.print(colors.underline[color](line));
        this.print(line);
        this.print(colors[color](middle));
        this.print(colors.underline[color](line));
        this.empty(``);
        TAG_DISABLED = tagState;
      };
      /**
       * Helper to log out a CLI message sub-header
       * @instance
       * @memberof Log
       * @function
       *
       * @param {string} title - Text to print as the sub-header
       * @param {string} color - Color of the header text
       *
       * @returns {void}
       */
      subHeader = (title, color) => {
        const tagState = TAG_DISABLED;
        TAG_DISABLED = true;
        const middle = `          ${title}       `;
        const line = middle.split("").reduce((line2, item, index) => line2 += " ");
        color = color || "white";
        this.empty(``);
        this.print(colors[color](middle));
        this.print(`  ${colors.underline[color](line)}`);
        this.empty(``);
        TAG_DISABLED = tagState;
      };
      /**
       * Helper to log a title and message in separate colors
       * @instance
       * @memberof Log
       * @function
       * @param {string} title - Prints the string in the color `cyan`
       * @param {string} message - Prints the string in the color `white`
       *
       * @returns {void}
       */
      pair = (title, message) => {
        const toLog = [];
        title && toLog.push(Logger3.colors.brightCyan(title));
        message && toLog.push(Logger3.colors.brightWhite(message));
        toLog.length && this.print(...toLog);
      };
      /**
       * Alias for `Log.pair`
       * @instance
       * @memberof Log
       * @function
       */
      label = (...args) => this.pair(...args);
      /**
       * Helper to log a spaced title and message in separate colors
       * @instance
       * @memberof Log
       * @function
       * @param {string} title - Prints the string in cyan
       * @param {string} message - Prints the string in white
       *
       * @returns {void}
       */
      spacedMsg = (title, message) => {
        this.empty();
        this.pair(title, message);
        this.empty();
      };
      /**
       * Alias for `Log.spacedMsg`
       * @instance
       * @memberof Log
       * @function
       */
      spaceMsg = (...args) => this.spacedMsg(...args);
      /**
       * Writes passed in arguments to the process stdout
       * @instance
       * @memberof Log
       * @function
       * @param {*} - Items to write to process stdout
       */
      stdout = (...args) => process.stdout.write(...args);
      /**
       * Writes to the process stderr
       * @instance
       * @memberof Log
       * @function
       * @param {*} - Items to write to process stderr
       */
      stderr = (...args) => process.stderr.write(...args);
      /**
       * Clears the terminal, does not allow scrolling back
       * @instance
       * @memberof Log
       * @function
       */
      clear = () => {
        process.stdout.write("\x1B[3J\x1B[2J\x1B[1J");
        console.clear();
      };
      /**
       * Helper to highlight a word in a logged message
       * @instance
       * @memberof Log
       * @function
       * @param {string} start - Beginning of the message
       * @param {string} highlight - Part of message to be highlighted
       * @param {string} end - End of the message
       *
       * @returns {void}
       */
      highlight = (start = "", highlight = "", end = "") => {
        this.log(`${start}`, Logger3.colors.cyan(highlight), end);
      };
    };
    var Logger3 = new Log();
    module2.exports = {
      Log,
      Logger: Logger3
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/error/error.js
var require_error = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/error/error.js"(exports10, module2) {
    var { Logger: Logger3 } = require_logger();
    var { noOpObj } = require_cjs();
    var throwError = (...message) => {
      Logger3.error(`
 ${message.join("\n ")}
`);
      throwTaskFailed();
    };
    var throwExitError = (err = noOpObj) => {
      Logger3.header(`Task Error:`);
      err.stack ? Logger3.error(`  ${err.stack}`) : Logger3.error(`  An unknown error occurred!`);
      Logger3.empty();
      process.exit(1);
    };
    var throwNoAction = (task = noOpObj) => {
      Logger3.error(
        `
 Task '${task.name}' requires a valid sub-task. No action exists for this task!`
      );
      task.alias && Logger3.pair(`  * Alias:`, task.alias.join(" | "));
      task.description && Logger3.pair(`  * Description:`, task.description);
      task.example && Logger3.pair(`  * Example:`, task.example);
      task.tasks && Logger3.pair(`  * Subtasks:`, Object.keys(task.tasks).join(" | "));
      Logger3.empty();
      throwTaskFailed();
    };
    var throwNoTask = (task) => {
      Logger3.empty();
      Logger3.error(`Unknown task => ${task}`);
      Logger3.green(`Type "keg help' to see all known tasks.`);
      Logger3.empty();
      throwTaskFailed();
    };
    var throwTaskFailed = () => {
      throw new Error(`Task failed!`);
    };
    var throwErr = (message) => {
      throw new Error(message);
    };
    module2.exports = {
      throwErr,
      throwError,
      throwExitError,
      throwNoTask,
      throwNoAction,
      throwTaskFailed
    };
  }
});

// node-modules-polyfills:path
function dew() {
  if (_dewExec)
    return exports;
  _dewExec = true;
  var process22 = exports = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e14) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e14) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e14) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e26) {
        return cachedSetTimeout.call(this || _global, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e14) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e26) {
        return cachedClearTimeout.call(this || _global, marker);
      }
    }
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  process22.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i13 = 1; i13 < arguments.length; i13++) {
        args[i13 - 1] = arguments[i13];
      }
    }
    queue.push(new Item2(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  };
  function Item2(fun, array) {
    (this || _global).fun = fun;
    (this || _global).array = array;
  }
  Item2.prototype.run = function() {
    (this || _global).fun.apply(null, (this || _global).array);
  };
  process22.title = "browser";
  process22.browser = true;
  process22.env = {};
  process22.argv = [];
  process22.version = "";
  process22.versions = {};
  function noop() {
  }
  process22.on = noop;
  process22.addListener = noop;
  process22.once = noop;
  process22.off = noop;
  process22.removeListener = noop;
  process22.removeAllListeners = noop;
  process22.emit = noop;
  process22.prependListener = noop;
  process22.prependOnceListener = noop;
  process22.listeners = function(name2) {
    return [];
  };
  process22.binding = function(name2) {
    throw new Error("process.binding is not supported");
  };
  process22.cwd = function() {
    return "/";
  };
  process22.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process22.umask = function() {
    return 0;
  };
  return exports;
}
function dew2() {
  if (_dewExec2)
    return exports$1;
  _dewExec2 = true;
  var process$1 = process2;
  function assertPath(path3) {
    if (typeof path3 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path3));
    }
  }
  function normalizeStringPosix(path3, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i13 = 0; i13 <= path3.length; ++i13) {
      if (i13 < path3.length)
        code = path3.charCodeAt(i13);
      else if (code === 47)
        break;
      else
        code = 47;
      if (code === 47) {
        if (lastSlash === i13 - 1 || dots === 1)
          ;
        else if (lastSlash !== i13 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i13;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i13;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += "/..";
            else
              res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path3.slice(lastSlash + 1, i13);
          else
            res = path3.slice(lastSlash + 1, i13);
          lastSegmentLength = i13 - lastSlash - 1;
        }
        lastSlash = i13;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep22, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep22 + base;
  }
  var posix22 = {
    // path.resolve([from ...], to)
    resolve: function resolve23() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd;
      for (var i13 = arguments.length - 1; i13 >= -1 && !resolvedAbsolute; i13--) {
        var path3;
        if (i13 >= 0)
          path3 = arguments[i13];
        else {
          if (cwd === void 0)
            cwd = process$1.cwd();
          path3 = cwd;
        }
        assertPath(path3);
        if (path3.length === 0) {
          continue;
        }
        resolvedPath = path3 + "/" + resolvedPath;
        resolvedAbsolute = path3.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return "/" + resolvedPath;
        else
          return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize22(path3) {
      assertPath(path3);
      if (path3.length === 0)
        return ".";
      var isAbsolute22 = path3.charCodeAt(0) === 47;
      var trailingSeparator = path3.charCodeAt(path3.length - 1) === 47;
      path3 = normalizeStringPosix(path3, !isAbsolute22);
      if (path3.length === 0 && !isAbsolute22)
        path3 = ".";
      if (path3.length > 0 && trailingSeparator)
        path3 += "/";
      if (isAbsolute22)
        return "/" + path3;
      return path3;
    },
    isAbsolute: function isAbsolute22(path3) {
      assertPath(path3);
      return path3.length > 0 && path3.charCodeAt(0) === 47;
    },
    join: function join22() {
      if (arguments.length === 0)
        return ".";
      var joined;
      for (var i13 = 0; i13 < arguments.length; ++i13) {
        var arg = arguments[i13];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += "/" + arg;
        }
      }
      if (joined === void 0)
        return ".";
      return posix22.normalize(joined);
    },
    relative: function relative22(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to)
        return "";
      from = posix22.resolve(from);
      to = posix22.resolve(to);
      if (from === to)
        return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i13 = 0;
      for (; i13 <= length; ++i13) {
        if (i13 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i13) === 47) {
              return to.slice(toStart + i13 + 1);
            } else if (i13 === 0) {
              return to.slice(toStart + i13);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i13) === 47) {
              lastCommonSep = i13;
            } else if (i13 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i13);
        var toCode = to.charCodeAt(toStart + i13);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i13;
      }
      var out = "";
      for (i13 = fromStart + lastCommonSep + 1; i13 <= fromEnd; ++i13) {
        if (i13 === fromEnd || from.charCodeAt(i13) === 47) {
          if (out.length === 0)
            out += "..";
          else
            out += "/..";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong22(path3) {
      return path3;
    },
    dirname: function dirname22(path3) {
      assertPath(path3);
      if (path3.length === 0)
        return ".";
      var code = path3.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i13 = path3.length - 1; i13 >= 1; --i13) {
        code = path3.charCodeAt(i13);
        if (code === 47) {
          if (!matchedSlash) {
            end = i13;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : ".";
      if (hasRoot && end === 1)
        return "//";
      return path3.slice(0, end);
    },
    basename: function basename22(path3, ext) {
      if (ext !== void 0 && typeof ext !== "string")
        throw new TypeError('"ext" argument must be a string');
      assertPath(path3);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i13;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path3.length) {
        if (ext.length === path3.length && ext === path3)
          return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i13 = path3.length - 1; i13 >= 0; --i13) {
          var code = path3.charCodeAt(i13);
          if (code === 47) {
            if (!matchedSlash) {
              start = i13 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i13 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i13;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path3.length;
        return path3.slice(start, end);
      } else {
        for (i13 = path3.length - 1; i13 >= 0; --i13) {
          if (path3.charCodeAt(i13) === 47) {
            if (!matchedSlash) {
              start = i13 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i13 + 1;
          }
        }
        if (end === -1)
          return "";
        return path3.slice(start, end);
      }
    },
    extname: function extname22(path3) {
      assertPath(path3);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i13 = path3.length - 1; i13 >= 0; --i13) {
        var code = path3.charCodeAt(i13);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i13 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i13 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i13;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path3.slice(startDot, end);
    },
    format: function format26(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse23(path3) {
      assertPath(path3);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path3.length === 0)
        return ret;
      var code = path3.charCodeAt(0);
      var isAbsolute22 = code === 47;
      var start;
      if (isAbsolute22) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i13 = path3.length - 1;
      var preDotState = 0;
      for (; i13 >= start; --i13) {
        code = path3.charCodeAt(i13);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i13 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i13 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i13;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute22)
            ret.base = ret.name = path3.slice(1, end);
          else
            ret.base = ret.name = path3.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute22) {
          ret.name = path3.slice(1, startDot);
          ret.base = path3.slice(1, end);
        } else {
          ret.name = path3.slice(startPart, startDot);
          ret.base = path3.slice(startPart, end);
        }
        ret.ext = path3.slice(startDot, end);
      }
      if (startPart > 0)
        ret.dir = path3.slice(0, startPart - 1);
      else if (isAbsolute22)
        ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix22.posix = posix22;
  exports$1 = posix22;
  return exports$1;
}
var exports, _dewExec, _global, process2, exports$1, _dewExec2, exports2, _makeLong, basename, delimiter, dirname, extname, format, isAbsolute, join, normalize, parse, posix, relative, resolve, sep, win32;
var init_path = __esm({
  "node-modules-polyfills:path"() {
    exports = {};
    _dewExec = false;
    _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    process2 = dew();
    process2.platform = "browser";
    process2.addListener;
    process2.argv;
    process2.binding;
    process2.browser;
    process2.chdir;
    process2.cwd;
    process2.emit;
    process2.env;
    process2.listeners;
    process2.nextTick;
    process2.off;
    process2.on;
    process2.once;
    process2.prependListener;
    process2.prependOnceListener;
    process2.removeAllListeners;
    process2.removeListener;
    process2.title;
    process2.umask;
    process2.version;
    process2.versions;
    exports$1 = {};
    _dewExec2 = false;
    exports2 = dew2();
    _makeLong = exports2._makeLong;
    basename = exports2.basename;
    delimiter = exports2.delimiter;
    dirname = exports2.dirname;
    extname = exports2.extname;
    format = exports2.format;
    isAbsolute = exports2.isAbsolute;
    join = exports2.join;
    normalize = exports2.normalize;
    parse = exports2.parse;
    posix = exports2.posix;
    relative = exports2.relative;
    resolve = exports2.resolve;
    sep = exports2.sep;
    win32 = exports2.win32;
  }
});

// node-modules-polyfills-commonjs:path
var path_exports = {};
__export(path_exports, {
  _makeLong: () => _makeLong,
  basename: () => basename,
  delimiter: () => delimiter,
  dirname: () => dirname,
  extname: () => extname,
  format: () => format,
  isAbsolute: () => isAbsolute,
  join: () => join,
  normalize: () => normalize,
  parse: () => parse,
  posix: () => posix,
  relative: () => relative,
  resolve: () => resolve,
  sep: () => sep,
  win32: () => win32
});
var init_path2 = __esm({
  "node-modules-polyfills-commonjs:path"() {
    init_path();
  }
});

// node-modules-polyfills:os
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function uptime() {
  return _performance.now() / 1e3;
}
function hrtime(previousTimestamp) {
  var baseNow = Math.floor((Date.now() - _performance.now()) * 1e-3);
  var clocktime = _performance.now() * 1e-3;
  var seconds = Math.floor(clocktime) + baseNow;
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += nanoPerSec;
    }
  }
  return [seconds, nanoseconds];
}
function dew3() {
  if (_dewExec3)
    return exports$12;
  _dewExec3 = true;
  exports$12.endianness = function() {
    return "LE";
  };
  exports$12.hostname = function() {
    if (typeof location !== "undefined") {
      return location.hostname;
    } else
      return "";
  };
  exports$12.loadavg = function() {
    return [];
  };
  exports$12.uptime = function() {
    return 0;
  };
  exports$12.freemem = function() {
    return Number.MAX_VALUE;
  };
  exports$12.totalmem = function() {
    return Number.MAX_VALUE;
  };
  exports$12.cpus = function() {
    return [];
  };
  exports$12.type = function() {
    return "Browser";
  };
  exports$12.release = function() {
    if (typeof navigator !== "undefined") {
      return navigator.appVersion;
    }
    return "";
  };
  exports$12.networkInterfaces = exports$12.getNetworkInterfaces = function() {
    return {};
  };
  exports$12.arch = function() {
    return "javascript";
  };
  exports$12.platform = function() {
    return "browser";
  };
  exports$12.tmpdir = exports$12.tmpDir = function() {
    return "/tmp";
  };
  exports$12.EOL = "\n";
  exports$12.homedir = function() {
    return "/";
  };
  return exports$12;
}
var env, _performance, nowOffset, nanoPerSec, exports$12, _dewExec3, exports3, _endianness, version, constants, EOL, arch, cpus, endianness, freemem, getNetworkInterfaces, homedir, hostname, loadavg, networkInterfaces, platform, release, tmpDir, tmpdir, totalmem, type;
var init_os = __esm({
  "node-modules-polyfills:os"() {
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    env = {
      PATH: "/usr/bin",
      LANG: navigator.language + ".UTF-8",
      PWD: "/",
      HOME: "/home",
      TMP: "/tmp"
    };
    _performance = {
      now: typeof performance !== "undefined" ? performance.now.bind(performance) : void 0,
      timing: typeof performance !== "undefined" ? performance.timing : void 0
    };
    if (_performance.now === void 0) {
      nowOffset = Date.now();
      if (_performance.timing && _performance.timing.navigationStart) {
        nowOffset = _performance.timing.navigationStart;
      }
      _performance.now = () => Date.now() - nowOffset;
    }
    nanoPerSec = 1e9;
    hrtime.bigint = function(time) {
      var diff = hrtime(time);
      if (typeof BigInt === "undefined") {
        return diff[0] * nanoPerSec + diff[1];
      }
      return BigInt(diff[0] * nanoPerSec) + BigInt(diff[1]);
    };
    exports$12 = {};
    _dewExec3 = false;
    exports3 = dew3();
    exports3["endianness"];
    exports3["hostname"];
    exports3["loadavg"];
    exports3["uptime"];
    exports3["freemem"];
    exports3["totalmem"];
    exports3["cpus"];
    exports3["type"];
    exports3["release"];
    exports3["networkInterfaces"];
    exports3["getNetworkInterfaces"];
    exports3["arch"];
    exports3["platform"];
    exports3["tmpdir"];
    exports3["tmpDir"];
    exports3["EOL"];
    exports3["homedir"];
    _endianness = new Uint8Array(new Uint16Array([1]).buffer)[0] === 1 ? "LE" : "BE";
    exports3.endianness = function() {
      return _endianness;
    };
    exports3.homedir = function() {
      return "/home";
    };
    exports3.version = function() {
      return "";
    };
    exports3.arch = function() {
      return "x64";
    };
    exports3.totalmem = function() {
      return navigator.deviceMemory !== void 0 ? navigator.deviceMemory * (1 << 30) : 2 * (1 << 30);
    };
    exports3.cpus = function() {
      return Array(navigator.hardwareConcurrency || 0).fill({ model: "", times: {} });
    };
    exports3.uptime = uptime;
    exports3.constants = {};
    version = exports3.version;
    constants = exports3.constants;
    EOL = exports3.EOL;
    arch = exports3.arch;
    cpus = exports3.cpus;
    endianness = exports3.endianness;
    freemem = exports3.freemem;
    getNetworkInterfaces = exports3.getNetworkInterfaces;
    homedir = exports3.homedir;
    hostname = exports3.hostname;
    loadavg = exports3.loadavg;
    networkInterfaces = exports3.networkInterfaces;
    platform = exports3.platform;
    release = exports3.release;
    tmpDir = exports3.tmpDir;
    tmpdir = exports3.tmpdir;
    totalmem = exports3.totalmem;
    type = exports3.type;
  }
});

// node-modules-polyfills-commonjs:os
var os_exports = {};
__export(os_exports, {
  EOL: () => EOL,
  arch: () => arch,
  constants: () => constants,
  cpus: () => cpus,
  endianness: () => endianness,
  freemem: () => freemem,
  getNetworkInterfaces: () => getNetworkInterfaces,
  homedir: () => homedir,
  hostname: () => hostname,
  loadavg: () => loadavg,
  networkInterfaces: () => networkInterfaces,
  platform: () => platform,
  release: () => release,
  tmpDir: () => tmpDir,
  tmpdir: () => tmpdir,
  totalmem: () => totalmem,
  type: () => type,
  uptime: () => uptime,
  version: () => version
});
var init_os2 = __esm({
  "node-modules-polyfills-commonjs:os"() {
    init_os();
  }
});

// node-modules-polyfills:child_process
function unimplemented() {
  throw new Error("Node.js child_process is not supported by JSPM core in the browser");
}
var init_child_process = __esm({
  "node-modules-polyfills:child_process"() {
  }
});

// node-modules-polyfills-commonjs:child_process
var child_process_exports = {};
__export(child_process_exports, {
  ChildProcess: () => unimplemented,
  _forkChild: () => unimplemented,
  exec: () => unimplemented,
  execFile: () => unimplemented,
  execFileSync: () => unimplemented,
  execSync: () => unimplemented,
  fork: () => unimplemented,
  spawn: () => unimplemented,
  spawnSync: () => unimplemented
});
var init_child_process2 = __esm({
  "node-modules-polyfills-commonjs:child_process"() {
    init_child_process();
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/src/node/findProc.js
var require_findProc = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/src/node/findProc.js"(exports10, module2) {
    var { exec } = (init_child_process2(), __toCommonJS(child_process_exports));
    var parseOutput = (procName, output) => {
      return output.trim().split(/\n|\r|\r\n/).reduce((acc, line) => {
        const [pid, tty, time, ...rest] = line.trim().split(" ").filter((part) => part);
        const cmd = rest.join(" ");
        cmd && cmd.includes(procName) && acc.push({
          tty,
          time,
          cmd,
          procName,
          running: true,
          pid: parseInt(pid, 10)
        });
        return acc;
      }, []);
    };
    var getPlatformCmd = (procName, platform2) => {
      const proc = `"[${procName[0]}]${procName.substring(1)}"`;
      switch (platform2) {
        case "linux":
        case "darwin":
          return `ps -A | grep ${proc}`;
        case "win32":
          return `tasklist`;
        default:
          return false;
      }
    };
    var findProc = (procName, opts2 = {}) => {
      return new Promise((res, rej) => {
        const platform2 = process.platform;
        const cmd = getPlatformCmd(procName, platform2);
        if (!cmd)
          return rej(`Error: ${platform2} platform not supported.`);
        exec(cmd, (err, stdout, stderr) => {
          err || stderr ? rej(stderr || err.message) : res(parseOutput(procName, stdout));
        });
      }).catch((err) => {
        opts2.log && console.error(err.message);
        return [];
      });
    };
    module2.exports = {
      findProc
    };
  }
});

// node-modules-polyfills:fs
function o() {
  o.init.call(this);
}
function u(e92) {
  if ("function" != typeof e92)
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e92);
}
function f(e92) {
  return void 0 === e92._maxListeners ? o.defaultMaxListeners : e92._maxListeners;
}
function v(e92, t82, n82, r92) {
  var i72, o82, s62, v62;
  if (u(n82), void 0 === (o82 = e92._events) ? (o82 = e92._events = /* @__PURE__ */ Object.create(null), e92._eventsCount = 0) : (void 0 !== o82.newListener && (e92.emit("newListener", t82, n82.listener ? n82.listener : n82), o82 = e92._events), s62 = o82[t82]), void 0 === s62)
    s62 = o82[t82] = n82, ++e92._eventsCount;
  else if ("function" == typeof s62 ? s62 = o82[t82] = r92 ? [n82, s62] : [s62, n82] : r92 ? s62.unshift(n82) : s62.push(n82), (i72 = f(e92)) > 0 && s62.length > i72 && !s62.warned) {
    s62.warned = true;
    var a72 = new Error("Possible EventEmitter memory leak detected. " + s62.length + " " + String(t82) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a72.name = "MaxListenersExceededWarning", a72.emitter = e92, a72.type = t82, a72.count = s62.length, v62 = a72, console && console.warn && console.warn(v62);
  }
  return e92;
}
function a() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function l(e92, t82, n82) {
  var r92 = { fired: false, wrapFn: void 0, target: e92, type: t82, listener: n82 }, i72 = a.bind(r92);
  return i72.listener = n82, r92.wrapFn = i72, i72;
}
function h(e92, t82, n82) {
  var r92 = e92._events;
  if (void 0 === r92)
    return [];
  var i72 = r92[t82];
  return void 0 === i72 ? [] : "function" == typeof i72 ? n82 ? [i72.listener || i72] : [i72] : n82 ? function(e102) {
    for (var t92 = new Array(e102.length), n92 = 0; n92 < t92.length; ++n92)
      t92[n92] = e102[n92].listener || e102[n92];
    return t92;
  }(i72) : c(i72, i72.length);
}
function p(e92) {
  var t82 = this._events;
  if (void 0 !== t82) {
    var n82 = t82[e92];
    if ("function" == typeof n82)
      return 1;
    if (void 0 !== n82)
      return n82.length;
  }
  return 0;
}
function c(e92, t82) {
  for (var n82 = new Array(t82), r92 = 0; r92 < t82; ++r92)
    n82[r92] = e92[r92];
  return n82;
}
function i2() {
  throw new Error("setTimeout has not been defined");
}
function u2() {
  throw new Error("clearTimeout has not been defined");
}
function c2(e92) {
  if (t2 === setTimeout)
    return setTimeout(e92, 0);
  if ((t2 === i2 || !t2) && setTimeout)
    return t2 = setTimeout, setTimeout(e92, 0);
  try {
    return t2(e92, 0);
  } catch (n82) {
    try {
      return t2.call(null, e92, 0);
    } catch (n92) {
      return t2.call(this || r2, e92, 0);
    }
  }
}
function h2() {
  f2 && l2 && (f2 = false, l2.length ? s2 = l2.concat(s2) : a2 = -1, s2.length && d());
}
function d() {
  if (!f2) {
    var e92 = c2(h2);
    f2 = true;
    for (var t82 = s2.length; t82; ) {
      for (l2 = s2, s2 = []; ++a2 < t82; )
        l2 && l2[a2].run();
      a2 = -1, t82 = s2.length;
    }
    l2 = null, f2 = false, function(e102) {
      if (n2 === clearTimeout)
        return clearTimeout(e102);
      if ((n2 === u2 || !n2) && clearTimeout)
        return n2 = clearTimeout, clearTimeout(e102);
      try {
        n2(e102);
      } catch (t92) {
        try {
          return n2.call(null, e102);
        } catch (t102) {
          return n2.call(this || r2, e102);
        }
      }
    }(e92);
  }
}
function m(e92, t82) {
  (this || r2).fun = e92, (this || r2).array = t82;
}
function p2() {
}
function c$1(e92) {
  return e92.call.bind(e92);
}
function O(e92, t82) {
  if ("object" != typeof e92)
    return false;
  try {
    return t82(e92), true;
  } catch (e102) {
    return false;
  }
}
function S(e92) {
  return l$1 && y2 ? void 0 !== b(e92) : B(e92) || k(e92) || E(e92) || D(e92) || U(e92) || P(e92) || x(e92) || I(e92) || M(e92) || z(e92) || F(e92);
}
function B(e92) {
  return l$1 && y2 ? "Uint8Array" === b(e92) : "[object Uint8Array]" === m2(e92) || u$1(e92) && void 0 !== e92.buffer;
}
function k(e92) {
  return l$1 && y2 ? "Uint8ClampedArray" === b(e92) : "[object Uint8ClampedArray]" === m2(e92);
}
function E(e92) {
  return l$1 && y2 ? "Uint16Array" === b(e92) : "[object Uint16Array]" === m2(e92);
}
function D(e92) {
  return l$1 && y2 ? "Uint32Array" === b(e92) : "[object Uint32Array]" === m2(e92);
}
function U(e92) {
  return l$1 && y2 ? "Int8Array" === b(e92) : "[object Int8Array]" === m2(e92);
}
function P(e92) {
  return l$1 && y2 ? "Int16Array" === b(e92) : "[object Int16Array]" === m2(e92);
}
function x(e92) {
  return l$1 && y2 ? "Int32Array" === b(e92) : "[object Int32Array]" === m2(e92);
}
function I(e92) {
  return l$1 && y2 ? "Float32Array" === b(e92) : "[object Float32Array]" === m2(e92);
}
function M(e92) {
  return l$1 && y2 ? "Float64Array" === b(e92) : "[object Float64Array]" === m2(e92);
}
function z(e92) {
  return l$1 && y2 ? "BigInt64Array" === b(e92) : "[object BigInt64Array]" === m2(e92);
}
function F(e92) {
  return l$1 && y2 ? "BigUint64Array" === b(e92) : "[object BigUint64Array]" === m2(e92);
}
function T2(e92) {
  return "[object Map]" === m2(e92);
}
function N(e92) {
  return "[object Set]" === m2(e92);
}
function W(e92) {
  return "[object WeakMap]" === m2(e92);
}
function $(e92) {
  return "[object WeakSet]" === m2(e92);
}
function C(e92) {
  return "[object ArrayBuffer]" === m2(e92);
}
function V(e92) {
  return "undefined" != typeof ArrayBuffer && (C.working ? C(e92) : e92 instanceof ArrayBuffer);
}
function G(e92) {
  return "[object DataView]" === m2(e92);
}
function R(e92) {
  return "undefined" != typeof DataView && (G.working ? G(e92) : e92 instanceof DataView);
}
function J(e92) {
  return "[object SharedArrayBuffer]" === m2(e92);
}
function _(e92) {
  return "undefined" != typeof SharedArrayBuffer && (J.working ? J(e92) : e92 instanceof SharedArrayBuffer);
}
function H(e92) {
  return O(e92, h3);
}
function Z(e92) {
  return O(e92, j);
}
function q(e92) {
  return O(e92, A);
}
function K(e92) {
  return s3 && O(e92, w);
}
function L(e92) {
  return p3 && O(e92, v2);
}
function oe(e92, t82) {
  var r92 = { seen: [], stylize: fe };
  return arguments.length >= 3 && (r92.depth = arguments[2]), arguments.length >= 4 && (r92.colors = arguments[3]), ye(t82) ? r92.showHidden = t82 : t82 && X._extend(r92, t82), be(r92.showHidden) && (r92.showHidden = false), be(r92.depth) && (r92.depth = 2), be(r92.colors) && (r92.colors = false), be(r92.customInspect) && (r92.customInspect = true), r92.colors && (r92.stylize = ue), ae(r92, e92, r92.depth);
}
function ue(e92, t82) {
  var r92 = oe.styles[t82];
  return r92 ? "\x1B[" + oe.colors[r92][0] + "m" + e92 + "\x1B[" + oe.colors[r92][1] + "m" : e92;
}
function fe(e92, t82) {
  return e92;
}
function ae(e92, t82, r92) {
  if (e92.customInspect && t82 && we(t82.inspect) && t82.inspect !== X.inspect && (!t82.constructor || t82.constructor.prototype !== t82)) {
    var n82 = t82.inspect(r92, e92);
    return ge(n82) || (n82 = ae(e92, n82, r92)), n82;
  }
  var i72 = function(e102, t92) {
    if (be(t92))
      return e102.stylize("undefined", "undefined");
    if (ge(t92)) {
      var r102 = "'" + JSON.stringify(t92).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return e102.stylize(r102, "string");
    }
    if (de(t92))
      return e102.stylize("" + t92, "number");
    if (ye(t92))
      return e102.stylize("" + t92, "boolean");
    if (le(t92))
      return e102.stylize("null", "null");
  }(e92, t82);
  if (i72)
    return i72;
  var o82 = Object.keys(t82), u72 = function(e102) {
    var t92 = {};
    return e102.forEach(function(e112, r102) {
      t92[e112] = true;
    }), t92;
  }(o82);
  if (e92.showHidden && (o82 = Object.getOwnPropertyNames(t82)), Ae(t82) && (o82.indexOf("message") >= 0 || o82.indexOf("description") >= 0))
    return ce(t82);
  if (0 === o82.length) {
    if (we(t82)) {
      var f72 = t82.name ? ": " + t82.name : "";
      return e92.stylize("[Function" + f72 + "]", "special");
    }
    if (me(t82))
      return e92.stylize(RegExp.prototype.toString.call(t82), "regexp");
    if (je(t82))
      return e92.stylize(Date.prototype.toString.call(t82), "date");
    if (Ae(t82))
      return ce(t82);
  }
  var a72, c72 = "", s62 = false, p72 = ["{", "}"];
  (pe(t82) && (s62 = true, p72 = ["[", "]"]), we(t82)) && (c72 = " [Function" + (t82.name ? ": " + t82.name : "") + "]");
  return me(t82) && (c72 = " " + RegExp.prototype.toString.call(t82)), je(t82) && (c72 = " " + Date.prototype.toUTCString.call(t82)), Ae(t82) && (c72 = " " + ce(t82)), 0 !== o82.length || s62 && 0 != t82.length ? r92 < 0 ? me(t82) ? e92.stylize(RegExp.prototype.toString.call(t82), "regexp") : e92.stylize("[Object]", "special") : (e92.seen.push(t82), a72 = s62 ? function(e102, t92, r102, n92, i82) {
    for (var o92 = [], u82 = 0, f82 = t92.length; u82 < f82; ++u82)
      ke(t92, String(u82)) ? o92.push(se(e102, t92, r102, n92, String(u82), true)) : o92.push("");
    return i82.forEach(function(i92) {
      i92.match(/^\d+$/) || o92.push(se(e102, t92, r102, n92, i92, true));
    }), o92;
  }(e92, t82, r92, u72, o82) : o82.map(function(n92) {
    return se(e92, t82, r92, u72, n92, s62);
  }), e92.seen.pop(), function(e102, t92, r102) {
    var n92 = 0;
    if (e102.reduce(function(e112, t102) {
      return n92++, t102.indexOf("\n") >= 0 && n92++, e112 + t102.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0) > 60)
      return r102[0] + ("" === t92 ? "" : t92 + "\n ") + " " + e102.join(",\n  ") + " " + r102[1];
    return r102[0] + t92 + " " + e102.join(", ") + " " + r102[1];
  }(a72, c72, p72)) : p72[0] + c72 + p72[1];
}
function ce(e92) {
  return "[" + Error.prototype.toString.call(e92) + "]";
}
function se(e92, t82, r92, n82, i72, o82) {
  var u72, f72, a72;
  if ((a72 = Object.getOwnPropertyDescriptor(t82, i72) || { value: t82[i72] }).get ? f72 = a72.set ? e92.stylize("[Getter/Setter]", "special") : e92.stylize("[Getter]", "special") : a72.set && (f72 = e92.stylize("[Setter]", "special")), ke(n82, i72) || (u72 = "[" + i72 + "]"), f72 || (e92.seen.indexOf(a72.value) < 0 ? (f72 = le(r92) ? ae(e92, a72.value, null) : ae(e92, a72.value, r92 - 1)).indexOf("\n") > -1 && (f72 = o82 ? f72.split("\n").map(function(e102) {
    return "  " + e102;
  }).join("\n").substr(2) : "\n" + f72.split("\n").map(function(e102) {
    return "   " + e102;
  }).join("\n")) : f72 = e92.stylize("[Circular]", "special")), be(u72)) {
    if (o82 && i72.match(/^\d+$/))
      return f72;
    (u72 = JSON.stringify("" + i72)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u72 = u72.substr(1, u72.length - 2), u72 = e92.stylize(u72, "name")) : (u72 = u72.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u72 = e92.stylize(u72, "string"));
  }
  return u72 + ": " + f72;
}
function pe(e92) {
  return Array.isArray(e92);
}
function ye(e92) {
  return "boolean" == typeof e92;
}
function le(e92) {
  return null === e92;
}
function de(e92) {
  return "number" == typeof e92;
}
function ge(e92) {
  return "string" == typeof e92;
}
function be(e92) {
  return void 0 === e92;
}
function me(e92) {
  return he(e92) && "[object RegExp]" === ve(e92);
}
function he(e92) {
  return "object" == typeof e92 && null !== e92;
}
function je(e92) {
  return he(e92) && "[object Date]" === ve(e92);
}
function Ae(e92) {
  return he(e92) && ("[object Error]" === ve(e92) || e92 instanceof Error);
}
function we(e92) {
  return "function" == typeof e92;
}
function ve(e92) {
  return Object.prototype.toString.call(e92);
}
function Oe(e92) {
  return e92 < 10 ? "0" + e92.toString(10) : e92.toString(10);
}
function Be() {
  var e92 = /* @__PURE__ */ new Date(), t82 = [Oe(e92.getHours()), Oe(e92.getMinutes()), Oe(e92.getSeconds())].join(":");
  return [e92.getDate(), Se[e92.getMonth()], t82].join(" ");
}
function ke(e92, t82) {
  return Object.prototype.hasOwnProperty.call(e92, t82);
}
function De(e92, t82) {
  if (!e92) {
    var r92 = new Error("Promise was rejected with a falsy value");
    r92.reason = e92, e92 = r92;
  }
  return t82(e92);
}
function dew4() {
  if (_dewExec4)
    return exports4;
  _dewExec4 = true;
  var process22 = exports4 = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e92) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e92) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e92) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e102) {
        return cachedSetTimeout.call(this || _global2, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e92) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e102) {
        return cachedClearTimeout.call(this || _global2, marker);
      }
    }
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  process22.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i72 = 1; i72 < arguments.length; i72++) {
        args[i72 - 1] = arguments[i72];
      }
    }
    queue.push(new Item2(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  };
  function Item2(fun, array) {
    (this || _global2).fun = fun;
    (this || _global2).array = array;
  }
  Item2.prototype.run = function() {
    (this || _global2).fun.apply(null, (this || _global2).array);
  };
  process22.title = "browser";
  process22.browser = true;
  process22.env = {};
  process22.argv = [];
  process22.version = "";
  process22.versions = {};
  function noop() {
  }
  process22.on = noop;
  process22.addListener = noop;
  process22.once = noop;
  process22.off = noop;
  process22.removeListener = noop;
  process22.removeAllListeners = noop;
  process22.emit = noop;
  process22.prependListener = noop;
  process22.prependOnceListener = noop;
  process22.listeners = function(name2) {
    return [];
  };
  process22.binding = function(name2) {
    throw new Error("process.binding is not supported");
  };
  process22.cwd = function() {
    return "/";
  };
  process22.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process22.umask = function() {
    return 0;
  };
  return exports4;
}
function u$2(r92) {
  var t82 = r92.length;
  if (t82 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var e92 = r92.indexOf("=");
  return -1 === e92 && (e92 = t82), [e92, e92 === t82 ? 0 : 4 - e92 % 4];
}
function c$12(r92, e92, n82) {
  for (var o82, a72, h82 = [], u72 = e92; u72 < n82; u72 += 3)
    o82 = (r92[u72] << 16 & 16711680) + (r92[u72 + 1] << 8 & 65280) + (255 & r92[u72 + 2]), h82.push(t$13[(a72 = o82) >> 18 & 63] + t$13[a72 >> 12 & 63] + t$13[a72 >> 6 & 63] + t$13[63 & a72]);
  return h82.join("");
}
function f$2(t82) {
  if (t82 > 2147483647)
    throw new RangeError('The value "' + t82 + '" is invalid for option "size"');
  var r92 = new Uint8Array(t82);
  return Object.setPrototypeOf(r92, u$1$1.prototype), r92;
}
function u$1$1(t82, r92, e92) {
  if ("number" == typeof t82) {
    if ("string" == typeof r92)
      throw new TypeError('The "string" argument must be of type string. Received type number');
    return a$2(t82);
  }
  return s$1(t82, r92, e92);
}
function s$1(t82, r92, e92) {
  if ("string" == typeof t82)
    return function(t92, r102) {
      "string" == typeof r102 && "" !== r102 || (r102 = "utf8");
      if (!u$1$1.isEncoding(r102))
        throw new TypeError("Unknown encoding: " + r102);
      var e102 = 0 | y3(t92, r102), n92 = f$2(e102), i82 = n92.write(t92, r102);
      i82 !== e102 && (n92 = n92.slice(0, i82));
      return n92;
    }(t82, r92);
  if (ArrayBuffer.isView(t82))
    return p4(t82);
  if (null == t82)
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t82);
  if (F2(t82, ArrayBuffer) || t82 && F2(t82.buffer, ArrayBuffer))
    return c$1$1(t82, r92, e92);
  if ("undefined" != typeof SharedArrayBuffer && (F2(t82, SharedArrayBuffer) || t82 && F2(t82.buffer, SharedArrayBuffer)))
    return c$1$1(t82, r92, e92);
  if ("number" == typeof t82)
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  var n82 = t82.valueOf && t82.valueOf();
  if (null != n82 && n82 !== t82)
    return u$1$1.from(n82, r92, e92);
  var i72 = function(t92) {
    if (u$1$1.isBuffer(t92)) {
      var r102 = 0 | l$12(t92.length), e102 = f$2(r102);
      return 0 === e102.length || t92.copy(e102, 0, 0, r102), e102;
    }
    if (void 0 !== t92.length)
      return "number" != typeof t92.length || N2(t92.length) ? f$2(0) : p4(t92);
    if ("Buffer" === t92.type && Array.isArray(t92.data))
      return p4(t92.data);
  }(t82);
  if (i72)
    return i72;
  if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t82[Symbol.toPrimitive])
    return u$1$1.from(t82[Symbol.toPrimitive]("string"), r92, e92);
  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t82);
}
function h$1$1(t82) {
  if ("number" != typeof t82)
    throw new TypeError('"size" argument must be of type number');
  if (t82 < 0)
    throw new RangeError('The value "' + t82 + '" is invalid for option "size"');
}
function a$2(t82) {
  return h$1$1(t82), f$2(t82 < 0 ? 0 : 0 | l$12(t82));
}
function p4(t82) {
  for (var r92 = t82.length < 0 ? 0 : 0 | l$12(t82.length), e92 = f$2(r92), n82 = 0; n82 < r92; n82 += 1)
    e92[n82] = 255 & t82[n82];
  return e92;
}
function c$1$1(t82, r92, e92) {
  if (r92 < 0 || t82.byteLength < r92)
    throw new RangeError('"offset" is outside of buffer bounds');
  if (t82.byteLength < r92 + (e92 || 0))
    throw new RangeError('"length" is outside of buffer bounds');
  var n82;
  return n82 = void 0 === r92 && void 0 === e92 ? new Uint8Array(t82) : void 0 === e92 ? new Uint8Array(t82, r92) : new Uint8Array(t82, r92, e92), Object.setPrototypeOf(n82, u$1$1.prototype), n82;
}
function l$12(t82) {
  if (t82 >= 2147483647)
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
  return 0 | t82;
}
function y3(t82, r92) {
  if (u$1$1.isBuffer(t82))
    return t82.length;
  if (ArrayBuffer.isView(t82) || F2(t82, ArrayBuffer))
    return t82.byteLength;
  if ("string" != typeof t82)
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t82);
  var e92 = t82.length, n82 = arguments.length > 2 && true === arguments[2];
  if (!n82 && 0 === e92)
    return 0;
  for (var i72 = false; ; )
    switch (r92) {
      case "ascii":
      case "latin1":
      case "binary":
        return e92;
      case "utf8":
      case "utf-8":
        return _2(t82).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * e92;
      case "hex":
        return e92 >>> 1;
      case "base64":
        return z2(t82).length;
      default:
        if (i72)
          return n82 ? -1 : _2(t82).length;
        r92 = ("" + r92).toLowerCase(), i72 = true;
    }
}
function g2(t82, r92, e92) {
  var n82 = false;
  if ((void 0 === r92 || r92 < 0) && (r92 = 0), r92 > this.length)
    return "";
  if ((void 0 === e92 || e92 > this.length) && (e92 = this.length), e92 <= 0)
    return "";
  if ((e92 >>>= 0) <= (r92 >>>= 0))
    return "";
  for (t82 || (t82 = "utf8"); ; )
    switch (t82) {
      case "hex":
        return O2(this, r92, e92);
      case "utf8":
      case "utf-8":
        return I2(this, r92, e92);
      case "ascii":
        return S2(this, r92, e92);
      case "latin1":
      case "binary":
        return R2(this, r92, e92);
      case "base64":
        return T3(this, r92, e92);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return L2(this, r92, e92);
      default:
        if (n82)
          throw new TypeError("Unknown encoding: " + t82);
        t82 = (t82 + "").toLowerCase(), n82 = true;
    }
}
function w2(t82, r92, e92) {
  var n82 = t82[r92];
  t82[r92] = t82[e92], t82[e92] = n82;
}
function d3(t82, r92, e92, n82, i72) {
  if (0 === t82.length)
    return -1;
  if ("string" == typeof e92 ? (n82 = e92, e92 = 0) : e92 > 2147483647 ? e92 = 2147483647 : e92 < -2147483648 && (e92 = -2147483648), N2(e92 = +e92) && (e92 = i72 ? 0 : t82.length - 1), e92 < 0 && (e92 = t82.length + e92), e92 >= t82.length) {
    if (i72)
      return -1;
    e92 = t82.length - 1;
  } else if (e92 < 0) {
    if (!i72)
      return -1;
    e92 = 0;
  }
  if ("string" == typeof r92 && (r92 = u$1$1.from(r92, n82)), u$1$1.isBuffer(r92))
    return 0 === r92.length ? -1 : v3(t82, r92, e92, n82, i72);
  if ("number" == typeof r92)
    return r92 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i72 ? Uint8Array.prototype.indexOf.call(t82, r92, e92) : Uint8Array.prototype.lastIndexOf.call(t82, r92, e92) : v3(t82, [r92], e92, n82, i72);
  throw new TypeError("val must be string, number or Buffer");
}
function v3(t82, r92, e92, n82, i72) {
  var o82, f72 = 1, u72 = t82.length, s62 = r92.length;
  if (void 0 !== n82 && ("ucs2" === (n82 = String(n82).toLowerCase()) || "ucs-2" === n82 || "utf16le" === n82 || "utf-16le" === n82)) {
    if (t82.length < 2 || r92.length < 2)
      return -1;
    f72 = 2, u72 /= 2, s62 /= 2, e92 /= 2;
  }
  function h82(t92, r102) {
    return 1 === f72 ? t92[r102] : t92.readUInt16BE(r102 * f72);
  }
  if (i72) {
    var a72 = -1;
    for (o82 = e92; o82 < u72; o82++)
      if (h82(t82, o82) === h82(r92, -1 === a72 ? 0 : o82 - a72)) {
        if (-1 === a72 && (a72 = o82), o82 - a72 + 1 === s62)
          return a72 * f72;
      } else
        -1 !== a72 && (o82 -= o82 - a72), a72 = -1;
  } else
    for (e92 + s62 > u72 && (e92 = u72 - s62), o82 = e92; o82 >= 0; o82--) {
      for (var p72 = true, c72 = 0; c72 < s62; c72++)
        if (h82(t82, o82 + c72) !== h82(r92, c72)) {
          p72 = false;
          break;
        }
      if (p72)
        return o82;
    }
  return -1;
}
function b2(t82, r92, e92, n82) {
  e92 = Number(e92) || 0;
  var i72 = t82.length - e92;
  n82 ? (n82 = Number(n82)) > i72 && (n82 = i72) : n82 = i72;
  var o82 = r92.length;
  n82 > o82 / 2 && (n82 = o82 / 2);
  for (var f72 = 0; f72 < n82; ++f72) {
    var u72 = parseInt(r92.substr(2 * f72, 2), 16);
    if (N2(u72))
      return f72;
    t82[e92 + f72] = u72;
  }
  return f72;
}
function m3(t82, r92, e92, n82) {
  return D2(_2(r92, t82.length - e92), t82, e92, n82);
}
function E2(t82, r92, e92, n82) {
  return D2(function(t92) {
    for (var r102 = [], e102 = 0; e102 < t92.length; ++e102)
      r102.push(255 & t92.charCodeAt(e102));
    return r102;
  }(r92), t82, e92, n82);
}
function B2(t82, r92, e92, n82) {
  return E2(t82, r92, e92, n82);
}
function A2(t82, r92, e92, n82) {
  return D2(z2(r92), t82, e92, n82);
}
function U2(t82, r92, e92, n82) {
  return D2(function(t92, r102) {
    for (var e102, n92, i72, o82 = [], f72 = 0; f72 < t92.length && !((r102 -= 2) < 0); ++f72)
      e102 = t92.charCodeAt(f72), n92 = e102 >> 8, i72 = e102 % 256, o82.push(i72), o82.push(n92);
    return o82;
  }(r92, t82.length - e92), t82, e92, n82);
}
function T3(t82, r92, e92) {
  return 0 === r92 && e92 === t82.length ? n$1$1.fromByteArray(t82) : n$1$1.fromByteArray(t82.slice(r92, e92));
}
function I2(t82, r92, e92) {
  e92 = Math.min(t82.length, e92);
  for (var n82 = [], i72 = r92; i72 < e92; ) {
    var o82, f72, u72, s62, h82 = t82[i72], a72 = null, p72 = h82 > 239 ? 4 : h82 > 223 ? 3 : h82 > 191 ? 2 : 1;
    if (i72 + p72 <= e92)
      switch (p72) {
        case 1:
          h82 < 128 && (a72 = h82);
          break;
        case 2:
          128 == (192 & (o82 = t82[i72 + 1])) && (s62 = (31 & h82) << 6 | 63 & o82) > 127 && (a72 = s62);
          break;
        case 3:
          o82 = t82[i72 + 1], f72 = t82[i72 + 2], 128 == (192 & o82) && 128 == (192 & f72) && (s62 = (15 & h82) << 12 | (63 & o82) << 6 | 63 & f72) > 2047 && (s62 < 55296 || s62 > 57343) && (a72 = s62);
          break;
        case 4:
          o82 = t82[i72 + 1], f72 = t82[i72 + 2], u72 = t82[i72 + 3], 128 == (192 & o82) && 128 == (192 & f72) && 128 == (192 & u72) && (s62 = (15 & h82) << 18 | (63 & o82) << 12 | (63 & f72) << 6 | 63 & u72) > 65535 && s62 < 1114112 && (a72 = s62);
      }
    null === a72 ? (a72 = 65533, p72 = 1) : a72 > 65535 && (a72 -= 65536, n82.push(a72 >>> 10 & 1023 | 55296), a72 = 56320 | 1023 & a72), n82.push(a72), i72 += p72;
  }
  return function(t92) {
    var r102 = t92.length;
    if (r102 <= 4096)
      return String.fromCharCode.apply(String, t92);
    var e102 = "", n92 = 0;
    for (; n92 < r102; )
      e102 += String.fromCharCode.apply(String, t92.slice(n92, n92 += 4096));
    return e102;
  }(n82);
}
function S2(t82, r92, e92) {
  var n82 = "";
  e92 = Math.min(t82.length, e92);
  for (var i72 = r92; i72 < e92; ++i72)
    n82 += String.fromCharCode(127 & t82[i72]);
  return n82;
}
function R2(t82, r92, e92) {
  var n82 = "";
  e92 = Math.min(t82.length, e92);
  for (var i72 = r92; i72 < e92; ++i72)
    n82 += String.fromCharCode(t82[i72]);
  return n82;
}
function O2(t82, r92, e92) {
  var n82 = t82.length;
  (!r92 || r92 < 0) && (r92 = 0), (!e92 || e92 < 0 || e92 > n82) && (e92 = n82);
  for (var i72 = "", o82 = r92; o82 < e92; ++o82)
    i72 += Y2[t82[o82]];
  return i72;
}
function L2(t82, r92, e92) {
  for (var n82 = t82.slice(r92, e92), i72 = "", o82 = 0; o82 < n82.length; o82 += 2)
    i72 += String.fromCharCode(n82[o82] + 256 * n82[o82 + 1]);
  return i72;
}
function x2(t82, r92, e92) {
  if (t82 % 1 != 0 || t82 < 0)
    throw new RangeError("offset is not uint");
  if (t82 + r92 > e92)
    throw new RangeError("Trying to access beyond buffer length");
}
function C2(t82, r92, e92, n82, i72, o82) {
  if (!u$1$1.isBuffer(t82))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (r92 > i72 || r92 < o82)
    throw new RangeError('"value" argument is out of bounds');
  if (e92 + n82 > t82.length)
    throw new RangeError("Index out of range");
}
function P2(t82, r92, e92, n82, i72, o82) {
  if (e92 + n82 > t82.length)
    throw new RangeError("Index out of range");
  if (e92 < 0)
    throw new RangeError("Index out of range");
}
function k2(t82, r92, e92, n82, o82) {
  return r92 = +r92, e92 >>>= 0, o82 || P2(t82, 0, e92, 4), i$12.write(t82, r92, e92, n82, 23, 4), e92 + 4;
}
function M2(t82, r92, e92, n82, o82) {
  return r92 = +r92, e92 >>>= 0, o82 || P2(t82, 0, e92, 8), i$12.write(t82, r92, e92, n82, 52, 8), e92 + 8;
}
function _2(t82, r92) {
  var e92;
  r92 = r92 || 1 / 0;
  for (var n82 = t82.length, i72 = null, o82 = [], f72 = 0; f72 < n82; ++f72) {
    if ((e92 = t82.charCodeAt(f72)) > 55295 && e92 < 57344) {
      if (!i72) {
        if (e92 > 56319) {
          (r92 -= 3) > -1 && o82.push(239, 191, 189);
          continue;
        }
        if (f72 + 1 === n82) {
          (r92 -= 3) > -1 && o82.push(239, 191, 189);
          continue;
        }
        i72 = e92;
        continue;
      }
      if (e92 < 56320) {
        (r92 -= 3) > -1 && o82.push(239, 191, 189), i72 = e92;
        continue;
      }
      e92 = 65536 + (i72 - 55296 << 10 | e92 - 56320);
    } else
      i72 && (r92 -= 3) > -1 && o82.push(239, 191, 189);
    if (i72 = null, e92 < 128) {
      if ((r92 -= 1) < 0)
        break;
      o82.push(e92);
    } else if (e92 < 2048) {
      if ((r92 -= 2) < 0)
        break;
      o82.push(e92 >> 6 | 192, 63 & e92 | 128);
    } else if (e92 < 65536) {
      if ((r92 -= 3) < 0)
        break;
      o82.push(e92 >> 12 | 224, e92 >> 6 & 63 | 128, 63 & e92 | 128);
    } else {
      if (!(e92 < 1114112))
        throw new Error("Invalid code point");
      if ((r92 -= 4) < 0)
        break;
      o82.push(e92 >> 18 | 240, e92 >> 12 & 63 | 128, e92 >> 6 & 63 | 128, 63 & e92 | 128);
    }
  }
  return o82;
}
function z2(t82) {
  return n$1$1.toByteArray(function(t92) {
    if ((t92 = (t92 = t92.split("=")[0]).trim().replace(j2, "")).length < 2)
      return "";
    for (; t92.length % 4 != 0; )
      t92 += "=";
    return t92;
  }(t82));
}
function D2(t82, r92, e92, n82) {
  for (var i72 = 0; i72 < n82 && !(i72 + e92 >= r92.length || i72 >= t82.length); ++i72)
    r92[i72 + e92] = t82[i72];
  return i72;
}
function F2(t82, r92) {
  return t82 instanceof r92 || null != t82 && null != t82.constructor && null != t82.constructor.name && t82.constructor.name === r92.name;
}
function N2(t82) {
  return t82 != t82;
}
function t4(r92, e92) {
  for (var n82 in r92)
    e92[n82] = r92[n82];
}
function f4(r92, e92, n82) {
  return o4(r92, e92, n82);
}
function a4(t82) {
  var e92;
  switch (this.encoding = function(t92) {
    var e102 = function(t102) {
      if (!t102)
        return "utf8";
      for (var e112; ; )
        switch (t102) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return t102;
          default:
            if (e112)
              return;
            t102 = ("" + t102).toLowerCase(), e112 = true;
        }
    }(t92);
    if ("string" != typeof e102 && (s4.isEncoding === i4 || !i4(t92)))
      throw new Error("Unknown encoding: " + t92);
    return e102 || t92;
  }(t82), this.encoding) {
    case "utf16le":
      this.text = h4, this.end = l4, e92 = 4;
      break;
    case "utf8":
      this.fillLast = n$12, e92 = 4;
      break;
    case "base64":
      this.text = u$12, this.end = o$12, e92 = 3;
      break;
    default:
      return this.write = f$1, this.end = c4, void 0;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = s4.allocUnsafe(e92);
}
function r4(t82) {
  return t82 <= 127 ? 0 : t82 >> 5 == 6 ? 2 : t82 >> 4 == 14 ? 3 : t82 >> 3 == 30 ? 4 : t82 >> 6 == 2 ? -1 : -2;
}
function n$12(t82) {
  var e92 = this.lastTotal - this.lastNeed, s62 = function(t92, e102, s72) {
    if (128 != (192 & e102[0]))
      return t92.lastNeed = 0, "\uFFFD";
    if (t92.lastNeed > 1 && e102.length > 1) {
      if (128 != (192 & e102[1]))
        return t92.lastNeed = 1, "\uFFFD";
      if (t92.lastNeed > 2 && e102.length > 2 && 128 != (192 & e102[2]))
        return t92.lastNeed = 2, "\uFFFD";
    }
  }(this, t82);
  return void 0 !== s62 ? s62 : this.lastNeed <= t82.length ? (t82.copy(this.lastChar, e92, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t82.copy(this.lastChar, e92, 0, t82.length), this.lastNeed -= t82.length, void 0);
}
function h4(t82, e92) {
  if ((t82.length - e92) % 2 == 0) {
    var s62 = t82.toString("utf16le", e92);
    if (s62) {
      var i72 = s62.charCodeAt(s62.length - 1);
      if (i72 >= 55296 && i72 <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t82[t82.length - 2], this.lastChar[1] = t82[t82.length - 1], s62.slice(0, -1);
    }
    return s62;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t82[t82.length - 1], t82.toString("utf16le", e92, t82.length - 1);
}
function l4(t82) {
  var e92 = t82 && t82.length ? this.write(t82) : "";
  if (this.lastNeed) {
    var s62 = this.lastTotal - this.lastNeed;
    return e92 + this.lastChar.toString("utf16le", 0, s62);
  }
  return e92;
}
function u$12(t82, e92) {
  var s62 = (t82.length - e92) % 3;
  return 0 === s62 ? t82.toString("base64", e92) : (this.lastNeed = 3 - s62, this.lastTotal = 3, 1 === s62 ? this.lastChar[0] = t82[t82.length - 1] : (this.lastChar[0] = t82[t82.length - 2], this.lastChar[1] = t82[t82.length - 1]), t82.toString("base64", e92, t82.length - s62));
}
function o$12(t82) {
  var e92 = t82 && t82.length ? this.write(t82) : "";
  return this.lastNeed ? e92 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e92;
}
function f$1(t82) {
  return t82.toString(this.encoding);
}
function c4(t82) {
  return t82 && t82.length ? this.write(t82) : "";
}
function dew$2$1() {
  if (_dewExec$2$1)
    return exports$2$1;
  _dewExec$2$1 = true;
  exports$2$1.byteLength = byteLength;
  exports$2$1.toByteArray = toByteArray;
  exports$2$1.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i72 = 0, len = code.length; i72 < len; ++i72) {
    lookup[i72] = code[i72];
    revLookup[code.charCodeAt(i72)] = i72;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i82;
    for (i82 = 0; i82 < len2; i82 += 4) {
      tmp = revLookup[b64.charCodeAt(i82)] << 18 | revLookup[b64.charCodeAt(i82 + 1)] << 12 | revLookup[b64.charCodeAt(i82 + 2)] << 6 | revLookup[b64.charCodeAt(i82 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i82)] << 2 | revLookup[b64.charCodeAt(i82 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i82)] << 10 | revLookup[b64.charCodeAt(i82 + 1)] << 4 | revLookup[b64.charCodeAt(i82 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i82 = start; i82 < end; i82 += 3) {
      tmp = (uint8[i82] << 16 & 16711680) + (uint8[i82 + 1] << 8 & 65280) + (uint8[i82 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i82 = 0, len22 = len2 - extraBytes; i82 < len22; i82 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i82, i82 + maxChunkLength > len22 ? len22 : i82 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  return exports$2$1;
}
function dew$1$1() {
  if (_dewExec$1$1)
    return exports$1$1;
  _dewExec$1$1 = true;
  exports$1$1.read = function(buffer22, offset, isLE, mLen, nBytes) {
    var e92, m62;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i72 = isLE ? nBytes - 1 : 0;
    var d62 = isLE ? -1 : 1;
    var s62 = buffer22[offset + i72];
    i72 += d62;
    e92 = s62 & (1 << -nBits) - 1;
    s62 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e92 = e92 * 256 + buffer22[offset + i72], i72 += d62, nBits -= 8) {
    }
    m62 = e92 & (1 << -nBits) - 1;
    e92 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m62 = m62 * 256 + buffer22[offset + i72], i72 += d62, nBits -= 8) {
    }
    if (e92 === 0) {
      e92 = 1 - eBias;
    } else if (e92 === eMax) {
      return m62 ? NaN : (s62 ? -1 : 1) * Infinity;
    } else {
      m62 = m62 + Math.pow(2, mLen);
      e92 = e92 - eBias;
    }
    return (s62 ? -1 : 1) * m62 * Math.pow(2, e92 - mLen);
  };
  exports$1$1.write = function(buffer22, value, offset, isLE, mLen, nBytes) {
    var e92, m62, c72;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i72 = isLE ? 0 : nBytes - 1;
    var d62 = isLE ? 1 : -1;
    var s62 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m62 = isNaN(value) ? 1 : 0;
      e92 = eMax;
    } else {
      e92 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c72 = Math.pow(2, -e92)) < 1) {
        e92--;
        c72 *= 2;
      }
      if (e92 + eBias >= 1) {
        value += rt / c72;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c72 >= 2) {
        e92++;
        c72 /= 2;
      }
      if (e92 + eBias >= eMax) {
        m62 = 0;
        e92 = eMax;
      } else if (e92 + eBias >= 1) {
        m62 = (value * c72 - 1) * Math.pow(2, mLen);
        e92 = e92 + eBias;
      } else {
        m62 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e92 = 0;
      }
    }
    for (; mLen >= 8; buffer22[offset + i72] = m62 & 255, i72 += d62, m62 /= 256, mLen -= 8) {
    }
    e92 = e92 << mLen | m62;
    eLen += mLen;
    for (; eLen > 0; buffer22[offset + i72] = e92 & 255, i72 += d62, e92 /= 256, eLen -= 8) {
    }
    buffer22[offset + i72 - d62] |= s62 * 128;
  };
  return exports$1$1;
}
function dew$g() {
  if (_dewExec$g)
    return exports$g;
  _dewExec$g = true;
  const base64 = dew$2$1();
  const ieee754 = dew$1$1();
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$g.Buffer = Buffer22;
  exports$g.SlowBuffer = SlowBuffer;
  exports$g.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$g.kMaxLength = K_MAX_LENGTH;
  Buffer22.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer22.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e92) {
      return false;
    }
  }
  Object.defineProperty(Buffer22.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer22.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer22.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer22.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer22.prototype);
    return buf;
  }
  function Buffer22(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer22.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer22.from(valueOf, encodingOrOffset, length);
    }
    const b52 = fromObject(value);
    if (b52)
      return b52;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer22.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer22.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer22.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer22, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer22.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer22.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer22.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer22.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i72 = 0; i72 < length; i72 += 1) {
      buf[i72] = array[i72] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer22.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer22.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer22.alloc(+length);
  }
  Buffer22.isBuffer = function isBuffer32(b52) {
    return b52 != null && b52._isBuffer === true && b52 !== Buffer22.prototype;
  };
  Buffer22.compare = function compare(a72, b52) {
    if (isInstance(a72, Uint8Array))
      a72 = Buffer22.from(a72, a72.offset, a72.byteLength);
    if (isInstance(b52, Uint8Array))
      b52 = Buffer22.from(b52, b52.offset, b52.byteLength);
    if (!Buffer22.isBuffer(a72) || !Buffer22.isBuffer(b52)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a72 === b52)
      return 0;
    let x42 = a72.length;
    let y62 = b52.length;
    for (let i72 = 0, len = Math.min(x42, y62); i72 < len; ++i72) {
      if (a72[i72] !== b52[i72]) {
        x42 = a72[i72];
        y62 = b52[i72];
        break;
      }
    }
    if (x42 < y62)
      return -1;
    if (y62 < x42)
      return 1;
    return 0;
  };
  Buffer22.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer22.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer22.alloc(0);
    }
    let i72;
    if (length === void 0) {
      length = 0;
      for (i72 = 0; i72 < list.length; ++i72) {
        length += list[i72].length;
      }
    }
    const buffer22 = Buffer22.allocUnsafe(length);
    let pos = 0;
    for (i72 = 0; i72 < list.length; ++i72) {
      let buf = list[i72];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer22.length) {
          if (!Buffer22.isBuffer(buf))
            buf = Buffer22.from(buf);
          buf.copy(buffer22, pos);
        } else {
          Uint8Array.prototype.set.call(buffer22, buf, pos);
        }
      } else if (!Buffer22.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer22, pos);
      }
      pos += buf.length;
    }
    return buffer22;
  };
  function byteLength(string, encoding) {
    if (Buffer22.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer22.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer22.prototype._isBuffer = true;
  function swap(b52, n82, m62) {
    const i72 = b52[n82];
    b52[n82] = b52[m62];
    b52[m62] = i72;
  }
  Buffer22.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i72 = 0; i72 < len; i72 += 2) {
      swap(this, i72, i72 + 1);
    }
    return this;
  };
  Buffer22.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i72 = 0; i72 < len; i72 += 4) {
      swap(this, i72, i72 + 3);
      swap(this, i72 + 1, i72 + 2);
    }
    return this;
  };
  Buffer22.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i72 = 0; i72 < len; i72 += 8) {
      swap(this, i72, i72 + 7);
      swap(this, i72 + 1, i72 + 6);
      swap(this, i72 + 2, i72 + 5);
      swap(this, i72 + 3, i72 + 4);
    }
    return this;
  };
  Buffer22.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer22.prototype.toLocaleString = Buffer22.prototype.toString;
  Buffer22.prototype.equals = function equals(b52) {
    if (!Buffer22.isBuffer(b52))
      throw new TypeError("Argument must be a Buffer");
    if (this === b52)
      return true;
    return Buffer22.compare(this, b52) === 0;
  };
  Buffer22.prototype.inspect = function inspect32() {
    let str = "";
    const max = exports$g.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer22.prototype[customInspectSymbol] = Buffer22.prototype.inspect;
  }
  Buffer22.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer22.from(target, target.offset, target.byteLength);
    }
    if (!Buffer22.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x42 = thisEnd - thisStart;
    let y62 = end - start;
    const len = Math.min(x42, y62);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i72 = 0; i72 < len; ++i72) {
      if (thisCopy[i72] !== targetCopy[i72]) {
        x42 = thisCopy[i72];
        y62 = targetCopy[i72];
        break;
      }
    }
    if (x42 < y62)
      return -1;
    if (y62 < x42)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer22, val, byteOffset, encoding, dir) {
    if (buffer22.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer22.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer22.length + byteOffset;
    if (byteOffset >= buffer22.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer22.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer22.from(val, encoding);
    }
    if (Buffer22.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer22, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer22, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer22, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer22, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i82) {
      if (indexSize === 1) {
        return buf[i82];
      } else {
        return buf.readUInt16BE(i82 * indexSize);
      }
    }
    let i72;
    if (dir) {
      let foundIndex = -1;
      for (i72 = byteOffset; i72 < arrLength; i72++) {
        if (read2(arr, i72) === read2(val, foundIndex === -1 ? 0 : i72 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i72;
          if (i72 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i72 -= i72 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i72 = byteOffset; i72 >= 0; i72--) {
        let found = true;
        for (let j42 = 0; j42 < valLength; j42++) {
          if (read2(arr, i72 + j42) !== read2(val, j42)) {
            found = false;
            break;
          }
        }
        if (found)
          return i72;
      }
    }
    return -1;
  }
  Buffer22.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer22.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer22.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i72;
    for (i72 = 0; i72 < length; ++i72) {
      const parsed = parseInt(string.substr(i72 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i72;
      buf[offset + i72] = parsed;
    }
    return i72;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer22.prototype.write = function write2(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer22.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i72 = start;
    while (i72 < end) {
      const firstByte = buf[i72];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i72 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i72 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i72 + 1];
            thirdByte = buf[i72 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i72 + 1];
            thirdByte = buf[i72 + 2];
            fourthByte = buf[i72 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i72 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i72 = 0;
    while (i72 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i72, i72 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i72 = start; i72 < end; ++i72) {
      ret += String.fromCharCode(buf[i72] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i72 = start; i72 < end; ++i72) {
      ret += String.fromCharCode(buf[i72]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i72 = start; i72 < end; ++i72) {
      out += hexSliceLookupTable[buf[i72]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i72 = 0; i72 < bytes.length - 1; i72 += 2) {
      res += String.fromCharCode(bytes[i72] + bytes[i72 + 1] * 256);
    }
    return res;
  }
  Buffer22.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer22.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer22.prototype.readUintLE = Buffer22.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i72 = 0;
    while (++i72 < byteLength2 && (mul *= 256)) {
      val += this[offset + i72] * mul;
    }
    return val;
  };
  Buffer22.prototype.readUintBE = Buffer22.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    let val = this[offset + --byteLength2];
    let mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer22.prototype.readUint8 = Buffer22.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer22.prototype.readUint16LE = Buffer22.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer22.prototype.readUint16BE = Buffer22.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer22.prototype.readUint32LE = Buffer22.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer22.prototype.readUint32BE = Buffer22.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer22.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer22.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer22.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i72 = 0;
    while (++i72 < byteLength2 && (mul *= 256)) {
      val += this[offset + i72] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer22.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let i72 = byteLength2;
    let mul = 1;
    let val = this[offset + --i72];
    while (i72 > 0 && (mul *= 256)) {
      val += this[offset + --i72] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer22.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer22.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer22.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer22.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer22.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer22.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer22.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer22.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer22.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer22.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer22.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer22.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer22.prototype.writeUintLE = Buffer22.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1;
    let i72 = 0;
    this[offset] = value & 255;
    while (++i72 < byteLength2 && (mul *= 256)) {
      this[offset + i72] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer22.prototype.writeUintBE = Buffer22.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i72 = byteLength2 - 1;
    let mul = 1;
    this[offset + i72] = value & 255;
    while (--i72 >= 0 && (mul *= 256)) {
      this[offset + i72] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer22.prototype.writeUint8 = Buffer22.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer22.prototype.writeUint16LE = Buffer22.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer22.prototype.writeUint16BE = Buffer22.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer22.prototype.writeUint32LE = Buffer22.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer22.prototype.writeUint32BE = Buffer22.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer22.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer22.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer22.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i72 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i72 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i72 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i72] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer22.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i72 = byteLength2 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i72] = value & 255;
    while (--i72 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i72 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i72] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer22.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer22.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer22.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer22.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer22.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer22.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer22.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer22.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer22.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer22.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer22.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer22.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer22.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer22.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer22.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code = val.charCodeAt(0);
        if (encoding === "utf8" && code < 128 || encoding === "latin1") {
          val = code;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i72;
    if (typeof val === "number") {
      for (i72 = start; i72 < end; ++i72) {
        this[i72] = val;
      }
    } else {
      const bytes = Buffer22.isBuffer(val) ? val : Buffer22.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i72 = 0; i72 < end - start; ++i72) {
        this[i72 + start] = bytes[i72 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E42(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E42("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
    if (name2) {
      return `${name2} is outside of buffer bounds`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E42("ERR_INVALID_ARG_TYPE", function(name2, actual) {
    return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  E42("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i72 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i72 >= start + 4; i72 -= 3) {
      res = `_${val.slice(i72 - 3, i72)}${res}`;
    }
    return `${val.slice(0, i72)}${res}`;
  }
  function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
      boundsError(offset, buf.length - (byteLength2 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
      const n82 = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength2 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n82} and < 2${n82} ** ${(byteLength2 + 1) * 8}${n82}`;
        } else {
          range = `>= -(2${n82} ** ${(byteLength2 + 1) * 8 - 1}${n82}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n82}`;
        }
      } else {
        range = `>= ${min}${n82} and <= ${max}${n82}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", `>= ${type2 ? 1 : 0} and <= ${length}`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i72 = 0; i72 < length; ++i72) {
      codePoint = string.charCodeAt(i72);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i72 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i72 = 0; i72 < str.length; ++i72) {
      byteArray.push(str.charCodeAt(i72) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c72, hi, lo;
    const byteArray = [];
    for (let i72 = 0; i72 < str.length; ++i72) {
      if ((units -= 2) < 0)
        break;
      c72 = str.charCodeAt(i72);
      hi = c72 >> 8;
      lo = c72 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i72;
    for (i72 = 0; i72 < length; ++i72) {
      if (i72 + offset >= dst.length || i72 >= src.length)
        break;
      dst[i72 + offset] = src[i72];
    }
    return i72;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i72 = 0; i72 < 16; ++i72) {
      const i16 = i72 * 16;
      for (let j42 = 0; j42 < 16; ++j42) {
        table[i16 + j42] = alphabet[i72] + alphabet[j42];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
  return exports$g;
}
function dew$f() {
  if (_dewExec$f)
    return exports$f;
  _dewExec$f = true;
  if (typeof Object.create === "function") {
    exports$f = function inherits32(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    exports$f = function inherits32(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return exports$f;
}
function dew$e() {
  if (_dewExec$e)
    return exports$e;
  _dewExec$e = true;
  exports$e = y.EventEmitter;
  return exports$e;
}
function dew$d() {
  if (_dewExec$d)
    return exports$d;
  _dewExec$d = true;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i72 = 1; i72 < arguments.length; i72++) {
      var source = arguments[i72] != null ? arguments[i72] : {};
      if (i72 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i72 = 0; i72 < props.length; i72++) {
      var descriptor = props[i72];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var _require = buffer, Buffer22 = _require.Buffer;
  var _require2 = X, inspect32 = _require2.inspect;
  var custom = inspect32 && inspect32.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer22.prototype.copy.call(src, target, offset);
  }
  exports$d = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v62) {
        var entry = {
          data: v62,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v62) {
        var entry = {
          data: v62,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join22(s62) {
        if (this.length === 0)
          return "";
        var p72 = this.head;
        var ret = "" + p72.data;
        while (p72 = p72.next) {
          ret += s62 + p72.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n82) {
        if (this.length === 0)
          return Buffer22.alloc(0);
        var ret = Buffer22.allocUnsafe(n82 >>> 0);
        var p72 = this.head;
        var i72 = 0;
        while (p72) {
          copyBuffer(p72.data, ret, i72);
          i72 += p72.data.length;
          p72 = p72.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n82, hasStrings) {
        var ret;
        if (n82 < this.head.data.length) {
          ret = this.head.data.slice(0, n82);
          this.head.data = this.head.data.slice(n82);
        } else if (n82 === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n82) : this._getBuffer(n82);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n82) {
        var p72 = this.head;
        var c72 = 1;
        var ret = p72.data;
        n82 -= ret.length;
        while (p72 = p72.next) {
          var str = p72.data;
          var nb = n82 > str.length ? str.length : n82;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n82);
          n82 -= nb;
          if (n82 === 0) {
            if (nb === str.length) {
              ++c72;
              if (p72.next)
                this.head = p72.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p72;
              p72.data = str.slice(nb);
            }
            break;
          }
          ++c72;
        }
        this.length -= c72;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n82) {
        var ret = Buffer22.allocUnsafe(n82);
        var p72 = this.head;
        var c72 = 1;
        p72.data.copy(ret);
        n82 -= p72.data.length;
        while (p72 = p72.next) {
          var buf = p72.data;
          var nb = n82 > buf.length ? buf.length : n82;
          buf.copy(ret, ret.length - n82, 0, nb);
          n82 -= nb;
          if (n82 === 0) {
            if (nb === buf.length) {
              ++c72;
              if (p72.next)
                this.head = p72.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p72;
              p72.data = buf.slice(nb);
            }
            break;
          }
          ++c72;
        }
        this.length -= c72;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_42, options) {
        return inspect32(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
  return exports$d;
}
function dew$c() {
  if (_dewExec$c)
    return exports$c;
  _dewExec$c = true;
  var process$1 = process3;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process$1.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process$1.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream.destroy(err);
    else
      stream.emit("error", err);
  }
  exports$c = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return exports$c;
}
function dew$b() {
  if (_dewExec$b)
    return exports$b;
  _dewExec$b = true;
  const codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i72) => String(i72));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
    return 'The value "' + value + '" is invalid for option "' + name2 + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name2, " argument")) {
      msg = `The ${name2} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type2 = includes(name2, ".") ? "property" : "argument";
      msg = `The "${name2}" ${type2} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
    return "The " + name2 + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name2) {
    return "Cannot call " + name2 + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  exports$b.codes = codes;
  return exports$b;
}
function dew$a() {
  if (_dewExec$a)
    return exports$a;
  _dewExec$a = true;
  var ERR_INVALID_OPT_VALUE = dew$b().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name2 = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name2, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  }
  exports$a = {
    getHighWaterMark
  };
  return exports$a;
}
function dew$9() {
  if (_dewExec$9)
    return exports$9;
  _dewExec$9 = true;
  exports$9 = deprecate32;
  function deprecate32(fn, msg) {
    if (config("noDeprecation")) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config("throwDeprecation")) {
          throw new Error(msg);
        } else if (config("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this || _global$2, arguments);
    }
    return deprecated;
  }
  function config(name2) {
    try {
      if (!_global$2.localStorage)
        return false;
    } catch (_42) {
      return false;
    }
    var val = _global$2.localStorage[name2];
    if (null == val)
      return false;
    return String(val).toLowerCase() === "true";
  }
  return exports$9;
}
function dew$8() {
  if (_dewExec$8)
    return exports$8;
  _dewExec$8 = true;
  var process$1 = process3;
  exports$8 = Writable22;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var Duplex22;
  Writable22.WritableState = WritableState;
  var internalUtil = {
    deprecate: dew$9()
  };
  var Stream22 = dew$e();
  var Buffer22 = buffer.Buffer;
  var OurUint8Array = _global$1.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer22.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer22.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = dew$c();
  var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  dew$f()(Writable22, Stream22);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex22 = Duplex22 || dew$7();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex22;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_42) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable22, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable22)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable22(options) {
    Duplex22 = Duplex22 || dew$7();
    var isDuplex = this instanceof Duplex22;
    if (!isDuplex && !realHasInstance.call(Writable22, this))
      return new Writable22(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream22.call(this);
  }
  Writable22.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process$1.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable22.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer22.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable22.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable22.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable22.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable22.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer22.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable22.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev2, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev2)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      process$1.nextTick(cb, er);
      process$1.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished22 = needFinish(state) || stream.destroyed;
      if (!finished22 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        process$1.nextTick(afterWrite, stream, state, finished22, cb);
      } else {
        afterWrite(stream, state, finished22, cb);
      }
    }
  }
  function afterWrite(stream, state, finished22, cb) {
    if (!finished22)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l72 = state.bufferedRequestCount;
      var buffer22 = new Array(l72);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer22[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer22.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer22, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable22.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable22.prototype._writev = null;
  Writable22.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable22.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process$1.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
        if (state.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        process$1.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable22.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable22.prototype.destroy = destroyImpl.destroy;
  Writable22.prototype._undestroy = destroyImpl.undestroy;
  Writable22.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return exports$8;
}
function dew$7() {
  if (_dewExec$7)
    return exports$7;
  _dewExec$7 = true;
  var process$1 = process3;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  exports$7 = Duplex22;
  var Readable22 = dew$3();
  var Writable22 = dew$8();
  dew$f()(Duplex22, Readable22);
  {
    var keys = objectKeys(Writable22.prototype);
    for (var v62 = 0; v62 < keys.length; v62++) {
      var method = keys[v62];
      if (!Duplex22.prototype[method])
        Duplex22.prototype[method] = Writable22.prototype[method];
    }
  }
  function Duplex22(options) {
    if (!(this instanceof Duplex22))
      return new Duplex22(options);
    Readable22.call(this, options);
    Writable22.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex22.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex22.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex22.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process$1.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex22.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return exports$7;
}
function dew$6() {
  if (_dewExec$6)
    return exports$6;
  _dewExec$6 = true;
  var ERR_STREAM_PREMATURE_CLOSE = dew$b().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once22(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts2, callback) {
    if (typeof opts2 === "function")
      return eos(stream, null, opts2);
    if (!opts2)
      opts2 = {};
    callback = once22(callback || noop);
    var readable = opts2.readable || opts2.readable !== false && stream.readable;
    var writable = opts2.writable || opts2.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable)
        onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts2.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  exports$6 = eos;
  return exports$6;
}
function dew$5() {
  if (_dewExec$5)
    return exports$5;
  _dewExec$5 = true;
  var process$1 = process3;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var finished22 = dew$6();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult2(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve32 = iter[kLastResolve];
    if (resolve32 !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve32(createIterResult2(data, false));
      }
    }
  }
  function onReadable(iter) {
    process$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve32, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve32(createIterResult2(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve32, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult2(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve32, reject) {
          process$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve32(createIterResult2(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult2(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve32, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve32(createIterResult2(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve32, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve32(createIterResult2(data, false));
        } else {
          iterator[kLastResolve] = resolve32;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished22(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve32 = iterator[kLastResolve];
      if (resolve32 !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve32(createIterResult2(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  exports$5 = createReadableStreamAsyncIterator;
  return exports$5;
}
function dew$4() {
  if (_dewExec$4)
    return exports$4;
  _dewExec$4 = true;
  exports$4 = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return exports$4;
}
function dew$3() {
  if (_dewExec$3)
    return exports$3;
  _dewExec$3 = true;
  var process$1 = process3;
  exports$3 = Readable22;
  var Duplex22;
  Readable22.ReadableState = ReadableState;
  y.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream22 = dew$e();
  var Buffer22 = buffer.Buffer;
  var OurUint8Array = _global22.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer22.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer22.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = X;
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList = dew$d();
  var destroyImpl = dew$c();
  var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  dew$f()(Readable22, Stream22);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex22 = Duplex22 || dew$7();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex22;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = e$12.StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable22(options) {
    Duplex22 = Duplex22 || dew$7();
    if (!(this instanceof Readable22))
      return new Readable22(options);
    var isDuplex = this instanceof Duplex22;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream22.call(this);
  }
  Object.defineProperty(Readable22.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable22.prototype.destroy = destroyImpl.destroy;
  Readable22.prototype._undestroy = destroyImpl.undestroy;
  Readable22.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable22.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer22.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable22.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer22.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable22.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable22.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = e$12.StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p72 = this._readableState.buffer.head;
    var content = "";
    while (p72 !== null) {
      content += decoder.write(p72.data);
      p72 = p72.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n82) {
    if (n82 >= MAX_HWM) {
      n82 = MAX_HWM;
    } else {
      n82--;
      n82 |= n82 >>> 1;
      n82 |= n82 >>> 2;
      n82 |= n82 >>> 4;
      n82 |= n82 >>> 8;
      n82 |= n82 >>> 16;
      n82++;
    }
    return n82;
  }
  function howMuchToRead(n82, state) {
    if (n82 <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n82 !== n82) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n82 > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n82);
    if (n82 <= state.length)
      return n82;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable22.prototype.read = function(n82) {
    debug("read", n82);
    n82 = parseInt(n82, 10);
    var state = this._readableState;
    var nOrig = n82;
    if (n82 !== 0)
      state.emittedReadable = false;
    if (n82 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n82 = howMuchToRead(n82, state);
    if (n82 === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n82 < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n82 = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n82 > 0)
      ret = fromList(n82, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n82 = 0;
    } else {
      state.length -= n82;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n82 && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process$1.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process$1.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable22.prototype._read = function(n82) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable22.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process$1.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable22.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i72 = 0; i72 < len; i72++) {
        dests[i72].emit("unpipe", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable22.prototype.on = function(ev, fn) {
    var res = Stream22.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process$1.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable22.prototype.addListener = Readable22.prototype.on;
  Readable22.prototype.removeListener = function(ev, fn) {
    var res = Stream22.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable22.prototype.removeAllListeners = function(ev) {
    var res = Stream22.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable22.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process$1.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable22.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
  }
  Readable22.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i72 in stream) {
      if (this[i72] === void 0 && typeof stream[i72] === "function") {
        this[i72] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i72);
      }
    }
    for (var n82 = 0; n82 < kProxyEvents.length; n82++) {
      stream.on(kProxyEvents[n82], this.emit.bind(this, kProxyEvents[n82]));
    }
    this._read = function(n92) {
      debug("wrapped _read", n92);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable22.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = dew$5();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable22.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable22.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable22.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable22._fromList = fromList;
  Object.defineProperty(Readable22.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.length;
    }
  });
  function fromList(n82, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n82 || n82 >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n82, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process$1.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable22.from = function(iterable, opts2) {
      if (from === void 0) {
        from = dew$4();
      }
      return from(Readable22, iterable, opts2);
    };
  }
  function indexOf(xs, x42) {
    for (var i72 = 0, l72 = xs.length; i72 < l72; i72++) {
      if (xs[i72] === x42)
        return i72;
    }
    return -1;
  }
  return exports$3;
}
function dew$2() {
  if (_dewExec$2)
    return exports$2;
  _dewExec$2 = true;
  exports$2 = Transform22;
  var _require$codes = dew$b().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex22 = dew$7();
  dew$f()(Transform22, Duplex22);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform22(options) {
    if (!(this instanceof Transform22))
      return new Transform22(options);
    Duplex22.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform22.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex22.prototype.push.call(this, chunk, encoding);
  };
  Transform22.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform22.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform22.prototype._read = function(n82) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform22.prototype._destroy = function(err, cb) {
    Duplex22.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
  return exports$2;
}
function dew$1() {
  if (_dewExec$1)
    return exports$13;
  _dewExec$1 = true;
  exports$13 = PassThrough22;
  var Transform22 = dew$2();
  dew$f()(PassThrough22, Transform22);
  function PassThrough22(options) {
    if (!(this instanceof PassThrough22))
      return new PassThrough22(options);
    Transform22.call(this, options);
  }
  PassThrough22.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return exports$13;
}
function dew22() {
  if (_dewExec22)
    return exports22;
  _dewExec22 = true;
  var eos;
  function once22(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = dew$b().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop(err) {
    if (err)
      throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once22(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0)
      eos = dew$6();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream))
        return stream.abort();
      if (typeof stream.destroy === "function")
        return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length)
      return noop;
    if (typeof streams[streams.length - 1] !== "function")
      return noop;
    return streams.pop();
  }
  function pipeline22() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i72) {
      var reading = i72 < streams.length - 1;
      var writing = i72 > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  exports22 = pipeline22;
  return exports22;
}
function e5(e92, r92) {
  if (null == e92)
    throw new TypeError("Cannot convert first argument to object");
  for (var t82 = Object(e92), n82 = 1; n82 < arguments.length; n82++) {
    var o82 = arguments[n82];
    if (null != o82)
      for (var a72 = Object.keys(Object(o82)), l72 = 0, i72 = a72.length; l72 < i72; l72++) {
        var c72 = a72[l72], b52 = Object.getOwnPropertyDescriptor(o82, c72);
        void 0 !== b52 && b52.enumerable && (t82[c72] = o82[c72]);
      }
  }
  return t82;
}
function i$5() {
  if (a$6)
    return c$4;
  function e92(t82) {
    return (e92 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t92) {
      return typeof t92;
    } : function(t92) {
      return t92 && "function" == typeof Symbol && t92.constructor === Symbol && t92 !== Symbol.prototype ? "symbol" : typeof t92;
    })(t82);
  }
  function n82(t82, n92) {
    return !n92 || "object" !== e92(n92) && "function" != typeof n92 ? function(t92) {
      if (void 0 === t92)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t92;
    }(t82) : n92;
  }
  function r92(t82) {
    return (r92 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t92) {
      return t92.__proto__ || Object.getPrototypeOf(t92);
    })(t82);
  }
  function o82(t82, e102) {
    return (o82 = Object.setPrototypeOf || function(t92, e112) {
      return t92.__proto__ = e112, t92;
    })(t82, e102);
  }
  a$6 = true;
  var i72, u72, l72 = {};
  function f72(t82, e102, c72) {
    c72 || (c72 = Error);
    var a72 = function(c82) {
      function a82(o92, c92, i82) {
        var u82;
        return !function(t92, e112) {
          if (!(t92 instanceof e112))
            throw new TypeError("Cannot call a class as a function");
        }(this, a82), (u82 = n82(this, r92(a82).call(this, function(t92, n92, r102) {
          return "string" == typeof e102 ? e102 : e102(t92, n92, r102);
        }(o92, c92, i82)))).code = t82, u82;
      }
      return !function(t92, e112) {
        if ("function" != typeof e112 && null !== e112)
          throw new TypeError("Super expression must either be null or a function");
        t92.prototype = Object.create(e112 && e112.prototype, { constructor: { value: t92, writable: true, configurable: true } }), e112 && o82(t92, e112);
      }(a82, c82), a82;
    }(c72);
    l72[t82] = a72;
  }
  function s62(t82, e102) {
    if (Array.isArray(t82)) {
      var n92 = t82.length;
      return t82 = t82.map(function(t92) {
        return String(t92);
      }), n92 > 2 ? "one of ".concat(e102, " ").concat(t82.slice(0, n92 - 1).join(", "), ", or ") + t82[n92 - 1] : 2 === n92 ? "one of ".concat(e102, " ").concat(t82[0], " or ").concat(t82[1]) : "of ".concat(e102, " ").concat(t82[0]);
    }
    return "of ".concat(e102, " ").concat(String(t82));
  }
  return f72("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), f72("ERR_INVALID_ARG_TYPE", function(t82, n92, r102) {
    var o92, c72, u82;
    if (void 0 === i72 && (i72 = tt()), i72("string" == typeof t82, "'name' must be a string"), "string" == typeof n92 && (c72 = "not ", n92.substr(0, c72.length) === c72) ? (o92 = "must not be", n92 = n92.replace(/^not /, "")) : o92 = "must be", function(t92, e102, n102) {
      return (void 0 === n102 || n102 > t92.length) && (n102 = t92.length), t92.substring(n102 - e102.length, n102) === e102;
    }(t82, " argument"))
      u82 = "The ".concat(t82, " ").concat(o92, " ").concat(s62(n92, "type"));
    else {
      var l82 = function(t92, e102, n102) {
        return "number" != typeof n102 && (n102 = 0), !(n102 + e102.length > t92.length) && -1 !== t92.indexOf(e102, n102);
      }(t82, ".") ? "property" : "argument";
      u82 = 'The "'.concat(t82, '" ').concat(l82, " ").concat(o92, " ").concat(s62(n92, "type"));
    }
    return u82 += ". Received type ".concat(e92(r102));
  }, TypeError), f72("ERR_INVALID_ARG_VALUE", function(e102, n92) {
    var r102 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "is invalid";
    void 0 === u72 && (u72 = X);
    var o92 = u72.inspect(n92);
    return o92.length > 128 && (o92 = "".concat(o92.slice(0, 128), "...")), "The argument '".concat(e102, "' ").concat(r102, ". Received ").concat(o92);
  }, TypeError), f72("ERR_INVALID_RETURN_VALUE", function(t82, n92, r102) {
    var o92;
    return o92 = r102 && r102.constructor && r102.constructor.name ? "instance of ".concat(r102.constructor.name) : "type ".concat(e92(r102)), "Expected ".concat(t82, ' to be returned from the "').concat(n92, '"') + " function but got ".concat(o92, ".");
  }, TypeError), f72("ERR_MISSING_ARGS", function() {
    for (var t82 = arguments.length, e102 = new Array(t82), n92 = 0; n92 < t82; n92++)
      e102[n92] = arguments[n92];
    void 0 === i72 && (i72 = tt()), i72(e102.length > 0, "At least one arg needs to be specified");
    var r102 = "The ", o92 = e102.length;
    switch (e102 = e102.map(function(t92) {
      return '"'.concat(t92, '"');
    }), o92) {
      case 1:
        r102 += "".concat(e102[0], " argument");
        break;
      case 2:
        r102 += "".concat(e102[0], " and ").concat(e102[1], " arguments");
        break;
      default:
        r102 += e102.slice(0, o92 - 1).join(", "), r102 += ", and ".concat(e102[o92 - 1], " arguments");
    }
    return "".concat(r102, " must be specified");
  }, TypeError), c$4.codes = l72, c$4;
}
function f$6() {
  if (l$6)
    return u$5;
  l$6 = true;
  var n82 = T;
  function r92(t82, e92, n92) {
    return e92 in t82 ? Object.defineProperty(t82, e92, { value: n92, enumerable: true, configurable: true, writable: true }) : t82[e92] = n92, t82;
  }
  function o82(t82, e92) {
    for (var n92 = 0; n92 < e92.length; n92++) {
      var r102 = e92[n92];
      r102.enumerable = r102.enumerable || false, r102.configurable = true, "value" in r102 && (r102.writable = true), Object.defineProperty(t82, r102.key, r102);
    }
  }
  function c72(t82, e92) {
    return !e92 || "object" !== y62(e92) && "function" != typeof e92 ? a72(t82) : e92;
  }
  function a72(t82) {
    if (void 0 === t82)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t82;
  }
  function f72(t82) {
    var e92 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
    return (f72 = function(t92) {
      if (null === t92 || (n92 = t92, -1 === Function.toString.call(n92).indexOf("[native code]")))
        return t92;
      var n92;
      if ("function" != typeof t92)
        throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== e92) {
        if (e92.has(t92))
          return e92.get(t92);
        e92.set(t92, r102);
      }
      function r102() {
        return p72(t92, arguments, h82(this).constructor);
      }
      return r102.prototype = Object.create(t92.prototype, { constructor: { value: r102, enumerable: false, writable: true, configurable: true } }), g52(r102, t92);
    })(t82);
  }
  function s62() {
    if ("undefined" == typeof Reflect || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if ("function" == typeof Proxy)
      return true;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      })), true;
    } catch (t82) {
      return false;
    }
  }
  function p72(t82, e92, n92) {
    return (p72 = s62() ? Reflect.construct : function(t92, e102, n102) {
      var r102 = [null];
      r102.push.apply(r102, e102);
      var o92 = new (Function.bind.apply(t92, r102))();
      return n102 && g52(o92, n102.prototype), o92;
    }).apply(null, arguments);
  }
  function g52(t82, e92) {
    return (g52 = Object.setPrototypeOf || function(t92, e102) {
      return t92.__proto__ = e102, t92;
    })(t82, e92);
  }
  function h82(t82) {
    return (h82 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t92) {
      return t92.__proto__ || Object.getPrototypeOf(t92);
    })(t82);
  }
  function y62(t82) {
    return (y62 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t92) {
      return typeof t92;
    } : function(t92) {
      return t92 && "function" == typeof Symbol && t92.constructor === Symbol && t92 !== Symbol.prototype ? "symbol" : typeof t92;
    })(t82);
  }
  var b52 = X.inspect, v62 = i$5().codes.ERR_INVALID_ARG_TYPE;
  function d62(t82, e92, n92) {
    return (void 0 === n92 || n92 > t82.length) && (n92 = t82.length), t82.substring(n92 - e92.length, n92) === e92;
  }
  var m62 = "", E42 = "", w42 = "", S42 = "", j42 = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" };
  function O52(t82) {
    var e92 = Object.keys(t82), n92 = Object.create(Object.getPrototypeOf(t82));
    return e92.forEach(function(e102) {
      n92[e102] = t82[e102];
    }), Object.defineProperty(n92, "message", { value: t82.message }), n92;
  }
  function x42(t82) {
    return b52(t82, { compact: false, customInspect: false, depth: 1e3, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
  }
  function q32(t82, e92, r102) {
    var o92 = "", c82 = "", a82 = 0, i72 = "", u72 = false, l72 = x42(t82), f82 = l72.split("\n"), s72 = x42(e92).split("\n"), p82 = 0, g62 = "";
    if ("strictEqual" === r102 && "object" === y62(t82) && "object" === y62(e92) && null !== t82 && null !== e92 && (r102 = "strictEqualObject"), 1 === f82.length && 1 === s72.length && f82[0] !== s72[0]) {
      var h92 = f82[0].length + s72[0].length;
      if (h92 <= 10) {
        if (!("object" === y62(t82) && null !== t82 || "object" === y62(e92) && null !== e92 || 0 === t82 && 0 === e92))
          return "".concat(j42[r102], "\n\n") + "".concat(f82[0], " !== ").concat(s72[0], "\n");
      } else if ("strictEqualObject" !== r102) {
        if (h92 < (n82.stderr && n82.stderr.isTTY ? n82.stderr.columns : 80)) {
          for (; f82[0][p82] === s72[0][p82]; )
            p82++;
          p82 > 2 && (g62 = "\n  ".concat(function(t92, e102) {
            if (e102 = Math.floor(e102), 0 == t92.length || 0 == e102)
              return "";
            var n92 = t92.length * e102;
            for (e102 = Math.floor(Math.log(e102) / Math.log(2)); e102; )
              t92 += t92, e102--;
            return t92 += t92.substring(0, n92 - t92.length);
          }(" ", p82), "^"), p82 = 0);
        }
      }
    }
    for (var b62 = f82[f82.length - 1], v72 = s72[s72.length - 1]; b62 === v72 && (p82++ < 2 ? i72 = "\n  ".concat(b62).concat(i72) : o92 = b62, f82.pop(), s72.pop(), 0 !== f82.length && 0 !== s72.length); )
      b62 = f82[f82.length - 1], v72 = s72[s72.length - 1];
    var O62 = Math.max(f82.length, s72.length);
    if (0 === O62) {
      var q42 = l72.split("\n");
      if (q42.length > 30)
        for (q42[26] = "".concat(m62, "...").concat(S42); q42.length > 27; )
          q42.pop();
      return "".concat(j42.notIdentical, "\n\n").concat(q42.join("\n"), "\n");
    }
    p82 > 3 && (i72 = "\n".concat(m62, "...").concat(S42).concat(i72), u72 = true), "" !== o92 && (i72 = "\n  ".concat(o92).concat(i72), o92 = "");
    var R52 = 0, A42 = j42[r102] + "\n".concat(E42, "+ actual").concat(S42, " ").concat(w42, "- expected").concat(S42), k42 = " ".concat(m62, "...").concat(S42, " Lines skipped");
    for (p82 = 0; p82 < O62; p82++) {
      var _42 = p82 - a82;
      if (f82.length < p82 + 1)
        _42 > 1 && p82 > 2 && (_42 > 4 ? (c82 += "\n".concat(m62, "...").concat(S42), u72 = true) : _42 > 3 && (c82 += "\n  ".concat(s72[p82 - 2]), R52++), c82 += "\n  ".concat(s72[p82 - 1]), R52++), a82 = p82, o92 += "\n".concat(w42, "-").concat(S42, " ").concat(s72[p82]), R52++;
      else if (s72.length < p82 + 1)
        _42 > 1 && p82 > 2 && (_42 > 4 ? (c82 += "\n".concat(m62, "...").concat(S42), u72 = true) : _42 > 3 && (c82 += "\n  ".concat(f82[p82 - 2]), R52++), c82 += "\n  ".concat(f82[p82 - 1]), R52++), a82 = p82, c82 += "\n".concat(E42, "+").concat(S42, " ").concat(f82[p82]), R52++;
      else {
        var T52 = s72[p82], P42 = f82[p82], I42 = P42 !== T52 && (!d62(P42, ",") || P42.slice(0, -1) !== T52);
        I42 && d62(T52, ",") && T52.slice(0, -1) === P42 && (I42 = false, P42 += ","), I42 ? (_42 > 1 && p82 > 2 && (_42 > 4 ? (c82 += "\n".concat(m62, "...").concat(S42), u72 = true) : _42 > 3 && (c82 += "\n  ".concat(f82[p82 - 2]), R52++), c82 += "\n  ".concat(f82[p82 - 1]), R52++), a82 = p82, c82 += "\n".concat(E42, "+").concat(S42, " ").concat(P42), o92 += "\n".concat(w42, "-").concat(S42, " ").concat(T52), R52 += 2) : (c82 += o92, o92 = "", 1 !== _42 && 0 !== p82 || (c82 += "\n  ".concat(P42), R52++));
      }
      if (R52 > 20 && p82 < O62 - 2)
        return "".concat(A42).concat(k42, "\n").concat(c82, "\n").concat(m62, "...").concat(S42).concat(o92, "\n") + "".concat(m62, "...").concat(S42);
    }
    return "".concat(A42).concat(u72 ? k42 : "", "\n").concat(c82).concat(o92).concat(i72).concat(g62);
  }
  var R42 = function(t82) {
    function e92(t92) {
      var r102;
      if (!function(t102, e102) {
        if (!(t102 instanceof e102))
          throw new TypeError("Cannot call a class as a function");
      }(this, e92), "object" !== y62(t92) || null === t92)
        throw new v62("options", "Object", t92);
      var o92 = t92.message, i82 = t92.operator, u82 = t92.stackStartFn, l72 = t92.actual, f82 = t92.expected, s72 = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, null != o92)
        r102 = c72(this, h82(e92).call(this, String(o92)));
      else if (n82.stderr && n82.stderr.isTTY && (n82.stderr && n82.stderr.getColorDepth && 1 !== n82.stderr.getColorDepth() ? (m62 = "\x1B[34m", E42 = "\x1B[32m", S42 = "\x1B[39m", w42 = "\x1B[31m") : (m62 = "", E42 = "", S42 = "", w42 = "")), "object" === y62(l72) && null !== l72 && "object" === y62(f82) && null !== f82 && "stack" in l72 && l72 instanceof Error && "stack" in f82 && f82 instanceof Error && (l72 = O52(l72), f82 = O52(f82)), "deepStrictEqual" === i82 || "strictEqual" === i82)
        r102 = c72(this, h82(e92).call(this, q32(l72, f82, i82)));
      else if ("notDeepStrictEqual" === i82 || "notStrictEqual" === i82) {
        var p82 = j42[i82], g62 = x42(l72).split("\n");
        if ("notStrictEqual" === i82 && "object" === y62(l72) && null !== l72 && (p82 = j42.notStrictEqualObject), g62.length > 30)
          for (g62[26] = "".concat(m62, "...").concat(S42); g62.length > 27; )
            g62.pop();
        r102 = 1 === g62.length ? c72(this, h82(e92).call(this, "".concat(p82, " ").concat(g62[0]))) : c72(this, h82(e92).call(this, "".concat(p82, "\n\n").concat(g62.join("\n"), "\n")));
      } else {
        var b62 = x42(l72), d72 = "", R52 = j42[i82];
        "notDeepEqual" === i82 || "notEqual" === i82 ? (b62 = "".concat(j42[i82], "\n\n").concat(b62)).length > 1024 && (b62 = "".concat(b62.slice(0, 1021), "...")) : (d72 = "".concat(x42(f82)), b62.length > 512 && (b62 = "".concat(b62.slice(0, 509), "...")), d72.length > 512 && (d72 = "".concat(d72.slice(0, 509), "...")), "deepEqual" === i82 || "equal" === i82 ? b62 = "".concat(R52, "\n\n").concat(b62, "\n\nshould equal\n\n") : d72 = " ".concat(i82, " ").concat(d72)), r102 = c72(this, h82(e92).call(this, "".concat(b62).concat(d72)));
      }
      return Error.stackTraceLimit = s72, r102.generatedMessage = !o92, Object.defineProperty(a72(r102), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), r102.code = "ERR_ASSERTION", r102.actual = l72, r102.expected = f82, r102.operator = i82, Error.captureStackTrace && Error.captureStackTrace(a72(r102), u82), r102.stack, r102.name = "AssertionError", c72(r102);
    }
    var i72, u72;
    return !function(t92, e102) {
      if ("function" != typeof e102 && null !== e102)
        throw new TypeError("Super expression must either be null or a function");
      t92.prototype = Object.create(e102 && e102.prototype, { constructor: { value: t92, writable: true, configurable: true } }), e102 && g52(t92, e102);
    }(e92, t82), i72 = e92, (u72 = [{ key: "toString", value: function() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    } }, { key: b52.custom, value: function(t92, e102) {
      return b52(this, function(t102) {
        for (var e112 = 1; e112 < arguments.length; e112++) {
          var n92 = null != arguments[e112] ? arguments[e112] : {}, o92 = Object.keys(n92);
          "function" == typeof Object.getOwnPropertySymbols && (o92 = o92.concat(Object.getOwnPropertySymbols(n92).filter(function(t112) {
            return Object.getOwnPropertyDescriptor(n92, t112).enumerable;
          }))), o92.forEach(function(e122) {
            r92(t102, e122, n92[e122]);
          });
        }
        return t102;
      }({}, e102, { customInspect: false, depth: 0 }));
    } }]) && o82(i72.prototype, u72), e92;
  }(f72(Error));
  return u$5 = R42;
}
function s$3(t82, e92) {
  return function(t92) {
    if (Array.isArray(t92))
      return t92;
  }(t82) || function(t92, e102) {
    var n82 = [], r92 = true, o82 = false, c72 = void 0;
    try {
      for (var a72, i72 = t92[Symbol.iterator](); !(r92 = (a72 = i72.next()).done) && (n82.push(a72.value), !e102 || n82.length !== e102); r92 = true)
        ;
    } catch (t102) {
      o82 = true, c72 = t102;
    } finally {
      try {
        r92 || null == i72.return || i72.return();
      } finally {
        if (o82)
          throw c72;
      }
    }
    return n82;
  }(t82, e92) || function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }();
}
function p$3(t82) {
  return (p$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t92) {
    return typeof t92;
  } : function(t92) {
    return t92 && "function" == typeof Symbol && t92.constructor === Symbol && t92 !== Symbol.prototype ? "symbol" : typeof t92;
  })(t82);
}
function m$2(t82) {
  return t82.call.bind(t82);
}
function U3(t82) {
  if (0 === t82.length || t82.length > 10)
    return true;
  for (var e92 = 0; e92 < t82.length; e92++) {
    var n82 = t82.charCodeAt(e92);
    if (n82 < 48 || n82 > 57)
      return true;
  }
  return 10 === t82.length && t82 >= Math.pow(2, 32);
}
function G2(t82) {
  return Object.keys(t82).filter(U3).concat(v$1(t82).filter(Object.prototype.propertyIsEnumerable.bind(t82)));
}
function V2(t82, e92) {
  if (t82 === e92)
    return 0;
  for (var n82 = t82.length, r92 = e92.length, o82 = 0, c72 = Math.min(n82, r92); o82 < c72; ++o82)
    if (t82[o82] !== e92[o82]) {
      n82 = t82[o82], r92 = e92[o82];
      break;
    }
  return n82 < r92 ? -1 : r92 < n82 ? 1 : 0;
}
function B3(t82, e92, n82, r92) {
  if (t82 === e92)
    return 0 !== t82 || (!n82 || b$1(t82, e92));
  if (n82) {
    if ("object" !== p$3(t82))
      return "number" == typeof t82 && d$1(t82) && d$1(e92);
    if ("object" !== p$3(e92) || null === t82 || null === e92)
      return false;
    if (Object.getPrototypeOf(t82) !== Object.getPrototypeOf(e92))
      return false;
  } else {
    if (null === t82 || "object" !== p$3(t82))
      return (null === e92 || "object" !== p$3(e92)) && t82 == e92;
    if (null === e92 || "object" !== p$3(e92))
      return false;
  }
  var o82, c72, a72, i72, u72 = S3(t82);
  if (u72 !== S3(e92))
    return false;
  if (Array.isArray(t82)) {
    if (t82.length !== e92.length)
      return false;
    var l72 = G2(t82), f72 = G2(e92);
    return l72.length === f72.length && C3(t82, e92, n82, r92, 1, l72);
  }
  if ("[object Object]" === u72 && (!R3(t82) && R3(e92) || !k3(t82) && k3(e92)))
    return false;
  if (q2(t82)) {
    if (!q2(e92) || Date.prototype.getTime.call(t82) !== Date.prototype.getTime.call(e92))
      return false;
  } else if (A$1(t82)) {
    if (!A$1(e92) || (a72 = t82, i72 = e92, !(g$1 ? a72.source === i72.source && a72.flags === i72.flags : RegExp.prototype.toString.call(a72) === RegExp.prototype.toString.call(i72))))
      return false;
  } else if (_3(t82) || t82 instanceof Error) {
    if (t82.message !== e92.message || t82.name !== e92.name)
      return false;
  } else {
    if (x3(t82)) {
      if (n82 || !L3(t82) && !M3(t82)) {
        if (!function(t92, e102) {
          return t92.byteLength === e102.byteLength && 0 === V2(new Uint8Array(t92.buffer, t92.byteOffset, t92.byteLength), new Uint8Array(e102.buffer, e102.byteOffset, e102.byteLength));
        }(t82, e92))
          return false;
      } else if (!function(t92, e102) {
        if (t92.byteLength !== e102.byteLength)
          return false;
        for (var n92 = 0; n92 < t92.byteLength; n92++)
          if (t92[n92] !== e102[n92])
            return false;
        return true;
      }(t82, e92))
        return false;
      var s62 = G2(t82), h82 = G2(e92);
      return s62.length === h82.length && C3(t82, e92, n82, r92, 0, s62);
    }
    if (k3(t82))
      return !(!k3(e92) || t82.size !== e92.size) && C3(t82, e92, n82, r92, 2);
    if (R3(t82))
      return !(!R3(e92) || t82.size !== e92.size) && C3(t82, e92, n82, r92, 3);
    if (O3(t82)) {
      if (c72 = e92, (o82 = t82).byteLength !== c72.byteLength || 0 !== V2(new Uint8Array(o82), new Uint8Array(c72)))
        return false;
    } else if (T4(t82) && !function(t92, e102) {
      return P$1(t92) ? P$1(e102) && b$1(Number.prototype.valueOf.call(t92), Number.prototype.valueOf.call(e102)) : I3(t92) ? I3(e102) && String.prototype.valueOf.call(t92) === String.prototype.valueOf.call(e102) : D3(t92) ? D3(e102) && Boolean.prototype.valueOf.call(t92) === Boolean.prototype.valueOf.call(e102) : F3(t92) ? F3(e102) && BigInt.prototype.valueOf.call(t92) === BigInt.prototype.valueOf.call(e102) : N$1(e102) && Symbol.prototype.valueOf.call(t92) === Symbol.prototype.valueOf.call(e102);
    }(t82, e92))
      return false;
  }
  return C3(t82, e92, n82, r92, 0);
}
function z3(t82, e92) {
  return e92.filter(function(e102) {
    return w$1(t82, e102);
  });
}
function C3(t82, e92, n82, r92, o82, c72) {
  if (5 === arguments.length) {
    c72 = Object.keys(t82);
    var a72 = Object.keys(e92);
    if (c72.length !== a72.length)
      return false;
  }
  for (var i72 = 0; i72 < c72.length; i72++)
    if (!E3(e92, c72[i72]))
      return false;
  if (n82 && 5 === arguments.length) {
    var u72 = v$1(t82);
    if (0 !== u72.length) {
      var l72 = 0;
      for (i72 = 0; i72 < u72.length; i72++) {
        var f72 = u72[i72];
        if (w$1(t82, f72)) {
          if (!w$1(e92, f72))
            return false;
          c72.push(f72), l72++;
        } else if (w$1(e92, f72))
          return false;
      }
      var s62 = v$1(e92);
      if (u72.length !== s62.length && z3(e92, s62).length !== l72)
        return false;
    } else {
      var p72 = v$1(e92);
      if (0 !== p72.length && 0 !== z3(e92, p72).length)
        return false;
    }
  }
  if (0 === c72.length && (0 === o82 || 1 === o82 && 0 === t82.length || 0 === t82.size))
    return true;
  if (void 0 === r92)
    r92 = { val1: /* @__PURE__ */ new Map(), val2: /* @__PURE__ */ new Map(), position: 0 };
  else {
    var g52 = r92.val1.get(t82);
    if (void 0 !== g52) {
      var h82 = r92.val2.get(e92);
      if (void 0 !== h82)
        return g52 === h82;
    }
    r92.position++;
  }
  r92.val1.set(t82, r92.position), r92.val2.set(e92, r92.position);
  var y62 = Q2(t82, e92, n82, c72, r92, o82);
  return r92.val1.delete(t82), r92.val2.delete(e92), y62;
}
function Y3(t82, e92, n82, r92) {
  for (var o82 = h$1(t82), c72 = 0; c72 < o82.length; c72++) {
    var a72 = o82[c72];
    if (B3(e92, a72, n82, r92))
      return t82.delete(a72), true;
  }
  return false;
}
function W2(t82) {
  switch (p$3(t82)) {
    case "undefined":
      return null;
    case "object":
      return;
    case "symbol":
      return false;
    case "string":
      t82 = +t82;
    case "number":
      if (d$1(t82))
        return false;
  }
  return true;
}
function H2(t82, e92, n82) {
  var r92 = W2(n82);
  return null != r92 ? r92 : e92.has(r92) && !t82.has(r92);
}
function J2(t82, e92, n82, r92, o82) {
  var c72 = W2(n82);
  if (null != c72)
    return c72;
  var a72 = e92.get(c72);
  return !(void 0 === a72 && !e92.has(c72) || !B3(r92, a72, false, o82)) && (!t82.has(c72) && B3(r92, a72, false, o82));
}
function K2(t82, e92, n82, r92, o82, c72) {
  for (var a72 = h$1(t82), i72 = 0; i72 < a72.length; i72++) {
    var u72 = a72[i72];
    if (B3(n82, u72, o82, c72) && B3(r92, e92.get(u72), o82, c72))
      return t82.delete(u72), true;
  }
  return false;
}
function Q2(t82, e92, n82, r92, o82, c72) {
  var a72 = 0;
  if (2 === c72) {
    if (!function(t92, e102, n92, r102) {
      for (var o92 = null, c82 = h$1(t92), a82 = 0; a82 < c82.length; a82++) {
        var i82 = c82[a82];
        if ("object" === p$3(i82) && null !== i82)
          null === o92 && (o92 = /* @__PURE__ */ new Set()), o92.add(i82);
        else if (!e102.has(i82)) {
          if (n92)
            return false;
          if (!H2(t92, e102, i82))
            return false;
          null === o92 && (o92 = /* @__PURE__ */ new Set()), o92.add(i82);
        }
      }
      if (null !== o92) {
        for (var u82 = h$1(e102), l82 = 0; l82 < u82.length; l82++) {
          var f72 = u82[l82];
          if ("object" === p$3(f72) && null !== f72) {
            if (!Y3(o92, f72, n92, r102))
              return false;
          } else if (!n92 && !t92.has(f72) && !Y3(o92, f72, n92, r102))
            return false;
        }
        return 0 === o92.size;
      }
      return true;
    }(t82, e92, n82, o82))
      return false;
  } else if (3 === c72) {
    if (!function(t92, e102, n92, r102) {
      for (var o92 = null, c82 = y$2(t92), a82 = 0; a82 < c82.length; a82++) {
        var i82 = s$3(c82[a82], 2), u82 = i82[0], l82 = i82[1];
        if ("object" === p$3(u82) && null !== u82)
          null === o92 && (o92 = /* @__PURE__ */ new Set()), o92.add(u82);
        else {
          var f72 = e102.get(u82);
          if (void 0 === f72 && !e102.has(u82) || !B3(l82, f72, n92, r102)) {
            if (n92)
              return false;
            if (!J2(t92, e102, u82, l82, r102))
              return false;
            null === o92 && (o92 = /* @__PURE__ */ new Set()), o92.add(u82);
          }
        }
      }
      if (null !== o92) {
        for (var g52 = y$2(e102), h82 = 0; h82 < g52.length; h82++) {
          var b52 = s$3(g52[h82], 2), v62 = (u82 = b52[0], b52[1]);
          if ("object" === p$3(u82) && null !== u82) {
            if (!K2(o92, t92, u82, v62, n92, r102))
              return false;
          } else if (!(n92 || t92.has(u82) && B3(t92.get(u82), v62, false, r102) || K2(o92, t92, u82, v62, false, r102)))
            return false;
        }
        return 0 === o92.size;
      }
      return true;
    }(t82, e92, n82, o82))
      return false;
  } else if (1 === c72)
    for (; a72 < t82.length; a72++) {
      if (!E3(t82, a72)) {
        if (E3(e92, a72))
          return false;
        for (var i72 = Object.keys(t82); a72 < i72.length; a72++) {
          var u72 = i72[a72];
          if (!E3(e92, u72) || !B3(t82[u72], e92[u72], n82, o82))
            return false;
        }
        return i72.length === Object.keys(e92).length;
      }
      if (!E3(e92, a72) || !B3(t82[a72], e92[a72], n82, o82))
        return false;
    }
  for (a72 = 0; a72 < r92.length; a72++) {
    var l72 = r92[a72];
    if (!B3(t82[l72], e92[l72], n82, o82))
      return false;
  }
  return true;
}
function tt() {
  if ($$1)
    return Z2;
  $$1 = true;
  var o82 = T;
  function c72(t82) {
    return (c72 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t92) {
      return typeof t92;
    } : function(t92) {
      return t92 && "function" == typeof Symbol && t92.constructor === Symbol && t92 !== Symbol.prototype ? "symbol" : typeof t92;
    })(t82);
  }
  var a72, u72, l72 = i$5().codes, s62 = l72.ERR_AMBIGUOUS_ARGUMENT, p72 = l72.ERR_INVALID_ARG_TYPE, g52 = l72.ERR_INVALID_ARG_VALUE, h82 = l72.ERR_INVALID_RETURN_VALUE, y62 = l72.ERR_MISSING_ARGS, b52 = f$6(), v62 = X.inspect, d62 = X.types, m$122 = d62.isPromise, E42 = d62.isRegExp, w42 = Object.assign ? Object.assign : r5.assign, S42 = Object.is ? Object.is : m4;
  function j42() {
    a72 = X2.isDeepEqual, u72 = X2.isDeepStrictEqual;
  }
  var O52 = false, x42 = Z2 = k42, q32 = {};
  function R42(t82) {
    if (t82.message instanceof Error)
      throw t82.message;
    throw new b52(t82);
  }
  function A42(t82, e92, n82, r92) {
    if (!n82) {
      var o92 = false;
      if (0 === e92)
        o92 = true, r92 = "No value argument passed to `assert.ok()`";
      else if (r92 instanceof Error)
        throw r92;
      var c82 = new b52({ actual: n82, expected: true, message: r92, operator: "==", stackStartFn: t82 });
      throw c82.generatedMessage = o92, c82;
    }
  }
  function k42() {
    for (var t82 = arguments.length, e92 = new Array(t82), n82 = 0; n82 < t82; n82++)
      e92[n82] = arguments[n82];
    A42.apply(void 0, [k42, e92.length].concat(e92));
  }
  x42.fail = function t82(e92, n82, r92, c82, a82) {
    var i72, u82 = arguments.length;
    if (0 === u82)
      i72 = "Failed";
    else if (1 === u82)
      r92 = e92, e92 = void 0;
    else {
      if (false === O52) {
        O52 = true;
        var l82 = o82.emitWarning ? o82.emitWarning : console.warn.bind(console);
        l82("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      2 === u82 && (c82 = "!=");
    }
    if (r92 instanceof Error)
      throw r92;
    var f72 = { actual: e92, expected: n82, operator: void 0 === c82 ? "fail" : c82, stackStartFn: a82 || t82 };
    void 0 !== r92 && (f72.message = r92);
    var s72 = new b52(f72);
    throw i72 && (s72.message = i72, s72.generatedMessage = true), s72;
  }, x42.AssertionError = b52, x42.ok = k42, x42.equal = function t82(e92, n82, r92) {
    if (arguments.length < 2)
      throw new y62("actual", "expected");
    e92 != n82 && R42({ actual: e92, expected: n82, message: r92, operator: "==", stackStartFn: t82 });
  }, x42.notEqual = function t82(e92, n82, r92) {
    if (arguments.length < 2)
      throw new y62("actual", "expected");
    e92 == n82 && R42({ actual: e92, expected: n82, message: r92, operator: "!=", stackStartFn: t82 });
  }, x42.deepEqual = function t82(e92, n82, r92) {
    if (arguments.length < 2)
      throw new y62("actual", "expected");
    void 0 === a72 && j42(), a72(e92, n82) || R42({ actual: e92, expected: n82, message: r92, operator: "deepEqual", stackStartFn: t82 });
  }, x42.notDeepEqual = function t82(e92, n82, r92) {
    if (arguments.length < 2)
      throw new y62("actual", "expected");
    void 0 === a72 && j42(), a72(e92, n82) && R42({ actual: e92, expected: n82, message: r92, operator: "notDeepEqual", stackStartFn: t82 });
  }, x42.deepStrictEqual = function t82(e92, n82, r92) {
    if (arguments.length < 2)
      throw new y62("actual", "expected");
    void 0 === a72 && j42(), u72(e92, n82) || R42({ actual: e92, expected: n82, message: r92, operator: "deepStrictEqual", stackStartFn: t82 });
  }, x42.notDeepStrictEqual = function t82(e92, n82, r92) {
    if (arguments.length < 2)
      throw new y62("actual", "expected");
    void 0 === a72 && j42();
    u72(e92, n82) && R42({ actual: e92, expected: n82, message: r92, operator: "notDeepStrictEqual", stackStartFn: t82 });
  }, x42.strictEqual = function t82(e92, n82, r92) {
    if (arguments.length < 2)
      throw new y62("actual", "expected");
    S42(e92, n82) || R42({ actual: e92, expected: n82, message: r92, operator: "strictEqual", stackStartFn: t82 });
  }, x42.notStrictEqual = function t82(e92, n82, r92) {
    if (arguments.length < 2)
      throw new y62("actual", "expected");
    S42(e92, n82) && R42({ actual: e92, expected: n82, message: r92, operator: "notStrictEqual", stackStartFn: t82 });
  };
  var _42 = function t82(e92, n82, r92) {
    var o92 = this;
    !function(t92, e102) {
      if (!(t92 instanceof e102))
        throw new TypeError("Cannot call a class as a function");
    }(this, t82), n82.forEach(function(t92) {
      t92 in e92 && (void 0 !== r92 && "string" == typeof r92[t92] && E42(e92[t92]) && e92[t92].test(r92[t92]) ? o92[t92] = r92[t92] : o92[t92] = e92[t92]);
    });
  };
  function T52(t82, e92, n82, r92, o92, c82) {
    if (!(n82 in t82) || !u72(t82[n82], e92[n82])) {
      if (!r92) {
        var a82 = new _42(t82, o92), i72 = new _42(e92, o92, t82), l82 = new b52({ actual: a82, expected: i72, operator: "deepStrictEqual", stackStartFn: c82 });
        throw l82.actual = t82, l82.expected = e92, l82.operator = c82.name, l82;
      }
      R42({ actual: t82, expected: e92, message: r92, operator: c82.name, stackStartFn: c82 });
    }
  }
  function P42(t82, e92, n82, r92) {
    if ("function" != typeof e92) {
      if (E42(e92))
        return e92.test(t82);
      if (2 === arguments.length)
        throw new p72("expected", ["Function", "RegExp"], e92);
      if ("object" !== c72(t82) || null === t82) {
        var o92 = new b52({ actual: t82, expected: e92, message: n82, operator: "deepStrictEqual", stackStartFn: r92 });
        throw o92.operator = r92.name, o92;
      }
      var i72 = Object.keys(e92);
      if (e92 instanceof Error)
        i72.push("name", "message");
      else if (0 === i72.length)
        throw new g52("error", e92, "may not be an empty object");
      return void 0 === a72 && j42(), i72.forEach(function(o102) {
        "string" == typeof t82[o102] && E42(e92[o102]) && e92[o102].test(t82[o102]) || T52(t82, e92, o102, n82, i72, r92);
      }), true;
    }
    return void 0 !== e92.prototype && t82 instanceof e92 || !Error.isPrototypeOf(e92) && true === e92.call({}, t82);
  }
  function I42(t82) {
    if ("function" != typeof t82)
      throw new p72("fn", "Function", t82);
    try {
      t82();
    } catch (t92) {
      return t92;
    }
    return q32;
  }
  function D42(t82) {
    return m$122(t82) || null !== t82 && "object" === c72(t82) && "function" == typeof t82.then && "function" == typeof t82.catch;
  }
  function F42(t82) {
    return Promise.resolve().then(function() {
      var e92;
      if ("function" == typeof t82) {
        if (!D42(e92 = t82()))
          throw new h82("instance of Promise", "promiseFn", e92);
      } else {
        if (!D42(t82))
          throw new p72("promiseFn", ["Function", "Promise"], t82);
        e92 = t82;
      }
      return Promise.resolve().then(function() {
        return e92;
      }).then(function() {
        return q32;
      }).catch(function(t92) {
        return t92;
      });
    });
  }
  function N42(t82, e92, n82, r92) {
    if ("string" == typeof n82) {
      if (4 === arguments.length)
        throw new p72("error", ["Object", "Error", "Function", "RegExp"], n82);
      if ("object" === c72(e92) && null !== e92) {
        if (e92.message === n82)
          throw new s62("error/message", 'The error message "'.concat(e92.message, '" is identical to the message.'));
      } else if (e92 === n82)
        throw new s62("error/message", 'The error "'.concat(e92, '" is identical to the message.'));
      r92 = n82, n82 = void 0;
    } else if (null != n82 && "object" !== c72(n82) && "function" != typeof n82)
      throw new p72("error", ["Object", "Error", "Function", "RegExp"], n82);
    if (e92 === q32) {
      var o92 = "";
      n82 && n82.name && (o92 += " (".concat(n82.name, ")")), o92 += r92 ? ": ".concat(r92) : ".";
      var a82 = "rejects" === t82.name ? "rejection" : "exception";
      R42({ actual: void 0, expected: n82, operator: t82.name, message: "Missing expected ".concat(a82).concat(o92), stackStartFn: t82 });
    }
    if (n82 && !P42(e92, n82, r92, t82))
      throw e92;
  }
  function L42(t82, e92, n82, r92) {
    if (e92 !== q32) {
      if ("string" == typeof n82 && (r92 = n82, n82 = void 0), !n82 || P42(e92, n82)) {
        var o92 = r92 ? ": ".concat(r92) : ".", c82 = "doesNotReject" === t82.name ? "rejection" : "exception";
        R42({ actual: e92, expected: n82, operator: t82.name, message: "Got unwanted ".concat(c82).concat(o92, "\n") + 'Actual message: "'.concat(e92 && e92.message, '"'), stackStartFn: t82 });
      }
      throw e92;
    }
  }
  function M42() {
    for (var t82 = arguments.length, e92 = new Array(t82), n82 = 0; n82 < t82; n82++)
      e92[n82] = arguments[n82];
    A42.apply(void 0, [M42, e92.length].concat(e92));
  }
  return x42.throws = function t82(e92) {
    for (var n82 = arguments.length, r92 = new Array(n82 > 1 ? n82 - 1 : 0), o92 = 1; o92 < n82; o92++)
      r92[o92 - 1] = arguments[o92];
    N42.apply(void 0, [t82, I42(e92)].concat(r92));
  }, x42.rejects = function t82(e92) {
    for (var n82 = arguments.length, r92 = new Array(n82 > 1 ? n82 - 1 : 0), o92 = 1; o92 < n82; o92++)
      r92[o92 - 1] = arguments[o92];
    return F42(e92).then(function(e102) {
      return N42.apply(void 0, [t82, e102].concat(r92));
    });
  }, x42.doesNotThrow = function t82(e92) {
    for (var n82 = arguments.length, r92 = new Array(n82 > 1 ? n82 - 1 : 0), o92 = 1; o92 < n82; o92++)
      r92[o92 - 1] = arguments[o92];
    L42.apply(void 0, [t82, I42(e92)].concat(r92));
  }, x42.doesNotReject = function t82(e92) {
    for (var n82 = arguments.length, r92 = new Array(n82 > 1 ? n82 - 1 : 0), o92 = 1; o92 < n82; o92++)
      r92[o92 - 1] = arguments[o92];
    return F42(e92).then(function(e102) {
      return L42.apply(void 0, [t82, e102].concat(r92));
    });
  }, x42.ifError = function t82(e92) {
    if (null != e92) {
      var n82 = "ifError got unwanted exception: ";
      "object" === c72(e92) && "string" == typeof e92.message ? 0 === e92.message.length && e92.constructor ? n82 += e92.constructor.name : n82 += e92.message : n82 += v62(e92);
      var r92 = new b52({ actual: e92, expected: null, operator: "ifError", message: n82, stackStartFn: t82 }), o92 = e92.stack;
      if ("string" == typeof o92) {
        var a82 = o92.split("\n");
        a82.shift();
        for (var i72 = r92.stack.split("\n"), u82 = 0; u82 < a82.length; u82++) {
          var l82 = i72.indexOf(a82[u82]);
          if (-1 !== l82) {
            i72 = i72.slice(0, l82);
            break;
          }
        }
        r92.stack = "".concat(i72.join("\n"), "\n").concat(a82.join("\n"));
      }
      throw r92;
    }
  }, x42.strict = w42(M42, x42, { equal: x42.strictEqual, deepEqual: x42.deepStrictEqual, notEqual: x42.notStrictEqual, notDeepEqual: x42.notDeepStrictEqual }), x42.strict.strict = x42.strict, Z2;
}
function dew32() {
  if (_dewExec32)
    return exports$122;
  _dewExec32 = true;
  var process$1 = process3;
  function assertPath(path22) {
    if (typeof path22 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path22));
    }
  }
  function normalizeStringPosix(path22, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i72 = 0; i72 <= path22.length; ++i72) {
      if (i72 < path22.length)
        code = path22.charCodeAt(i72);
      else if (code === 47)
        break;
      else
        code = 47;
      if (code === 47) {
        if (lastSlash === i72 - 1 || dots === 1)
          ;
        else if (lastSlash !== i72 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i72;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i72;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += "/..";
            else
              res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path22.slice(lastSlash + 1, i72);
          else
            res = path22.slice(lastSlash + 1, i72);
          lastSegmentLength = i72 - lastSlash - 1;
        }
        lastSlash = i72;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep22, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep22 + base;
  }
  var posix22 = {
    // path.resolve([from ...], to)
    resolve: function resolve32() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd;
      for (var i72 = arguments.length - 1; i72 >= -1 && !resolvedAbsolute; i72--) {
        var path22;
        if (i72 >= 0)
          path22 = arguments[i72];
        else {
          if (cwd === void 0)
            cwd = process$1.cwd();
          path22 = cwd;
        }
        assertPath(path22);
        if (path22.length === 0) {
          continue;
        }
        resolvedPath = path22 + "/" + resolvedPath;
        resolvedAbsolute = path22.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return "/" + resolvedPath;
        else
          return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize22(path22) {
      assertPath(path22);
      if (path22.length === 0)
        return ".";
      var isAbsolute22 = path22.charCodeAt(0) === 47;
      var trailingSeparator = path22.charCodeAt(path22.length - 1) === 47;
      path22 = normalizeStringPosix(path22, !isAbsolute22);
      if (path22.length === 0 && !isAbsolute22)
        path22 = ".";
      if (path22.length > 0 && trailingSeparator)
        path22 += "/";
      if (isAbsolute22)
        return "/" + path22;
      return path22;
    },
    isAbsolute: function isAbsolute22(path22) {
      assertPath(path22);
      return path22.length > 0 && path22.charCodeAt(0) === 47;
    },
    join: function join22() {
      if (arguments.length === 0)
        return ".";
      var joined;
      for (var i72 = 0; i72 < arguments.length; ++i72) {
        var arg = arguments[i72];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += "/" + arg;
        }
      }
      if (joined === void 0)
        return ".";
      return posix22.normalize(joined);
    },
    relative: function relative22(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to)
        return "";
      from = posix22.resolve(from);
      to = posix22.resolve(to);
      if (from === to)
        return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i72 = 0;
      for (; i72 <= length; ++i72) {
        if (i72 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i72) === 47) {
              return to.slice(toStart + i72 + 1);
            } else if (i72 === 0) {
              return to.slice(toStart + i72);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i72) === 47) {
              lastCommonSep = i72;
            } else if (i72 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i72);
        var toCode = to.charCodeAt(toStart + i72);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i72;
      }
      var out = "";
      for (i72 = fromStart + lastCommonSep + 1; i72 <= fromEnd; ++i72) {
        if (i72 === fromEnd || from.charCodeAt(i72) === 47) {
          if (out.length === 0)
            out += "..";
          else
            out += "/..";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong22(path22) {
      return path22;
    },
    dirname: function dirname22(path22) {
      assertPath(path22);
      if (path22.length === 0)
        return ".";
      var code = path22.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i72 = path22.length - 1; i72 >= 1; --i72) {
        code = path22.charCodeAt(i72);
        if (code === 47) {
          if (!matchedSlash) {
            end = i72;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : ".";
      if (hasRoot && end === 1)
        return "//";
      return path22.slice(0, end);
    },
    basename: function basename22(path22, ext) {
      if (ext !== void 0 && typeof ext !== "string")
        throw new TypeError('"ext" argument must be a string');
      assertPath(path22);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i72;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path22.length) {
        if (ext.length === path22.length && ext === path22)
          return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i72 = path22.length - 1; i72 >= 0; --i72) {
          var code = path22.charCodeAt(i72);
          if (code === 47) {
            if (!matchedSlash) {
              start = i72 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i72 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i72;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path22.length;
        return path22.slice(start, end);
      } else {
        for (i72 = path22.length - 1; i72 >= 0; --i72) {
          if (path22.charCodeAt(i72) === 47) {
            if (!matchedSlash) {
              start = i72 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i72 + 1;
          }
        }
        if (end === -1)
          return "";
        return path22.slice(start, end);
      }
    },
    extname: function extname22(path22) {
      assertPath(path22);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i72 = path22.length - 1; i72 >= 0; --i72) {
        var code = path22.charCodeAt(i72);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i72 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i72 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i72;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path22.slice(startDot, end);
    },
    format: function format52(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse32(path22) {
      assertPath(path22);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path22.length === 0)
        return ret;
      var code = path22.charCodeAt(0);
      var isAbsolute22 = code === 47;
      var start;
      if (isAbsolute22) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i72 = path22.length - 1;
      var preDotState = 0;
      for (; i72 >= start; --i72) {
        code = path22.charCodeAt(i72);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i72 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i72 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i72;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute22)
            ret.base = ret.name = path22.slice(1, end);
          else
            ret.base = ret.name = path22.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute22) {
          ret.name = path22.slice(1, startDot);
          ret.base = path22.slice(1, end);
        } else {
          ret.name = path22.slice(startPart, startDot);
          ret.base = path22.slice(startPart, end);
        }
        ret.ext = path22.slice(startDot, end);
      }
      if (startPart > 0)
        ret.dir = path22.slice(0, startPart - 1);
      else if (isAbsolute22)
        ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix22.posix = posix22;
  exports$122 = posix22;
  return exports$122;
}
function dew42() {
  if (_dewExec42)
    return exports$132;
  _dewExec42 = true;
  exports$132 = Stream22;
  var EE = y.EventEmitter;
  var inherits32 = dew$f();
  inherits32(Stream22, EE);
  Stream22.Readable = dew$3();
  Stream22.Writable = dew$8();
  Stream22.Duplex = dew$7();
  Stream22.Transform = dew$2();
  Stream22.PassThrough = dew$1();
  Stream22.finished = dew$6();
  Stream22.pipeline = dew22();
  Stream22.Stream = Stream22;
  function Stream22() {
    EE.call(this || _global3);
  }
  Stream22.prototype.pipe = function(dest, options) {
    var source = this || _global3;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      if (typeof dest.destroy === "function")
        dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this || _global3, "error") === 0) {
        throw er;
      }
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  return exports$132;
}
function i5(t82) {
  throw new RangeError(r6[t82]);
}
function f5(t82, o82) {
  const n82 = t82.split("@");
  let r92 = "";
  n82.length > 1 && (r92 = n82[0] + "@", t82 = n82[1]);
  const c72 = function(t92, o92) {
    const n92 = [];
    let e92 = t92.length;
    for (; e92--; )
      n92[e92] = o92(t92[e92]);
    return n92;
  }((t82 = t82.replace(e6, ".")).split("."), o82).join(".");
  return r92 + c72;
}
function l5(t82) {
  const o82 = [];
  let n82 = 0;
  const e92 = t82.length;
  for (; n82 < e92; ) {
    const r92 = t82.charCodeAt(n82++);
    if (r92 >= 55296 && r92 <= 56319 && n82 < e92) {
      const e102 = t82.charCodeAt(n82++);
      56320 == (64512 & e102) ? o82.push(((1023 & r92) << 10) + (1023 & e102) + 65536) : (o82.push(r92), n82--);
    } else
      o82.push(r92);
  }
  return o82;
}
function e7(e92, n82) {
  return Object.prototype.hasOwnProperty.call(e92, n82);
}
function r8() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
function O4(t82, s62, h82) {
  if (t82 && a6.isObject(t82) && t82 instanceof r8)
    return t82;
  var e92 = new r8();
  return e92.parse(t82, s62, h82), e92;
}
function dew5() {
  if (_dewExec5)
    return exports5;
  _dewExec5 = true;
  var process22 = T;
  function assertPath(path22) {
    if (typeof path22 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path22));
    }
  }
  function normalizeStringPosix(path22, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i72 = 0; i72 <= path22.length; ++i72) {
      if (i72 < path22.length)
        code = path22.charCodeAt(i72);
      else if (code === 47)
        break;
      else
        code = 47;
      if (code === 47) {
        if (lastSlash === i72 - 1 || dots === 1)
          ;
        else if (lastSlash !== i72 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i72;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i72;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += "/..";
            else
              res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path22.slice(lastSlash + 1, i72);
          else
            res = path22.slice(lastSlash + 1, i72);
          lastSegmentLength = i72 - lastSlash - 1;
        }
        lastSlash = i72;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep22, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep22 + base;
  }
  var posix22 = {
    // path.resolve([from ...], to)
    resolve: function resolve32() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd;
      for (var i72 = arguments.length - 1; i72 >= -1 && !resolvedAbsolute; i72--) {
        var path22;
        if (i72 >= 0)
          path22 = arguments[i72];
        else {
          if (cwd === void 0)
            cwd = process22.cwd();
          path22 = cwd;
        }
        assertPath(path22);
        if (path22.length === 0) {
          continue;
        }
        resolvedPath = path22 + "/" + resolvedPath;
        resolvedAbsolute = path22.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return "/" + resolvedPath;
        else
          return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize22(path22) {
      assertPath(path22);
      if (path22.length === 0)
        return ".";
      var isAbsolute22 = path22.charCodeAt(0) === 47;
      var trailingSeparator = path22.charCodeAt(path22.length - 1) === 47;
      path22 = normalizeStringPosix(path22, !isAbsolute22);
      if (path22.length === 0 && !isAbsolute22)
        path22 = ".";
      if (path22.length > 0 && trailingSeparator)
        path22 += "/";
      if (isAbsolute22)
        return "/" + path22;
      return path22;
    },
    isAbsolute: function isAbsolute22(path22) {
      assertPath(path22);
      return path22.length > 0 && path22.charCodeAt(0) === 47;
    },
    join: function join22() {
      if (arguments.length === 0)
        return ".";
      var joined;
      for (var i72 = 0; i72 < arguments.length; ++i72) {
        var arg = arguments[i72];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += "/" + arg;
        }
      }
      if (joined === void 0)
        return ".";
      return posix22.normalize(joined);
    },
    relative: function relative22(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to)
        return "";
      from = posix22.resolve(from);
      to = posix22.resolve(to);
      if (from === to)
        return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i72 = 0;
      for (; i72 <= length; ++i72) {
        if (i72 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i72) === 47) {
              return to.slice(toStart + i72 + 1);
            } else if (i72 === 0) {
              return to.slice(toStart + i72);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i72) === 47) {
              lastCommonSep = i72;
            } else if (i72 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i72);
        var toCode = to.charCodeAt(toStart + i72);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i72;
      }
      var out = "";
      for (i72 = fromStart + lastCommonSep + 1; i72 <= fromEnd; ++i72) {
        if (i72 === fromEnd || from.charCodeAt(i72) === 47) {
          if (out.length === 0)
            out += "..";
          else
            out += "/..";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong22(path22) {
      return path22;
    },
    dirname: function dirname22(path22) {
      assertPath(path22);
      if (path22.length === 0)
        return ".";
      var code = path22.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i72 = path22.length - 1; i72 >= 1; --i72) {
        code = path22.charCodeAt(i72);
        if (code === 47) {
          if (!matchedSlash) {
            end = i72;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : ".";
      if (hasRoot && end === 1)
        return "//";
      return path22.slice(0, end);
    },
    basename: function basename22(path22, ext) {
      if (ext !== void 0 && typeof ext !== "string")
        throw new TypeError('"ext" argument must be a string');
      assertPath(path22);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i72;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path22.length) {
        if (ext.length === path22.length && ext === path22)
          return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i72 = path22.length - 1; i72 >= 0; --i72) {
          var code = path22.charCodeAt(i72);
          if (code === 47) {
            if (!matchedSlash) {
              start = i72 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i72 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i72;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path22.length;
        return path22.slice(start, end);
      } else {
        for (i72 = path22.length - 1; i72 >= 0; --i72) {
          if (path22.charCodeAt(i72) === 47) {
            if (!matchedSlash) {
              start = i72 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i72 + 1;
          }
        }
        if (end === -1)
          return "";
        return path22.slice(start, end);
      }
    },
    extname: function extname22(path22) {
      assertPath(path22);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i72 = path22.length - 1; i72 >= 0; --i72) {
        var code = path22.charCodeAt(i72);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i72 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i72 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i72;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path22.slice(startDot, end);
    },
    format: function format52(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse32(path22) {
      assertPath(path22);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path22.length === 0)
        return ret;
      var code = path22.charCodeAt(0);
      var isAbsolute22 = code === 47;
      var start;
      if (isAbsolute22) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i72 = path22.length - 1;
      var preDotState = 0;
      for (; i72 >= start; --i72) {
        code = path22.charCodeAt(i72);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i72 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i72 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i72;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute22)
            ret.base = ret.name = path22.slice(1, end);
          else
            ret.base = ret.name = path22.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute22) {
          ret.name = path22.slice(1, startDot);
          ret.base = path22.slice(1, end);
        } else {
          ret.name = path22.slice(startPart, startDot);
          ret.base = path22.slice(startPart, end);
        }
        ret.ext = path22.slice(startDot, end);
      }
      if (startPart > 0)
        ret.dir = path22.slice(0, startPart - 1);
      else if (isAbsolute22)
        ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix22.posix = posix22;
  exports5 = posix22;
  return exports5;
}
function fileURLToPath$1(path22) {
  if (typeof path22 === "string")
    path22 = new URL(path22);
  else if (!(path22 instanceof URL)) {
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path22.protocol !== "file:") {
    throw new Deno.errors.InvalidData("invalid url scheme");
  }
  return isWindows$1 ? getPathFromURLWin$1(path22) : getPathFromURLPosix$1(path22);
}
function getPathFromURLWin$1(url) {
  const hostname2 = url.hostname;
  let pathname = url.pathname;
  for (let n82 = 0; n82 < pathname.length; n82++) {
    if (pathname[n82] === "%") {
      const third = pathname.codePointAt(n82 + 2) || 32;
      if (pathname[n82 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n82 + 1] === "5" && third === 99) {
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx$1, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname2 !== "") {
    return `\\\\${hostname2}${pathname}`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep22 = pathname[2];
    if (letter < CHAR_LOWERCASE_A$1 || letter > CHAR_LOWERCASE_Z$1 || // a..z A..Z
    sep22 !== ":") {
      throw new Deno.errors.InvalidData("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix$1(url) {
  if (url.hostname !== "") {
    throw new Deno.errors.InvalidData("invalid file url hostname");
  }
  const pathname = url.pathname;
  for (let n82 = 0; n82 < pathname.length; n82++) {
    if (pathname[n82] === "%") {
      const third = pathname.codePointAt(n82 + 2) || 32;
      if (pathname[n82 + 1] === "2" && third === 102) {
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL$1(filepath) {
  let resolved = path.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH$1 || isWindows$1 && filePathLast === CHAR_BACKWARD_SLASH$1) && resolved[resolved.length - 1] !== path.sep) {
    resolved += "/";
  }
  const outURL = new URL("file://");
  if (resolved.includes("%"))
    resolved = resolved.replace(percentRegEx$1, "%25");
  if (!isWindows$1 && resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx$1, "%5C");
  }
  if (resolved.includes("\n"))
    resolved = resolved.replace(newlineRegEx$1, "%0A");
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx$1, "%0D");
  }
  if (resolved.includes("	"))
    resolved = resolved.replace(tabRegEx$1, "%09");
  outURL.pathname = resolved;
  return outURL;
}
function fileURLToPath(path22) {
  if (typeof path22 === "string")
    path22 = new URL(path22);
  else if (!(path22 instanceof URL)) {
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path22.protocol !== "file:") {
    throw new Deno.errors.InvalidData("invalid url scheme");
  }
  return isWindows ? getPathFromURLWin(path22) : getPathFromURLPosix(path22);
}
function getPathFromURLWin(url) {
  const hostname2 = url.hostname;
  let pathname = url.pathname;
  for (let n82 = 0; n82 < pathname.length; n82++) {
    if (pathname[n82] === "%") {
      const third = pathname.codePointAt(n82 + 2) || 32;
      if (pathname[n82 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n82 + 1] === "5" && third === 99) {
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname2 !== "") {
    return `\\\\${hostname2}${pathname}`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep22 = pathname[2];
    if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || // a..z A..Z
    sep22 !== ":") {
      throw new Deno.errors.InvalidData("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    throw new Deno.errors.InvalidData("invalid file url hostname");
  }
  const pathname = url.pathname;
  for (let n82 = 0; n82 < pathname.length; n82++) {
    if (pathname[n82] === "%") {
      const third = pathname.codePointAt(n82 + 2) || 32;
      if (pathname[n82 + 1] === "2" && third === 102) {
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL(filepath) {
  let resolved = exports32.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH || isWindows && filePathLast === CHAR_BACKWARD_SLASH) && resolved[resolved.length - 1] !== exports32.sep) {
    resolved += "/";
  }
  const outURL = new URL("file://");
  if (resolved.includes("%"))
    resolved = resolved.replace(percentRegEx, "%25");
  if (!isWindows && resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx, "%5C");
  }
  if (resolved.includes("\n"))
    resolved = resolved.replace(newlineRegEx, "%0A");
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx, "%0D");
  }
  if (resolved.includes("	"))
    resolved = resolved.replace(tabRegEx, "%09");
  outURL.pathname = resolved;
  return outURL;
}
function dew$22() {
  if (_dewExec$22)
    return exports$32;
  _dewExec$22 = true;
  exports$32.byteLength = byteLength;
  exports$32.toByteArray = toByteArray;
  exports$32.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i72 = 0, len = code.length; i72 < len; ++i72) {
    lookup[i72] = code[i72];
    revLookup[code.charCodeAt(i72)] = i72;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i82;
    for (i82 = 0; i82 < len2; i82 += 4) {
      tmp = revLookup[b64.charCodeAt(i82)] << 18 | revLookup[b64.charCodeAt(i82 + 1)] << 12 | revLookup[b64.charCodeAt(i82 + 2)] << 6 | revLookup[b64.charCodeAt(i82 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i82)] << 2 | revLookup[b64.charCodeAt(i82 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i82)] << 10 | revLookup[b64.charCodeAt(i82 + 1)] << 4 | revLookup[b64.charCodeAt(i82 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i82 = start; i82 < end; i82 += 3) {
      tmp = (uint8[i82] << 16 & 16711680) + (uint8[i82 + 1] << 8 & 65280) + (uint8[i82 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i82 = 0, len22 = len2 - extraBytes; i82 < len22; i82 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i82, i82 + maxChunkLength > len22 ? len22 : i82 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  return exports$32;
}
function dew$12() {
  if (_dewExec$12)
    return exports$22;
  _dewExec$12 = true;
  exports$22.read = function(buffer22, offset, isLE, mLen, nBytes) {
    var e92, m62;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i72 = isLE ? nBytes - 1 : 0;
    var d62 = isLE ? -1 : 1;
    var s62 = buffer22[offset + i72];
    i72 += d62;
    e92 = s62 & (1 << -nBits) - 1;
    s62 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e92 = e92 * 256 + buffer22[offset + i72], i72 += d62, nBits -= 8) {
    }
    m62 = e92 & (1 << -nBits) - 1;
    e92 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m62 = m62 * 256 + buffer22[offset + i72], i72 += d62, nBits -= 8) {
    }
    if (e92 === 0) {
      e92 = 1 - eBias;
    } else if (e92 === eMax) {
      return m62 ? NaN : (s62 ? -1 : 1) * Infinity;
    } else {
      m62 = m62 + Math.pow(2, mLen);
      e92 = e92 - eBias;
    }
    return (s62 ? -1 : 1) * m62 * Math.pow(2, e92 - mLen);
  };
  exports$22.write = function(buffer22, value, offset, isLE, mLen, nBytes) {
    var e92, m62, c72;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i72 = isLE ? 0 : nBytes - 1;
    var d62 = isLE ? 1 : -1;
    var s62 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m62 = isNaN(value) ? 1 : 0;
      e92 = eMax;
    } else {
      e92 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c72 = Math.pow(2, -e92)) < 1) {
        e92--;
        c72 *= 2;
      }
      if (e92 + eBias >= 1) {
        value += rt / c72;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c72 >= 2) {
        e92++;
        c72 /= 2;
      }
      if (e92 + eBias >= eMax) {
        m62 = 0;
        e92 = eMax;
      } else if (e92 + eBias >= 1) {
        m62 = (value * c72 - 1) * Math.pow(2, mLen);
        e92 = e92 + eBias;
      } else {
        m62 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e92 = 0;
      }
    }
    for (; mLen >= 8; buffer22[offset + i72] = m62 & 255, i72 += d62, m62 /= 256, mLen -= 8) {
    }
    e92 = e92 << mLen | m62;
    eLen += mLen;
    for (; eLen > 0; buffer22[offset + i72] = e92 & 255, i72 += d62, e92 /= 256, eLen -= 8) {
    }
    buffer22[offset + i72 - d62] |= s62 * 128;
  };
  return exports$22;
}
function dew6() {
  if (_dewExec6)
    return exports$14;
  _dewExec6 = true;
  const base64 = dew$22();
  const ieee754 = dew$12();
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$14.Buffer = Buffer22;
  exports$14.SlowBuffer = SlowBuffer;
  exports$14.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$14.kMaxLength = K_MAX_LENGTH;
  Buffer22.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer22.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e92) {
      return false;
    }
  }
  Object.defineProperty(Buffer22.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer22.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer22.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer22.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer22.prototype);
    return buf;
  }
  function Buffer22(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer22.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer22.from(valueOf, encodingOrOffset, length);
    }
    const b52 = fromObject(value);
    if (b52)
      return b52;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer22.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer22.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer22.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer22, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer22.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer22.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer22.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer22.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i72 = 0; i72 < length; i72 += 1) {
      buf[i72] = array[i72] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer22.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer22.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer22.alloc(+length);
  }
  Buffer22.isBuffer = function isBuffer32(b52) {
    return b52 != null && b52._isBuffer === true && b52 !== Buffer22.prototype;
  };
  Buffer22.compare = function compare(a72, b52) {
    if (isInstance(a72, Uint8Array))
      a72 = Buffer22.from(a72, a72.offset, a72.byteLength);
    if (isInstance(b52, Uint8Array))
      b52 = Buffer22.from(b52, b52.offset, b52.byteLength);
    if (!Buffer22.isBuffer(a72) || !Buffer22.isBuffer(b52)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a72 === b52)
      return 0;
    let x42 = a72.length;
    let y62 = b52.length;
    for (let i72 = 0, len = Math.min(x42, y62); i72 < len; ++i72) {
      if (a72[i72] !== b52[i72]) {
        x42 = a72[i72];
        y62 = b52[i72];
        break;
      }
    }
    if (x42 < y62)
      return -1;
    if (y62 < x42)
      return 1;
    return 0;
  };
  Buffer22.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer22.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer22.alloc(0);
    }
    let i72;
    if (length === void 0) {
      length = 0;
      for (i72 = 0; i72 < list.length; ++i72) {
        length += list[i72].length;
      }
    }
    const buffer22 = Buffer22.allocUnsafe(length);
    let pos = 0;
    for (i72 = 0; i72 < list.length; ++i72) {
      let buf = list[i72];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer22.length) {
          if (!Buffer22.isBuffer(buf))
            buf = Buffer22.from(buf);
          buf.copy(buffer22, pos);
        } else {
          Uint8Array.prototype.set.call(buffer22, buf, pos);
        }
      } else if (!Buffer22.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer22, pos);
      }
      pos += buf.length;
    }
    return buffer22;
  };
  function byteLength(string, encoding) {
    if (Buffer22.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer22.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer22.prototype._isBuffer = true;
  function swap(b52, n82, m62) {
    const i72 = b52[n82];
    b52[n82] = b52[m62];
    b52[m62] = i72;
  }
  Buffer22.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i72 = 0; i72 < len; i72 += 2) {
      swap(this, i72, i72 + 1);
    }
    return this;
  };
  Buffer22.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i72 = 0; i72 < len; i72 += 4) {
      swap(this, i72, i72 + 3);
      swap(this, i72 + 1, i72 + 2);
    }
    return this;
  };
  Buffer22.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i72 = 0; i72 < len; i72 += 8) {
      swap(this, i72, i72 + 7);
      swap(this, i72 + 1, i72 + 6);
      swap(this, i72 + 2, i72 + 5);
      swap(this, i72 + 3, i72 + 4);
    }
    return this;
  };
  Buffer22.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer22.prototype.toLocaleString = Buffer22.prototype.toString;
  Buffer22.prototype.equals = function equals(b52) {
    if (!Buffer22.isBuffer(b52))
      throw new TypeError("Argument must be a Buffer");
    if (this === b52)
      return true;
    return Buffer22.compare(this, b52) === 0;
  };
  Buffer22.prototype.inspect = function inspect32() {
    let str = "";
    const max = exports$14.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer22.prototype[customInspectSymbol] = Buffer22.prototype.inspect;
  }
  Buffer22.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer22.from(target, target.offset, target.byteLength);
    }
    if (!Buffer22.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x42 = thisEnd - thisStart;
    let y62 = end - start;
    const len = Math.min(x42, y62);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i72 = 0; i72 < len; ++i72) {
      if (thisCopy[i72] !== targetCopy[i72]) {
        x42 = thisCopy[i72];
        y62 = targetCopy[i72];
        break;
      }
    }
    if (x42 < y62)
      return -1;
    if (y62 < x42)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer22, val, byteOffset, encoding, dir) {
    if (buffer22.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer22.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer22.length + byteOffset;
    if (byteOffset >= buffer22.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer22.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer22.from(val, encoding);
    }
    if (Buffer22.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer22, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer22, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer22, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer22, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i82) {
      if (indexSize === 1) {
        return buf[i82];
      } else {
        return buf.readUInt16BE(i82 * indexSize);
      }
    }
    let i72;
    if (dir) {
      let foundIndex = -1;
      for (i72 = byteOffset; i72 < arrLength; i72++) {
        if (read2(arr, i72) === read2(val, foundIndex === -1 ? 0 : i72 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i72;
          if (i72 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i72 -= i72 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i72 = byteOffset; i72 >= 0; i72--) {
        let found = true;
        for (let j42 = 0; j42 < valLength; j42++) {
          if (read2(arr, i72 + j42) !== read2(val, j42)) {
            found = false;
            break;
          }
        }
        if (found)
          return i72;
      }
    }
    return -1;
  }
  Buffer22.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer22.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer22.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i72;
    for (i72 = 0; i72 < length; ++i72) {
      const parsed = parseInt(string.substr(i72 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i72;
      buf[offset + i72] = parsed;
    }
    return i72;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer22.prototype.write = function write2(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer22.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i72 = start;
    while (i72 < end) {
      const firstByte = buf[i72];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i72 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i72 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i72 + 1];
            thirdByte = buf[i72 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i72 + 1];
            thirdByte = buf[i72 + 2];
            fourthByte = buf[i72 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i72 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i72 = 0;
    while (i72 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i72, i72 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i72 = start; i72 < end; ++i72) {
      ret += String.fromCharCode(buf[i72] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i72 = start; i72 < end; ++i72) {
      ret += String.fromCharCode(buf[i72]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i72 = start; i72 < end; ++i72) {
      out += hexSliceLookupTable[buf[i72]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i72 = 0; i72 < bytes.length - 1; i72 += 2) {
      res += String.fromCharCode(bytes[i72] + bytes[i72 + 1] * 256);
    }
    return res;
  }
  Buffer22.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer22.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer22.prototype.readUintLE = Buffer22.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i72 = 0;
    while (++i72 < byteLength2 && (mul *= 256)) {
      val += this[offset + i72] * mul;
    }
    return val;
  };
  Buffer22.prototype.readUintBE = Buffer22.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    let val = this[offset + --byteLength2];
    let mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer22.prototype.readUint8 = Buffer22.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer22.prototype.readUint16LE = Buffer22.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer22.prototype.readUint16BE = Buffer22.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer22.prototype.readUint32LE = Buffer22.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer22.prototype.readUint32BE = Buffer22.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer22.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer22.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer22.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i72 = 0;
    while (++i72 < byteLength2 && (mul *= 256)) {
      val += this[offset + i72] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer22.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let i72 = byteLength2;
    let mul = 1;
    let val = this[offset + --i72];
    while (i72 > 0 && (mul *= 256)) {
      val += this[offset + --i72] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer22.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer22.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer22.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer22.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer22.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer22.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer22.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer22.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer22.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer22.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer22.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer22.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer22.prototype.writeUintLE = Buffer22.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1;
    let i72 = 0;
    this[offset] = value & 255;
    while (++i72 < byteLength2 && (mul *= 256)) {
      this[offset + i72] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer22.prototype.writeUintBE = Buffer22.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i72 = byteLength2 - 1;
    let mul = 1;
    this[offset + i72] = value & 255;
    while (--i72 >= 0 && (mul *= 256)) {
      this[offset + i72] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer22.prototype.writeUint8 = Buffer22.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer22.prototype.writeUint16LE = Buffer22.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer22.prototype.writeUint16BE = Buffer22.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer22.prototype.writeUint32LE = Buffer22.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer22.prototype.writeUint32BE = Buffer22.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer22.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer22.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer22.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i72 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i72 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i72 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i72] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer22.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i72 = byteLength2 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i72] = value & 255;
    while (--i72 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i72 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i72] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer22.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer22.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer22.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer22.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer22.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer22.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer22.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer22.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer22.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer22.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer22.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer22.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer22.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer22.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer22.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code = val.charCodeAt(0);
        if (encoding === "utf8" && code < 128 || encoding === "latin1") {
          val = code;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i72;
    if (typeof val === "number") {
      for (i72 = start; i72 < end; ++i72) {
        this[i72] = val;
      }
    } else {
      const bytes = Buffer22.isBuffer(val) ? val : Buffer22.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i72 = 0; i72 < end - start; ++i72) {
        this[i72 + start] = bytes[i72 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E42(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E42("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
    if (name2) {
      return `${name2} is outside of buffer bounds`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E42("ERR_INVALID_ARG_TYPE", function(name2, actual) {
    return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  E42("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i72 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i72 >= start + 4; i72 -= 3) {
      res = `_${val.slice(i72 - 3, i72)}${res}`;
    }
    return `${val.slice(0, i72)}${res}`;
  }
  function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
      boundsError(offset, buf.length - (byteLength2 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
      const n82 = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength2 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n82} and < 2${n82} ** ${(byteLength2 + 1) * 8}${n82}`;
        } else {
          range = `>= -(2${n82} ** ${(byteLength2 + 1) * 8 - 1}${n82}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n82}`;
        }
      } else {
        range = `>= ${min}${n82} and <= ${max}${n82}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", `>= ${type2 ? 1 : 0} and <= ${length}`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i72 = 0; i72 < length; ++i72) {
      codePoint = string.charCodeAt(i72);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i72 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i72 = 0; i72 < str.length; ++i72) {
      byteArray.push(str.charCodeAt(i72) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c72, hi, lo;
    const byteArray = [];
    for (let i72 = 0; i72 < str.length; ++i72) {
      if ((units -= 2) < 0)
        break;
      c72 = str.charCodeAt(i72);
      hi = c72 >> 8;
      lo = c72 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i72;
    for (i72 = 0; i72 < length; ++i72) {
      if (i72 + offset >= dst.length || i72 >= src.length)
        break;
      dst[i72 + offset] = src[i72];
    }
    return i72;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i72 = 0; i72 < 16; ++i72) {
      const i16 = i72 * 16;
      for (let j42 = 0; j42 < 16; ++j42) {
        table[i16 + j42] = alphabet[i72] + alphabet[j42];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
  return exports$14;
}
function dew$f2() {
  if (_dewExec$f2)
    return exports$h;
  _dewExec$f2 = true;
  Object.defineProperty(exports$h, "__esModule", {
    value: true
  });
  exports$h.constants = void 0;
  exports$h.constants = {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 64,
    O_EXCL: 128,
    O_NOCTTY: 256,
    O_TRUNC: 512,
    O_APPEND: 1024,
    O_DIRECTORY: 65536,
    O_NOATIME: 262144,
    O_NOFOLLOW: 131072,
    O_SYNC: 1052672,
    O_DIRECT: 16384,
    O_NONBLOCK: 2048,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    UV_FS_COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_EXCL: 1,
    COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE_FORCE: 4
  };
  return exports$h;
}
function dew$e2() {
  if (_dewExec$e2)
    return exports$g2;
  _dewExec$e2 = true;
  if (typeof BigInt === "function")
    exports$g2.default = BigInt;
  else
    exports$g2.default = function BigIntNotSupported() {
      throw new Error("BigInt is not supported in this environment.");
    };
  return exports$g2;
}
function dew$d2() {
  if (_dewExec$d2)
    return exports$f2;
  _dewExec$d2 = true;
  Object.defineProperty(exports$f2, "__esModule", {
    value: true
  });
  exports$f2.Stats = void 0;
  var constants_1 = dew$f2();
  var getBigInt_1 = dew$e2();
  var S_IFMT2 = constants_1.constants.S_IFMT, S_IFDIR2 = constants_1.constants.S_IFDIR, S_IFREG2 = constants_1.constants.S_IFREG, S_IFBLK2 = constants_1.constants.S_IFBLK, S_IFCHR2 = constants_1.constants.S_IFCHR, S_IFLNK2 = constants_1.constants.S_IFLNK, S_IFIFO2 = constants_1.constants.S_IFIFO, S_IFSOCK2 = constants_1.constants.S_IFSOCK;
  var Stats2 = function() {
    function Stats3() {
    }
    Stats3.build = function(node, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }
      var stats = new Stats3();
      var uid = node.uid, gid = node.gid, atime = node.atime, mtime = node.mtime, ctime = node.ctime;
      var getStatNumber = !bigint ? function(number) {
        return number;
      } : getBigInt_1.default;
      stats.uid = getStatNumber(uid);
      stats.gid = getStatNumber(gid);
      stats.rdev = getStatNumber(0);
      stats.blksize = getStatNumber(4096);
      stats.ino = getStatNumber(node.ino);
      stats.size = getStatNumber(node.getSize());
      stats.blocks = getStatNumber(1);
      stats.atime = atime;
      stats.mtime = mtime;
      stats.ctime = ctime;
      stats.birthtime = ctime;
      stats.atimeMs = getStatNumber(atime.getTime());
      stats.mtimeMs = getStatNumber(mtime.getTime());
      var ctimeMs = getStatNumber(ctime.getTime());
      stats.ctimeMs = ctimeMs;
      stats.birthtimeMs = ctimeMs;
      stats.dev = getStatNumber(0);
      stats.mode = getStatNumber(node.mode);
      stats.nlink = getStatNumber(node.nlink);
      return stats;
    };
    Stats3.prototype._checkModeProperty = function(property) {
      return (Number(this.mode) & S_IFMT2) === property;
    };
    Stats3.prototype.isDirectory = function() {
      return this._checkModeProperty(S_IFDIR2);
    };
    Stats3.prototype.isFile = function() {
      return this._checkModeProperty(S_IFREG2);
    };
    Stats3.prototype.isBlockDevice = function() {
      return this._checkModeProperty(S_IFBLK2);
    };
    Stats3.prototype.isCharacterDevice = function() {
      return this._checkModeProperty(S_IFCHR2);
    };
    Stats3.prototype.isSymbolicLink = function() {
      return this._checkModeProperty(S_IFLNK2);
    };
    Stats3.prototype.isFIFO = function() {
      return this._checkModeProperty(S_IFIFO2);
    };
    Stats3.prototype.isSocket = function() {
      return this._checkModeProperty(S_IFSOCK2);
    };
    return Stats3;
  }();
  exports$f2.Stats = Stats2;
  exports$f2.default = Stats2;
  return exports$f2;
}
function dew$c2() {
  if (_dewExec$c2)
    return exports$e2;
  _dewExec$c2 = true;
  var __spreadArray = exports$e2 && exports$e2.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i72 = 0, l72 = from.length, ar; i72 < l72; i72++) {
        if (ar || !(i72 in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i72);
          ar[i72] = from[i72];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports$e2, "__esModule", {
    value: true
  });
  exports$e2.bufferFrom = exports$e2.bufferAllocUnsafe = exports$e2.Buffer = void 0;
  var buffer_1 = buffer;
  Object.defineProperty(exports$e2, "Buffer", {
    enumerable: true,
    get: function() {
      return buffer_1.Buffer;
    }
  });
  function bufferV0P12Ponyfill(arg0) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    return new (buffer_1.Buffer.bind.apply(buffer_1.Buffer, __spreadArray([void 0, arg0], args, false)))();
  }
  var bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
  exports$e2.bufferAllocUnsafe = bufferAllocUnsafe;
  var bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
  exports$e2.bufferFrom = bufferFrom;
  return exports$e2;
}
function dew$b2() {
  if (_dewExec$b2)
    return exports$d2;
  _dewExec$b2 = true;
  var __extends = exports$d2 && exports$d2.__extends || function() {
    var extendStatics = function(d62, b52) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d72, b62) {
        d72.__proto__ = b62;
      } || function(d72, b62) {
        for (var p72 in b62)
          if (Object.prototype.hasOwnProperty.call(b62, p72))
            d72[p72] = b62[p72];
      };
      return extendStatics(d62, b52);
    };
    return function(d62, b52) {
      if (typeof b52 !== "function" && b52 !== null)
        throw new TypeError("Class extends value " + String(b52) + " is not a constructor or null");
      extendStatics(d62, b52);
      function __() {
        this.constructor = d62;
      }
      d62.prototype = b52 === null ? Object.create(b52) : (__.prototype = b52.prototype, new __());
    };
  }();
  Object.defineProperty(exports$d2, "__esModule", {
    value: true
  });
  exports$d2.E = exports$d2.AssertionError = exports$d2.message = exports$d2.RangeError = exports$d2.TypeError = exports$d2.Error = void 0;
  var assert = et;
  var util = X;
  var kCode = typeof Symbol === "undefined" ? "_kCode" : Symbol("code");
  var messages = {};
  function makeNodeError(Base) {
    return function(_super) {
      __extends(NodeError, _super);
      function NodeError(key) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var _this = _super.call(this, message(key, args)) || this;
        _this.code = key;
        _this[kCode] = key;
        _this.name = _super.prototype.name + " [" + _this[kCode] + "]";
        return _this;
      }
      return NodeError;
    }(Base);
  }
  var g52 = typeof globalThis !== "undefined" ? globalThis : _global$3;
  var AssertionError22 = function(_super) {
    __extends(AssertionError3, _super);
    function AssertionError3(options) {
      var _this = this;
      if (typeof options !== "object" || options === null) {
        throw new exports$d2.TypeError("ERR_INVALID_ARG_TYPE", "options", "object");
      }
      if (options.message) {
        _this = _super.call(this, options.message) || this;
      } else {
        _this = _super.call(this, util.inspect(options.actual).slice(0, 128) + " " + (options.operator + " " + util.inspect(options.expected).slice(0, 128))) || this;
      }
      _this.generatedMessage = !options.message;
      _this.name = "AssertionError [ERR_ASSERTION]";
      _this.code = "ERR_ASSERTION";
      _this.actual = options.actual;
      _this.expected = options.expected;
      _this.operator = options.operator;
      exports$d2.Error.captureStackTrace(_this, options.stackStartFunction);
      return _this;
    }
    return AssertionError3;
  }(g52.Error);
  exports$d2.AssertionError = AssertionError22;
  function message(key, args) {
    assert.strictEqual(typeof key, "string");
    var msg = messages[key];
    assert(msg, "An invalid error message key was used: " + key + ".");
    var fmt;
    if (typeof msg === "function") {
      fmt = msg;
    } else {
      fmt = util.format;
      if (args === void 0 || args.length === 0)
        return msg;
      args.unshift(msg);
    }
    return String(fmt.apply(null, args));
  }
  exports$d2.message = message;
  function E42(sym, val) {
    messages[sym] = typeof val === "function" ? val : String(val);
  }
  exports$d2.E = E42;
  exports$d2.Error = makeNodeError(g52.Error);
  exports$d2.TypeError = makeNodeError(g52.TypeError);
  exports$d2.RangeError = makeNodeError(g52.RangeError);
  E42("ERR_ARG_NOT_ITERABLE", "%s must be iterable");
  E42("ERR_ASSERTION", "%s");
  E42("ERR_BUFFER_OUT_OF_BOUNDS", bufferOutOfBounds);
  E42("ERR_CHILD_CLOSED_BEFORE_REPLY", "Child closed before reply received");
  E42("ERR_CONSOLE_WRITABLE_STREAM", "Console expects a writable stream instance for %s");
  E42("ERR_CPU_USAGE", "Unable to obtain cpu usage %s");
  E42("ERR_DNS_SET_SERVERS_FAILED", function(err, servers) {
    return 'c-ares failed to set servers: "' + err + '" [' + servers + "]";
  });
  E42("ERR_FALSY_VALUE_REJECTION", "Promise was rejected with falsy value");
  E42("ERR_ENCODING_NOT_SUPPORTED", function(enc) {
    return 'The "' + enc + '" encoding is not supported';
  });
  E42("ERR_ENCODING_INVALID_ENCODED_DATA", function(enc) {
    return "The encoded data was not valid for encoding " + enc;
  });
  E42("ERR_HTTP_HEADERS_SENT", "Cannot render headers after they are sent to the client");
  E42("ERR_HTTP_INVALID_STATUS_CODE", "Invalid status code: %s");
  E42("ERR_HTTP_TRAILER_INVALID", "Trailers are invalid with this transfer encoding");
  E42("ERR_INDEX_OUT_OF_RANGE", "Index out of range");
  E42("ERR_INVALID_ARG_TYPE", invalidArgType);
  E42("ERR_INVALID_ARRAY_LENGTH", function(name2, len, actual) {
    assert.strictEqual(typeof actual, "number");
    return 'The array "' + name2 + '" (length ' + actual + ") must be of length " + len + ".";
  });
  E42("ERR_INVALID_BUFFER_SIZE", "Buffer size must be a multiple of %s");
  E42("ERR_INVALID_CALLBACK", "Callback must be a function");
  E42("ERR_INVALID_CHAR", "Invalid character in %s");
  E42("ERR_INVALID_CURSOR_POS", "Cannot set cursor row without setting its column");
  E42("ERR_INVALID_FD", '"fd" must be a positive integer: %s');
  E42("ERR_INVALID_FILE_URL_HOST", 'File URL host must be "localhost" or empty on %s');
  E42("ERR_INVALID_FILE_URL_PATH", "File URL path %s");
  E42("ERR_INVALID_HANDLE_TYPE", "This handle type cannot be sent");
  E42("ERR_INVALID_IP_ADDRESS", "Invalid IP address: %s");
  E42("ERR_INVALID_OPT_VALUE", function(name2, value) {
    return 'The value "' + String(value) + '" is invalid for option "' + name2 + '"';
  });
  E42("ERR_INVALID_OPT_VALUE_ENCODING", function(value) {
    return 'The value "' + String(value) + '" is invalid for option "encoding"';
  });
  E42("ERR_INVALID_REPL_EVAL_CONFIG", 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL');
  E42("ERR_INVALID_SYNC_FORK_INPUT", "Asynchronous forks do not support Buffer, Uint8Array or string input: %s");
  E42("ERR_INVALID_THIS", 'Value of "this" must be of type %s');
  E42("ERR_INVALID_TUPLE", "%s must be an iterable %s tuple");
  E42("ERR_INVALID_URL", "Invalid URL: %s");
  E42("ERR_INVALID_URL_SCHEME", function(expected) {
    return "The URL must be " + oneOf(expected, "scheme");
  });
  E42("ERR_IPC_CHANNEL_CLOSED", "Channel closed");
  E42("ERR_IPC_DISCONNECTED", "IPC channel is already disconnected");
  E42("ERR_IPC_ONE_PIPE", "Child process can have only one IPC pipe");
  E42("ERR_IPC_SYNC_FORK", "IPC cannot be used with synchronous forks");
  E42("ERR_MISSING_ARGS", missingArgs);
  E42("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  E42("ERR_NAPI_CONS_FUNCTION", "Constructor must be a function");
  E42("ERR_NAPI_CONS_PROTOTYPE_OBJECT", "Constructor.prototype must be an object");
  E42("ERR_NO_CRYPTO", "Node.js is not compiled with OpenSSL crypto support");
  E42("ERR_NO_LONGER_SUPPORTED", "%s is no longer supported");
  E42("ERR_PARSE_HISTORY_DATA", "Could not parse history data in %s");
  E42("ERR_SOCKET_ALREADY_BOUND", "Socket is already bound");
  E42("ERR_SOCKET_BAD_PORT", "Port should be > 0 and < 65536");
  E42("ERR_SOCKET_BAD_TYPE", "Bad socket type specified. Valid types are: udp4, udp6");
  E42("ERR_SOCKET_CANNOT_SEND", "Unable to send data");
  E42("ERR_SOCKET_CLOSED", "Socket is closed");
  E42("ERR_SOCKET_DGRAM_NOT_RUNNING", "Not running");
  E42("ERR_STDERR_CLOSE", "process.stderr cannot be closed");
  E42("ERR_STDOUT_CLOSE", "process.stdout cannot be closed");
  E42("ERR_STREAM_WRAP", "Stream has StringDecoder set or is in objectMode");
  E42("ERR_TLS_CERT_ALTNAME_INVALID", "Hostname/IP does not match certificate's altnames: %s");
  E42("ERR_TLS_DH_PARAM_SIZE", function(size) {
    return "DH parameter size " + size + " is less than 2048";
  });
  E42("ERR_TLS_HANDSHAKE_TIMEOUT", "TLS handshake timeout");
  E42("ERR_TLS_RENEGOTIATION_FAILED", "Failed to renegotiate");
  E42("ERR_TLS_REQUIRED_SERVER_NAME", '"servername" is required parameter for Server.addContext');
  E42("ERR_TLS_SESSION_ATTACK", "TSL session renegotiation attack detected");
  E42("ERR_TRANSFORM_ALREADY_TRANSFORMING", "Calling transform done when still transforming");
  E42("ERR_TRANSFORM_WITH_LENGTH_0", "Calling transform done when writableState.length != 0");
  E42("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s");
  E42("ERR_UNKNOWN_SIGNAL", "Unknown signal: %s");
  E42("ERR_UNKNOWN_STDIN_TYPE", "Unknown stdin file type");
  E42("ERR_UNKNOWN_STREAM_TYPE", "Unknown stream file type");
  E42("ERR_V8BREAKITERATOR", "Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl");
  function invalidArgType(name2, expected, actual) {
    assert(name2, "name is required");
    var determiner;
    if (expected.includes("not ")) {
      determiner = "must not be";
      expected = expected.split("not ")[1];
    } else {
      determiner = "must be";
    }
    var msg;
    if (Array.isArray(name2)) {
      var names = name2.map(function(val) {
        return '"' + val + '"';
      }).join(", ");
      msg = "The " + names + " arguments " + determiner + " " + oneOf(expected, "type");
    } else if (name2.includes(" argument")) {
      msg = "The " + name2 + " " + determiner + " " + oneOf(expected, "type");
    } else {
      var type2 = name2.includes(".") ? "property" : "argument";
      msg = 'The "' + name2 + '" ' + type2 + " " + determiner + " " + oneOf(expected, "type");
    }
    if (arguments.length >= 3) {
      msg += ". Received type " + (actual !== null ? typeof actual : "null");
    }
    return msg;
  }
  function missingArgs() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    assert(args.length > 0, "At least one arg needs to be specified");
    var msg = "The ";
    var len = args.length;
    args = args.map(function(a72) {
      return '"' + a72 + '"';
    });
    switch (len) {
      case 1:
        msg += args[0] + " argument";
        break;
      case 2:
        msg += args[0] + " and " + args[1] + " arguments";
        break;
      default:
        msg += args.slice(0, len - 1).join(", ");
        msg += ", and " + args[len - 1] + " arguments";
        break;
    }
    return msg + " must be specified";
  }
  function oneOf(expected, thing) {
    assert(expected, "expected is required");
    assert(typeof thing === "string", "thing is required");
    if (Array.isArray(expected)) {
      var len = expected.length;
      assert(len > 0, "At least one expected value needs to be specified");
      expected = expected.map(function(i72) {
        return String(i72);
      });
      if (len > 2) {
        return "one of " + thing + " " + expected.slice(0, len - 1).join(", ") + ", or " + expected[len - 1];
      } else if (len === 2) {
        return "one of " + thing + " " + expected[0] + " or " + expected[1];
      } else {
        return "of " + thing + " " + expected[0];
      }
    } else {
      return "of " + thing + " " + String(expected);
    }
  }
  function bufferOutOfBounds(name2, isWriting) {
    if (isWriting) {
      return "Attempt to write outside buffer bounds";
    } else {
      return '"' + name2 + '" is outside of buffer bounds';
    }
  }
  return exports$d2;
}
function dew$a2() {
  if (_dewExec$a2)
    return exports$c2;
  _dewExec$a2 = true;
  Object.defineProperty(exports$c2, "__esModule", {
    value: true
  });
  exports$c2.strToEncoding = exports$c2.assertEncoding = exports$c2.ENCODING_UTF8 = void 0;
  var buffer_1 = dew$c2();
  var errors = dew$b2();
  exports$c2.ENCODING_UTF8 = "utf8";
  function assertEncoding(encoding) {
    if (encoding && !buffer_1.Buffer.isEncoding(encoding))
      throw new errors.TypeError("ERR_INVALID_OPT_VALUE_ENCODING", encoding);
  }
  exports$c2.assertEncoding = assertEncoding;
  function strToEncoding(str, encoding) {
    if (!encoding || encoding === exports$c2.ENCODING_UTF8)
      return str;
    if (encoding === "buffer")
      return new buffer_1.Buffer(str);
    return new buffer_1.Buffer(str).toString(encoding);
  }
  exports$c2.strToEncoding = strToEncoding;
  return exports$c2;
}
function dew$92() {
  if (_dewExec$92)
    return exports$b2;
  _dewExec$92 = true;
  Object.defineProperty(exports$b2, "__esModule", {
    value: true
  });
  exports$b2.Dirent = void 0;
  var constants_1 = dew$f2();
  var encoding_1 = dew$a2();
  var S_IFMT2 = constants_1.constants.S_IFMT, S_IFDIR2 = constants_1.constants.S_IFDIR, S_IFREG2 = constants_1.constants.S_IFREG, S_IFBLK2 = constants_1.constants.S_IFBLK, S_IFCHR2 = constants_1.constants.S_IFCHR, S_IFLNK2 = constants_1.constants.S_IFLNK, S_IFIFO2 = constants_1.constants.S_IFIFO, S_IFSOCK2 = constants_1.constants.S_IFSOCK;
  var Dirent2 = function() {
    function Dirent3() {
      this.name = "";
      this.mode = 0;
    }
    Dirent3.build = function(link2, encoding) {
      var dirent = new Dirent3();
      var mode = link2.getNode().mode;
      dirent.name = (0, encoding_1.strToEncoding)(link2.getName(), encoding);
      dirent.mode = mode;
      return dirent;
    };
    Dirent3.prototype._checkModeProperty = function(property) {
      return (this.mode & S_IFMT2) === property;
    };
    Dirent3.prototype.isDirectory = function() {
      return this._checkModeProperty(S_IFDIR2);
    };
    Dirent3.prototype.isFile = function() {
      return this._checkModeProperty(S_IFREG2);
    };
    Dirent3.prototype.isBlockDevice = function() {
      return this._checkModeProperty(S_IFBLK2);
    };
    Dirent3.prototype.isCharacterDevice = function() {
      return this._checkModeProperty(S_IFCHR2);
    };
    Dirent3.prototype.isSymbolicLink = function() {
      return this._checkModeProperty(S_IFLNK2);
    };
    Dirent3.prototype.isFIFO = function() {
      return this._checkModeProperty(S_IFIFO2);
    };
    Dirent3.prototype.isSocket = function() {
      return this._checkModeProperty(S_IFSOCK2);
    };
    return Dirent3;
  }();
  exports$b2.Dirent = Dirent2;
  exports$b2.default = Dirent2;
  return exports$b2;
}
function dew$82() {
  if (_dewExec$82)
    return exports$a2;
  _dewExec$82 = true;
  var process$1 = process3;
  Object.defineProperty(exports$a2, "__esModule", {
    value: true
  });
  var _setImmediate;
  if (typeof process$1.nextTick === "function")
    _setImmediate = process$1.nextTick.bind(typeof globalThis !== "undefined" ? globalThis : _global$22);
  else
    _setImmediate = setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : _global$22);
  exports$a2.default = _setImmediate;
  return exports$a2;
}
function dew$72() {
  if (_dewExec$72)
    return exports$92;
  _dewExec$72 = true;
  var process$1 = process3;
  Object.defineProperty(exports$92, "__esModule", {
    value: true
  });
  exports$92.createProcess = void 0;
  var maybeReturnProcess = function() {
    if (typeof process$1 !== "undefined") {
      return process$1;
    }
    try {
      return process3;
    } catch (_a) {
      return void 0;
    }
  };
  function createProcess() {
    var p72 = maybeReturnProcess() || {};
    if (!p72.getuid)
      p72.getuid = function() {
        return 0;
      };
    if (!p72.getgid)
      p72.getgid = function() {
        return 0;
      };
    if (!p72.cwd)
      p72.cwd = function() {
        return "/";
      };
    if (!p72.nextTick)
      p72.nextTick = dew$82().default;
    if (!p72.emitWarning)
      p72.emitWarning = function(message, type2) {
        console.warn("" + type2 + (type2 ? ": " : "") + message);
      };
    if (!p72.env)
      p72.env = {};
    return p72;
  }
  exports$92.createProcess = createProcess;
  exports$92.default = createProcess();
  return exports$92;
}
function dew$62() {
  if (_dewExec$62)
    return exports$82;
  _dewExec$62 = true;
  var __extends = exports$82 && exports$82.__extends || function() {
    var extendStatics = function(d62, b52) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d72, b62) {
        d72.__proto__ = b62;
      } || function(d72, b62) {
        for (var p72 in b62)
          if (Object.prototype.hasOwnProperty.call(b62, p72))
            d72[p72] = b62[p72];
      };
      return extendStatics(d62, b52);
    };
    return function(d62, b52) {
      if (typeof b52 !== "function" && b52 !== null)
        throw new TypeError("Class extends value " + String(b52) + " is not a constructor or null");
      extendStatics(d62, b52);
      function __() {
        this.constructor = d62;
      }
      d62.prototype = b52 === null ? Object.create(b52) : (__.prototype = b52.prototype, new __());
    };
  }();
  Object.defineProperty(exports$82, "__esModule", {
    value: true
  });
  exports$82.File = exports$82.Link = exports$82.Node = exports$82.SEP = void 0;
  var process_1 = dew$72();
  var buffer_1 = dew$c2();
  var constants_1 = dew$f2();
  var events_1 = y;
  var Stats_1 = dew$d2();
  var S_IFMT2 = constants_1.constants.S_IFMT, S_IFDIR2 = constants_1.constants.S_IFDIR, S_IFREG2 = constants_1.constants.S_IFREG, S_IFLNK2 = constants_1.constants.S_IFLNK, O_APPEND2 = constants_1.constants.O_APPEND;
  exports$82.SEP = "/";
  var Node = function(_super) {
    __extends(Node2, _super);
    function Node2(ino, perm) {
      if (perm === void 0) {
        perm = 438;
      }
      var _this = _super.call(this) || this;
      _this.uid = process_1.default.getuid();
      _this.gid = process_1.default.getgid();
      _this.atime = /* @__PURE__ */ new Date();
      _this.mtime = /* @__PURE__ */ new Date();
      _this.ctime = /* @__PURE__ */ new Date();
      _this.perm = 438;
      _this.mode = S_IFREG2;
      _this.nlink = 1;
      _this.perm = perm;
      _this.mode |= perm;
      _this.ino = ino;
      return _this;
    }
    Node2.prototype.getString = function(encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      return this.getBuffer().toString(encoding);
    };
    Node2.prototype.setString = function(str) {
      this.buf = (0, buffer_1.bufferFrom)(str, "utf8");
      this.touch();
    };
    Node2.prototype.getBuffer = function() {
      if (!this.buf)
        this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));
      return (0, buffer_1.bufferFrom)(this.buf);
    };
    Node2.prototype.setBuffer = function(buf) {
      this.buf = (0, buffer_1.bufferFrom)(buf);
      this.touch();
    };
    Node2.prototype.getSize = function() {
      return this.buf ? this.buf.length : 0;
    };
    Node2.prototype.setModeProperty = function(property) {
      this.mode = this.mode & ~S_IFMT2 | property;
    };
    Node2.prototype.setIsFile = function() {
      this.setModeProperty(S_IFREG2);
    };
    Node2.prototype.setIsDirectory = function() {
      this.setModeProperty(S_IFDIR2);
    };
    Node2.prototype.setIsSymlink = function() {
      this.setModeProperty(S_IFLNK2);
    };
    Node2.prototype.isFile = function() {
      return (this.mode & S_IFMT2) === S_IFREG2;
    };
    Node2.prototype.isDirectory = function() {
      return (this.mode & S_IFMT2) === S_IFDIR2;
    };
    Node2.prototype.isSymlink = function() {
      return (this.mode & S_IFMT2) === S_IFLNK2;
    };
    Node2.prototype.makeSymlink = function(steps) {
      this.symlink = steps;
      this.setIsSymlink();
    };
    Node2.prototype.write = function(buf, off, len, pos) {
      if (off === void 0) {
        off = 0;
      }
      if (len === void 0) {
        len = buf.length;
      }
      if (pos === void 0) {
        pos = 0;
      }
      if (!this.buf)
        this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
      if (pos + len > this.buf.length) {
        var newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
        this.buf.copy(newBuf, 0, 0, this.buf.length);
        this.buf = newBuf;
      }
      buf.copy(this.buf, pos, off, off + len);
      this.touch();
      return len;
    };
    Node2.prototype.read = function(buf, off, len, pos) {
      if (off === void 0) {
        off = 0;
      }
      if (len === void 0) {
        len = buf.byteLength;
      }
      if (pos === void 0) {
        pos = 0;
      }
      if (!this.buf)
        this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
      var actualLen = len;
      if (actualLen > buf.byteLength) {
        actualLen = buf.byteLength;
      }
      if (actualLen + pos > this.buf.length) {
        actualLen = this.buf.length - pos;
      }
      this.buf.copy(buf, off, pos, pos + actualLen);
      return actualLen;
    };
    Node2.prototype.truncate = function(len) {
      if (len === void 0) {
        len = 0;
      }
      if (!len)
        this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
      else {
        if (!this.buf)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        if (len <= this.buf.length) {
          this.buf = this.buf.slice(0, len);
        } else {
          var buf = (0, buffer_1.bufferAllocUnsafe)(0);
          this.buf.copy(buf);
          buf.fill(0, len);
        }
      }
      this.touch();
    };
    Node2.prototype.chmod = function(perm) {
      this.perm = perm;
      this.mode = this.mode & ~511 | perm;
      this.touch();
    };
    Node2.prototype.chown = function(uid, gid) {
      this.uid = uid;
      this.gid = gid;
      this.touch();
    };
    Node2.prototype.touch = function() {
      this.mtime = /* @__PURE__ */ new Date();
      this.emit("change", this);
    };
    Node2.prototype.canRead = function(uid, gid) {
      if (uid === void 0) {
        uid = process_1.default.getuid();
      }
      if (gid === void 0) {
        gid = process_1.default.getgid();
      }
      if (this.perm & 4) {
        return true;
      }
      if (gid === this.gid) {
        if (this.perm & 32) {
          return true;
        }
      }
      if (uid === this.uid) {
        if (this.perm & 256) {
          return true;
        }
      }
      return false;
    };
    Node2.prototype.canWrite = function(uid, gid) {
      if (uid === void 0) {
        uid = process_1.default.getuid();
      }
      if (gid === void 0) {
        gid = process_1.default.getgid();
      }
      if (this.perm & 2) {
        return true;
      }
      if (gid === this.gid) {
        if (this.perm & 16) {
          return true;
        }
      }
      if (uid === this.uid) {
        if (this.perm & 128) {
          return true;
        }
      }
      return false;
    };
    Node2.prototype.del = function() {
      this.emit("delete", this);
    };
    Node2.prototype.toJSON = function() {
      return {
        ino: this.ino,
        uid: this.uid,
        gid: this.gid,
        atime: this.atime.getTime(),
        mtime: this.mtime.getTime(),
        ctime: this.ctime.getTime(),
        perm: this.perm,
        mode: this.mode,
        nlink: this.nlink,
        symlink: this.symlink,
        data: this.getString()
      };
    };
    return Node2;
  }(events_1.EventEmitter);
  exports$82.Node = Node;
  var Link = function(_super) {
    __extends(Link2, _super);
    function Link2(vol2, parent, name2) {
      var _this = _super.call(this) || this;
      _this.children = {};
      _this.steps = [];
      _this.ino = 0;
      _this.length = 0;
      _this.vol = vol2;
      _this.parent = parent;
      _this.steps = parent ? parent.steps.concat([name2]) : [name2];
      return _this;
    }
    Link2.prototype.setNode = function(node) {
      this.node = node;
      this.ino = node.ino;
    };
    Link2.prototype.getNode = function() {
      return this.node;
    };
    Link2.prototype.createChild = function(name2, node) {
      if (node === void 0) {
        node = this.vol.createNode();
      }
      var link2 = new Link2(this.vol, this, name2);
      link2.setNode(node);
      if (node.isDirectory())
        ;
      this.setChild(name2, link2);
      return link2;
    };
    Link2.prototype.setChild = function(name2, link2) {
      if (link2 === void 0) {
        link2 = new Link2(this.vol, this, name2);
      }
      this.children[name2] = link2;
      link2.parent = this;
      this.length++;
      this.emit("child:add", link2, this);
      return link2;
    };
    Link2.prototype.deleteChild = function(link2) {
      delete this.children[link2.getName()];
      this.length--;
      this.emit("child:delete", link2, this);
    };
    Link2.prototype.getChild = function(name2) {
      if (Object.hasOwnProperty.call(this.children, name2)) {
        return this.children[name2];
      }
    };
    Link2.prototype.getPath = function() {
      return this.steps.join(exports$82.SEP);
    };
    Link2.prototype.getName = function() {
      return this.steps[this.steps.length - 1];
    };
    Link2.prototype.walk = function(steps, stop, i72) {
      if (stop === void 0) {
        stop = steps.length;
      }
      if (i72 === void 0) {
        i72 = 0;
      }
      if (i72 >= steps.length)
        return this;
      if (i72 >= stop)
        return this;
      var step = steps[i72];
      var link2 = this.getChild(step);
      if (!link2)
        return null;
      return link2.walk(steps, stop, i72 + 1);
    };
    Link2.prototype.toJSON = function() {
      return {
        steps: this.steps,
        ino: this.ino,
        children: Object.keys(this.children)
      };
    };
    return Link2;
  }(events_1.EventEmitter);
  exports$82.Link = Link;
  var File = function() {
    function File2(link2, node, flags, fd) {
      this.position = 0;
      this.link = link2;
      this.node = node;
      this.flags = flags;
      this.fd = fd;
    }
    File2.prototype.getString = function(encoding) {
      return this.node.getString();
    };
    File2.prototype.setString = function(str) {
      this.node.setString(str);
    };
    File2.prototype.getBuffer = function() {
      return this.node.getBuffer();
    };
    File2.prototype.setBuffer = function(buf) {
      this.node.setBuffer(buf);
    };
    File2.prototype.getSize = function() {
      return this.node.getSize();
    };
    File2.prototype.truncate = function(len) {
      this.node.truncate(len);
    };
    File2.prototype.seekTo = function(position) {
      this.position = position;
    };
    File2.prototype.stats = function() {
      return Stats_1.default.build(this.node);
    };
    File2.prototype.write = function(buf, offset, length, position) {
      if (offset === void 0) {
        offset = 0;
      }
      if (length === void 0) {
        length = buf.length;
      }
      if (typeof position !== "number")
        position = this.position;
      if (this.flags & O_APPEND2)
        position = this.getSize();
      var bytes = this.node.write(buf, offset, length, position);
      this.position = position + bytes;
      return bytes;
    };
    File2.prototype.read = function(buf, offset, length, position) {
      if (offset === void 0) {
        offset = 0;
      }
      if (length === void 0) {
        length = buf.byteLength;
      }
      if (typeof position !== "number")
        position = this.position;
      var bytes = this.node.read(buf, offset, length, position);
      this.position = position + bytes;
      return bytes;
    };
    File2.prototype.chmod = function(perm) {
      this.node.chmod(perm);
    };
    File2.prototype.chown = function(uid, gid) {
      this.node.chown(uid, gid);
    };
    return File2;
  }();
  exports$82.File = File;
  return exports$82;
}
function dew$52() {
  if (_dewExec$52)
    return exports$72;
  _dewExec$52 = true;
  Object.defineProperty(exports$72, "__esModule", {
    value: true
  });
  function setTimeoutUnref(callback, time, args) {
    var ref = setTimeout.apply(typeof globalThis !== "undefined" ? globalThis : _global$12, arguments);
    if (ref && typeof ref === "object" && typeof ref.unref === "function")
      ref.unref();
    return ref;
  }
  exports$72.default = setTimeoutUnref;
  return exports$72;
}
function dew$42() {
  if (_dewExec$42)
    return exports$62;
  _dewExec$42 = true;
  var __spreadArray = exports$62 && exports$62.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i72 = 0, l72 = from.length, ar; i72 < l72; i72++) {
        if (ar || !(i72 in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i72);
          ar[i72] = from[i72];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports$62, "__esModule", {
    value: true
  });
  exports$62.FileHandle = void 0;
  function promisify32(vol2, fn, getResult) {
    if (getResult === void 0) {
      getResult = function(input) {
        return input;
      };
    }
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new Promise(function(resolve32, reject) {
        vol2[fn].bind(vol2).apply(void 0, __spreadArray(__spreadArray([], args, false), [function(error, result) {
          if (error)
            return reject(error);
          return resolve32(getResult(result));
        }], false));
      });
    };
  }
  var FileHandle = function() {
    function FileHandle2(vol2, fd) {
      this.vol = vol2;
      this.fd = fd;
    }
    FileHandle2.prototype.appendFile = function(data, options) {
      return promisify32(this.vol, "appendFile")(this.fd, data, options);
    };
    FileHandle2.prototype.chmod = function(mode) {
      return promisify32(this.vol, "fchmod")(this.fd, mode);
    };
    FileHandle2.prototype.chown = function(uid, gid) {
      return promisify32(this.vol, "fchown")(this.fd, uid, gid);
    };
    FileHandle2.prototype.close = function() {
      return promisify32(this.vol, "close")(this.fd);
    };
    FileHandle2.prototype.datasync = function() {
      return promisify32(this.vol, "fdatasync")(this.fd);
    };
    FileHandle2.prototype.read = function(buffer22, offset, length, position) {
      return promisify32(this.vol, "read", function(bytesRead) {
        return {
          bytesRead,
          buffer: buffer22
        };
      })(this.fd, buffer22, offset, length, position);
    };
    FileHandle2.prototype.readFile = function(options) {
      return promisify32(this.vol, "readFile")(this.fd, options);
    };
    FileHandle2.prototype.stat = function(options) {
      return promisify32(this.vol, "fstat")(this.fd, options);
    };
    FileHandle2.prototype.sync = function() {
      return promisify32(this.vol, "fsync")(this.fd);
    };
    FileHandle2.prototype.truncate = function(len) {
      return promisify32(this.vol, "ftruncate")(this.fd, len);
    };
    FileHandle2.prototype.utimes = function(atime, mtime) {
      return promisify32(this.vol, "futimes")(this.fd, atime, mtime);
    };
    FileHandle2.prototype.write = function(buffer22, offset, length, position) {
      return promisify32(this.vol, "write", function(bytesWritten) {
        return {
          bytesWritten,
          buffer: buffer22
        };
      })(this.fd, buffer22, offset, length, position);
    };
    FileHandle2.prototype.writeFile = function(data, options) {
      return promisify32(this.vol, "writeFile")(this.fd, data, options);
    };
    return FileHandle2;
  }();
  exports$62.FileHandle = FileHandle;
  function createPromisesApi(vol2) {
    if (typeof Promise === "undefined")
      return null;
    return {
      FileHandle,
      access: function(path22, mode) {
        return promisify32(vol2, "access")(path22, mode);
      },
      appendFile: function(path22, data, options) {
        return promisify32(vol2, "appendFile")(path22 instanceof FileHandle ? path22.fd : path22, data, options);
      },
      chmod: function(path22, mode) {
        return promisify32(vol2, "chmod")(path22, mode);
      },
      chown: function(path22, uid, gid) {
        return promisify32(vol2, "chown")(path22, uid, gid);
      },
      copyFile: function(src, dest, flags) {
        return promisify32(vol2, "copyFile")(src, dest, flags);
      },
      lchmod: function(path22, mode) {
        return promisify32(vol2, "lchmod")(path22, mode);
      },
      lchown: function(path22, uid, gid) {
        return promisify32(vol2, "lchown")(path22, uid, gid);
      },
      link: function(existingPath, newPath) {
        return promisify32(vol2, "link")(existingPath, newPath);
      },
      lstat: function(path22, options) {
        return promisify32(vol2, "lstat")(path22, options);
      },
      mkdir: function(path22, options) {
        return promisify32(vol2, "mkdir")(path22, options);
      },
      mkdtemp: function(prefix, options) {
        return promisify32(vol2, "mkdtemp")(prefix, options);
      },
      open: function(path22, flags, mode) {
        return promisify32(vol2, "open", function(fd) {
          return new FileHandle(vol2, fd);
        })(path22, flags, mode);
      },
      readdir: function(path22, options) {
        return promisify32(vol2, "readdir")(path22, options);
      },
      readFile: function(id, options) {
        return promisify32(vol2, "readFile")(id instanceof FileHandle ? id.fd : id, options);
      },
      readlink: function(path22, options) {
        return promisify32(vol2, "readlink")(path22, options);
      },
      realpath: function(path22, options) {
        return promisify32(vol2, "realpath")(path22, options);
      },
      rename: function(oldPath, newPath) {
        return promisify32(vol2, "rename")(oldPath, newPath);
      },
      rmdir: function(path22) {
        return promisify32(vol2, "rmdir")(path22);
      },
      stat: function(path22, options) {
        return promisify32(vol2, "stat")(path22, options);
      },
      symlink: function(target, path22, type2) {
        return promisify32(vol2, "symlink")(target, path22, type2);
      },
      truncate: function(path22, len) {
        return promisify32(vol2, "truncate")(path22, len);
      },
      unlink: function(path22) {
        return promisify32(vol2, "unlink")(path22);
      },
      utimes: function(path22, atime, mtime) {
        return promisify32(vol2, "utimes")(path22, atime, mtime);
      },
      writeFile: function(id, data, options) {
        return promisify32(vol2, "writeFile")(id instanceof FileHandle ? id.fd : id, data, options);
      }
    };
  }
  exports$62.default = createPromisesApi;
  return exports$62;
}
function dew$32() {
  if (_dewExec$32)
    return exports$52;
  _dewExec$32 = true;
  var process$1 = process3;
  Object.defineProperty(exports$52, "__esModule", {
    value: true
  });
  exports$52.unixify = unixify;
  exports$52.correctPath = correctPath;
  var isWin = process$1.platform === "win32";
  function removeTrailingSeparator(str) {
    var i72 = str.length - 1;
    if (i72 < 2) {
      return str;
    }
    while (isSeparator(str, i72)) {
      i72--;
    }
    return str.substr(0, i72 + 1);
  }
  function isSeparator(str, i72) {
    var _char = str[i72];
    return i72 > 0 && (_char === "/" || isWin && _char === "\\");
  }
  function normalizePath(str, stripTrailing) {
    if (typeof str !== "string") {
      throw new TypeError("expected a string");
    }
    str = str.replace(/[\\\/]+/g, "/");
    if (stripTrailing !== false) {
      str = removeTrailingSeparator(str);
    }
    return str;
  }
  function unixify(filepath) {
    var stripTrailing = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (isWin) {
      filepath = normalizePath(filepath, stripTrailing);
      return filepath.replace(/^([a-zA-Z]+:|\.\/)/, "");
    }
    return filepath;
  }
  function correctPath(filepath) {
    return unixify(filepath.replace(/^\\\\\?\\.:\\/, "\\"));
  }
  return exports$52;
}
function dew$23() {
  if (_dewExec$23)
    return exports$42;
  _dewExec$23 = true;
  var __extends = exports$42 && exports$42.__extends || function() {
    var extendStatics = function(d62, b52) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d72, b62) {
        d72.__proto__ = b62;
      } || function(d72, b62) {
        for (var p72 in b62)
          if (Object.prototype.hasOwnProperty.call(b62, p72))
            d72[p72] = b62[p72];
      };
      return extendStatics(d62, b52);
    };
    return function(d62, b52) {
      if (typeof b52 !== "function" && b52 !== null)
        throw new TypeError("Class extends value " + String(b52) + " is not a constructor or null");
      extendStatics(d62, b52);
      function __() {
        this.constructor = d62;
      }
      d62.prototype = b52 === null ? Object.create(b52) : (__.prototype = b52.prototype, new __());
    };
  }();
  var __spreadArray = exports$42 && exports$42.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i72 = 0, l72 = from.length, ar; i72 < l72; i72++) {
        if (ar || !(i72 in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i72);
          ar[i72] = from[i72];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports$42, "__esModule", {
    value: true
  });
  exports$42.FSWatcher = exports$42.StatWatcher = exports$42.Volume = exports$42.toUnixTimestamp = exports$42.bufferToEncoding = exports$42.dataToBuffer = exports$42.dataToStr = exports$42.pathToSteps = exports$42.filenameToSteps = exports$42.pathToFilename = exports$42.flagsToNumber = exports$42.FLAGS = void 0;
  var pathModule = exports32;
  var node_1 = dew$62();
  var Stats_1 = dew$d2();
  var Dirent_1 = dew$92();
  var buffer_1 = dew$c2();
  var setImmediate_1 = dew$82();
  var process_1 = dew$72();
  var setTimeoutUnref_1 = dew$52();
  var stream_1 = exports42;
  var constants_1 = dew$f2();
  var events_1 = y;
  var encoding_1 = dew$a2();
  var errors = dew$b2();
  var util = X;
  var promises_1 = dew$42();
  var resolveCrossPlatform = pathModule.resolve;
  var O_RDONLY2 = constants_1.constants.O_RDONLY, O_WRONLY2 = constants_1.constants.O_WRONLY, O_RDWR2 = constants_1.constants.O_RDWR, O_CREAT2 = constants_1.constants.O_CREAT, O_EXCL2 = constants_1.constants.O_EXCL, O_TRUNC2 = constants_1.constants.O_TRUNC, O_APPEND2 = constants_1.constants.O_APPEND, O_SYNC2 = constants_1.constants.O_SYNC, O_DIRECTORY2 = constants_1.constants.O_DIRECTORY, F_OK22 = constants_1.constants.F_OK, COPYFILE_EXCL = constants_1.constants.COPYFILE_EXCL, COPYFILE_FICLONE_FORCE = constants_1.constants.COPYFILE_FICLONE_FORCE;
  var _a = pathModule.posix ? pathModule.posix : pathModule, sep22 = _a.sep, relative22 = _a.relative, join22 = _a.join, dirname22 = _a.dirname;
  var isWin = process_1.default.platform === "win32";
  var kMinPoolSpace = 128;
  var ERRSTR = {
    PATH_STR: "path must be a string or Buffer",
    // FD:             'file descriptor must be a unsigned 32-bit integer',
    FD: "fd must be a file descriptor",
    MODE_INT: "mode must be an int",
    CB: "callback must be a function",
    UID: "uid must be an unsigned int",
    GID: "gid must be an unsigned int",
    LEN: "len must be an integer",
    ATIME: "atime must be an integer",
    MTIME: "mtime must be an integer",
    PREFIX: "filename prefix is required",
    BUFFER: "buffer must be an instance of Buffer or StaticBuffer",
    OFFSET: "offset must be an integer",
    LENGTH: "length must be an integer",
    POSITION: "position must be an integer"
  };
  var ERRSTR_OPTS = function(tipeof) {
    return "Expected options to be either an object or a string, but got " + tipeof + " instead";
  };
  var ENOENT2 = "ENOENT";
  var EBADF2 = "EBADF";
  var EINVAL2 = "EINVAL";
  var EPERM2 = "EPERM";
  var EPROTO2 = "EPROTO";
  var EEXIST2 = "EEXIST";
  var ENOTDIR2 = "ENOTDIR";
  var EMFILE2 = "EMFILE";
  var EACCES2 = "EACCES";
  var EISDIR2 = "EISDIR";
  var ENOTEMPTY2 = "ENOTEMPTY";
  var ENOSYS2 = "ENOSYS";
  function formatError(errorCode, func, path22, path222) {
    if (func === void 0) {
      func = "";
    }
    if (path22 === void 0) {
      path22 = "";
    }
    if (path222 === void 0) {
      path222 = "";
    }
    var pathFormatted = "";
    if (path22)
      pathFormatted = " '" + path22 + "'";
    if (path222)
      pathFormatted += " -> '" + path222 + "'";
    switch (errorCode) {
      case ENOENT2:
        return "ENOENT: no such file or directory, " + func + pathFormatted;
      case EBADF2:
        return "EBADF: bad file descriptor, " + func + pathFormatted;
      case EINVAL2:
        return "EINVAL: invalid argument, " + func + pathFormatted;
      case EPERM2:
        return "EPERM: operation not permitted, " + func + pathFormatted;
      case EPROTO2:
        return "EPROTO: protocol error, " + func + pathFormatted;
      case EEXIST2:
        return "EEXIST: file already exists, " + func + pathFormatted;
      case ENOTDIR2:
        return "ENOTDIR: not a directory, " + func + pathFormatted;
      case EISDIR2:
        return "EISDIR: illegal operation on a directory, " + func + pathFormatted;
      case EACCES2:
        return "EACCES: permission denied, " + func + pathFormatted;
      case ENOTEMPTY2:
        return "ENOTEMPTY: directory not empty, " + func + pathFormatted;
      case EMFILE2:
        return "EMFILE: too many open files, " + func + pathFormatted;
      case ENOSYS2:
        return "ENOSYS: function not implemented, " + func + pathFormatted;
      default:
        return errorCode + ": error occurred, " + func + pathFormatted;
    }
  }
  function createError(errorCode, func, path22, path222, Constructor) {
    if (func === void 0) {
      func = "";
    }
    if (path22 === void 0) {
      path22 = "";
    }
    if (path222 === void 0) {
      path222 = "";
    }
    if (Constructor === void 0) {
      Constructor = Error;
    }
    var error = new Constructor(formatError(errorCode, func, path22, path222));
    error.code = errorCode;
    return error;
  }
  var FLAGS;
  (function(FLAGS2) {
    FLAGS2[FLAGS2["r"] = O_RDONLY2] = "r";
    FLAGS2[FLAGS2["r+"] = O_RDWR2] = "r+";
    FLAGS2[FLAGS2["rs"] = O_RDONLY2 | O_SYNC2] = "rs";
    FLAGS2[FLAGS2["sr"] = FLAGS2.rs] = "sr";
    FLAGS2[FLAGS2["rs+"] = O_RDWR2 | O_SYNC2] = "rs+";
    FLAGS2[FLAGS2["sr+"] = FLAGS2["rs+"]] = "sr+";
    FLAGS2[FLAGS2["w"] = O_WRONLY2 | O_CREAT2 | O_TRUNC2] = "w";
    FLAGS2[FLAGS2["wx"] = O_WRONLY2 | O_CREAT2 | O_TRUNC2 | O_EXCL2] = "wx";
    FLAGS2[FLAGS2["xw"] = FLAGS2.wx] = "xw";
    FLAGS2[FLAGS2["w+"] = O_RDWR2 | O_CREAT2 | O_TRUNC2] = "w+";
    FLAGS2[FLAGS2["wx+"] = O_RDWR2 | O_CREAT2 | O_TRUNC2 | O_EXCL2] = "wx+";
    FLAGS2[FLAGS2["xw+"] = FLAGS2["wx+"]] = "xw+";
    FLAGS2[FLAGS2["a"] = O_WRONLY2 | O_APPEND2 | O_CREAT2] = "a";
    FLAGS2[FLAGS2["ax"] = O_WRONLY2 | O_APPEND2 | O_CREAT2 | O_EXCL2] = "ax";
    FLAGS2[FLAGS2["xa"] = FLAGS2.ax] = "xa";
    FLAGS2[FLAGS2["a+"] = O_RDWR2 | O_APPEND2 | O_CREAT2] = "a+";
    FLAGS2[FLAGS2["ax+"] = O_RDWR2 | O_APPEND2 | O_CREAT2 | O_EXCL2] = "ax+";
    FLAGS2[FLAGS2["xa+"] = FLAGS2["ax+"]] = "xa+";
  })(FLAGS = exports$42.FLAGS || (exports$42.FLAGS = {}));
  function flagsToNumber(flags) {
    if (typeof flags === "number")
      return flags;
    if (typeof flags === "string") {
      var flagsNum = FLAGS[flags];
      if (typeof flagsNum !== "undefined")
        return flagsNum;
    }
    throw new errors.TypeError("ERR_INVALID_OPT_VALUE", "flags", flags);
  }
  exports$42.flagsToNumber = flagsToNumber;
  function getOptions(defaults, options) {
    var opts2;
    if (!options)
      return defaults;
    else {
      var tipeof = typeof options;
      switch (tipeof) {
        case "string":
          opts2 = Object.assign({}, defaults, {
            encoding: options
          });
          break;
        case "object":
          opts2 = Object.assign({}, defaults, options);
          break;
        default:
          throw TypeError(ERRSTR_OPTS(tipeof));
      }
    }
    if (opts2.encoding !== "buffer")
      (0, encoding_1.assertEncoding)(opts2.encoding);
    return opts2;
  }
  function optsGenerator(defaults) {
    return function(options) {
      return getOptions(defaults, options);
    };
  }
  function validateCallback(callback) {
    if (typeof callback !== "function")
      throw TypeError(ERRSTR.CB);
    return callback;
  }
  function optsAndCbGenerator(getOpts) {
    return function(options, callback) {
      return typeof options === "function" ? [getOpts(), options] : [getOpts(options), validateCallback(callback)];
    };
  }
  var optsDefaults = {
    encoding: "utf8"
  };
  var getDefaultOpts = optsGenerator(optsDefaults);
  var getDefaultOptsAndCb = optsAndCbGenerator(getDefaultOpts);
  var readFileOptsDefaults = {
    flag: "r"
  };
  var getReadFileOptions = optsGenerator(readFileOptsDefaults);
  var writeFileDefaults = {
    encoding: "utf8",
    mode: 438,
    flag: FLAGS[FLAGS.w]
  };
  var getWriteFileOptions = optsGenerator(writeFileDefaults);
  var appendFileDefaults = {
    encoding: "utf8",
    mode: 438,
    flag: FLAGS[FLAGS.a]
  };
  var getAppendFileOpts = optsGenerator(appendFileDefaults);
  var getAppendFileOptsAndCb = optsAndCbGenerator(getAppendFileOpts);
  var realpathDefaults = optsDefaults;
  var getRealpathOptions = optsGenerator(realpathDefaults);
  var getRealpathOptsAndCb = optsAndCbGenerator(getRealpathOptions);
  var mkdirDefaults = {
    mode: 511,
    recursive: false
  };
  var getMkdirOptions = function(options) {
    if (typeof options === "number")
      return Object.assign({}, mkdirDefaults, {
        mode: options
      });
    return Object.assign({}, mkdirDefaults, options);
  };
  var rmdirDefaults = {
    recursive: false
  };
  var getRmdirOptions = function(options) {
    return Object.assign({}, rmdirDefaults, options);
  };
  var readdirDefaults = {
    encoding: "utf8",
    withFileTypes: false
  };
  var getReaddirOptions = optsGenerator(readdirDefaults);
  var getReaddirOptsAndCb = optsAndCbGenerator(getReaddirOptions);
  var statDefaults = {
    bigint: false
  };
  var getStatOptions = function(options) {
    if (options === void 0) {
      options = {};
    }
    return Object.assign({}, statDefaults, options);
  };
  var getStatOptsAndCb = function(options, callback) {
    return typeof options === "function" ? [getStatOptions(), options] : [getStatOptions(options), validateCallback(callback)];
  };
  function getPathFromURLPosix22(url) {
    if (url.hostname !== "") {
      throw new errors.TypeError("ERR_INVALID_FILE_URL_HOST", process_1.default.platform);
    }
    var pathname = url.pathname;
    for (var n82 = 0; n82 < pathname.length; n82++) {
      if (pathname[n82] === "%") {
        var third = pathname.codePointAt(n82 + 2) | 32;
        if (pathname[n82 + 1] === "2" && third === 102) {
          throw new errors.TypeError("ERR_INVALID_FILE_URL_PATH", "must not include encoded / characters");
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  function pathToFilename(path22) {
    if (typeof path22 !== "string" && !buffer_1.Buffer.isBuffer(path22)) {
      try {
        if (!(path22 instanceof h7.URL))
          throw new TypeError(ERRSTR.PATH_STR);
      } catch (err) {
        throw new TypeError(ERRSTR.PATH_STR);
      }
      path22 = getPathFromURLPosix22(path22);
    }
    var pathString = String(path22);
    nullCheck(pathString);
    return pathString;
  }
  exports$42.pathToFilename = pathToFilename;
  var resolve32 = function(filename, base) {
    if (base === void 0) {
      base = process_1.default.cwd();
    }
    return resolveCrossPlatform(base, filename);
  };
  if (isWin) {
    var _resolve_1 = resolve32;
    var unixify_1 = dew$32().unixify;
    resolve32 = function(filename, base) {
      return unixify_1(_resolve_1(filename, base));
    };
  }
  function filenameToSteps(filename, base) {
    var fullPath = resolve32(filename, base);
    var fullPathSansSlash = fullPath.substr(1);
    if (!fullPathSansSlash)
      return [];
    return fullPathSansSlash.split(sep22);
  }
  exports$42.filenameToSteps = filenameToSteps;
  function pathToSteps(path22) {
    return filenameToSteps(pathToFilename(path22));
  }
  exports$42.pathToSteps = pathToSteps;
  function dataToStr(data, encoding) {
    if (encoding === void 0) {
      encoding = encoding_1.ENCODING_UTF8;
    }
    if (buffer_1.Buffer.isBuffer(data))
      return data.toString(encoding);
    else if (data instanceof Uint8Array)
      return (0, buffer_1.bufferFrom)(data).toString(encoding);
    else
      return String(data);
  }
  exports$42.dataToStr = dataToStr;
  function dataToBuffer(data, encoding) {
    if (encoding === void 0) {
      encoding = encoding_1.ENCODING_UTF8;
    }
    if (buffer_1.Buffer.isBuffer(data))
      return data;
    else if (data instanceof Uint8Array)
      return (0, buffer_1.bufferFrom)(data);
    else
      return (0, buffer_1.bufferFrom)(String(data), encoding);
  }
  exports$42.dataToBuffer = dataToBuffer;
  function bufferToEncoding(buffer22, encoding) {
    if (!encoding || encoding === "buffer")
      return buffer22;
    else
      return buffer22.toString(encoding);
  }
  exports$42.bufferToEncoding = bufferToEncoding;
  function nullCheck(path22, callback) {
    if (("" + path22).indexOf("\0") !== -1) {
      var er = new Error("Path must be a string without null bytes");
      er.code = ENOENT2;
      if (typeof callback !== "function")
        throw er;
      process_1.default.nextTick(callback, er);
      return false;
    }
    return true;
  }
  function _modeToNumber(mode, def) {
    if (typeof mode === "number")
      return mode;
    if (typeof mode === "string")
      return parseInt(mode, 8);
    if (def)
      return modeToNumber(def);
    return void 0;
  }
  function modeToNumber(mode, def) {
    var result = _modeToNumber(mode, def);
    if (typeof result !== "number" || isNaN(result))
      throw new TypeError(ERRSTR.MODE_INT);
    return result;
  }
  function isFd(path22) {
    return path22 >>> 0 === path22;
  }
  function validateFd(fd) {
    if (!isFd(fd))
      throw TypeError(ERRSTR.FD);
  }
  function toUnixTimestamp(time) {
    if (typeof time === "string" && +time == time) {
      return +time;
    }
    if (time instanceof Date) {
      return time.getTime() / 1e3;
    }
    if (isFinite(time)) {
      if (time < 0) {
        return Date.now() / 1e3;
      }
      return time;
    }
    throw new Error("Cannot parse time: " + time);
  }
  exports$42.toUnixTimestamp = toUnixTimestamp;
  function validateUid(uid) {
    if (typeof uid !== "number")
      throw TypeError(ERRSTR.UID);
  }
  function validateGid(gid) {
    if (typeof gid !== "number")
      throw TypeError(ERRSTR.GID);
  }
  function flattenJSON(nestedJSON) {
    var flatJSON = {};
    function flatten(pathPrefix, node) {
      for (var path22 in node) {
        var contentOrNode = node[path22];
        var joinedPath = join22(pathPrefix, path22);
        if (typeof contentOrNode === "string") {
          flatJSON[joinedPath] = contentOrNode;
        } else if (typeof contentOrNode === "object" && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {
          flatten(joinedPath, contentOrNode);
        } else {
          flatJSON[joinedPath] = null;
        }
      }
    }
    flatten("", nestedJSON);
    return flatJSON;
  }
  var Volume = function() {
    function Volume2(props) {
      if (props === void 0) {
        props = {};
      }
      this.ino = 0;
      this.inodes = {};
      this.releasedInos = [];
      this.fds = {};
      this.releasedFds = [];
      this.maxFiles = 1e4;
      this.openFiles = 0;
      this.promisesApi = (0, promises_1.default)(this);
      this.statWatchers = {};
      this.props = Object.assign({
        Node: node_1.Node,
        Link: node_1.Link,
        File: node_1.File
      }, props);
      var root = this.createLink();
      root.setNode(this.createNode(true));
      var self2 = this;
      this.StatWatcher = function(_super) {
        __extends(StatWatcher2, _super);
        function StatWatcher2() {
          return _super.call(this, self2) || this;
        }
        return StatWatcher2;
      }(StatWatcher);
      var _ReadStream = FsReadStream;
      this.ReadStream = function(_super) {
        __extends(class_1, _super);
        function class_1() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return _super.apply(this, __spreadArray([self2], args, false)) || this;
        }
        return class_1;
      }(_ReadStream);
      var _WriteStream = FsWriteStream;
      this.WriteStream = function(_super) {
        __extends(class_2, _super);
        function class_2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return _super.apply(this, __spreadArray([self2], args, false)) || this;
        }
        return class_2;
      }(_WriteStream);
      this.FSWatcher = function(_super) {
        __extends(FSWatcher2, _super);
        function FSWatcher2() {
          return _super.call(this, self2) || this;
        }
        return FSWatcher2;
      }(FSWatcher);
      this.root = root;
    }
    Volume2.fromJSON = function(json, cwd) {
      var vol2 = new Volume2();
      vol2.fromJSON(json, cwd);
      return vol2;
    };
    Volume2.fromNestedJSON = function(json, cwd) {
      var vol2 = new Volume2();
      vol2.fromNestedJSON(json, cwd);
      return vol2;
    };
    Object.defineProperty(Volume2.prototype, "promises", {
      get: function() {
        if (this.promisesApi === null)
          throw new Error("Promise is not supported in this environment.");
        return this.promisesApi;
      },
      enumerable: false,
      configurable: true
    });
    Volume2.prototype.createLink = function(parent, name2, isDirectory, perm) {
      if (isDirectory === void 0) {
        isDirectory = false;
      }
      if (!parent) {
        return new this.props.Link(this, null, "");
      }
      if (!name2) {
        throw new Error("createLink: name cannot be empty");
      }
      return parent.createChild(name2, this.createNode(isDirectory, perm));
    };
    Volume2.prototype.deleteLink = function(link2) {
      var parent = link2.parent;
      if (parent) {
        parent.deleteChild(link2);
        return true;
      }
      return false;
    };
    Volume2.prototype.newInoNumber = function() {
      var releasedFd = this.releasedInos.pop();
      if (releasedFd)
        return releasedFd;
      else {
        this.ino = (this.ino + 1) % 4294967295;
        return this.ino;
      }
    };
    Volume2.prototype.newFdNumber = function() {
      var releasedFd = this.releasedFds.pop();
      return typeof releasedFd === "number" ? releasedFd : Volume2.fd--;
    };
    Volume2.prototype.createNode = function(isDirectory, perm) {
      if (isDirectory === void 0) {
        isDirectory = false;
      }
      var node = new this.props.Node(this.newInoNumber(), perm);
      if (isDirectory)
        node.setIsDirectory();
      this.inodes[node.ino] = node;
      return node;
    };
    Volume2.prototype.getNode = function(ino) {
      return this.inodes[ino];
    };
    Volume2.prototype.deleteNode = function(node) {
      node.del();
      delete this.inodes[node.ino];
      this.releasedInos.push(node.ino);
    };
    Volume2.prototype.genRndStr = function() {
      var str = (Math.random() + 1).toString(36).substr(2, 6);
      if (str.length === 6)
        return str;
      else
        return this.genRndStr();
    };
    Volume2.prototype.getLink = function(steps) {
      return this.root.walk(steps);
    };
    Volume2.prototype.getLinkOrThrow = function(filename, funcName) {
      var steps = filenameToSteps(filename);
      var link2 = this.getLink(steps);
      if (!link2)
        throw createError(ENOENT2, funcName, filename);
      return link2;
    };
    Volume2.prototype.getResolvedLink = function(filenameOrSteps) {
      var steps = typeof filenameOrSteps === "string" ? filenameToSteps(filenameOrSteps) : filenameOrSteps;
      var link2 = this.root;
      var i72 = 0;
      while (i72 < steps.length) {
        var step = steps[i72];
        link2 = link2.getChild(step);
        if (!link2)
          return null;
        var node = link2.getNode();
        if (node.isSymlink()) {
          steps = node.symlink.concat(steps.slice(i72 + 1));
          link2 = this.root;
          i72 = 0;
          continue;
        }
        i72++;
      }
      return link2;
    };
    Volume2.prototype.getResolvedLinkOrThrow = function(filename, funcName) {
      var link2 = this.getResolvedLink(filename);
      if (!link2)
        throw createError(ENOENT2, funcName, filename);
      return link2;
    };
    Volume2.prototype.resolveSymlinks = function(link2) {
      return this.getResolvedLink(link2.steps.slice(1));
    };
    Volume2.prototype.getLinkAsDirOrThrow = function(filename, funcName) {
      var link2 = this.getLinkOrThrow(filename, funcName);
      if (!link2.getNode().isDirectory())
        throw createError(ENOTDIR2, funcName, filename);
      return link2;
    };
    Volume2.prototype.getLinkParent = function(steps) {
      return this.root.walk(steps, steps.length - 1);
    };
    Volume2.prototype.getLinkParentAsDirOrThrow = function(filenameOrSteps, funcName) {
      var steps = filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps);
      var link2 = this.getLinkParent(steps);
      if (!link2)
        throw createError(ENOENT2, funcName, sep22 + steps.join(sep22));
      if (!link2.getNode().isDirectory())
        throw createError(ENOTDIR2, funcName, sep22 + steps.join(sep22));
      return link2;
    };
    Volume2.prototype.getFileByFd = function(fd) {
      return this.fds[String(fd)];
    };
    Volume2.prototype.getFileByFdOrThrow = function(fd, funcName) {
      if (!isFd(fd))
        throw TypeError(ERRSTR.FD);
      var file = this.getFileByFd(fd);
      if (!file)
        throw createError(EBADF2, funcName);
      return file;
    };
    Volume2.prototype.getNodeByIdOrCreate = function(id, flags, perm) {
      if (typeof id === "number") {
        var file = this.getFileByFd(id);
        if (!file)
          throw Error("File nto found");
        return file.node;
      } else {
        var steps = pathToSteps(id);
        var link2 = this.getLink(steps);
        if (link2)
          return link2.getNode();
        if (flags & O_CREAT2) {
          var dirLink = this.getLinkParent(steps);
          if (dirLink) {
            var name_1 = steps[steps.length - 1];
            link2 = this.createLink(dirLink, name_1, false, perm);
            return link2.getNode();
          }
        }
        throw createError(ENOENT2, "getNodeByIdOrCreate", pathToFilename(id));
      }
    };
    Volume2.prototype.wrapAsync = function(method, args, callback) {
      var _this = this;
      validateCallback(callback);
      (0, setImmediate_1.default)(function() {
        var result;
        try {
          result = method.apply(_this, args);
        } catch (err) {
          callback(err);
          return;
        }
        callback(null, result);
      });
    };
    Volume2.prototype._toJSON = function(link2, json, path22) {
      var _a2;
      if (link2 === void 0) {
        link2 = this.root;
      }
      if (json === void 0) {
        json = {};
      }
      var isEmpty = true;
      var children = link2.children;
      if (link2.getNode().isFile()) {
        children = (_a2 = {}, _a2[link2.getName()] = link2.parent.getChild(link2.getName()), _a2);
        link2 = link2.parent;
      }
      for (var name_2 in children) {
        isEmpty = false;
        var child = link2.getChild(name_2);
        if (!child) {
          throw new Error("_toJSON: unexpected undefined");
        }
        var node = child.getNode();
        if (node.isFile()) {
          var filename = child.getPath();
          if (path22)
            filename = relative22(path22, filename);
          json[filename] = node.getString();
        } else if (node.isDirectory()) {
          this._toJSON(child, json, path22);
        }
      }
      var dirPath = link2.getPath();
      if (path22)
        dirPath = relative22(path22, dirPath);
      if (dirPath && isEmpty) {
        json[dirPath] = null;
      }
      return json;
    };
    Volume2.prototype.toJSON = function(paths, json, isRelative) {
      if (json === void 0) {
        json = {};
      }
      if (isRelative === void 0) {
        isRelative = false;
      }
      var links = [];
      if (paths) {
        if (!(paths instanceof Array))
          paths = [paths];
        for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
          var path22 = paths_1[_i];
          var filename = pathToFilename(path22);
          var link2 = this.getResolvedLink(filename);
          if (!link2)
            continue;
          links.push(link2);
        }
      } else {
        links.push(this.root);
      }
      if (!links.length)
        return json;
      for (var _a2 = 0, links_1 = links; _a2 < links_1.length; _a2++) {
        var link2 = links_1[_a2];
        this._toJSON(link2, json, isRelative ? link2.getPath() : "");
      }
      return json;
    };
    Volume2.prototype.fromJSON = function(json, cwd) {
      if (cwd === void 0) {
        cwd = process_1.default.cwd();
      }
      for (var filename in json) {
        var data = json[filename];
        filename = resolve32(filename, cwd);
        if (typeof data === "string") {
          var dir = dirname22(filename);
          this.mkdirpBase(
            dir,
            511
            /* DIR */
          );
          this.writeFileSync(filename, data);
        } else {
          this.mkdirpBase(
            filename,
            511
            /* DIR */
          );
        }
      }
    };
    Volume2.prototype.fromNestedJSON = function(json, cwd) {
      this.fromJSON(flattenJSON(json), cwd);
    };
    Volume2.prototype.reset = function() {
      this.ino = 0;
      this.inodes = {};
      this.releasedInos = [];
      this.fds = {};
      this.releasedFds = [];
      this.openFiles = 0;
      this.root = this.createLink();
      this.root.setNode(this.createNode(true));
    };
    Volume2.prototype.mountSync = function(mountpoint, json) {
      this.fromJSON(json, mountpoint);
    };
    Volume2.prototype.openLink = function(link2, flagsNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }
      if (this.openFiles >= this.maxFiles) {
        throw createError(EMFILE2, "open", link2.getPath());
      }
      var realLink = link2;
      if (resolveSymlinks)
        realLink = this.resolveSymlinks(link2);
      if (!realLink)
        throw createError(ENOENT2, "open", link2.getPath());
      var node = realLink.getNode();
      if (node.isDirectory()) {
        if ((flagsNum & (O_RDONLY2 | O_RDWR2 | O_WRONLY2)) !== O_RDONLY2)
          throw createError(EISDIR2, "open", link2.getPath());
      } else {
        if (flagsNum & O_DIRECTORY2)
          throw createError(ENOTDIR2, "open", link2.getPath());
      }
      if (!(flagsNum & O_WRONLY2)) {
        if (!node.canRead()) {
          throw createError(EACCES2, "open", link2.getPath());
        }
      }
      var file = new this.props.File(link2, node, flagsNum, this.newFdNumber());
      this.fds[file.fd] = file;
      this.openFiles++;
      if (flagsNum & O_TRUNC2)
        file.truncate();
      return file;
    };
    Volume2.prototype.openFile = function(filename, flagsNum, modeNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }
      var steps = filenameToSteps(filename);
      var link2 = resolveSymlinks ? this.getResolvedLink(steps) : this.getLink(steps);
      if (!link2 && flagsNum & O_CREAT2) {
        var dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1));
        if (!dirLink)
          throw createError(ENOENT2, "open", sep22 + steps.join(sep22));
        if (flagsNum & O_CREAT2 && typeof modeNum === "number") {
          link2 = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
        }
      }
      if (link2)
        return this.openLink(link2, flagsNum, resolveSymlinks);
      throw createError(ENOENT2, "open", filename);
    };
    Volume2.prototype.openBase = function(filename, flagsNum, modeNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }
      var file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
      if (!file)
        throw createError(ENOENT2, "open", filename);
      return file.fd;
    };
    Volume2.prototype.openSync = function(path22, flags, mode) {
      if (mode === void 0) {
        mode = 438;
      }
      var modeNum = modeToNumber(mode);
      var fileName = pathToFilename(path22);
      var flagsNum = flagsToNumber(flags);
      return this.openBase(fileName, flagsNum, modeNum);
    };
    Volume2.prototype.open = function(path22, flags, a72, b52) {
      var mode = a72;
      var callback = b52;
      if (typeof a72 === "function") {
        mode = 438;
        callback = a72;
      }
      mode = mode || 438;
      var modeNum = modeToNumber(mode);
      var fileName = pathToFilename(path22);
      var flagsNum = flagsToNumber(flags);
      this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);
    };
    Volume2.prototype.closeFile = function(file) {
      if (!this.fds[file.fd])
        return;
      this.openFiles--;
      delete this.fds[file.fd];
      this.releasedFds.push(file.fd);
    };
    Volume2.prototype.closeSync = function(fd) {
      validateFd(fd);
      var file = this.getFileByFdOrThrow(fd, "close");
      this.closeFile(file);
    };
    Volume2.prototype.close = function(fd, callback) {
      validateFd(fd);
      this.wrapAsync(this.closeSync, [fd], callback);
    };
    Volume2.prototype.openFileOrGetById = function(id, flagsNum, modeNum) {
      if (typeof id === "number") {
        var file = this.fds[id];
        if (!file)
          throw createError(ENOENT2);
        return file;
      } else {
        return this.openFile(pathToFilename(id), flagsNum, modeNum);
      }
    };
    Volume2.prototype.readBase = function(fd, buffer22, offset, length, position) {
      var file = this.getFileByFdOrThrow(fd);
      return file.read(buffer22, Number(offset), Number(length), position);
    };
    Volume2.prototype.readSync = function(fd, buffer22, offset, length, position) {
      validateFd(fd);
      return this.readBase(fd, buffer22, offset, length, position);
    };
    Volume2.prototype.read = function(fd, buffer22, offset, length, position, callback) {
      var _this = this;
      validateCallback(callback);
      if (length === 0) {
        return process_1.default.nextTick(function() {
          if (callback)
            callback(null, 0, buffer22);
        });
      }
      (0, setImmediate_1.default)(function() {
        try {
          var bytes = _this.readBase(fd, buffer22, offset, length, position);
          callback(null, bytes, buffer22);
        } catch (err) {
          callback(err);
        }
      });
    };
    Volume2.prototype.readFileBase = function(id, flagsNum, encoding) {
      var result;
      var isUserFd = typeof id === "number";
      var userOwnsFd = isUserFd && isFd(id);
      var fd;
      if (userOwnsFd)
        fd = id;
      else {
        var filename = pathToFilename(id);
        var steps = filenameToSteps(filename);
        var link2 = this.getResolvedLink(steps);
        if (link2) {
          var node = link2.getNode();
          if (node.isDirectory())
            throw createError(EISDIR2, "open", link2.getPath());
        }
        fd = this.openSync(id, flagsNum);
      }
      try {
        result = bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
      } finally {
        if (!userOwnsFd) {
          this.closeSync(fd);
        }
      }
      return result;
    };
    Volume2.prototype.readFileSync = function(file, options) {
      var opts2 = getReadFileOptions(options);
      var flagsNum = flagsToNumber(opts2.flag);
      return this.readFileBase(file, flagsNum, opts2.encoding);
    };
    Volume2.prototype.readFile = function(id, a72, b52) {
      var _a2 = optsAndCbGenerator(getReadFileOptions)(a72, b52), opts2 = _a2[0], callback = _a2[1];
      var flagsNum = flagsToNumber(opts2.flag);
      this.wrapAsync(this.readFileBase, [id, flagsNum, opts2.encoding], callback);
    };
    Volume2.prototype.writeBase = function(fd, buf, offset, length, position) {
      var file = this.getFileByFdOrThrow(fd, "write");
      return file.write(buf, offset, length, position);
    };
    Volume2.prototype.writeSync = function(fd, a72, b52, c72, d62) {
      validateFd(fd);
      var encoding;
      var offset;
      var length;
      var position;
      var isBuffer32 = typeof a72 !== "string";
      if (isBuffer32) {
        offset = (b52 || 0) | 0;
        length = c72;
        position = d62;
      } else {
        position = b52;
        encoding = c72;
      }
      var buf = dataToBuffer(a72, encoding);
      if (isBuffer32) {
        if (typeof length === "undefined") {
          length = buf.length;
        }
      } else {
        offset = 0;
        length = buf.length;
      }
      return this.writeBase(fd, buf, offset, length, position);
    };
    Volume2.prototype.write = function(fd, a72, b52, c72, d62, e92) {
      var _this = this;
      validateFd(fd);
      var offset;
      var length;
      var position;
      var encoding;
      var callback;
      var tipa = typeof a72;
      var tipb = typeof b52;
      var tipc = typeof c72;
      var tipd = typeof d62;
      if (tipa !== "string") {
        if (tipb === "function") {
          callback = b52;
        } else if (tipc === "function") {
          offset = b52 | 0;
          callback = c72;
        } else if (tipd === "function") {
          offset = b52 | 0;
          length = c72;
          callback = d62;
        } else {
          offset = b52 | 0;
          length = c72;
          position = d62;
          callback = e92;
        }
      } else {
        if (tipb === "function") {
          callback = b52;
        } else if (tipc === "function") {
          position = b52;
          callback = c72;
        } else if (tipd === "function") {
          position = b52;
          encoding = c72;
          callback = d62;
        }
      }
      var buf = dataToBuffer(a72, encoding);
      if (tipa !== "string") {
        if (typeof length === "undefined")
          length = buf.length;
      } else {
        offset = 0;
        length = buf.length;
      }
      var cb = validateCallback(callback);
      (0, setImmediate_1.default)(function() {
        try {
          var bytes = _this.writeBase(fd, buf, offset, length, position);
          if (tipa !== "string") {
            cb(null, bytes, buf);
          } else {
            cb(null, bytes, a72);
          }
        } catch (err) {
          cb(err);
        }
      });
    };
    Volume2.prototype.writeFileBase = function(id, buf, flagsNum, modeNum) {
      var isUserFd = typeof id === "number";
      var fd;
      if (isUserFd)
        fd = id;
      else {
        fd = this.openBase(pathToFilename(id), flagsNum, modeNum);
      }
      var offset = 0;
      var length = buf.length;
      var position = flagsNum & O_APPEND2 ? void 0 : 0;
      try {
        while (length > 0) {
          var written = this.writeSync(fd, buf, offset, length, position);
          offset += written;
          length -= written;
          if (position !== void 0)
            position += written;
        }
      } finally {
        if (!isUserFd)
          this.closeSync(fd);
      }
    };
    Volume2.prototype.writeFileSync = function(id, data, options) {
      var opts2 = getWriteFileOptions(options);
      var flagsNum = flagsToNumber(opts2.flag);
      var modeNum = modeToNumber(opts2.mode);
      var buf = dataToBuffer(data, opts2.encoding);
      this.writeFileBase(id, buf, flagsNum, modeNum);
    };
    Volume2.prototype.writeFile = function(id, data, a72, b52) {
      var options = a72;
      var callback = b52;
      if (typeof a72 === "function") {
        options = writeFileDefaults;
        callback = a72;
      }
      var cb = validateCallback(callback);
      var opts2 = getWriteFileOptions(options);
      var flagsNum = flagsToNumber(opts2.flag);
      var modeNum = modeToNumber(opts2.mode);
      var buf = dataToBuffer(data, opts2.encoding);
      this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);
    };
    Volume2.prototype.linkBase = function(filename1, filename2) {
      var steps1 = filenameToSteps(filename1);
      var link1 = this.getLink(steps1);
      if (!link1)
        throw createError(ENOENT2, "link", filename1, filename2);
      var steps2 = filenameToSteps(filename2);
      var dir2 = this.getLinkParent(steps2);
      if (!dir2)
        throw createError(ENOENT2, "link", filename1, filename2);
      var name2 = steps2[steps2.length - 1];
      if (dir2.getChild(name2))
        throw createError(EEXIST2, "link", filename1, filename2);
      var node = link1.getNode();
      node.nlink++;
      dir2.createChild(name2, node);
    };
    Volume2.prototype.copyFileBase = function(src, dest, flags) {
      var buf = this.readFileSync(src);
      if (flags & COPYFILE_EXCL) {
        if (this.existsSync(dest)) {
          throw createError(EEXIST2, "copyFile", src, dest);
        }
      }
      if (flags & COPYFILE_FICLONE_FORCE) {
        throw createError(ENOSYS2, "copyFile", src, dest);
      }
      this.writeFileBase(
        dest,
        buf,
        FLAGS.w,
        438
        /* DEFAULT */
      );
    };
    Volume2.prototype.copyFileSync = function(src, dest, flags) {
      var srcFilename = pathToFilename(src);
      var destFilename = pathToFilename(dest);
      return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
    };
    Volume2.prototype.copyFile = function(src, dest, a72, b52) {
      var srcFilename = pathToFilename(src);
      var destFilename = pathToFilename(dest);
      var flags;
      var callback;
      if (typeof a72 === "function") {
        flags = 0;
        callback = a72;
      } else {
        flags = a72;
        callback = b52;
      }
      validateCallback(callback);
      this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
    };
    Volume2.prototype.linkSync = function(existingPath, newPath) {
      var existingPathFilename = pathToFilename(existingPath);
      var newPathFilename = pathToFilename(newPath);
      this.linkBase(existingPathFilename, newPathFilename);
    };
    Volume2.prototype.link = function(existingPath, newPath, callback) {
      var existingPathFilename = pathToFilename(existingPath);
      var newPathFilename = pathToFilename(newPath);
      this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
    };
    Volume2.prototype.unlinkBase = function(filename) {
      var steps = filenameToSteps(filename);
      var link2 = this.getLink(steps);
      if (!link2)
        throw createError(ENOENT2, "unlink", filename);
      if (link2.length)
        throw Error("Dir not empty...");
      this.deleteLink(link2);
      var node = link2.getNode();
      node.nlink--;
      if (node.nlink <= 0) {
        this.deleteNode(node);
      }
    };
    Volume2.prototype.unlinkSync = function(path22) {
      var filename = pathToFilename(path22);
      this.unlinkBase(filename);
    };
    Volume2.prototype.unlink = function(path22, callback) {
      var filename = pathToFilename(path22);
      this.wrapAsync(this.unlinkBase, [filename], callback);
    };
    Volume2.prototype.symlinkBase = function(targetFilename, pathFilename) {
      var pathSteps = filenameToSteps(pathFilename);
      var dirLink = this.getLinkParent(pathSteps);
      if (!dirLink)
        throw createError(ENOENT2, "symlink", targetFilename, pathFilename);
      var name2 = pathSteps[pathSteps.length - 1];
      if (dirLink.getChild(name2))
        throw createError(EEXIST2, "symlink", targetFilename, pathFilename);
      var symlink2 = dirLink.createChild(name2);
      symlink2.getNode().makeSymlink(filenameToSteps(targetFilename));
      return symlink2;
    };
    Volume2.prototype.symlinkSync = function(target, path22, type2) {
      var targetFilename = pathToFilename(target);
      var pathFilename = pathToFilename(path22);
      this.symlinkBase(targetFilename, pathFilename);
    };
    Volume2.prototype.symlink = function(target, path22, a72, b52) {
      var callback = validateCallback(typeof a72 === "function" ? a72 : b52);
      var targetFilename = pathToFilename(target);
      var pathFilename = pathToFilename(path22);
      this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
    };
    Volume2.prototype.realpathBase = function(filename, encoding) {
      var steps = filenameToSteps(filename);
      var realLink = this.getResolvedLink(steps);
      if (!realLink)
        throw createError(ENOENT2, "realpath", filename);
      return (0, encoding_1.strToEncoding)(realLink.getPath(), encoding);
    };
    Volume2.prototype.realpathSync = function(path22, options) {
      return this.realpathBase(pathToFilename(path22), getRealpathOptions(options).encoding);
    };
    Volume2.prototype.realpath = function(path22, a72, b52) {
      var _a2 = getRealpathOptsAndCb(a72, b52), opts2 = _a2[0], callback = _a2[1];
      var pathFilename = pathToFilename(path22);
      this.wrapAsync(this.realpathBase, [pathFilename, opts2.encoding], callback);
    };
    Volume2.prototype.lstatBase = function(filename, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }
      var link2 = this.getLink(filenameToSteps(filename));
      if (!link2)
        throw createError(ENOENT2, "lstat", filename);
      return Stats_1.default.build(link2.getNode(), bigint);
    };
    Volume2.prototype.lstatSync = function(path22, options) {
      return this.lstatBase(pathToFilename(path22), getStatOptions(options).bigint);
    };
    Volume2.prototype.lstat = function(path22, a72, b52) {
      var _a2 = getStatOptsAndCb(a72, b52), opts2 = _a2[0], callback = _a2[1];
      this.wrapAsync(this.lstatBase, [pathToFilename(path22), opts2.bigint], callback);
    };
    Volume2.prototype.statBase = function(filename, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }
      var link2 = this.getResolvedLink(filenameToSteps(filename));
      if (!link2)
        throw createError(ENOENT2, "stat", filename);
      return Stats_1.default.build(link2.getNode(), bigint);
    };
    Volume2.prototype.statSync = function(path22, options) {
      return this.statBase(pathToFilename(path22), getStatOptions(options).bigint);
    };
    Volume2.prototype.stat = function(path22, a72, b52) {
      var _a2 = getStatOptsAndCb(a72, b52), opts2 = _a2[0], callback = _a2[1];
      this.wrapAsync(this.statBase, [pathToFilename(path22), opts2.bigint], callback);
    };
    Volume2.prototype.fstatBase = function(fd, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }
      var file = this.getFileByFd(fd);
      if (!file)
        throw createError(EBADF2, "fstat");
      return Stats_1.default.build(file.node, bigint);
    };
    Volume2.prototype.fstatSync = function(fd, options) {
      return this.fstatBase(fd, getStatOptions(options).bigint);
    };
    Volume2.prototype.fstat = function(fd, a72, b52) {
      var _a2 = getStatOptsAndCb(a72, b52), opts2 = _a2[0], callback = _a2[1];
      this.wrapAsync(this.fstatBase, [fd, opts2.bigint], callback);
    };
    Volume2.prototype.renameBase = function(oldPathFilename, newPathFilename) {
      var link2 = this.getLink(filenameToSteps(oldPathFilename));
      if (!link2)
        throw createError(ENOENT2, "rename", oldPathFilename, newPathFilename);
      var newPathSteps = filenameToSteps(newPathFilename);
      var newPathDirLink = this.getLinkParent(newPathSteps);
      if (!newPathDirLink)
        throw createError(ENOENT2, "rename", oldPathFilename, newPathFilename);
      var oldLinkParent = link2.parent;
      if (oldLinkParent) {
        oldLinkParent.deleteChild(link2);
      }
      var name2 = newPathSteps[newPathSteps.length - 1];
      link2.steps = __spreadArray(__spreadArray([], newPathDirLink.steps, true), [name2], false);
      newPathDirLink.setChild(link2.getName(), link2);
    };
    Volume2.prototype.renameSync = function(oldPath, newPath) {
      var oldPathFilename = pathToFilename(oldPath);
      var newPathFilename = pathToFilename(newPath);
      this.renameBase(oldPathFilename, newPathFilename);
    };
    Volume2.prototype.rename = function(oldPath, newPath, callback) {
      var oldPathFilename = pathToFilename(oldPath);
      var newPathFilename = pathToFilename(newPath);
      this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
    };
    Volume2.prototype.existsBase = function(filename) {
      return !!this.statBase(filename);
    };
    Volume2.prototype.existsSync = function(path22) {
      try {
        return this.existsBase(pathToFilename(path22));
      } catch (err) {
        return false;
      }
    };
    Volume2.prototype.exists = function(path22, callback) {
      var _this = this;
      var filename = pathToFilename(path22);
      if (typeof callback !== "function")
        throw Error(ERRSTR.CB);
      (0, setImmediate_1.default)(function() {
        try {
          callback(_this.existsBase(filename));
        } catch (err) {
          callback(false);
        }
      });
    };
    Volume2.prototype.accessBase = function(filename, mode) {
      this.getLinkOrThrow(filename, "access");
    };
    Volume2.prototype.accessSync = function(path22, mode) {
      if (mode === void 0) {
        mode = F_OK22;
      }
      var filename = pathToFilename(path22);
      mode = mode | 0;
      this.accessBase(filename, mode);
    };
    Volume2.prototype.access = function(path22, a72, b52) {
      var mode = F_OK22;
      var callback;
      if (typeof a72 !== "function") {
        mode = a72 | 0;
        callback = validateCallback(b52);
      } else {
        callback = a72;
      }
      var filename = pathToFilename(path22);
      this.wrapAsync(this.accessBase, [filename, mode], callback);
    };
    Volume2.prototype.appendFileSync = function(id, data, options) {
      if (options === void 0) {
        options = appendFileDefaults;
      }
      var opts2 = getAppendFileOpts(options);
      if (!opts2.flag || isFd(id))
        opts2.flag = "a";
      this.writeFileSync(id, data, opts2);
    };
    Volume2.prototype.appendFile = function(id, data, a72, b52) {
      var _a2 = getAppendFileOptsAndCb(a72, b52), opts2 = _a2[0], callback = _a2[1];
      if (!opts2.flag || isFd(id))
        opts2.flag = "a";
      this.writeFile(id, data, opts2, callback);
    };
    Volume2.prototype.readdirBase = function(filename, options) {
      var steps = filenameToSteps(filename);
      var link2 = this.getResolvedLink(steps);
      if (!link2)
        throw createError(ENOENT2, "readdir", filename);
      var node = link2.getNode();
      if (!node.isDirectory())
        throw createError(ENOTDIR2, "scandir", filename);
      if (options.withFileTypes) {
        var list_1 = [];
        for (var name_3 in link2.children) {
          var child = link2.getChild(name_3);
          if (!child) {
            continue;
          }
          list_1.push(Dirent_1.default.build(child, options.encoding));
        }
        if (!isWin && options.encoding !== "buffer")
          list_1.sort(function(a72, b52) {
            if (a72.name < b52.name)
              return -1;
            if (a72.name > b52.name)
              return 1;
            return 0;
          });
        return list_1;
      }
      var list = [];
      for (var name_4 in link2.children) {
        list.push((0, encoding_1.strToEncoding)(name_4, options.encoding));
      }
      if (!isWin && options.encoding !== "buffer")
        list.sort();
      return list;
    };
    Volume2.prototype.readdirSync = function(path22, options) {
      var opts2 = getReaddirOptions(options);
      var filename = pathToFilename(path22);
      return this.readdirBase(filename, opts2);
    };
    Volume2.prototype.readdir = function(path22, a72, b52) {
      var _a2 = getReaddirOptsAndCb(a72, b52), options = _a2[0], callback = _a2[1];
      var filename = pathToFilename(path22);
      this.wrapAsync(this.readdirBase, [filename, options], callback);
    };
    Volume2.prototype.readlinkBase = function(filename, encoding) {
      var link2 = this.getLinkOrThrow(filename, "readlink");
      var node = link2.getNode();
      if (!node.isSymlink())
        throw createError(EINVAL2, "readlink", filename);
      var str = sep22 + node.symlink.join(sep22);
      return (0, encoding_1.strToEncoding)(str, encoding);
    };
    Volume2.prototype.readlinkSync = function(path22, options) {
      var opts2 = getDefaultOpts(options);
      var filename = pathToFilename(path22);
      return this.readlinkBase(filename, opts2.encoding);
    };
    Volume2.prototype.readlink = function(path22, a72, b52) {
      var _a2 = getDefaultOptsAndCb(a72, b52), opts2 = _a2[0], callback = _a2[1];
      var filename = pathToFilename(path22);
      this.wrapAsync(this.readlinkBase, [filename, opts2.encoding], callback);
    };
    Volume2.prototype.fsyncBase = function(fd) {
      this.getFileByFdOrThrow(fd, "fsync");
    };
    Volume2.prototype.fsyncSync = function(fd) {
      this.fsyncBase(fd);
    };
    Volume2.prototype.fsync = function(fd, callback) {
      this.wrapAsync(this.fsyncBase, [fd], callback);
    };
    Volume2.prototype.fdatasyncBase = function(fd) {
      this.getFileByFdOrThrow(fd, "fdatasync");
    };
    Volume2.prototype.fdatasyncSync = function(fd) {
      this.fdatasyncBase(fd);
    };
    Volume2.prototype.fdatasync = function(fd, callback) {
      this.wrapAsync(this.fdatasyncBase, [fd], callback);
    };
    Volume2.prototype.ftruncateBase = function(fd, len) {
      var file = this.getFileByFdOrThrow(fd, "ftruncate");
      file.truncate(len);
    };
    Volume2.prototype.ftruncateSync = function(fd, len) {
      this.ftruncateBase(fd, len);
    };
    Volume2.prototype.ftruncate = function(fd, a72, b52) {
      var len = typeof a72 === "number" ? a72 : 0;
      var callback = validateCallback(typeof a72 === "number" ? b52 : a72);
      this.wrapAsync(this.ftruncateBase, [fd, len], callback);
    };
    Volume2.prototype.truncateBase = function(path22, len) {
      var fd = this.openSync(path22, "r+");
      try {
        this.ftruncateSync(fd, len);
      } finally {
        this.closeSync(fd);
      }
    };
    Volume2.prototype.truncateSync = function(id, len) {
      if (isFd(id))
        return this.ftruncateSync(id, len);
      this.truncateBase(id, len);
    };
    Volume2.prototype.truncate = function(id, a72, b52) {
      var len = typeof a72 === "number" ? a72 : 0;
      var callback = validateCallback(typeof a72 === "number" ? b52 : a72);
      if (isFd(id))
        return this.ftruncate(id, len, callback);
      this.wrapAsync(this.truncateBase, [id, len], callback);
    };
    Volume2.prototype.futimesBase = function(fd, atime, mtime) {
      var file = this.getFileByFdOrThrow(fd, "futimes");
      var node = file.node;
      node.atime = new Date(atime * 1e3);
      node.mtime = new Date(mtime * 1e3);
    };
    Volume2.prototype.futimesSync = function(fd, atime, mtime) {
      this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };
    Volume2.prototype.futimes = function(fd, atime, mtime, callback) {
      this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };
    Volume2.prototype.utimesBase = function(filename, atime, mtime) {
      var fd = this.openSync(filename, "r+");
      try {
        this.futimesBase(fd, atime, mtime);
      } finally {
        this.closeSync(fd);
      }
    };
    Volume2.prototype.utimesSync = function(path22, atime, mtime) {
      this.utimesBase(pathToFilename(path22), toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };
    Volume2.prototype.utimes = function(path22, atime, mtime, callback) {
      this.wrapAsync(this.utimesBase, [pathToFilename(path22), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };
    Volume2.prototype.mkdirBase = function(filename, modeNum) {
      var steps = filenameToSteps(filename);
      if (!steps.length) {
        throw createError(EEXIST2, "mkdir", filename);
      }
      var dir = this.getLinkParentAsDirOrThrow(filename, "mkdir");
      var name2 = steps[steps.length - 1];
      if (dir.getChild(name2))
        throw createError(EEXIST2, "mkdir", filename);
      dir.createChild(name2, this.createNode(true, modeNum));
    };
    Volume2.prototype.mkdirpBase = function(filename, modeNum) {
      var steps = filenameToSteps(filename);
      var link2 = this.root;
      for (var i72 = 0; i72 < steps.length; i72++) {
        var step = steps[i72];
        if (!link2.getNode().isDirectory())
          throw createError(ENOTDIR2, "mkdir", link2.getPath());
        var child = link2.getChild(step);
        if (child) {
          if (child.getNode().isDirectory())
            link2 = child;
          else
            throw createError(ENOTDIR2, "mkdir", child.getPath());
        } else {
          link2 = link2.createChild(step, this.createNode(true, modeNum));
        }
      }
    };
    Volume2.prototype.mkdirSync = function(path22, options) {
      var opts2 = getMkdirOptions(options);
      var modeNum = modeToNumber(opts2.mode, 511);
      var filename = pathToFilename(path22);
      if (opts2.recursive)
        this.mkdirpBase(filename, modeNum);
      else
        this.mkdirBase(filename, modeNum);
    };
    Volume2.prototype.mkdir = function(path22, a72, b52) {
      var opts2 = getMkdirOptions(a72);
      var callback = validateCallback(typeof a72 === "function" ? a72 : b52);
      var modeNum = modeToNumber(opts2.mode, 511);
      var filename = pathToFilename(path22);
      if (opts2.recursive)
        this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);
      else
        this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
    };
    Volume2.prototype.mkdirpSync = function(path22, mode) {
      this.mkdirSync(path22, {
        mode,
        recursive: true
      });
    };
    Volume2.prototype.mkdirp = function(path22, a72, b52) {
      var mode = typeof a72 === "function" ? void 0 : a72;
      var callback = validateCallback(typeof a72 === "function" ? a72 : b52);
      this.mkdir(path22, {
        mode,
        recursive: true
      }, callback);
    };
    Volume2.prototype.mkdtempBase = function(prefix, encoding, retry) {
      if (retry === void 0) {
        retry = 5;
      }
      var filename = prefix + this.genRndStr();
      try {
        this.mkdirBase(
          filename,
          511
          /* DIR */
        );
        return (0, encoding_1.strToEncoding)(filename, encoding);
      } catch (err) {
        if (err.code === EEXIST2) {
          if (retry > 1)
            return this.mkdtempBase(prefix, encoding, retry - 1);
          else
            throw Error("Could not create temp dir.");
        } else
          throw err;
      }
    };
    Volume2.prototype.mkdtempSync = function(prefix, options) {
      var encoding = getDefaultOpts(options).encoding;
      if (!prefix || typeof prefix !== "string")
        throw new TypeError("filename prefix is required");
      nullCheck(prefix);
      return this.mkdtempBase(prefix, encoding);
    };
    Volume2.prototype.mkdtemp = function(prefix, a72, b52) {
      var _a2 = getDefaultOptsAndCb(a72, b52), encoding = _a2[0].encoding, callback = _a2[1];
      if (!prefix || typeof prefix !== "string")
        throw new TypeError("filename prefix is required");
      if (!nullCheck(prefix))
        return;
      this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
    };
    Volume2.prototype.rmdirBase = function(filename, options) {
      var opts2 = getRmdirOptions(options);
      var link2 = this.getLinkAsDirOrThrow(filename, "rmdir");
      if (link2.length && !opts2.recursive)
        throw createError(ENOTEMPTY2, "rmdir", filename);
      this.deleteLink(link2);
    };
    Volume2.prototype.rmdirSync = function(path22, options) {
      this.rmdirBase(pathToFilename(path22), options);
    };
    Volume2.prototype.rmdir = function(path22, a72, b52) {
      var opts2 = getRmdirOptions(a72);
      var callback = validateCallback(typeof a72 === "function" ? a72 : b52);
      this.wrapAsync(this.rmdirBase, [pathToFilename(path22), opts2], callback);
    };
    Volume2.prototype.fchmodBase = function(fd, modeNum) {
      var file = this.getFileByFdOrThrow(fd, "fchmod");
      file.chmod(modeNum);
    };
    Volume2.prototype.fchmodSync = function(fd, mode) {
      this.fchmodBase(fd, modeToNumber(mode));
    };
    Volume2.prototype.fchmod = function(fd, mode, callback) {
      this.wrapAsync(this.fchmodBase, [fd, modeToNumber(mode)], callback);
    };
    Volume2.prototype.chmodBase = function(filename, modeNum) {
      var fd = this.openSync(filename, "r+");
      try {
        this.fchmodBase(fd, modeNum);
      } finally {
        this.closeSync(fd);
      }
    };
    Volume2.prototype.chmodSync = function(path22, mode) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path22);
      this.chmodBase(filename, modeNum);
    };
    Volume2.prototype.chmod = function(path22, mode, callback) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path22);
      this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
    };
    Volume2.prototype.lchmodBase = function(filename, modeNum) {
      var fd = this.openBase(filename, O_RDWR2, 0, false);
      try {
        this.fchmodBase(fd, modeNum);
      } finally {
        this.closeSync(fd);
      }
    };
    Volume2.prototype.lchmodSync = function(path22, mode) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path22);
      this.lchmodBase(filename, modeNum);
    };
    Volume2.prototype.lchmod = function(path22, mode, callback) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path22);
      this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
    };
    Volume2.prototype.fchownBase = function(fd, uid, gid) {
      this.getFileByFdOrThrow(fd, "fchown").chown(uid, gid);
    };
    Volume2.prototype.fchownSync = function(fd, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.fchownBase(fd, uid, gid);
    };
    Volume2.prototype.fchown = function(fd, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
    };
    Volume2.prototype.chownBase = function(filename, uid, gid) {
      var link2 = this.getResolvedLinkOrThrow(filename, "chown");
      var node = link2.getNode();
      node.chown(uid, gid);
    };
    Volume2.prototype.chownSync = function(path22, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.chownBase(pathToFilename(path22), uid, gid);
    };
    Volume2.prototype.chown = function(path22, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.chownBase, [pathToFilename(path22), uid, gid], callback);
    };
    Volume2.prototype.lchownBase = function(filename, uid, gid) {
      this.getLinkOrThrow(filename, "lchown").getNode().chown(uid, gid);
    };
    Volume2.prototype.lchownSync = function(path22, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.lchownBase(pathToFilename(path22), uid, gid);
    };
    Volume2.prototype.lchown = function(path22, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.lchownBase, [pathToFilename(path22), uid, gid], callback);
    };
    Volume2.prototype.watchFile = function(path22, a72, b52) {
      var filename = pathToFilename(path22);
      var options = a72;
      var listener = b52;
      if (typeof options === "function") {
        listener = a72;
        options = null;
      }
      if (typeof listener !== "function") {
        throw Error('"watchFile()" requires a listener function');
      }
      var interval = 5007;
      var persistent = true;
      if (options && typeof options === "object") {
        if (typeof options.interval === "number")
          interval = options.interval;
        if (typeof options.persistent === "boolean")
          persistent = options.persistent;
      }
      var watcher = this.statWatchers[filename];
      if (!watcher) {
        watcher = new this.StatWatcher();
        watcher.start(filename, persistent, interval);
        this.statWatchers[filename] = watcher;
      }
      watcher.addListener("change", listener);
      return watcher;
    };
    Volume2.prototype.unwatchFile = function(path22, listener) {
      var filename = pathToFilename(path22);
      var watcher = this.statWatchers[filename];
      if (!watcher)
        return;
      if (typeof listener === "function") {
        watcher.removeListener("change", listener);
      } else {
        watcher.removeAllListeners("change");
      }
      if (watcher.listenerCount("change") === 0) {
        watcher.stop();
        delete this.statWatchers[filename];
      }
    };
    Volume2.prototype.createReadStream = function(path22, options) {
      return new this.ReadStream(path22, options);
    };
    Volume2.prototype.createWriteStream = function(path22, options) {
      return new this.WriteStream(path22, options);
    };
    Volume2.prototype.watch = function(path22, options, listener) {
      var filename = pathToFilename(path22);
      var givenOptions = options;
      if (typeof options === "function") {
        listener = options;
        givenOptions = null;
      }
      var _a2 = getDefaultOpts(givenOptions), persistent = _a2.persistent, recursive = _a2.recursive, encoding = _a2.encoding;
      if (persistent === void 0)
        persistent = true;
      if (recursive === void 0)
        recursive = false;
      var watcher = new this.FSWatcher();
      watcher.start(filename, persistent, recursive, encoding);
      if (listener) {
        watcher.addListener("change", listener);
      }
      return watcher;
    };
    Volume2.fd = 2147483647;
    return Volume2;
  }();
  exports$42.Volume = Volume;
  function emitStop(self2) {
    self2.emit("stop");
  }
  var StatWatcher = function(_super) {
    __extends(StatWatcher2, _super);
    function StatWatcher2(vol2) {
      var _this = _super.call(this) || this;
      _this.onInterval = function() {
        try {
          var stats = _this.vol.statSync(_this.filename);
          if (_this.hasChanged(stats)) {
            _this.emit("change", stats, _this.prev);
            _this.prev = stats;
          }
        } finally {
          _this.loop();
        }
      };
      _this.vol = vol2;
      return _this;
    }
    StatWatcher2.prototype.loop = function() {
      this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
    };
    StatWatcher2.prototype.hasChanged = function(stats) {
      if (stats.mtimeMs > this.prev.mtimeMs)
        return true;
      if (stats.nlink !== this.prev.nlink)
        return true;
      return false;
    };
    StatWatcher2.prototype.start = function(path22, persistent, interval) {
      if (persistent === void 0) {
        persistent = true;
      }
      if (interval === void 0) {
        interval = 5007;
      }
      this.filename = pathToFilename(path22);
      this.setTimeout = persistent ? setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : _global4) : setTimeoutUnref_1.default;
      this.interval = interval;
      this.prev = this.vol.statSync(this.filename);
      this.loop();
    };
    StatWatcher2.prototype.stop = function() {
      clearTimeout(this.timeoutRef);
      process_1.default.nextTick(emitStop, this);
    };
    return StatWatcher2;
  }(events_1.EventEmitter);
  exports$42.StatWatcher = StatWatcher;
  var pool;
  function allocNewPool(poolSize) {
    pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);
    pool.used = 0;
  }
  util.inherits(FsReadStream, stream_1.Readable);
  exports$42.ReadStream = FsReadStream;
  function FsReadStream(vol2, path22, options) {
    if (!(this instanceof FsReadStream))
      return new FsReadStream(vol2, path22, options);
    this._vol = vol2;
    options = Object.assign({}, getOptions(options, {}));
    if (options.highWaterMark === void 0)
      options.highWaterMark = 64 * 1024;
    stream_1.Readable.call(this, options);
    this.path = pathToFilename(path22);
    this.fd = options.fd === void 0 ? null : options.fd;
    this.flags = options.flags === void 0 ? "r" : options.flags;
    this.mode = options.mode === void 0 ? 438 : options.mode;
    this.start = options.start;
    this.end = options.end;
    this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
    this.pos = void 0;
    this.bytesRead = 0;
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw new TypeError('"start" option must be a Number');
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if (typeof this.end !== "number") {
        throw new TypeError('"end" option must be a Number');
      }
      if (this.start > this.end) {
        throw new Error('"start" option must be <= "end" option');
      }
      this.pos = this.start;
    }
    if (typeof this.fd !== "number")
      this.open();
    this.on("end", function() {
      if (this.autoClose) {
        if (this.destroy)
          this.destroy();
      }
    });
  }
  FsReadStream.prototype.open = function() {
    var self2 = this;
    this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
      if (er) {
        if (self2.autoClose) {
          if (self2.destroy)
            self2.destroy();
        }
        self2.emit("error", er);
        return;
      }
      self2.fd = fd;
      self2.emit("open", fd);
      self2.read();
    });
  };
  FsReadStream.prototype._read = function(n82) {
    if (typeof this.fd !== "number") {
      return this.once("open", function() {
        this._read(n82);
      });
    }
    if (this.destroyed)
      return;
    if (!pool || pool.length - pool.used < kMinPoolSpace) {
      allocNewPool(this._readableState.highWaterMark);
    }
    var thisPool = pool;
    var toRead = Math.min(pool.length - pool.used, n82);
    var start = pool.used;
    if (this.pos !== void 0)
      toRead = Math.min(this.end - this.pos + 1, toRead);
    if (toRead <= 0)
      return this.push(null);
    var self2 = this;
    this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread);
    if (this.pos !== void 0)
      this.pos += toRead;
    pool.used += toRead;
    function onread(er, bytesRead) {
      if (er) {
        if (self2.autoClose && self2.destroy) {
          self2.destroy();
        }
        self2.emit("error", er);
      } else {
        var b52 = null;
        if (bytesRead > 0) {
          self2.bytesRead += bytesRead;
          b52 = thisPool.slice(start, start + bytesRead);
        }
        self2.push(b52);
      }
    }
  };
  FsReadStream.prototype._destroy = function(err, cb) {
    this.close(function(err2) {
      cb(err || err2);
    });
  };
  FsReadStream.prototype.close = function(cb) {
    var _this = this;
    if (cb)
      this.once("close", cb);
    if (this.closed || typeof this.fd !== "number") {
      if (typeof this.fd !== "number") {
        this.once("open", closeOnOpen);
        return;
      }
      return process_1.default.nextTick(function() {
        return _this.emit("close");
      });
    }
    this.closed = true;
    this._vol.close(this.fd, function(er) {
      if (er)
        _this.emit("error", er);
      else
        _this.emit("close");
    });
    this.fd = null;
  };
  function closeOnOpen(fd) {
    this.close();
  }
  util.inherits(FsWriteStream, stream_1.Writable);
  exports$42.WriteStream = FsWriteStream;
  function FsWriteStream(vol2, path22, options) {
    if (!(this instanceof FsWriteStream))
      return new FsWriteStream(vol2, path22, options);
    this._vol = vol2;
    options = Object.assign({}, getOptions(options, {}));
    stream_1.Writable.call(this, options);
    this.path = pathToFilename(path22);
    this.fd = options.fd === void 0 ? null : options.fd;
    this.flags = options.flags === void 0 ? "w" : options.flags;
    this.mode = options.mode === void 0 ? 438 : options.mode;
    this.start = options.start;
    this.autoClose = options.autoClose === void 0 ? true : !!options.autoClose;
    this.pos = void 0;
    this.bytesWritten = 0;
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw new TypeError('"start" option must be a Number');
      }
      if (this.start < 0) {
        throw new Error('"start" must be >= zero');
      }
      this.pos = this.start;
    }
    if (options.encoding)
      this.setDefaultEncoding(options.encoding);
    if (typeof this.fd !== "number")
      this.open();
    this.once("finish", function() {
      if (this.autoClose) {
        this.close();
      }
    });
  }
  FsWriteStream.prototype.open = function() {
    this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
      if (er) {
        if (this.autoClose && this.destroy) {
          this.destroy();
        }
        this.emit("error", er);
        return;
      }
      this.fd = fd;
      this.emit("open", fd);
    }.bind(this));
  };
  FsWriteStream.prototype._write = function(data, encoding, cb) {
    if (!(data instanceof buffer_1.Buffer))
      return this.emit("error", new Error("Invalid data"));
    if (typeof this.fd !== "number") {
      return this.once("open", function() {
        this._write(data, encoding, cb);
      });
    }
    var self2 = this;
    this._vol.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {
      if (er) {
        if (self2.autoClose && self2.destroy) {
          self2.destroy();
        }
        return cb(er);
      }
      self2.bytesWritten += bytes;
      cb();
    });
    if (this.pos !== void 0)
      this.pos += data.length;
  };
  FsWriteStream.prototype._writev = function(data, cb) {
    if (typeof this.fd !== "number") {
      return this.once("open", function() {
        this._writev(data, cb);
      });
    }
    var self2 = this;
    var len = data.length;
    var chunks = new Array(len);
    var size = 0;
    for (var i72 = 0; i72 < len; i72++) {
      var chunk = data[i72].chunk;
      chunks[i72] = chunk;
      size += chunk.length;
    }
    var buf = buffer_1.Buffer.concat(chunks);
    this._vol.write(this.fd, buf, 0, buf.length, this.pos, function(er, bytes) {
      if (er) {
        if (self2.destroy)
          self2.destroy();
        return cb(er);
      }
      self2.bytesWritten += bytes;
      cb();
    });
    if (this.pos !== void 0)
      this.pos += size;
  };
  FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
  FsWriteStream.prototype.close = FsReadStream.prototype.close;
  FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
  var FSWatcher = function(_super) {
    __extends(FSWatcher2, _super);
    function FSWatcher2(vol2) {
      var _this = _super.call(this) || this;
      _this._filename = "";
      _this._filenameEncoded = "";
      _this._recursive = false;
      _this._encoding = encoding_1.ENCODING_UTF8;
      _this._onNodeChange = function() {
        _this._emit("change");
      };
      _this._onParentChild = function(link2) {
        if (link2.getName() === _this._getName()) {
          _this._emit("rename");
        }
      };
      _this._emit = function(type2) {
        _this.emit("change", type2, _this._filenameEncoded);
      };
      _this._persist = function() {
        _this._timer = setTimeout(_this._persist, 1e6);
      };
      _this._vol = vol2;
      return _this;
    }
    FSWatcher2.prototype._getName = function() {
      return this._steps[this._steps.length - 1];
    };
    FSWatcher2.prototype.start = function(path22, persistent, recursive, encoding) {
      if (persistent === void 0) {
        persistent = true;
      }
      if (recursive === void 0) {
        recursive = false;
      }
      if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
      }
      this._filename = pathToFilename(path22);
      this._steps = filenameToSteps(this._filename);
      this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);
      this._recursive = recursive;
      this._encoding = encoding;
      try {
        this._link = this._vol.getLinkOrThrow(this._filename, "FSWatcher");
      } catch (err) {
        var error = new Error("watch " + this._filename + " " + err.code);
        error.code = err.code;
        error.errno = err.code;
        throw error;
      }
      this._link.getNode().on("change", this._onNodeChange);
      this._link.on("child:add", this._onNodeChange);
      this._link.on("child:delete", this._onNodeChange);
      var parent = this._link.parent;
      if (parent) {
        parent.setMaxListeners(parent.getMaxListeners() + 1);
        parent.on("child:delete", this._onParentChild);
      }
      if (persistent)
        this._persist();
    };
    FSWatcher2.prototype.close = function() {
      clearTimeout(this._timer);
      this._link.getNode().removeListener("change", this._onNodeChange);
      var parent = this._link.parent;
      if (parent) {
        parent.removeListener("child:delete", this._onParentChild);
      }
    };
    return FSWatcher2;
  }(events_1.EventEmitter);
  exports$42.FSWatcher = FSWatcher;
  return exports$42;
}
function dew$13() {
  if (_dewExec$13)
    return exports$33;
  _dewExec$13 = true;
  Object.defineProperty(exports$33, "__esModule", {
    value: true
  });
  exports$33.fsAsyncMethods = exports$33.fsSyncMethods = exports$33.fsProps = void 0;
  var fsProps = ["constants", "F_OK", "R_OK", "W_OK", "X_OK", "Stats"];
  exports$33.fsProps = fsProps;
  var fsSyncMethods = ["renameSync", "ftruncateSync", "truncateSync", "chownSync", "fchownSync", "lchownSync", "chmodSync", "fchmodSync", "lchmodSync", "statSync", "lstatSync", "fstatSync", "linkSync", "symlinkSync", "readlinkSync", "realpathSync", "unlinkSync", "rmdirSync", "mkdirSync", "mkdirpSync", "readdirSync", "closeSync", "openSync", "utimesSync", "futimesSync", "fsyncSync", "writeSync", "readSync", "readFileSync", "writeFileSync", "appendFileSync", "existsSync", "accessSync", "fdatasyncSync", "mkdtempSync", "copyFileSync", "createReadStream", "createWriteStream"];
  exports$33.fsSyncMethods = fsSyncMethods;
  var fsAsyncMethods = ["rename", "ftruncate", "truncate", "chown", "fchown", "lchown", "chmod", "fchmod", "lchmod", "stat", "lstat", "fstat", "link", "symlink", "readlink", "realpath", "unlink", "rmdir", "mkdir", "mkdirp", "readdir", "close", "open", "utimes", "futimes", "fsync", "write", "read", "readFile", "writeFile", "appendFile", "exists", "access", "fdatasync", "mkdtemp", "copyFile", "watchFile", "unwatchFile", "watch"];
  exports$33.fsAsyncMethods = fsAsyncMethods;
  return exports$33;
}
function dew7() {
  if (_dewExec7)
    return exports$23;
  _dewExec7 = true;
  var __assign = exports$23 && exports$23.__assign || function() {
    __assign = Object.assign || function(t82) {
      for (var s62, i72 = 1, n82 = arguments.length; i72 < n82; i72++) {
        s62 = arguments[i72];
        for (var p72 in s62)
          if (Object.prototype.hasOwnProperty.call(s62, p72))
            t82[p72] = s62[p72];
      }
      return t82;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports$23, "__esModule", {
    value: true
  });
  exports$23.fs = exports$23.createFsFromVolume = exports$23.vol = exports$23.Volume = void 0;
  var Stats_1 = dew$d2();
  var Dirent_1 = dew$92();
  var volume_1 = dew$23();
  var _a = dew$13(), fsSyncMethods = _a.fsSyncMethods, fsAsyncMethods = _a.fsAsyncMethods;
  var constants_1 = dew$f2();
  var F_OK22 = constants_1.constants.F_OK, R_OK22 = constants_1.constants.R_OK, W_OK22 = constants_1.constants.W_OK, X_OK22 = constants_1.constants.X_OK;
  exports$23.Volume = volume_1.Volume;
  exports$23.vol = new volume_1.Volume();
  function createFsFromVolume2(vol2) {
    var fs2 = {
      F_OK: F_OK22,
      R_OK: R_OK22,
      W_OK: W_OK22,
      X_OK: X_OK22,
      constants: constants_1.constants,
      Stats: Stats_1.default,
      Dirent: Dirent_1.default
    };
    for (var _i = 0, fsSyncMethods_1 = fsSyncMethods; _i < fsSyncMethods_1.length; _i++) {
      var method = fsSyncMethods_1[_i];
      if (typeof vol2[method] === "function")
        fs2[method] = vol2[method].bind(vol2);
    }
    for (var _a2 = 0, fsAsyncMethods_1 = fsAsyncMethods; _a2 < fsAsyncMethods_1.length; _a2++) {
      var method = fsAsyncMethods_1[_a2];
      if (typeof vol2[method] === "function")
        fs2[method] = vol2[method].bind(vol2);
    }
    fs2.StatWatcher = vol2.StatWatcher;
    fs2.FSWatcher = vol2.FSWatcher;
    fs2.WriteStream = vol2.WriteStream;
    fs2.ReadStream = vol2.ReadStream;
    fs2.promises = vol2.promises;
    fs2._toUnixTimestamp = volume_1.toUnixTimestamp;
    return fs2;
  }
  exports$23.createFsFromVolume = createFsFromVolume2;
  exports$23.fs = createFsFromVolume2(exports$23.vol);
  exports$23 = __assign(__assign({}, exports$23), exports$23.fs);
  exports$23.semantic = true;
  return exports$23;
}
function unimplemented2(name2) {
  throw new Error(`Node.js fs ${name2} is not supported by JSPM core in the browser`);
}
function watchStdo(path22, fd, listener) {
  let oldSize = 0;
  const decoder = new TextDecoder();
  vol.watch(path22, "utf8", () => {
    const { size } = vol.fstatSync(fd);
    const buf = Buffer2.alloc(size - oldSize);
    vol.readSync(fd, buf, 0, buf.length, oldSize);
    oldSize = size;
    listener(decoder.decode(buf, { stream: true }));
  });
}
function handleFsUrl(url, isSync) {
  if (url.protocol === "file:")
    return fileURLToPath(url);
  if (url.protocol === "https:" || url.protocol === "http:") {
    const path22 = "\\\\url\\" + url.href.replaceAll(/\//g, "\\\\");
    if (existsSync(path22))
      return path22;
    if (isSync)
      throw new Error(`Cannot sync request URL ${url} via FS. JSPM FS support for network URLs requires using async FS methods or priming the MemFS cache first with an async request before a sync request.`);
    return (async () => {
      const res = await fetch(url);
      if (!res.ok)
        throw new Error(`Unable to fetch ${url.href}, ${res.status}`);
      const buf = await res.arrayBuffer();
      writeFileSync(path22, Buffer2.from(buf));
      return path22;
    })();
  }
  throw new Error("URL " + url + " not supported in JSPM FS implementation.");
}
function wrapFsSync(fn) {
  return function(path22, ...args) {
    if (path22 instanceof URL)
      return fn(handleFsUrl(path22, true), ...args);
    return fn(path22, ...args);
  };
}
function wrapFsPromise(fn) {
  return async function(path22, ...args) {
    if (path22 instanceof URL)
      return fn(await handleFsUrl(path22), ...args);
    return fn(path22, ...args);
  };
}
function wrapFsCallback(fn) {
  return function(path22, ...args) {
    const cb = args[args.length - 1];
    if (path22 instanceof URL && typeof cb === "function") {
      handleFsUrl(path22).then((path3) => {
        fn(path3, ...args);
      }, cb);
    } else {
      fn(path22, ...args);
    }
  };
}
var e, t, n, r, i, s, y, e2, t2, n2, r2, o2, l2, s2, f2, a2, T, t3, e3, o3, n3, r3, l3, t$1, o$1, n$1, e$1, r$1, c3, u3, i3, t$2, i$1, o$2, u$1, f3, a3, s3, p3, y2, l$1, d2, m2, h3, j, A, Q, X, Y, ee, te, re, ne, ie, Se, Ee, _extend, callbackify, debuglog, deprecate, format2, inherits, inspect, isArray, isBoolean, isBuffer, isDate, isError, isFunction, isNull, isNullOrUndefined, isNumber, isObject, isPrimitive, isRegExp, isString, isSymbol, isUndefined, log, promisify, types, TextEncoder, TextDecoder2, exports4, _dewExec4, _global2, process3, r$13, t$13, e$22, n$22, o$23, a$12, h$12, a$1$1, e$1$1, n$1$1, i$12, o$1$1, j2, Y2, e4, n4, o4, u4, e$12, s4, i4, exports$2$1, _dewExec$2$1, exports$1$1, _dewExec$1$1, exports$g, _dewExec$g, buffer, exports$f, _dewExec$f, exports$e, _dewExec$e, exports$d, _dewExec$d, exports$c, _dewExec$c, exports$b, _dewExec$b, exports$a, _dewExec$a, exports$9, _dewExec$9, _global$2, exports$8, _dewExec$8, _global$1, exports$7, _dewExec$7, exports$6, _dewExec$6, exports$5, _dewExec$5, exports$4, _dewExec$4, exports$3, _dewExec$3, _global22, exports$2, _dewExec$2, exports$13, _dewExec$1, exports22, _dewExec22, r5, t5, e$13, r$12, n8, o8, c7, l7, i7, a7, u7, f7, p7, s6, y4, b3, g3, h5, $2, j3, w3, r$2, e$2, o$13, n$13, a$1, c$13, l$13, u$13, f$12, t$12, f$22, e$3, l$2, t$22, n$2, o$22, r$3, e$4, o$3, t$3, n$3, y$1, a$22, i$13, d4, f$3, u$22, A3, l$3, v4, P3, c$2, t$4, p$1, o$4, i$2, a$3, l$4, r$4, n$4, i$3, o$5, c$3, f$4, u$3, s$12, a$4, l$5, p$2, m4, N3, e$5, i$4, n$5, t$5, u$4, a$5, m$1, o$6, s$2, f$5, c$4, a$6, u$5, l$6, g$1, h$1, y$2, b$1, v$1, d$1, E3, w$1, S3, j$1, O3, x3, q2, R3, A$1, k3, _3, T4, P$1, I3, D3, F3, N$1, L3, M3, X2, Z2, $$1, et, AssertionError, deepEqual, deepStrictEqual, doesNotReject, doesNotThrow, equal, fail, ifError, notDeepEqual, notDeepStrictEqual, notEqual, notStrictEqual, ok, rejects, strict, strictEqual, throws, _extend2, callbackify2, debuglog2, deprecate2, format22, inherits2, inspect2, isArray2, isBoolean2, isBuffer2, isDate2, isError2, isFunction2, isNull2, isNullOrUndefined2, isNumber2, isObject2, isPrimitive2, isRegExp2, isString2, isSymbol2, isUndefined2, log2, promisify2, types2, TextEncoder2, TextDecoder3, exports$122, _dewExec32, exports32, _makeLong2, basename2, delimiter2, dirname2, extname2, format3, isAbsolute2, join2, normalize2, parse2, posix2, relative2, resolve2, sep2, win322, EventEmitter, defaultMaxListeners, init, listenerCount, on, once, exports$132, _dewExec42, _global3, exports42, Readable, Writable, Duplex, Transform, PassThrough, finished, pipeline, Stream, promises, t6, o5, n5, e6, r6, c5, s5, u5, a5, d5, h6, p5, n6, r7, t7, o6, h7, e8, a6, o7, n7, i6, l6, p6, c6, u6, f6, m5, v5, g4, y5, b4, exports5, _dewExec5, path, processPlatform$1, CHAR_BACKWARD_SLASH$1, CHAR_FORWARD_SLASH$1, CHAR_LOWERCASE_A$1, CHAR_LOWERCASE_Z$1, isWindows$1, forwardSlashRegEx$1, percentRegEx$1, backslashRegEx$1, newlineRegEx$1, carriageReturnRegEx$1, tabRegEx$1, processPlatform, Url, format4, resolve22, resolveObject, parse22, _URL, CHAR_BACKWARD_SLASH, CHAR_FORWARD_SLASH, CHAR_LOWERCASE_A, CHAR_LOWERCASE_Z, isWindows, forwardSlashRegEx, percentRegEx, backslashRegEx, newlineRegEx, carriageReturnRegEx, tabRegEx, exports$32, _dewExec$22, exports$22, _dewExec$12, exports$14, _dewExec6, exports6, Buffer2, INSPECT_MAX_BYTES, kMaxLength, exports$h, _dewExec$f2, exports$g2, _dewExec$e2, exports$f2, _dewExec$d2, exports$e2, _dewExec$c2, exports$d2, _dewExec$b2, _global$3, exports$c2, _dewExec$a2, exports$b2, _dewExec$92, exports$a2, _dewExec$82, _global$22, exports$92, _dewExec$72, exports$82, _dewExec$62, exports$72, _dewExec$52, _global$12, exports$62, _dewExec$42, exports$52, _dewExec$32, exports$42, _dewExec$23, _global4, exports$33, _dewExec$13, exports$23, _dewExec7, exports$15, exports7, vol, createFsFromVolume, fs, appendFile, appendFileSync, access, accessSync, chown, chownSync, chmod, chmodSync, close, closeSync, copyFile, copyFileSync, cp, cpSync, createReadStream, createWriteStream, exists, existsSync, fchown, fchownSync, fchmod, fchmodSync, fdatasync, fdatasyncSync, fstat, fstatSync, fsync, fsyncSync, ftruncate, ftruncateSync, futimes, futimesSync, lchown, lchownSync, lchmod, lchmodSync, link, linkSync, lstat, lstatSync, mkdir, mkdirSync, mkdtemp, mkdtempSync, open, openSync, opendir, opendirSync, readdir, readdirSync, read, readSync, readv, readvSync, readFile, readFileSync, readlink, readlinkSync, realpath, realpathSync, rename, renameSync, rm, rmSync, rmdir, rmdirSync, stat, statSync, symlink, symlinkSync, truncate, truncateSync, unwatchFile, unlink, unlinkSync, utimes, utimesSync, watch, watchFile, writeFile, writeFileSync, write, writeSync, writev, writevSync, Dir, Dirent, Stats, ReadStream, WriteStream, FileReadStream, FileWriteStream, _toUnixTimestamp, F_OK, R_OK, W_OK, X_OK, constants2, promises2;
var init_fs = __esm({
  "node-modules-polyfills:fs"() {
    n = "object" == typeof Reflect ? Reflect : null;
    r = n && "function" == typeof n.apply ? n.apply : function(e92, t82, n82) {
      return Function.prototype.apply.call(e92, t82, n82);
    };
    t = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(e92) {
      return Object.getOwnPropertyNames(e92).concat(Object.getOwnPropertySymbols(e92));
    } : function(e92) {
      return Object.getOwnPropertyNames(e92);
    };
    i = Number.isNaN || function(e92) {
      return e92 != e92;
    };
    e = o, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
    s = 10;
    Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
      return s;
    }, set: function(e92) {
      if ("number" != typeof e92 || e92 < 0 || i(e92))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e92 + ".");
      s = e92;
    } }), o.init = function() {
      void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    }, o.prototype.setMaxListeners = function(e92) {
      if ("number" != typeof e92 || e92 < 0 || i(e92))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e92 + ".");
      return this._maxListeners = e92, this;
    }, o.prototype.getMaxListeners = function() {
      return f(this);
    }, o.prototype.emit = function(e92) {
      for (var t82 = [], n82 = 1; n82 < arguments.length; n82++)
        t82.push(arguments[n82]);
      var i72 = "error" === e92, o82 = this._events;
      if (void 0 !== o82)
        i72 = i72 && void 0 === o82.error;
      else if (!i72)
        return false;
      if (i72) {
        var s62;
        if (t82.length > 0 && (s62 = t82[0]), s62 instanceof Error)
          throw s62;
        var u72 = new Error("Unhandled error." + (s62 ? " (" + s62.message + ")" : ""));
        throw u72.context = s62, u72;
      }
      var f72 = o82[e92];
      if (void 0 === f72)
        return false;
      if ("function" == typeof f72)
        r(f72, this, t82);
      else {
        var v62 = f72.length, a72 = c(f72, v62);
        for (n82 = 0; n82 < v62; ++n82)
          r(a72[n82], this, t82);
      }
      return true;
    }, o.prototype.addListener = function(e92, t82) {
      return v(this, e92, t82, false);
    }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e92, t82) {
      return v(this, e92, t82, true);
    }, o.prototype.once = function(e92, t82) {
      return u(t82), this.on(e92, l(this, e92, t82)), this;
    }, o.prototype.prependOnceListener = function(e92, t82) {
      return u(t82), this.prependListener(e92, l(this, e92, t82)), this;
    }, o.prototype.removeListener = function(e92, t82) {
      var n82, r92, i72, o82, s62;
      if (u(t82), void 0 === (r92 = this._events))
        return this;
      if (void 0 === (n82 = r92[e92]))
        return this;
      if (n82 === t82 || n82.listener === t82)
        0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r92[e92], r92.removeListener && this.emit("removeListener", e92, n82.listener || t82));
      else if ("function" != typeof n82) {
        for (i72 = -1, o82 = n82.length - 1; o82 >= 0; o82--)
          if (n82[o82] === t82 || n82[o82].listener === t82) {
            s62 = n82[o82].listener, i72 = o82;
            break;
          }
        if (i72 < 0)
          return this;
        0 === i72 ? n82.shift() : !function(e102, t92) {
          for (; t92 + 1 < e102.length; t92++)
            e102[t92] = e102[t92 + 1];
          e102.pop();
        }(n82, i72), 1 === n82.length && (r92[e92] = n82[0]), void 0 !== r92.removeListener && this.emit("removeListener", e92, s62 || t82);
      }
      return this;
    }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(e92) {
      var t82, n82, r92;
      if (void 0 === (n82 = this._events))
        return this;
      if (void 0 === n82.removeListener)
        return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n82[e92] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n82[e92]), this;
      if (0 === arguments.length) {
        var i72, o82 = Object.keys(n82);
        for (r92 = 0; r92 < o82.length; ++r92)
          "removeListener" !== (i72 = o82[r92]) && this.removeAllListeners(i72);
        return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
      }
      if ("function" == typeof (t82 = n82[e92]))
        this.removeListener(e92, t82);
      else if (void 0 !== t82)
        for (r92 = t82.length - 1; r92 >= 0; r92--)
          this.removeListener(e92, t82[r92]);
      return this;
    }, o.prototype.listeners = function(e92) {
      return h(this, e92, true);
    }, o.prototype.rawListeners = function(e92) {
      return h(this, e92, false);
    }, o.listenerCount = function(e92, t82) {
      return "function" == typeof e92.listenerCount ? e92.listenerCount(t82) : p.call(e92, t82);
    }, o.prototype.listenerCount = p, o.prototype.eventNames = function() {
      return this._eventsCount > 0 ? t(this._events) : [];
    };
    y = e;
    y.EventEmitter;
    y.defaultMaxListeners;
    y.init;
    y.listenerCount;
    y.EventEmitter;
    y.defaultMaxListeners;
    y.init;
    y.listenerCount;
    r2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis;
    o2 = e2 = {};
    !function() {
      try {
        t2 = "function" == typeof setTimeout ? setTimeout : i2;
      } catch (e92) {
        t2 = i2;
      }
      try {
        n2 = "function" == typeof clearTimeout ? clearTimeout : u2;
      } catch (e92) {
        n2 = u2;
      }
    }();
    s2 = [];
    f2 = false;
    a2 = -1;
    o2.nextTick = function(e92) {
      var t82 = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var n82 = 1; n82 < arguments.length; n82++)
          t82[n82 - 1] = arguments[n82];
      s2.push(new m(e92, t82)), 1 !== s2.length || f2 || c2(d);
    }, m.prototype.run = function() {
      (this || r2).fun.apply(null, (this || r2).array);
    }, o2.title = "browser", o2.browser = true, o2.env = {}, o2.argv = [], o2.version = "", o2.versions = {}, o2.on = p2, o2.addListener = p2, o2.once = p2, o2.off = p2, o2.removeListener = p2, o2.removeAllListeners = p2, o2.emit = p2, o2.prependListener = p2, o2.prependOnceListener = p2, o2.listeners = function(e92) {
      return [];
    }, o2.binding = function(e92) {
      throw new Error("process.binding is not supported");
    }, o2.cwd = function() {
      return "/";
    }, o2.chdir = function(e92) {
      throw new Error("process.chdir is not supported");
    }, o2.umask = function() {
      return 0;
    };
    T = e2;
    T.addListener;
    T.argv;
    T.binding;
    T.browser;
    T.chdir;
    T.cwd;
    T.emit;
    T.env;
    T.listeners;
    T.nextTick;
    T.off;
    T.on;
    T.once;
    T.prependListener;
    T.prependOnceListener;
    T.removeAllListeners;
    T.removeListener;
    T.title;
    T.umask;
    T.version;
    T.versions;
    t3 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
    e3 = Object.prototype.toString;
    o3 = function(o82) {
      return !(t3 && o82 && "object" == typeof o82 && Symbol.toStringTag in o82) && "[object Arguments]" === e3.call(o82);
    };
    n3 = function(t82) {
      return !!o3(t82) || null !== t82 && "object" == typeof t82 && "number" == typeof t82.length && t82.length >= 0 && "[object Array]" !== e3.call(t82) && "[object Function]" === e3.call(t82.callee);
    };
    r3 = function() {
      return o3(arguments);
    }();
    o3.isLegacyArguments = n3;
    l3 = r3 ? o3 : n3;
    t$1 = Object.prototype.toString;
    o$1 = Function.prototype.toString;
    n$1 = /^\s*(?:function)?\*/;
    e$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
    r$1 = Object.getPrototypeOf;
    c3 = function() {
      if (!e$1)
        return false;
      try {
        return Function("return function*() {}")();
      } catch (t82) {
      }
    }();
    u3 = c3 ? r$1(c3) : {};
    i3 = function(c72) {
      return "function" == typeof c72 && (!!n$1.test(o$1.call(c72)) || (e$1 ? r$1(c72) === u3 : "[object GeneratorFunction]" === t$1.call(c72)));
    };
    t$2 = "function" == typeof Object.create ? function(t82, e92) {
      e92 && (t82.super_ = e92, t82.prototype = Object.create(e92.prototype, { constructor: { value: t82, enumerable: false, writable: true, configurable: true } }));
    } : function(t82, e92) {
      if (e92) {
        t82.super_ = e92;
        var o82 = function() {
        };
        o82.prototype = e92.prototype, t82.prototype = new o82(), t82.prototype.constructor = t82;
      }
    };
    i$1 = function(e92) {
      return e92 && "object" == typeof e92 && "function" == typeof e92.copy && "function" == typeof e92.fill && "function" == typeof e92.readUInt8;
    };
    o$2 = {};
    u$1 = i$1;
    f3 = l3;
    a3 = i3;
    s3 = "undefined" != typeof BigInt;
    p3 = "undefined" != typeof Symbol;
    y2 = p3 && void 0 !== Symbol.toStringTag;
    l$1 = "undefined" != typeof Uint8Array;
    d2 = "undefined" != typeof ArrayBuffer;
    if (l$1 && y2)
      var g = Object.getPrototypeOf(Uint8Array.prototype), b = c$1(Object.getOwnPropertyDescriptor(g, Symbol.toStringTag).get);
    m2 = c$1(Object.prototype.toString);
    h3 = c$1(Number.prototype.valueOf);
    j = c$1(String.prototype.valueOf);
    A = c$1(Boolean.prototype.valueOf);
    if (s3)
      var w = c$1(BigInt.prototype.valueOf);
    if (p3)
      var v2 = c$1(Symbol.prototype.valueOf);
    o$2.isArgumentsObject = f3, o$2.isGeneratorFunction = a3, o$2.isPromise = function(e92) {
      return "undefined" != typeof Promise && e92 instanceof Promise || null !== e92 && "object" == typeof e92 && "function" == typeof e92.then && "function" == typeof e92.catch;
    }, o$2.isArrayBufferView = function(e92) {
      return d2 && ArrayBuffer.isView ? ArrayBuffer.isView(e92) : S(e92) || R(e92);
    }, o$2.isTypedArray = S, o$2.isUint8Array = B, o$2.isUint8ClampedArray = k, o$2.isUint16Array = E, o$2.isUint32Array = D, o$2.isInt8Array = U, o$2.isInt16Array = P, o$2.isInt32Array = x, o$2.isFloat32Array = I, o$2.isFloat64Array = M, o$2.isBigInt64Array = z, o$2.isBigUint64Array = F, T2.working = "undefined" != typeof Map && T2(/* @__PURE__ */ new Map()), o$2.isMap = function(e92) {
      return "undefined" != typeof Map && (T2.working ? T2(e92) : e92 instanceof Map);
    }, N.working = "undefined" != typeof Set && N(/* @__PURE__ */ new Set()), o$2.isSet = function(e92) {
      return "undefined" != typeof Set && (N.working ? N(e92) : e92 instanceof Set);
    }, W.working = "undefined" != typeof WeakMap && W(/* @__PURE__ */ new WeakMap()), o$2.isWeakMap = function(e92) {
      return "undefined" != typeof WeakMap && (W.working ? W(e92) : e92 instanceof WeakMap);
    }, $.working = "undefined" != typeof WeakSet && $(/* @__PURE__ */ new WeakSet()), o$2.isWeakSet = function(e92) {
      return $(e92);
    }, C.working = "undefined" != typeof ArrayBuffer && C(new ArrayBuffer()), o$2.isArrayBuffer = V, G.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && G(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R, J.working = "undefined" != typeof SharedArrayBuffer && J(new SharedArrayBuffer()), o$2.isSharedArrayBuffer = _, o$2.isAsyncFunction = function(e92) {
      return "[object AsyncFunction]" === m2(e92);
    }, o$2.isMapIterator = function(e92) {
      return "[object Map Iterator]" === m2(e92);
    }, o$2.isSetIterator = function(e92) {
      return "[object Set Iterator]" === m2(e92);
    }, o$2.isGeneratorObject = function(e92) {
      return "[object Generator]" === m2(e92);
    }, o$2.isWebAssemblyCompiledModule = function(e92) {
      return "[object WebAssembly.Module]" === m2(e92);
    }, o$2.isNumberObject = H, o$2.isStringObject = Z, o$2.isBooleanObject = q, o$2.isBigIntObject = K, o$2.isSymbolObject = L, o$2.isBoxedPrimitive = function(e92) {
      return H(e92) || Z(e92) || q(e92) || K(e92) || L(e92);
    }, o$2.isAnyArrayBuffer = function(e92) {
      return l$1 && (V(e92) || _(e92));
    }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e92) {
      Object.defineProperty(o$2, e92, { enumerable: false, value: function() {
        throw new Error(e92 + " is not supported in userland");
      } });
    });
    Q = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis;
    X = {};
    Y = T;
    ee = Object.getOwnPropertyDescriptors || function(e92) {
      for (var t82 = Object.keys(e92), r92 = {}, n82 = 0; n82 < t82.length; n82++)
        r92[t82[n82]] = Object.getOwnPropertyDescriptor(e92, t82[n82]);
      return r92;
    };
    te = /%[sdj%]/g;
    X.format = function(e92) {
      if (!ge(e92)) {
        for (var t82 = [], r92 = 0; r92 < arguments.length; r92++)
          t82.push(oe(arguments[r92]));
        return t82.join(" ");
      }
      r92 = 1;
      for (var n82 = arguments, i72 = n82.length, o82 = String(e92).replace(te, function(e102) {
        if ("%%" === e102)
          return "%";
        if (r92 >= i72)
          return e102;
        switch (e102) {
          case "%s":
            return String(n82[r92++]);
          case "%d":
            return Number(n82[r92++]);
          case "%j":
            try {
              return JSON.stringify(n82[r92++]);
            } catch (e112) {
              return "[Circular]";
            }
          default:
            return e102;
        }
      }), u72 = n82[r92]; r92 < i72; u72 = n82[++r92])
        le(u72) || !he(u72) ? o82 += " " + u72 : o82 += " " + oe(u72);
      return o82;
    }, X.deprecate = function(e92, t82) {
      if (void 0 !== Y && true === Y.noDeprecation)
        return e92;
      if (void 0 === Y)
        return function() {
          return X.deprecate(e92, t82).apply(this || Q, arguments);
        };
      var r92 = false;
      return function() {
        if (!r92) {
          if (Y.throwDeprecation)
            throw new Error(t82);
          Y.traceDeprecation ? console.trace(t82) : console.error(t82), r92 = true;
        }
        return e92.apply(this || Q, arguments);
      };
    };
    re = {};
    ne = /^$/;
    if (Y.env.NODE_DEBUG) {
      ie = Y.env.NODE_DEBUG;
      ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie + "$", "i");
    }
    X.debuglog = function(e92) {
      if (e92 = e92.toUpperCase(), !re[e92])
        if (ne.test(e92)) {
          var t82 = Y.pid;
          re[e92] = function() {
            var r92 = X.format.apply(X, arguments);
            console.error("%s %d: %s", e92, t82, r92);
          };
        } else
          re[e92] = function() {
          };
      return re[e92];
    }, X.inspect = oe, oe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X.types = o$2, X.isArray = pe, X.isBoolean = ye, X.isNull = le, X.isNullOrUndefined = function(e92) {
      return null == e92;
    }, X.isNumber = de, X.isString = ge, X.isSymbol = function(e92) {
      return "symbol" == typeof e92;
    }, X.isUndefined = be, X.isRegExp = me, X.types.isRegExp = me, X.isObject = he, X.isDate = je, X.types.isDate = je, X.isError = Ae, X.types.isNativeError = Ae, X.isFunction = we, X.isPrimitive = function(e92) {
      return null === e92 || "boolean" == typeof e92 || "number" == typeof e92 || "string" == typeof e92 || "symbol" == typeof e92 || void 0 === e92;
    }, X.isBuffer = i$1;
    Se = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    X.log = function() {
      console.log("%s - %s", Be(), X.format.apply(X, arguments));
    }, X.inherits = t$2, X._extend = function(e92, t82) {
      if (!t82 || !he(t82))
        return e92;
      for (var r92 = Object.keys(t82), n82 = r92.length; n82--; )
        e92[r92[n82]] = t82[r92[n82]];
      return e92;
    };
    Ee = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
    X.promisify = function(e92) {
      if ("function" != typeof e92)
        throw new TypeError('The "original" argument must be of type Function');
      if (Ee && e92[Ee]) {
        var t82;
        if ("function" != typeof (t82 = e92[Ee]))
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(t82, Ee, { value: t82, enumerable: false, writable: false, configurable: true }), t82;
      }
      function t82() {
        for (var t92, r92, n82 = new Promise(function(e102, n92) {
          t92 = e102, r92 = n92;
        }), i72 = [], o82 = 0; o82 < arguments.length; o82++)
          i72.push(arguments[o82]);
        i72.push(function(e102, n92) {
          e102 ? r92(e102) : t92(n92);
        });
        try {
          e92.apply(this || Q, i72);
        } catch (e102) {
          r92(e102);
        }
        return n82;
      }
      return Object.setPrototypeOf(t82, Object.getPrototypeOf(e92)), Ee && Object.defineProperty(t82, Ee, { value: t82, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t82, ee(e92));
    }, X.promisify.custom = Ee, X.callbackify = function(e92) {
      if ("function" != typeof e92)
        throw new TypeError('The "original" argument must be of type Function');
      function t82() {
        for (var t92 = [], r92 = 0; r92 < arguments.length; r92++)
          t92.push(arguments[r92]);
        var n82 = t92.pop();
        if ("function" != typeof n82)
          throw new TypeError("The last argument must be of type Function");
        var i72 = this || Q, o82 = function() {
          return n82.apply(i72, arguments);
        };
        e92.apply(this || Q, t92).then(function(e102) {
          Y.nextTick(o82.bind(null, null, e102));
        }, function(e102) {
          Y.nextTick(De.bind(null, e102, o82));
        });
      }
      return Object.setPrototypeOf(t82, Object.getPrototypeOf(e92)), Object.defineProperties(t82, ee(e92)), t82;
    };
    X._extend;
    X.callbackify;
    X.debuglog;
    X.deprecate;
    X.format;
    X.inherits;
    X.inspect;
    X.isArray;
    X.isBoolean;
    X.isBuffer;
    X.isDate;
    X.isError;
    X.isFunction;
    X.isNull;
    X.isNullOrUndefined;
    X.isNumber;
    X.isObject;
    X.isPrimitive;
    X.isRegExp;
    X.isString;
    X.isSymbol;
    X.isUndefined;
    X.log;
    X.promisify;
    _extend = X._extend;
    callbackify = X.callbackify;
    debuglog = X.debuglog;
    deprecate = X.deprecate;
    format2 = X.format;
    inherits = X.inherits;
    inspect = X.inspect;
    isArray = X.isArray;
    isBoolean = X.isBoolean;
    isBuffer = X.isBuffer;
    isDate = X.isDate;
    isError = X.isError;
    isFunction = X.isFunction;
    isNull = X.isNull;
    isNullOrUndefined = X.isNullOrUndefined;
    isNumber = X.isNumber;
    isObject = X.isObject;
    isPrimitive = X.isPrimitive;
    isRegExp = X.isRegExp;
    isString = X.isString;
    isSymbol = X.isSymbol;
    isUndefined = X.isUndefined;
    log = X.log;
    promisify = X.promisify;
    types = X.types;
    TextEncoder = self.TextEncoder;
    TextDecoder2 = self.TextDecoder;
    exports4 = {};
    _dewExec4 = false;
    _global2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    process3 = dew4();
    process3.platform = "browser";
    process3.addListener;
    process3.argv;
    process3.binding;
    process3.browser;
    process3.chdir;
    process3.cwd;
    process3.emit;
    process3.env;
    process3.listeners;
    process3.nextTick;
    process3.off;
    process3.on;
    process3.once;
    process3.prependListener;
    process3.prependOnceListener;
    process3.removeAllListeners;
    process3.removeListener;
    process3.title;
    process3.umask;
    process3.version;
    process3.versions;
    for (r$13 = { byteLength: function(r92) {
      var t82 = u$2(r92), e92 = t82[0], n82 = t82[1];
      return 3 * (e92 + n82) / 4 - n82;
    }, toByteArray: function(r92) {
      var t82, o82, a72 = u$2(r92), h82 = a72[0], c72 = a72[1], d62 = new n$22(function(r102, t92, e92) {
        return 3 * (t92 + e92) / 4 - e92;
      }(0, h82, c72)), f72 = 0, A42 = c72 > 0 ? h82 - 4 : h82;
      for (o82 = 0; o82 < A42; o82 += 4)
        t82 = e$22[r92.charCodeAt(o82)] << 18 | e$22[r92.charCodeAt(o82 + 1)] << 12 | e$22[r92.charCodeAt(o82 + 2)] << 6 | e$22[r92.charCodeAt(o82 + 3)], d62[f72++] = t82 >> 16 & 255, d62[f72++] = t82 >> 8 & 255, d62[f72++] = 255 & t82;
      2 === c72 && (t82 = e$22[r92.charCodeAt(o82)] << 2 | e$22[r92.charCodeAt(o82 + 1)] >> 4, d62[f72++] = 255 & t82);
      1 === c72 && (t82 = e$22[r92.charCodeAt(o82)] << 10 | e$22[r92.charCodeAt(o82 + 1)] << 4 | e$22[r92.charCodeAt(o82 + 2)] >> 2, d62[f72++] = t82 >> 8 & 255, d62[f72++] = 255 & t82);
      return d62;
    }, fromByteArray: function(r92) {
      for (var e92, n82 = r92.length, o82 = n82 % 3, a72 = [], h82 = 0, u72 = n82 - o82; h82 < u72; h82 += 16383)
        a72.push(c$12(r92, h82, h82 + 16383 > u72 ? u72 : h82 + 16383));
      1 === o82 ? (e92 = r92[n82 - 1], a72.push(t$13[e92 >> 2] + t$13[e92 << 4 & 63] + "==")) : 2 === o82 && (e92 = (r92[n82 - 2] << 8) + r92[n82 - 1], a72.push(t$13[e92 >> 10] + t$13[e92 >> 4 & 63] + t$13[e92 << 2 & 63] + "="));
      return a72.join("");
    } }, t$13 = [], e$22 = [], n$22 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o$23 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a$12 = 0, h$12 = o$23.length; a$12 < h$12; ++a$12)
      t$13[a$12] = o$23[a$12], e$22[o$23.charCodeAt(a$12)] = a$12;
    e$22["-".charCodeAt(0)] = 62, e$22["_".charCodeAt(0)] = 63;
    a$1$1 = { read: function(a72, t82, o82, r92, h82) {
      var M42, f72, p72 = 8 * h82 - r92 - 1, w42 = (1 << p72) - 1, e92 = w42 >> 1, i72 = -7, N42 = o82 ? h82 - 1 : 0, n82 = o82 ? -1 : 1, u72 = a72[t82 + N42];
      for (N42 += n82, M42 = u72 & (1 << -i72) - 1, u72 >>= -i72, i72 += p72; i72 > 0; M42 = 256 * M42 + a72[t82 + N42], N42 += n82, i72 -= 8)
        ;
      for (f72 = M42 & (1 << -i72) - 1, M42 >>= -i72, i72 += r92; i72 > 0; f72 = 256 * f72 + a72[t82 + N42], N42 += n82, i72 -= 8)
        ;
      if (0 === M42)
        M42 = 1 - e92;
      else {
        if (M42 === w42)
          return f72 ? NaN : 1 / 0 * (u72 ? -1 : 1);
        f72 += Math.pow(2, r92), M42 -= e92;
      }
      return (u72 ? -1 : 1) * f72 * Math.pow(2, M42 - r92);
    }, write: function(a72, t82, o82, r92, h82, M42) {
      var f72, p72, w42, e92 = 8 * M42 - h82 - 1, i72 = (1 << e92) - 1, N42 = i72 >> 1, n82 = 23 === h82 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, u72 = r92 ? 0 : M42 - 1, l72 = r92 ? 1 : -1, s62 = t82 < 0 || 0 === t82 && 1 / t82 < 0 ? 1 : 0;
      for (t82 = Math.abs(t82), isNaN(t82) || t82 === 1 / 0 ? (p72 = isNaN(t82) ? 1 : 0, f72 = i72) : (f72 = Math.floor(Math.log(t82) / Math.LN2), t82 * (w42 = Math.pow(2, -f72)) < 1 && (f72--, w42 *= 2), (t82 += f72 + N42 >= 1 ? n82 / w42 : n82 * Math.pow(2, 1 - N42)) * w42 >= 2 && (f72++, w42 /= 2), f72 + N42 >= i72 ? (p72 = 0, f72 = i72) : f72 + N42 >= 1 ? (p72 = (t82 * w42 - 1) * Math.pow(2, h82), f72 += N42) : (p72 = t82 * Math.pow(2, N42 - 1) * Math.pow(2, h82), f72 = 0)); h82 >= 8; a72[o82 + u72] = 255 & p72, u72 += l72, p72 /= 256, h82 -= 8)
        ;
      for (f72 = f72 << h82 | p72, e92 += h82; e92 > 0; a72[o82 + u72] = 255 & f72, u72 += l72, f72 /= 256, e92 -= 8)
        ;
      a72[o82 + u72 - l72] |= 128 * s62;
    } };
    e$1$1 = {};
    n$1$1 = r$13;
    i$12 = a$1$1;
    o$1$1 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
    e$1$1.Buffer = u$1$1, e$1$1.SlowBuffer = function(t82) {
      +t82 != t82 && (t82 = 0);
      return u$1$1.alloc(+t82);
    }, e$1$1.INSPECT_MAX_BYTES = 50;
    e$1$1.kMaxLength = 2147483647, u$1$1.TYPED_ARRAY_SUPPORT = function() {
      try {
        var t82 = new Uint8Array(1), r92 = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(r92, Uint8Array.prototype), Object.setPrototypeOf(t82, r92), 42 === t82.foo();
      } catch (t92) {
        return false;
      }
    }(), u$1$1.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u$1$1.prototype, "parent", { enumerable: true, get: function() {
      if (u$1$1.isBuffer(this))
        return this.buffer;
    } }), Object.defineProperty(u$1$1.prototype, "offset", { enumerable: true, get: function() {
      if (u$1$1.isBuffer(this))
        return this.byteOffset;
    } }), u$1$1.poolSize = 8192, u$1$1.from = function(t82, r92, e92) {
      return s$1(t82, r92, e92);
    }, Object.setPrototypeOf(u$1$1.prototype, Uint8Array.prototype), Object.setPrototypeOf(u$1$1, Uint8Array), u$1$1.alloc = function(t82, r92, e92) {
      return function(t92, r102, e102) {
        return h$1$1(t92), t92 <= 0 ? f$2(t92) : void 0 !== r102 ? "string" == typeof e102 ? f$2(t92).fill(r102, e102) : f$2(t92).fill(r102) : f$2(t92);
      }(t82, r92, e92);
    }, u$1$1.allocUnsafe = function(t82) {
      return a$2(t82);
    }, u$1$1.allocUnsafeSlow = function(t82) {
      return a$2(t82);
    }, u$1$1.isBuffer = function(t82) {
      return null != t82 && true === t82._isBuffer && t82 !== u$1$1.prototype;
    }, u$1$1.compare = function(t82, r92) {
      if (F2(t82, Uint8Array) && (t82 = u$1$1.from(t82, t82.offset, t82.byteLength)), F2(r92, Uint8Array) && (r92 = u$1$1.from(r92, r92.offset, r92.byteLength)), !u$1$1.isBuffer(t82) || !u$1$1.isBuffer(r92))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t82 === r92)
        return 0;
      for (var e92 = t82.length, n82 = r92.length, i72 = 0, o82 = Math.min(e92, n82); i72 < o82; ++i72)
        if (t82[i72] !== r92[i72]) {
          e92 = t82[i72], n82 = r92[i72];
          break;
        }
      return e92 < n82 ? -1 : n82 < e92 ? 1 : 0;
    }, u$1$1.isEncoding = function(t82) {
      switch (String(t82).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, u$1$1.concat = function(t82, r92) {
      if (!Array.isArray(t82))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (0 === t82.length)
        return u$1$1.alloc(0);
      var e92;
      if (void 0 === r92)
        for (r92 = 0, e92 = 0; e92 < t82.length; ++e92)
          r92 += t82[e92].length;
      var n82 = u$1$1.allocUnsafe(r92), i72 = 0;
      for (e92 = 0; e92 < t82.length; ++e92) {
        var o82 = t82[e92];
        if (F2(o82, Uint8Array) && (o82 = u$1$1.from(o82)), !u$1$1.isBuffer(o82))
          throw new TypeError('"list" argument must be an Array of Buffers');
        o82.copy(n82, i72), i72 += o82.length;
      }
      return n82;
    }, u$1$1.byteLength = y3, u$1$1.prototype._isBuffer = true, u$1$1.prototype.swap16 = function() {
      var t82 = this.length;
      if (t82 % 2 != 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var r92 = 0; r92 < t82; r92 += 2)
        w2(this, r92, r92 + 1);
      return this;
    }, u$1$1.prototype.swap32 = function() {
      var t82 = this.length;
      if (t82 % 4 != 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var r92 = 0; r92 < t82; r92 += 4)
        w2(this, r92, r92 + 3), w2(this, r92 + 1, r92 + 2);
      return this;
    }, u$1$1.prototype.swap64 = function() {
      var t82 = this.length;
      if (t82 % 8 != 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var r92 = 0; r92 < t82; r92 += 8)
        w2(this, r92, r92 + 7), w2(this, r92 + 1, r92 + 6), w2(this, r92 + 2, r92 + 5), w2(this, r92 + 3, r92 + 4);
      return this;
    }, u$1$1.prototype.toString = function() {
      var t82 = this.length;
      return 0 === t82 ? "" : 0 === arguments.length ? I2(this, 0, t82) : g2.apply(this, arguments);
    }, u$1$1.prototype.toLocaleString = u$1$1.prototype.toString, u$1$1.prototype.equals = function(t82) {
      if (!u$1$1.isBuffer(t82))
        throw new TypeError("Argument must be a Buffer");
      return this === t82 || 0 === u$1$1.compare(this, t82);
    }, u$1$1.prototype.inspect = function() {
      var t82 = "", r92 = e$1$1.INSPECT_MAX_BYTES;
      return t82 = this.toString("hex", 0, r92).replace(/(.{2})/g, "$1 ").trim(), this.length > r92 && (t82 += " ... "), "<Buffer " + t82 + ">";
    }, o$1$1 && (u$1$1.prototype[o$1$1] = u$1$1.prototype.inspect), u$1$1.prototype.compare = function(t82, r92, e92, n82, i72) {
      if (F2(t82, Uint8Array) && (t82 = u$1$1.from(t82, t82.offset, t82.byteLength)), !u$1$1.isBuffer(t82))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t82);
      if (void 0 === r92 && (r92 = 0), void 0 === e92 && (e92 = t82 ? t82.length : 0), void 0 === n82 && (n82 = 0), void 0 === i72 && (i72 = this.length), r92 < 0 || e92 > t82.length || n82 < 0 || i72 > this.length)
        throw new RangeError("out of range index");
      if (n82 >= i72 && r92 >= e92)
        return 0;
      if (n82 >= i72)
        return -1;
      if (r92 >= e92)
        return 1;
      if (this === t82)
        return 0;
      for (var o82 = (i72 >>>= 0) - (n82 >>>= 0), f72 = (e92 >>>= 0) - (r92 >>>= 0), s62 = Math.min(o82, f72), h82 = this.slice(n82, i72), a72 = t82.slice(r92, e92), p72 = 0; p72 < s62; ++p72)
        if (h82[p72] !== a72[p72]) {
          o82 = h82[p72], f72 = a72[p72];
          break;
        }
      return o82 < f72 ? -1 : f72 < o82 ? 1 : 0;
    }, u$1$1.prototype.includes = function(t82, r92, e92) {
      return -1 !== this.indexOf(t82, r92, e92);
    }, u$1$1.prototype.indexOf = function(t82, r92, e92) {
      return d3(this, t82, r92, e92, true);
    }, u$1$1.prototype.lastIndexOf = function(t82, r92, e92) {
      return d3(this, t82, r92, e92, false);
    }, u$1$1.prototype.write = function(t82, r92, e92, n82) {
      if (void 0 === r92)
        n82 = "utf8", e92 = this.length, r92 = 0;
      else if (void 0 === e92 && "string" == typeof r92)
        n82 = r92, e92 = this.length, r92 = 0;
      else {
        if (!isFinite(r92))
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        r92 >>>= 0, isFinite(e92) ? (e92 >>>= 0, void 0 === n82 && (n82 = "utf8")) : (n82 = e92, e92 = void 0);
      }
      var i72 = this.length - r92;
      if ((void 0 === e92 || e92 > i72) && (e92 = i72), t82.length > 0 && (e92 < 0 || r92 < 0) || r92 > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      n82 || (n82 = "utf8");
      for (var o82 = false; ; )
        switch (n82) {
          case "hex":
            return b2(this, t82, r92, e92);
          case "utf8":
          case "utf-8":
            return m3(this, t82, r92, e92);
          case "ascii":
            return E2(this, t82, r92, e92);
          case "latin1":
          case "binary":
            return B2(this, t82, r92, e92);
          case "base64":
            return A2(this, t82, r92, e92);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return U2(this, t82, r92, e92);
          default:
            if (o82)
              throw new TypeError("Unknown encoding: " + n82);
            n82 = ("" + n82).toLowerCase(), o82 = true;
        }
    }, u$1$1.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    u$1$1.prototype.slice = function(t82, r92) {
      var e92 = this.length;
      (t82 = ~~t82) < 0 ? (t82 += e92) < 0 && (t82 = 0) : t82 > e92 && (t82 = e92), (r92 = void 0 === r92 ? e92 : ~~r92) < 0 ? (r92 += e92) < 0 && (r92 = 0) : r92 > e92 && (r92 = e92), r92 < t82 && (r92 = t82);
      var n82 = this.subarray(t82, r92);
      return Object.setPrototypeOf(n82, u$1$1.prototype), n82;
    }, u$1$1.prototype.readUIntLE = function(t82, r92, e92) {
      t82 >>>= 0, r92 >>>= 0, e92 || x2(t82, r92, this.length);
      for (var n82 = this[t82], i72 = 1, o82 = 0; ++o82 < r92 && (i72 *= 256); )
        n82 += this[t82 + o82] * i72;
      return n82;
    }, u$1$1.prototype.readUIntBE = function(t82, r92, e92) {
      t82 >>>= 0, r92 >>>= 0, e92 || x2(t82, r92, this.length);
      for (var n82 = this[t82 + --r92], i72 = 1; r92 > 0 && (i72 *= 256); )
        n82 += this[t82 + --r92] * i72;
      return n82;
    }, u$1$1.prototype.readUInt8 = function(t82, r92) {
      return t82 >>>= 0, r92 || x2(t82, 1, this.length), this[t82];
    }, u$1$1.prototype.readUInt16LE = function(t82, r92) {
      return t82 >>>= 0, r92 || x2(t82, 2, this.length), this[t82] | this[t82 + 1] << 8;
    }, u$1$1.prototype.readUInt16BE = function(t82, r92) {
      return t82 >>>= 0, r92 || x2(t82, 2, this.length), this[t82] << 8 | this[t82 + 1];
    }, u$1$1.prototype.readUInt32LE = function(t82, r92) {
      return t82 >>>= 0, r92 || x2(t82, 4, this.length), (this[t82] | this[t82 + 1] << 8 | this[t82 + 2] << 16) + 16777216 * this[t82 + 3];
    }, u$1$1.prototype.readUInt32BE = function(t82, r92) {
      return t82 >>>= 0, r92 || x2(t82, 4, this.length), 16777216 * this[t82] + (this[t82 + 1] << 16 | this[t82 + 2] << 8 | this[t82 + 3]);
    }, u$1$1.prototype.readIntLE = function(t82, r92, e92) {
      t82 >>>= 0, r92 >>>= 0, e92 || x2(t82, r92, this.length);
      for (var n82 = this[t82], i72 = 1, o82 = 0; ++o82 < r92 && (i72 *= 256); )
        n82 += this[t82 + o82] * i72;
      return n82 >= (i72 *= 128) && (n82 -= Math.pow(2, 8 * r92)), n82;
    }, u$1$1.prototype.readIntBE = function(t82, r92, e92) {
      t82 >>>= 0, r92 >>>= 0, e92 || x2(t82, r92, this.length);
      for (var n82 = r92, i72 = 1, o82 = this[t82 + --n82]; n82 > 0 && (i72 *= 256); )
        o82 += this[t82 + --n82] * i72;
      return o82 >= (i72 *= 128) && (o82 -= Math.pow(2, 8 * r92)), o82;
    }, u$1$1.prototype.readInt8 = function(t82, r92) {
      return t82 >>>= 0, r92 || x2(t82, 1, this.length), 128 & this[t82] ? -1 * (255 - this[t82] + 1) : this[t82];
    }, u$1$1.prototype.readInt16LE = function(t82, r92) {
      t82 >>>= 0, r92 || x2(t82, 2, this.length);
      var e92 = this[t82] | this[t82 + 1] << 8;
      return 32768 & e92 ? 4294901760 | e92 : e92;
    }, u$1$1.prototype.readInt16BE = function(t82, r92) {
      t82 >>>= 0, r92 || x2(t82, 2, this.length);
      var e92 = this[t82 + 1] | this[t82] << 8;
      return 32768 & e92 ? 4294901760 | e92 : e92;
    }, u$1$1.prototype.readInt32LE = function(t82, r92) {
      return t82 >>>= 0, r92 || x2(t82, 4, this.length), this[t82] | this[t82 + 1] << 8 | this[t82 + 2] << 16 | this[t82 + 3] << 24;
    }, u$1$1.prototype.readInt32BE = function(t82, r92) {
      return t82 >>>= 0, r92 || x2(t82, 4, this.length), this[t82] << 24 | this[t82 + 1] << 16 | this[t82 + 2] << 8 | this[t82 + 3];
    }, u$1$1.prototype.readFloatLE = function(t82, r92) {
      return t82 >>>= 0, r92 || x2(t82, 4, this.length), i$12.read(this, t82, true, 23, 4);
    }, u$1$1.prototype.readFloatBE = function(t82, r92) {
      return t82 >>>= 0, r92 || x2(t82, 4, this.length), i$12.read(this, t82, false, 23, 4);
    }, u$1$1.prototype.readDoubleLE = function(t82, r92) {
      return t82 >>>= 0, r92 || x2(t82, 8, this.length), i$12.read(this, t82, true, 52, 8);
    }, u$1$1.prototype.readDoubleBE = function(t82, r92) {
      return t82 >>>= 0, r92 || x2(t82, 8, this.length), i$12.read(this, t82, false, 52, 8);
    }, u$1$1.prototype.writeUIntLE = function(t82, r92, e92, n82) {
      (t82 = +t82, r92 >>>= 0, e92 >>>= 0, n82) || C2(this, t82, r92, e92, Math.pow(2, 8 * e92) - 1, 0);
      var i72 = 1, o82 = 0;
      for (this[r92] = 255 & t82; ++o82 < e92 && (i72 *= 256); )
        this[r92 + o82] = t82 / i72 & 255;
      return r92 + e92;
    }, u$1$1.prototype.writeUIntBE = function(t82, r92, e92, n82) {
      (t82 = +t82, r92 >>>= 0, e92 >>>= 0, n82) || C2(this, t82, r92, e92, Math.pow(2, 8 * e92) - 1, 0);
      var i72 = e92 - 1, o82 = 1;
      for (this[r92 + i72] = 255 & t82; --i72 >= 0 && (o82 *= 256); )
        this[r92 + i72] = t82 / o82 & 255;
      return r92 + e92;
    }, u$1$1.prototype.writeUInt8 = function(t82, r92, e92) {
      return t82 = +t82, r92 >>>= 0, e92 || C2(this, t82, r92, 1, 255, 0), this[r92] = 255 & t82, r92 + 1;
    }, u$1$1.prototype.writeUInt16LE = function(t82, r92, e92) {
      return t82 = +t82, r92 >>>= 0, e92 || C2(this, t82, r92, 2, 65535, 0), this[r92] = 255 & t82, this[r92 + 1] = t82 >>> 8, r92 + 2;
    }, u$1$1.prototype.writeUInt16BE = function(t82, r92, e92) {
      return t82 = +t82, r92 >>>= 0, e92 || C2(this, t82, r92, 2, 65535, 0), this[r92] = t82 >>> 8, this[r92 + 1] = 255 & t82, r92 + 2;
    }, u$1$1.prototype.writeUInt32LE = function(t82, r92, e92) {
      return t82 = +t82, r92 >>>= 0, e92 || C2(this, t82, r92, 4, 4294967295, 0), this[r92 + 3] = t82 >>> 24, this[r92 + 2] = t82 >>> 16, this[r92 + 1] = t82 >>> 8, this[r92] = 255 & t82, r92 + 4;
    }, u$1$1.prototype.writeUInt32BE = function(t82, r92, e92) {
      return t82 = +t82, r92 >>>= 0, e92 || C2(this, t82, r92, 4, 4294967295, 0), this[r92] = t82 >>> 24, this[r92 + 1] = t82 >>> 16, this[r92 + 2] = t82 >>> 8, this[r92 + 3] = 255 & t82, r92 + 4;
    }, u$1$1.prototype.writeIntLE = function(t82, r92, e92, n82) {
      if (t82 = +t82, r92 >>>= 0, !n82) {
        var i72 = Math.pow(2, 8 * e92 - 1);
        C2(this, t82, r92, e92, i72 - 1, -i72);
      }
      var o82 = 0, f72 = 1, u72 = 0;
      for (this[r92] = 255 & t82; ++o82 < e92 && (f72 *= 256); )
        t82 < 0 && 0 === u72 && 0 !== this[r92 + o82 - 1] && (u72 = 1), this[r92 + o82] = (t82 / f72 >> 0) - u72 & 255;
      return r92 + e92;
    }, u$1$1.prototype.writeIntBE = function(t82, r92, e92, n82) {
      if (t82 = +t82, r92 >>>= 0, !n82) {
        var i72 = Math.pow(2, 8 * e92 - 1);
        C2(this, t82, r92, e92, i72 - 1, -i72);
      }
      var o82 = e92 - 1, f72 = 1, u72 = 0;
      for (this[r92 + o82] = 255 & t82; --o82 >= 0 && (f72 *= 256); )
        t82 < 0 && 0 === u72 && 0 !== this[r92 + o82 + 1] && (u72 = 1), this[r92 + o82] = (t82 / f72 >> 0) - u72 & 255;
      return r92 + e92;
    }, u$1$1.prototype.writeInt8 = function(t82, r92, e92) {
      return t82 = +t82, r92 >>>= 0, e92 || C2(this, t82, r92, 1, 127, -128), t82 < 0 && (t82 = 255 + t82 + 1), this[r92] = 255 & t82, r92 + 1;
    }, u$1$1.prototype.writeInt16LE = function(t82, r92, e92) {
      return t82 = +t82, r92 >>>= 0, e92 || C2(this, t82, r92, 2, 32767, -32768), this[r92] = 255 & t82, this[r92 + 1] = t82 >>> 8, r92 + 2;
    }, u$1$1.prototype.writeInt16BE = function(t82, r92, e92) {
      return t82 = +t82, r92 >>>= 0, e92 || C2(this, t82, r92, 2, 32767, -32768), this[r92] = t82 >>> 8, this[r92 + 1] = 255 & t82, r92 + 2;
    }, u$1$1.prototype.writeInt32LE = function(t82, r92, e92) {
      return t82 = +t82, r92 >>>= 0, e92 || C2(this, t82, r92, 4, 2147483647, -2147483648), this[r92] = 255 & t82, this[r92 + 1] = t82 >>> 8, this[r92 + 2] = t82 >>> 16, this[r92 + 3] = t82 >>> 24, r92 + 4;
    }, u$1$1.prototype.writeInt32BE = function(t82, r92, e92) {
      return t82 = +t82, r92 >>>= 0, e92 || C2(this, t82, r92, 4, 2147483647, -2147483648), t82 < 0 && (t82 = 4294967295 + t82 + 1), this[r92] = t82 >>> 24, this[r92 + 1] = t82 >>> 16, this[r92 + 2] = t82 >>> 8, this[r92 + 3] = 255 & t82, r92 + 4;
    }, u$1$1.prototype.writeFloatLE = function(t82, r92, e92) {
      return k2(this, t82, r92, true, e92);
    }, u$1$1.prototype.writeFloatBE = function(t82, r92, e92) {
      return k2(this, t82, r92, false, e92);
    }, u$1$1.prototype.writeDoubleLE = function(t82, r92, e92) {
      return M2(this, t82, r92, true, e92);
    }, u$1$1.prototype.writeDoubleBE = function(t82, r92, e92) {
      return M2(this, t82, r92, false, e92);
    }, u$1$1.prototype.copy = function(t82, r92, e92, n82) {
      if (!u$1$1.isBuffer(t82))
        throw new TypeError("argument should be a Buffer");
      if (e92 || (e92 = 0), n82 || 0 === n82 || (n82 = this.length), r92 >= t82.length && (r92 = t82.length), r92 || (r92 = 0), n82 > 0 && n82 < e92 && (n82 = e92), n82 === e92)
        return 0;
      if (0 === t82.length || 0 === this.length)
        return 0;
      if (r92 < 0)
        throw new RangeError("targetStart out of bounds");
      if (e92 < 0 || e92 >= this.length)
        throw new RangeError("Index out of range");
      if (n82 < 0)
        throw new RangeError("sourceEnd out of bounds");
      n82 > this.length && (n82 = this.length), t82.length - r92 < n82 - e92 && (n82 = t82.length - r92 + e92);
      var i72 = n82 - e92;
      if (this === t82 && "function" == typeof Uint8Array.prototype.copyWithin)
        this.copyWithin(r92, e92, n82);
      else if (this === t82 && e92 < r92 && r92 < n82)
        for (var o82 = i72 - 1; o82 >= 0; --o82)
          t82[o82 + r92] = this[o82 + e92];
      else
        Uint8Array.prototype.set.call(t82, this.subarray(e92, n82), r92);
      return i72;
    }, u$1$1.prototype.fill = function(t82, r92, e92, n82) {
      if ("string" == typeof t82) {
        if ("string" == typeof r92 ? (n82 = r92, r92 = 0, e92 = this.length) : "string" == typeof e92 && (n82 = e92, e92 = this.length), void 0 !== n82 && "string" != typeof n82)
          throw new TypeError("encoding must be a string");
        if ("string" == typeof n82 && !u$1$1.isEncoding(n82))
          throw new TypeError("Unknown encoding: " + n82);
        if (1 === t82.length) {
          var i72 = t82.charCodeAt(0);
          ("utf8" === n82 && i72 < 128 || "latin1" === n82) && (t82 = i72);
        }
      } else
        "number" == typeof t82 ? t82 &= 255 : "boolean" == typeof t82 && (t82 = Number(t82));
      if (r92 < 0 || this.length < r92 || this.length < e92)
        throw new RangeError("Out of range index");
      if (e92 <= r92)
        return this;
      var o82;
      if (r92 >>>= 0, e92 = void 0 === e92 ? this.length : e92 >>> 0, t82 || (t82 = 0), "number" == typeof t82)
        for (o82 = r92; o82 < e92; ++o82)
          this[o82] = t82;
      else {
        var f72 = u$1$1.isBuffer(t82) ? t82 : u$1$1.from(t82, n82), s62 = f72.length;
        if (0 === s62)
          throw new TypeError('The value "' + t82 + '" is invalid for argument "value"');
        for (o82 = 0; o82 < e92 - r92; ++o82)
          this[o82 + r92] = f72[o82 % s62];
      }
      return this;
    };
    j2 = /[^+/0-9A-Za-z-_]/g;
    Y2 = function() {
      for (var t82 = new Array(256), r92 = 0; r92 < 16; ++r92)
        for (var e92 = 16 * r92, n82 = 0; n82 < 16; ++n82)
          t82[e92 + n82] = "0123456789abcdef"[r92] + "0123456789abcdef"[n82];
      return t82;
    }();
    e$1$1.Buffer;
    e$1$1.INSPECT_MAX_BYTES;
    e$1$1.kMaxLength;
    e4 = {};
    n4 = e$1$1;
    o4 = n4.Buffer;
    o4.from && o4.alloc && o4.allocUnsafe && o4.allocUnsafeSlow ? e4 = n4 : (t4(n4, e4), e4.Buffer = f4), f4.prototype = Object.create(o4.prototype), t4(o4, f4), f4.from = function(r92, e92, n82) {
      if ("number" == typeof r92)
        throw new TypeError("Argument must not be a number");
      return o4(r92, e92, n82);
    }, f4.alloc = function(r92, e92, n82) {
      if ("number" != typeof r92)
        throw new TypeError("Argument must be a number");
      var t82 = o4(r92);
      return void 0 !== e92 ? "string" == typeof n82 ? t82.fill(e92, n82) : t82.fill(e92) : t82.fill(0), t82;
    }, f4.allocUnsafe = function(r92) {
      if ("number" != typeof r92)
        throw new TypeError("Argument must be a number");
      return o4(r92);
    }, f4.allocUnsafeSlow = function(r92) {
      if ("number" != typeof r92)
        throw new TypeError("Argument must be a number");
      return n4.SlowBuffer(r92);
    };
    u4 = e4;
    e$12 = {};
    s4 = u4.Buffer;
    i4 = s4.isEncoding || function(t82) {
      switch ((t82 = "" + t82) && t82.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    e$12.StringDecoder = a4, a4.prototype.write = function(t82) {
      if (0 === t82.length)
        return "";
      var e92, s62;
      if (this.lastNeed) {
        if (void 0 === (e92 = this.fillLast(t82)))
          return "";
        s62 = this.lastNeed, this.lastNeed = 0;
      } else
        s62 = 0;
      return s62 < t82.length ? e92 ? e92 + this.text(t82, s62) : this.text(t82, s62) : e92 || "";
    }, a4.prototype.end = function(t82) {
      var e92 = t82 && t82.length ? this.write(t82) : "";
      return this.lastNeed ? e92 + "\uFFFD" : e92;
    }, a4.prototype.text = function(t82, e92) {
      var s62 = function(t92, e102, s72) {
        var i82 = e102.length - 1;
        if (i82 < s72)
          return 0;
        var a72 = r4(e102[i82]);
        if (a72 >= 0)
          return a72 > 0 && (t92.lastNeed = a72 - 1), a72;
        if (--i82 < s72 || -2 === a72)
          return 0;
        if ((a72 = r4(e102[i82])) >= 0)
          return a72 > 0 && (t92.lastNeed = a72 - 2), a72;
        if (--i82 < s72 || -2 === a72)
          return 0;
        if ((a72 = r4(e102[i82])) >= 0)
          return a72 > 0 && (2 === a72 ? a72 = 0 : t92.lastNeed = a72 - 3), a72;
        return 0;
      }(this, t82, e92);
      if (!this.lastNeed)
        return t82.toString("utf8", e92);
      this.lastTotal = s62;
      var i72 = t82.length - (s62 - this.lastNeed);
      return t82.copy(this.lastChar, 0, i72), t82.toString("utf8", e92, i72);
    }, a4.prototype.fillLast = function(t82) {
      if (this.lastNeed <= t82.length)
        return t82.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t82.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t82.length), this.lastNeed -= t82.length;
    };
    e$12.StringDecoder;
    e$12.StringDecoder;
    exports$2$1 = {};
    _dewExec$2$1 = false;
    exports$1$1 = {};
    _dewExec$1$1 = false;
    exports$g = {};
    _dewExec$g = false;
    buffer = dew$g();
    buffer.Buffer;
    buffer.INSPECT_MAX_BYTES;
    buffer.kMaxLength;
    exports$f = {};
    _dewExec$f = false;
    exports$e = {};
    _dewExec$e = false;
    exports$d = {};
    _dewExec$d = false;
    exports$c = {};
    _dewExec$c = false;
    exports$b = {};
    _dewExec$b = false;
    exports$a = {};
    _dewExec$a = false;
    exports$9 = {};
    _dewExec$9 = false;
    _global$2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$8 = {};
    _dewExec$8 = false;
    _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$7 = {};
    _dewExec$7 = false;
    exports$6 = {};
    _dewExec$6 = false;
    exports$5 = {};
    _dewExec$5 = false;
    exports$4 = {};
    _dewExec$4 = false;
    exports$3 = {};
    _dewExec$3 = false;
    _global22 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$2 = {};
    _dewExec$2 = false;
    exports$13 = {};
    _dewExec$1 = false;
    exports22 = {};
    _dewExec22 = false;
    r5 = { assign: e5, polyfill: function() {
      Object.assign || Object.defineProperty(Object, "assign", { enumerable: false, configurable: true, writable: true, value: e5 });
    } };
    e$13 = Object.prototype.toString;
    r$12 = function(t82) {
      var r92 = e$13.call(t82), n82 = "[object Arguments]" === r92;
      return n82 || (n82 = "[object Array]" !== r92 && null !== t82 && "object" == typeof t82 && "number" == typeof t82.length && t82.length >= 0 && "[object Function]" === e$13.call(t82.callee)), n82;
    };
    if (!Object.keys) {
      n8 = Object.prototype.hasOwnProperty, o8 = Object.prototype.toString, c7 = r$12, l7 = Object.prototype.propertyIsEnumerable, i7 = !l7.call({ toString: null }, "toString"), a7 = l7.call(function() {
      }, "prototype"), u7 = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], f7 = function(t82) {
        var e92 = t82.constructor;
        return e92 && e92.prototype === t82;
      }, p7 = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, s6 = function() {
        if ("undefined" == typeof window)
          return false;
        for (var t82 in window)
          try {
            if (!p7["$" + t82] && n8.call(window, t82) && null !== window[t82] && "object" == typeof window[t82])
              try {
                f7(window[t82]);
              } catch (t92) {
                return true;
              }
          } catch (t92) {
            return true;
          }
        return false;
      }();
      t5 = function(t82) {
        var e92 = null !== t82 && "object" == typeof t82, r92 = "[object Function]" === o8.call(t82), l82 = c7(t82), p82 = e92 && "[object String]" === o8.call(t82), y62 = [];
        if (!e92 && !r92 && !l82)
          throw new TypeError("Object.keys called on a non-object");
        var b52 = a7 && r92;
        if (p82 && t82.length > 0 && !n8.call(t82, 0))
          for (var g52 = 0; g52 < t82.length; ++g52)
            y62.push(String(g52));
        if (l82 && t82.length > 0)
          for (var h82 = 0; h82 < t82.length; ++h82)
            y62.push(String(h82));
        else
          for (var $32 in t82)
            b52 && "prototype" === $32 || !n8.call(t82, $32) || y62.push(String($32));
        if (i7)
          for (var j42 = function(t92) {
            if ("undefined" == typeof window || !s6)
              return f7(t92);
            try {
              return f7(t92);
            } catch (t102) {
              return false;
            }
          }(t82), w42 = 0; w42 < u7.length; ++w42)
            j42 && "constructor" === u7[w42] || !n8.call(t82, u7[w42]) || y62.push(u7[w42]);
        return y62;
      };
    }
    y4 = t5;
    b3 = Array.prototype.slice;
    g3 = r$12;
    h5 = Object.keys;
    $2 = h5 ? function(t82) {
      return h5(t82);
    } : y4;
    j3 = Object.keys;
    $2.shim = function() {
      Object.keys ? function() {
        var t82 = Object.keys(arguments);
        return t82 && t82.length === arguments.length;
      }(1, 2) || (Object.keys = function(t82) {
        return g3(t82) ? j3(b3.call(t82)) : j3(t82);
      }) : Object.keys = $2;
      return Object.keys || $2;
    };
    w3 = $2;
    r$2 = w3;
    e$2 = "function" == typeof Symbol && "symbol" == typeof Symbol("foo");
    o$13 = Object.prototype.toString;
    n$13 = Array.prototype.concat;
    a$1 = Object.defineProperty;
    c$13 = a$1 && function() {
      var t82 = {};
      try {
        for (var r92 in a$1(t82, "x", { enumerable: false, value: t82 }), t82)
          return false;
        return t82.x === t82;
      } catch (t92) {
        return false;
      }
    }();
    l$13 = function(t82, r92, e92, n82) {
      var l72;
      (!(r92 in t82) || "function" == typeof (l72 = n82) && "[object Function]" === o$13.call(l72) && n82()) && (c$13 ? a$1(t82, r92, { configurable: true, enumerable: false, value: e92, writable: true }) : t82[r92] = e92);
    };
    u$13 = function(t82, o82) {
      var a72 = arguments.length > 2 ? arguments[2] : {}, c72 = r$2(o82);
      e$2 && (c72 = n$13.call(c72, Object.getOwnPropertySymbols(o82)));
      for (var u72 = 0; u72 < c72.length; u72 += 1)
        l$13(t82, c72[u72], o82[c72[u72]], a72[c72[u72]]);
    };
    u$13.supportsDescriptors = !!c$13;
    f$12 = u$13;
    t$12 = function() {
      if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols)
        return false;
      if ("symbol" == typeof Symbol.iterator)
        return true;
      var t82 = {}, e92 = Symbol("test"), r92 = Object(e92);
      if ("string" == typeof e92)
        return false;
      if ("[object Symbol]" !== Object.prototype.toString.call(e92))
        return false;
      if ("[object Symbol]" !== Object.prototype.toString.call(r92))
        return false;
      for (e92 in t82[e92] = 42, t82)
        return false;
      if ("function" == typeof Object.keys && 0 !== Object.keys(t82).length)
        return false;
      if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t82).length)
        return false;
      var o82 = Object.getOwnPropertySymbols(t82);
      if (1 !== o82.length || o82[0] !== e92)
        return false;
      if (!Object.prototype.propertyIsEnumerable.call(t82, e92))
        return false;
      if ("function" == typeof Object.getOwnPropertyDescriptor) {
        var n82 = Object.getOwnPropertyDescriptor(t82, e92);
        if (42 !== n82.value || true !== n82.enumerable)
          return false;
      }
      return true;
    };
    f$22 = ("undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis).Symbol;
    e$3 = t$12;
    l$2 = function() {
      return "function" == typeof f$22 && ("function" == typeof Symbol && ("symbol" == typeof f$22("foo") && ("symbol" == typeof Symbol("bar") && e$3())));
    };
    t$22 = "Function.prototype.bind called on incompatible ";
    n$2 = Array.prototype.slice;
    o$22 = Object.prototype.toString;
    r$3 = function(r92) {
      var e92 = this;
      if ("function" != typeof e92 || "[object Function]" !== o$22.call(e92))
        throw new TypeError(t$22 + e92);
      for (var p72, i72 = n$2.call(arguments, 1), c72 = function() {
        if (this instanceof p72) {
          var t82 = e92.apply(this, i72.concat(n$2.call(arguments)));
          return Object(t82) === t82 ? t82 : this;
        }
        return e92.apply(r92, i72.concat(n$2.call(arguments)));
      }, a72 = Math.max(0, e92.length - i72.length), l72 = [], u72 = 0; u72 < a72; u72++)
        l72.push("$" + u72);
      if (p72 = Function("binder", "return function (" + l72.join(",") + "){ return binder.apply(this,arguments); }")(c72), e92.prototype) {
        var y62 = function() {
        };
        y62.prototype = e92.prototype, p72.prototype = new y62(), y62.prototype = null;
      }
      return p72;
    };
    e$4 = Function.prototype.bind || r$3;
    o$3 = TypeError;
    t$3 = Object.getOwnPropertyDescriptor;
    if (t$3)
      try {
        t$3({}, "");
      } catch (r92) {
        t$3 = null;
      }
    n$3 = function() {
      throw new o$3();
    };
    y$1 = t$3 ? function() {
      try {
        return arguments.callee, n$3;
      } catch (r92) {
        try {
          return t$3(arguments, "callee").get;
        } catch (r102) {
          return n$3;
        }
      }
    }() : n$3;
    a$22 = l$2();
    i$13 = Object.getPrototypeOf || function(r92) {
      return r92.__proto__;
    };
    d4 = "undefined" == typeof Uint8Array ? void 0 : i$13(Uint8Array);
    f$3 = { "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer, "%ArrayBufferPrototype%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer.prototype, "%ArrayIteratorPrototype%": a$22 ? i$13([][Symbol.iterator]()) : void 0, "%ArrayPrototype%": Array.prototype, "%ArrayProto_entries%": Array.prototype.entries, "%ArrayProto_forEach%": Array.prototype.forEach, "%ArrayProto_keys%": Array.prototype.keys, "%ArrayProto_values%": Array.prototype.values, "%AsyncFromSyncIteratorPrototype%": void 0, "%AsyncFunction%": void 0, "%AsyncFunctionPrototype%": void 0, "%AsyncGenerator%": void 0, "%AsyncGeneratorFunction%": void 0, "%AsyncGeneratorPrototype%": void 0, "%AsyncIteratorPrototype%": void 0, "%Atomics%": "undefined" == typeof Atomics ? void 0 : Atomics, "%Boolean%": Boolean, "%BooleanPrototype%": Boolean.prototype, "%DataView%": "undefined" == typeof DataView ? void 0 : DataView, "%DataViewPrototype%": "undefined" == typeof DataView ? void 0 : DataView.prototype, "%Date%": Date, "%DatePrototype%": Date.prototype, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%ErrorPrototype%": Error.prototype, "%eval%": eval, "%EvalError%": EvalError, "%EvalErrorPrototype%": EvalError.prototype, "%Float32Array%": "undefined" == typeof Float32Array ? void 0 : Float32Array, "%Float32ArrayPrototype%": "undefined" == typeof Float32Array ? void 0 : Float32Array.prototype, "%Float64Array%": "undefined" == typeof Float64Array ? void 0 : Float64Array, "%Float64ArrayPrototype%": "undefined" == typeof Float64Array ? void 0 : Float64Array.prototype, "%Function%": Function, "%FunctionPrototype%": Function.prototype, "%Generator%": void 0, "%GeneratorFunction%": void 0, "%GeneratorPrototype%": void 0, "%Int8Array%": "undefined" == typeof Int8Array ? void 0 : Int8Array, "%Int8ArrayPrototype%": "undefined" == typeof Int8Array ? void 0 : Int8Array.prototype, "%Int16Array%": "undefined" == typeof Int16Array ? void 0 : Int16Array, "%Int16ArrayPrototype%": "undefined" == typeof Int16Array ? void 0 : Int8Array.prototype, "%Int32Array%": "undefined" == typeof Int32Array ? void 0 : Int32Array, "%Int32ArrayPrototype%": "undefined" == typeof Int32Array ? void 0 : Int32Array.prototype, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": a$22 ? i$13(i$13([][Symbol.iterator]())) : void 0, "%JSON%": "object" == typeof JSON ? JSON : void 0, "%JSONParse%": "object" == typeof JSON ? JSON.parse : void 0, "%Map%": "undefined" == typeof Map ? void 0 : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && a$22 ? i$13((/* @__PURE__ */ new Map())[Symbol.iterator]()) : void 0, "%MapPrototype%": "undefined" == typeof Map ? void 0 : Map.prototype, "%Math%": Math, "%Number%": Number, "%NumberPrototype%": Number.prototype, "%Object%": Object, "%ObjectPrototype%": Object.prototype, "%ObjProto_toString%": Object.prototype.toString, "%ObjProto_valueOf%": Object.prototype.valueOf, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? void 0 : Promise, "%PromisePrototype%": "undefined" == typeof Promise ? void 0 : Promise.prototype, "%PromiseProto_then%": "undefined" == typeof Promise ? void 0 : Promise.prototype.then, "%Promise_all%": "undefined" == typeof Promise ? void 0 : Promise.all, "%Promise_reject%": "undefined" == typeof Promise ? void 0 : Promise.reject, "%Promise_resolve%": "undefined" == typeof Promise ? void 0 : Promise.resolve, "%Proxy%": "undefined" == typeof Proxy ? void 0 : Proxy, "%RangeError%": RangeError, "%RangeErrorPrototype%": RangeError.prototype, "%ReferenceError%": ReferenceError, "%ReferenceErrorPrototype%": ReferenceError.prototype, "%Reflect%": "undefined" == typeof Reflect ? void 0 : Reflect, "%RegExp%": RegExp, "%RegExpPrototype%": RegExp.prototype, "%Set%": "undefined" == typeof Set ? void 0 : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && a$22 ? i$13((/* @__PURE__ */ new Set())[Symbol.iterator]()) : void 0, "%SetPrototype%": "undefined" == typeof Set ? void 0 : Set.prototype, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer, "%SharedArrayBufferPrototype%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer.prototype, "%String%": String, "%StringIteratorPrototype%": a$22 ? i$13(""[Symbol.iterator]()) : void 0, "%StringPrototype%": String.prototype, "%Symbol%": a$22 ? Symbol : void 0, "%SymbolPrototype%": a$22 ? Symbol.prototype : void 0, "%SyntaxError%": SyntaxError, "%SyntaxErrorPrototype%": SyntaxError.prototype, "%ThrowTypeError%": y$1, "%TypedArray%": d4, "%TypedArrayPrototype%": d4 ? d4.prototype : void 0, "%TypeError%": o$3, "%TypeErrorPrototype%": o$3.prototype, "%Uint8Array%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array, "%Uint8ArrayPrototype%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array.prototype, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray, "%Uint8ClampedArrayPrototype%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray.prototype, "%Uint16Array%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array, "%Uint16ArrayPrototype%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array.prototype, "%Uint32Array%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array, "%Uint32ArrayPrototype%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array.prototype, "%URIError%": URIError, "%URIErrorPrototype%": URIError.prototype, "%WeakMap%": "undefined" == typeof WeakMap ? void 0 : WeakMap, "%WeakMapPrototype%": "undefined" == typeof WeakMap ? void 0 : WeakMap.prototype, "%WeakSet%": "undefined" == typeof WeakSet ? void 0 : WeakSet, "%WeakSetPrototype%": "undefined" == typeof WeakSet ? void 0 : WeakSet.prototype };
    u$22 = e$4.call(Function.call, String.prototype.replace);
    A3 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    l$3 = /\\(\\)?/g;
    v4 = function(r92) {
      var e92 = [];
      return u$22(r92, A3, function(r102, o82, t82, n82) {
        e92[e92.length] = t82 ? u$22(n82, l$3, "$1") : o82 || r102;
      }), e92;
    };
    P3 = function(r92, e92) {
      if (!(r92 in f$3))
        throw new SyntaxError("intrinsic " + r92 + " does not exist!");
      if (void 0 === f$3[r92] && !e92)
        throw new o$3("intrinsic " + r92 + " exists, but is not available. Please file an issue!");
      return f$3[r92];
    };
    c$2 = function(r92, e92) {
      if ("string" != typeof r92 || 0 === r92.length)
        throw new TypeError("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && "boolean" != typeof e92)
        throw new TypeError('"allowMissing" argument must be a boolean');
      for (var n82 = v4(r92), y62 = P3("%" + (n82.length > 0 ? n82[0] : "") + "%", e92), a72 = 1; a72 < n82.length; a72 += 1)
        if (null != y62)
          if (t$3 && a72 + 1 >= n82.length) {
            var i72 = t$3(y62, n82[a72]);
            if (!e92 && !(n82[a72] in y62))
              throw new o$3("base intrinsic for " + r92 + " exists, but the property is not available.");
            y62 = i72 ? i72.get || i72.value : y62[n82[a72]];
          } else
            y62 = y62[n82[a72]];
      return y62;
    };
    p$1 = e$4;
    o$4 = c$2("%Function%");
    i$2 = o$4.apply;
    a$3 = o$4.call;
    (t$4 = function() {
      return p$1.apply(a$3, arguments);
    }).apply = function() {
      return p$1.apply(i$2, arguments);
    };
    l$4 = t$4;
    i$3 = function(t82) {
      return t82 != t82;
    };
    o$5 = (r$4 = function(t82, e92) {
      return 0 === t82 && 0 === e92 ? 1 / t82 == 1 / e92 : t82 === e92 || !(!i$3(t82) || !i$3(e92));
    }, r$4);
    c$3 = (n$4 = function() {
      return "function" == typeof Object.is ? Object.is : o$5;
    }, n$4);
    f$4 = f$12;
    u$3 = f$12;
    s$12 = r$4;
    a$4 = n$4;
    l$5 = function() {
      var t82 = c$3();
      return f$4(Object, { is: t82 }, { is: function() {
        return Object.is !== t82;
      } }), t82;
    };
    p$2 = l$4(a$4(), Object);
    u$3(p$2, { getPolyfill: a$4, implementation: s$12, shim: l$5 });
    m4 = p$2;
    N3 = function(r92) {
      return r92 != r92;
    };
    i$4 = N3;
    n$5 = (e$5 = function() {
      return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : i$4;
    }, f$12);
    t$5 = e$5;
    u$4 = f$12;
    a$5 = N3;
    m$1 = e$5;
    o$6 = function() {
      var r92 = t$5();
      return n$5(Number, { isNaN: r92 }, { isNaN: function() {
        return Number.isNaN !== r92;
      } }), r92;
    };
    s$2 = m$1();
    u$4(s$2, { getPolyfill: m$1, implementation: a$5, shim: o$6 });
    f$5 = s$2;
    c$4 = {};
    a$6 = false;
    u$5 = {};
    l$6 = false;
    g$1 = void 0 !== /a/g.flags;
    h$1 = function(t82) {
      var e92 = [];
      return t82.forEach(function(t92) {
        return e92.push(t92);
      }), e92;
    };
    y$2 = function(t82) {
      var e92 = [];
      return t82.forEach(function(t92, n82) {
        return e92.push([n82, t92]);
      }), e92;
    };
    b$1 = Object.is ? Object.is : m4;
    v$1 = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
      return [];
    };
    d$1 = Number.isNaN ? Number.isNaN : f$5;
    E3 = m$2(Object.prototype.hasOwnProperty);
    w$1 = m$2(Object.prototype.propertyIsEnumerable);
    S3 = m$2(Object.prototype.toString);
    j$1 = X.types;
    O3 = j$1.isAnyArrayBuffer;
    x3 = j$1.isArrayBufferView;
    q2 = j$1.isDate;
    R3 = j$1.isMap;
    A$1 = j$1.isRegExp;
    k3 = j$1.isSet;
    _3 = j$1.isNativeError;
    T4 = j$1.isBoxedPrimitive;
    P$1 = j$1.isNumberObject;
    I3 = j$1.isStringObject;
    D3 = j$1.isBooleanObject;
    F3 = j$1.isBigIntObject;
    N$1 = j$1.isSymbolObject;
    L3 = j$1.isFloat32Array;
    M3 = j$1.isFloat64Array;
    X2 = { isDeepEqual: function(t82, e92) {
      return B3(t82, e92, false);
    }, isDeepStrictEqual: function(t82, e92) {
      return B3(t82, e92, true);
    } };
    Z2 = {};
    $$1 = false;
    et = tt();
    et.AssertionError;
    et.deepEqual;
    et.deepStrictEqual;
    et.doesNotReject;
    et.doesNotThrow;
    et.equal;
    et.fail;
    et.ifError;
    et.notDeepEqual;
    et.notDeepStrictEqual;
    et.notEqual;
    et.notStrictEqual;
    et.ok;
    et.rejects;
    et.strict;
    et.strictEqual;
    et.throws;
    et.AssertionError;
    et.deepEqual;
    et.deepStrictEqual;
    et.doesNotReject;
    et.doesNotThrow;
    et.equal;
    et.fail;
    et.ifError;
    et.notDeepEqual;
    et.notDeepStrictEqual;
    et.notEqual;
    et.notStrictEqual;
    et.ok;
    et.rejects;
    et.strict;
    et.strictEqual;
    et.throws;
    AssertionError = et.AssertionError;
    deepEqual = et.deepEqual;
    deepStrictEqual = et.deepStrictEqual;
    doesNotReject = et.doesNotReject;
    doesNotThrow = et.doesNotThrow;
    equal = et.equal;
    fail = et.fail;
    ifError = et.ifError;
    notDeepEqual = et.notDeepEqual;
    notDeepStrictEqual = et.notDeepStrictEqual;
    notEqual = et.notEqual;
    notStrictEqual = et.notStrictEqual;
    ok = et.ok;
    rejects = et.rejects;
    strict = et.strict;
    strictEqual = et.strictEqual;
    throws = et.throws;
    _extend2 = X._extend;
    callbackify2 = X.callbackify;
    debuglog2 = X.debuglog;
    deprecate2 = X.deprecate;
    format22 = X.format;
    inherits2 = X.inherits;
    inspect2 = X.inspect;
    isArray2 = X.isArray;
    isBoolean2 = X.isBoolean;
    isBuffer2 = X.isBuffer;
    isDate2 = X.isDate;
    isError2 = X.isError;
    isFunction2 = X.isFunction;
    isNull2 = X.isNull;
    isNullOrUndefined2 = X.isNullOrUndefined;
    isNumber2 = X.isNumber;
    isObject2 = X.isObject;
    isPrimitive2 = X.isPrimitive;
    isRegExp2 = X.isRegExp;
    isString2 = X.isString;
    isSymbol2 = X.isSymbol;
    isUndefined2 = X.isUndefined;
    log2 = X.log;
    promisify2 = X.promisify;
    types2 = X.types;
    TextEncoder2 = X.TextEncoder = globalThis.TextEncoder;
    TextDecoder3 = X.TextDecoder = globalThis.TextDecoder;
    exports$122 = {};
    _dewExec32 = false;
    exports32 = dew32();
    _makeLong2 = exports32._makeLong;
    basename2 = exports32.basename;
    delimiter2 = exports32.delimiter;
    dirname2 = exports32.dirname;
    extname2 = exports32.extname;
    format3 = exports32.format;
    isAbsolute2 = exports32.isAbsolute;
    join2 = exports32.join;
    normalize2 = exports32.normalize;
    parse2 = exports32.parse;
    posix2 = exports32.posix;
    relative2 = exports32.relative;
    resolve2 = exports32.resolve;
    sep2 = exports32.sep;
    win322 = exports32.win32;
    y.once = function(emitter, event) {
      return new Promise((resolve32, reject) => {
        function eventListener(...args) {
          if (errorListener !== void 0) {
            emitter.removeListener("error", errorListener);
          }
          resolve32(args);
        }
        let errorListener;
        if (event !== "error") {
          errorListener = (err) => {
            emitter.removeListener(name, eventListener);
            reject(err);
          };
          emitter.once("error", errorListener);
        }
        emitter.once(event, eventListener);
      });
    };
    y.on = function(emitter, event) {
      const unconsumedEventValues = [];
      const unconsumedPromises = [];
      let error = null;
      let finished22 = false;
      const iterator = {
        async next() {
          const value = unconsumedEventValues.shift();
          if (value) {
            return createIterResult(value, false);
          }
          if (error) {
            const p72 = Promise.reject(error);
            error = null;
            return p72;
          }
          if (finished22) {
            return createIterResult(void 0, true);
          }
          return new Promise((resolve32, reject) => unconsumedPromises.push({ resolve: resolve32, reject }));
        },
        async return() {
          emitter.removeListener(event, eventHandler);
          emitter.removeListener("error", errorHandler);
          finished22 = true;
          for (const promise of unconsumedPromises) {
            promise.resolve(createIterResult(void 0, true));
          }
          return createIterResult(void 0, true);
        },
        throw(err) {
          error = err;
          emitter.removeListener(event, eventHandler);
          emitter.removeListener("error", errorHandler);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
      emitter.on(event, eventHandler);
      emitter.on("error", errorHandler);
      return iterator;
      function eventHandler(...args) {
        const promise = unconsumedPromises.shift();
        if (promise) {
          promise.resolve(createIterResult(args, false));
        } else {
          unconsumedEventValues.push(args);
        }
      }
      function errorHandler(err) {
        finished22 = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
          toError.reject(err);
        } else {
          error = err;
        }
        iterator.return();
      }
    };
    ({
      EventEmitter,
      defaultMaxListeners,
      init,
      listenerCount,
      on,
      once
    } = y);
    exports$132 = {};
    _dewExec42 = false;
    _global3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports42 = dew42();
    Readable = exports42.Readable;
    Readable.wrap = function(src, options) {
      options = Object.assign({ objectMode: src.readableObjectMode != null || src.objectMode != null || true }, options);
      options.destroy = function(err, callback) {
        src.destroy(err);
        callback(err);
      };
      return new Readable(options).wrap(src);
    };
    Writable = exports42.Writable;
    Duplex = exports42.Duplex;
    Transform = exports42.Transform;
    PassThrough = exports42.PassThrough;
    finished = exports42.finished;
    pipeline = exports42.pipeline;
    Stream = exports42.Stream;
    promises = {
      finished: promisify2(exports42.finished),
      pipeline: promisify2(exports42.pipeline)
    };
    t6 = 2147483647;
    o5 = /^xn--/;
    n5 = /[^\0-\x7E]/;
    e6 = /[\x2E\u3002\uFF0E\uFF61]/g;
    r6 = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" };
    c5 = Math.floor;
    s5 = String.fromCharCode;
    u5 = function(t82, o82) {
      return t82 + 22 + 75 * (t82 < 26) - ((0 != o82) << 5);
    };
    a5 = function(t82, o82, n82) {
      let e92 = 0;
      for (t82 = n82 ? c5(t82 / 700) : t82 >> 1, t82 += c5(t82 / o82); t82 > 455; e92 += 36)
        t82 = c5(t82 / 35);
      return c5(e92 + 36 * t82 / (t82 + 38));
    };
    d5 = function(o82) {
      const n82 = [], e92 = o82.length;
      let r92 = 0, s62 = 128, f72 = 72, l72 = o82.lastIndexOf("-");
      l72 < 0 && (l72 = 0);
      for (let t82 = 0; t82 < l72; ++t82)
        o82.charCodeAt(t82) >= 128 && i5("not-basic"), n82.push(o82.charCodeAt(t82));
      for (let d62 = l72 > 0 ? l72 + 1 : 0; d62 < e92; ) {
        let l82 = r92;
        for (let n92 = 1, s72 = 36; ; s72 += 36) {
          d62 >= e92 && i5("invalid-input");
          const l92 = (u72 = o82.charCodeAt(d62++)) - 48 < 10 ? u72 - 22 : u72 - 65 < 26 ? u72 - 65 : u72 - 97 < 26 ? u72 - 97 : 36;
          (l92 >= 36 || l92 > c5((t6 - r92) / n92)) && i5("overflow"), r92 += l92 * n92;
          const a72 = s72 <= f72 ? 1 : s72 >= f72 + 26 ? 26 : s72 - f72;
          if (l92 < a72)
            break;
          const h92 = 36 - a72;
          n92 > c5(t6 / h92) && i5("overflow"), n92 *= h92;
        }
        const h82 = n82.length + 1;
        f72 = a5(r92 - l82, h82, 0 == l82), c5(r92 / h82) > t6 - s62 && i5("overflow"), s62 += c5(r92 / h82), r92 %= h82, n82.splice(r92++, 0, s62);
      }
      var u72;
      return String.fromCodePoint(...n82);
    };
    h6 = function(o82) {
      const n82 = [];
      let e92 = (o82 = l5(o82)).length, r92 = 128, f72 = 0, d62 = 72;
      for (const t82 of o82)
        t82 < 128 && n82.push(s5(t82));
      let h82 = n82.length, p72 = h82;
      for (h82 && n82.push("-"); p72 < e92; ) {
        let e102 = t6;
        for (const t82 of o82)
          t82 >= r92 && t82 < e102 && (e102 = t82);
        const l72 = p72 + 1;
        e102 - r92 > c5((t6 - f72) / l72) && i5("overflow"), f72 += (e102 - r92) * l72, r92 = e102;
        for (const e112 of o82)
          if (e112 < r92 && ++f72 > t6 && i5("overflow"), e112 == r92) {
            let t82 = f72;
            for (let o92 = 36; ; o92 += 36) {
              const e122 = o92 <= d62 ? 1 : o92 >= d62 + 26 ? 26 : o92 - d62;
              if (t82 < e122)
                break;
              const r102 = t82 - e122, i72 = 36 - e122;
              n82.push(s5(u5(e122 + r102 % i72, 0))), t82 = c5(r102 / i72);
            }
            n82.push(s5(u5(t82, 0))), d62 = a5(f72, l72, p72 == h82), f72 = 0, ++p72;
          }
        ++f72, ++r92;
      }
      return n82.join("");
    };
    p5 = { version: "2.1.0", ucs2: { decode: l5, encode: (t82) => String.fromCodePoint(...t82) }, decode: d5, encode: h6, toASCII: function(t82) {
      return f5(t82, function(t92) {
        return n5.test(t92) ? "xn--" + h6(t92) : t92;
      });
    }, toUnicode: function(t82) {
      return f5(t82, function(t92) {
        return o5.test(t92) ? d5(t92.slice(4).toLowerCase()) : t92;
      });
    } };
    p5.decode;
    p5.encode;
    p5.toASCII;
    p5.toUnicode;
    p5.ucs2;
    p5.version;
    n6 = function(n82, r92, t82, o82) {
      r92 = r92 || "&", t82 = t82 || "=";
      var a72 = {};
      if ("string" != typeof n82 || 0 === n82.length)
        return a72;
      var u72 = /\+/g;
      n82 = n82.split(r92);
      var c72 = 1e3;
      o82 && "number" == typeof o82.maxKeys && (c72 = o82.maxKeys);
      var i72 = n82.length;
      c72 > 0 && i72 > c72 && (i72 = c72);
      for (var s62 = 0; s62 < i72; ++s62) {
        var p72, f72, d62, y62, m62 = n82[s62].replace(u72, "%20"), l72 = m62.indexOf(t82);
        l72 >= 0 ? (p72 = m62.substr(0, l72), f72 = m62.substr(l72 + 1)) : (p72 = m62, f72 = ""), d62 = decodeURIComponent(p72), y62 = decodeURIComponent(f72), e7(a72, d62) ? Array.isArray(a72[d62]) ? a72[d62].push(y62) : a72[d62] = [a72[d62], y62] : a72[d62] = y62;
      }
      return a72;
    };
    r7 = function(e92) {
      switch (typeof e92) {
        case "string":
          return e92;
        case "boolean":
          return e92 ? "true" : "false";
        case "number":
          return isFinite(e92) ? e92 : "";
        default:
          return "";
      }
    };
    t7 = function(e92, n82, t82, o82) {
      return n82 = n82 || "&", t82 = t82 || "=", null === e92 && (e92 = void 0), "object" == typeof e92 ? Object.keys(e92).map(function(o92) {
        var a72 = encodeURIComponent(r7(o92)) + t82;
        return Array.isArray(e92[o92]) ? e92[o92].map(function(e102) {
          return a72 + encodeURIComponent(r7(e102));
        }).join(n82) : a72 + encodeURIComponent(r7(e92[o92]));
      }).join(n82) : o82 ? encodeURIComponent(r7(o82)) + t82 + encodeURIComponent(r7(e92)) : "";
    };
    o6 = {};
    o6.decode = o6.parse = n6, o6.encode = o6.stringify = t7;
    o6.decode;
    o6.encode;
    o6.parse;
    o6.stringify;
    h7 = {};
    e8 = p5;
    a6 = { isString: function(t82) {
      return "string" == typeof t82;
    }, isObject: function(t82) {
      return "object" == typeof t82 && null !== t82;
    }, isNull: function(t82) {
      return null === t82;
    }, isNullOrUndefined: function(t82) {
      return null == t82;
    } };
    h7.parse = O4, h7.resolve = function(t82, s62) {
      return O4(t82, false, true).resolve(s62);
    }, h7.resolveObject = function(t82, s62) {
      return t82 ? O4(t82, false, true).resolveObject(s62) : s62;
    }, h7.format = function(t82) {
      a6.isString(t82) && (t82 = O4(t82));
      return t82 instanceof r8 ? t82.format() : r8.prototype.format.call(t82);
    }, h7.Url = r8;
    o7 = /^([a-z0-9.+-]+:)/i;
    n7 = /:[0-9]*$/;
    i6 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    l6 = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]);
    p6 = ["'"].concat(l6);
    c6 = ["%", "/", "?", ";", "#"].concat(p6);
    u6 = ["/", "?", "#"];
    f6 = /^[+a-z0-9A-Z_-]{0,63}$/;
    m5 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    v5 = { javascript: true, "javascript:": true };
    g4 = { javascript: true, "javascript:": true };
    y5 = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
    b4 = o6;
    r8.prototype.parse = function(t82, s62, h82) {
      if (!a6.isString(t82))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof t82);
      var r92 = t82.indexOf("?"), n82 = -1 !== r92 && r92 < t82.indexOf("#") ? "?" : "#", l72 = t82.split(n82);
      l72[0] = l72[0].replace(/\\/g, "/");
      var O52 = t82 = l72.join(n82);
      if (O52 = O52.trim(), !h82 && 1 === t82.split("#").length) {
        var d62 = i6.exec(O52);
        if (d62)
          return this.path = O52, this.href = O52, this.pathname = d62[1], d62[2] ? (this.search = d62[2], this.query = s62 ? b4.parse(this.search.substr(1)) : this.search.substr(1)) : s62 && (this.search = "", this.query = {}), this;
      }
      var j42 = o7.exec(O52);
      if (j42) {
        var q32 = (j42 = j42[0]).toLowerCase();
        this.protocol = q32, O52 = O52.substr(j42.length);
      }
      if (h82 || j42 || O52.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var x42 = "//" === O52.substr(0, 2);
        !x42 || j42 && g4[j42] || (O52 = O52.substr(2), this.slashes = true);
      }
      if (!g4[j42] && (x42 || j42 && !y5[j42])) {
        for (var A42, C42, I42 = -1, w42 = 0; w42 < u6.length; w42++) {
          -1 !== (N42 = O52.indexOf(u6[w42])) && (-1 === I42 || N42 < I42) && (I42 = N42);
        }
        -1 !== (C42 = -1 === I42 ? O52.lastIndexOf("@") : O52.lastIndexOf("@", I42)) && (A42 = O52.slice(0, C42), O52 = O52.slice(C42 + 1), this.auth = decodeURIComponent(A42)), I42 = -1;
        for (w42 = 0; w42 < c6.length; w42++) {
          var N42;
          -1 !== (N42 = O52.indexOf(c6[w42])) && (-1 === I42 || N42 < I42) && (I42 = N42);
        }
        -1 === I42 && (I42 = O52.length), this.host = O52.slice(0, I42), O52 = O52.slice(I42), this.parseHost(), this.hostname = this.hostname || "";
        var U42 = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
        if (!U42)
          for (var k42 = this.hostname.split(/\./), S42 = (w42 = 0, k42.length); w42 < S42; w42++) {
            var R42 = k42[w42];
            if (R42 && !R42.match(f6)) {
              for (var $32 = "", z42 = 0, H32 = R42.length; z42 < H32; z42++)
                R42.charCodeAt(z42) > 127 ? $32 += "x" : $32 += R42[z42];
              if (!$32.match(f6)) {
                var L42 = k42.slice(0, w42), Z32 = k42.slice(w42 + 1), _42 = R42.match(m5);
                _42 && (L42.push(_42[1]), Z32.unshift(_42[2])), Z32.length && (O52 = "/" + Z32.join(".") + O52), this.hostname = L42.join(".");
                break;
              }
            }
          }
        this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), U42 || (this.hostname = e8.toASCII(this.hostname));
        var E42 = this.port ? ":" + this.port : "", P42 = this.hostname || "";
        this.host = P42 + E42, this.href += this.host, U42 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== O52[0] && (O52 = "/" + O52));
      }
      if (!v5[q32])
        for (w42 = 0, S42 = p6.length; w42 < S42; w42++) {
          var T52 = p6[w42];
          if (-1 !== O52.indexOf(T52)) {
            var B42 = encodeURIComponent(T52);
            B42 === T52 && (B42 = escape(T52)), O52 = O52.split(T52).join(B42);
          }
        }
      var D42 = O52.indexOf("#");
      -1 !== D42 && (this.hash = O52.substr(D42), O52 = O52.slice(0, D42));
      var F42 = O52.indexOf("?");
      if (-1 !== F42 ? (this.search = O52.substr(F42), this.query = O52.substr(F42 + 1), s62 && (this.query = b4.parse(this.query)), O52 = O52.slice(0, F42)) : s62 && (this.search = "", this.query = {}), O52 && (this.pathname = O52), y5[q32] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        E42 = this.pathname || "";
        var G32 = this.search || "";
        this.path = E42 + G32;
      }
      return this.href = this.format(), this;
    }, r8.prototype.format = function() {
      var t82 = this.auth || "";
      t82 && (t82 = (t82 = encodeURIComponent(t82)).replace(/%3A/i, ":"), t82 += "@");
      var s62 = this.protocol || "", h82 = this.pathname || "", e92 = this.hash || "", r92 = false, o82 = "";
      this.host ? r92 = t82 + this.host : this.hostname && (r92 = t82 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (r92 += ":" + this.port)), this.query && a6.isObject(this.query) && Object.keys(this.query).length && (o82 = b4.stringify(this.query));
      var n82 = this.search || o82 && "?" + o82 || "";
      return s62 && ":" !== s62.substr(-1) && (s62 += ":"), this.slashes || (!s62 || y5[s62]) && false !== r92 ? (r92 = "//" + (r92 || ""), h82 && "/" !== h82.charAt(0) && (h82 = "/" + h82)) : r92 || (r92 = ""), e92 && "#" !== e92.charAt(0) && (e92 = "#" + e92), n82 && "?" !== n82.charAt(0) && (n82 = "?" + n82), s62 + r92 + (h82 = h82.replace(/[?#]/g, function(t92) {
        return encodeURIComponent(t92);
      })) + (n82 = n82.replace("#", "%23")) + e92;
    }, r8.prototype.resolve = function(t82) {
      return this.resolveObject(O4(t82, false, true)).format();
    }, r8.prototype.resolveObject = function(t82) {
      if (a6.isString(t82)) {
        var s62 = new r8();
        s62.parse(t82, false, true), t82 = s62;
      }
      for (var h82 = new r8(), e92 = Object.keys(this), o82 = 0; o82 < e92.length; o82++) {
        var n82 = e92[o82];
        h82[n82] = this[n82];
      }
      if (h82.hash = t82.hash, "" === t82.href)
        return h82.href = h82.format(), h82;
      if (t82.slashes && !t82.protocol) {
        for (var i72 = Object.keys(t82), l72 = 0; l72 < i72.length; l72++) {
          var p72 = i72[l72];
          "protocol" !== p72 && (h82[p72] = t82[p72]);
        }
        return y5[h82.protocol] && h82.hostname && !h82.pathname && (h82.path = h82.pathname = "/"), h82.href = h82.format(), h82;
      }
      if (t82.protocol && t82.protocol !== h82.protocol) {
        if (!y5[t82.protocol]) {
          for (var c72 = Object.keys(t82), u72 = 0; u72 < c72.length; u72++) {
            var f72 = c72[u72];
            h82[f72] = t82[f72];
          }
          return h82.href = h82.format(), h82;
        }
        if (h82.protocol = t82.protocol, t82.host || g4[t82.protocol])
          h82.pathname = t82.pathname;
        else {
          for (var m62 = (t82.pathname || "").split("/"); m62.length && !(t82.host = m62.shift()); )
            ;
          t82.host || (t82.host = ""), t82.hostname || (t82.hostname = ""), "" !== m62[0] && m62.unshift(""), m62.length < 2 && m62.unshift(""), h82.pathname = m62.join("/");
        }
        if (h82.search = t82.search, h82.query = t82.query, h82.host = t82.host || "", h82.auth = t82.auth, h82.hostname = t82.hostname || t82.host, h82.port = t82.port, h82.pathname || h82.search) {
          var v62 = h82.pathname || "", b52 = h82.search || "";
          h82.path = v62 + b52;
        }
        return h82.slashes = h82.slashes || t82.slashes, h82.href = h82.format(), h82;
      }
      var O52 = h82.pathname && "/" === h82.pathname.charAt(0), d62 = t82.host || t82.pathname && "/" === t82.pathname.charAt(0), j42 = d62 || O52 || h82.host && t82.pathname, q32 = j42, x42 = h82.pathname && h82.pathname.split("/") || [], A42 = (m62 = t82.pathname && t82.pathname.split("/") || [], h82.protocol && !y5[h82.protocol]);
      if (A42 && (h82.hostname = "", h82.port = null, h82.host && ("" === x42[0] ? x42[0] = h82.host : x42.unshift(h82.host)), h82.host = "", t82.protocol && (t82.hostname = null, t82.port = null, t82.host && ("" === m62[0] ? m62[0] = t82.host : m62.unshift(t82.host)), t82.host = null), j42 = j42 && ("" === m62[0] || "" === x42[0])), d62)
        h82.host = t82.host || "" === t82.host ? t82.host : h82.host, h82.hostname = t82.hostname || "" === t82.hostname ? t82.hostname : h82.hostname, h82.search = t82.search, h82.query = t82.query, x42 = m62;
      else if (m62.length)
        x42 || (x42 = []), x42.pop(), x42 = x42.concat(m62), h82.search = t82.search, h82.query = t82.query;
      else if (!a6.isNullOrUndefined(t82.search)) {
        if (A42)
          h82.hostname = h82.host = x42.shift(), (U42 = !!(h82.host && h82.host.indexOf("@") > 0) && h82.host.split("@")) && (h82.auth = U42.shift(), h82.host = h82.hostname = U42.shift());
        return h82.search = t82.search, h82.query = t82.query, a6.isNull(h82.pathname) && a6.isNull(h82.search) || (h82.path = (h82.pathname ? h82.pathname : "") + (h82.search ? h82.search : "")), h82.href = h82.format(), h82;
      }
      if (!x42.length)
        return h82.pathname = null, h82.search ? h82.path = "/" + h82.search : h82.path = null, h82.href = h82.format(), h82;
      for (var C42 = x42.slice(-1)[0], I42 = (h82.host || t82.host || x42.length > 1) && ("." === C42 || ".." === C42) || "" === C42, w42 = 0, N42 = x42.length; N42 >= 0; N42--)
        "." === (C42 = x42[N42]) ? x42.splice(N42, 1) : ".." === C42 ? (x42.splice(N42, 1), w42++) : w42 && (x42.splice(N42, 1), w42--);
      if (!j42 && !q32)
        for (; w42--; w42)
          x42.unshift("..");
      !j42 || "" === x42[0] || x42[0] && "/" === x42[0].charAt(0) || x42.unshift(""), I42 && "/" !== x42.join("/").substr(-1) && x42.push("");
      var U42, k42 = "" === x42[0] || x42[0] && "/" === x42[0].charAt(0);
      A42 && (h82.hostname = h82.host = k42 ? "" : x42.length ? x42.shift() : "", (U42 = !!(h82.host && h82.host.indexOf("@") > 0) && h82.host.split("@")) && (h82.auth = U42.shift(), h82.host = h82.hostname = U42.shift()));
      return (j42 = j42 || h82.host && x42.length) && !k42 && x42.unshift(""), x42.length ? h82.pathname = x42.join("/") : (h82.pathname = null, h82.path = null), a6.isNull(h82.pathname) && a6.isNull(h82.search) || (h82.path = (h82.pathname ? h82.pathname : "") + (h82.search ? h82.search : "")), h82.auth = t82.auth || h82.auth, h82.slashes = h82.slashes || t82.slashes, h82.href = h82.format(), h82;
    }, r8.prototype.parseHost = function() {
      var t82 = this.host, s62 = n7.exec(t82);
      s62 && (":" !== (s62 = s62[0]) && (this.port = s62.substr(1)), t82 = t82.substr(0, t82.length - s62.length)), t82 && (this.hostname = t82);
    };
    h7.Url;
    h7.format;
    h7.resolve;
    h7.resolveObject;
    exports5 = {};
    _dewExec5 = false;
    path = dew5();
    processPlatform$1 = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
    h7.URL = typeof URL !== "undefined" ? URL : null;
    h7.pathToFileURL = pathToFileURL$1;
    h7.fileURLToPath = fileURLToPath$1;
    h7.Url;
    h7.format;
    h7.resolve;
    h7.resolveObject;
    h7.URL;
    CHAR_BACKWARD_SLASH$1 = 92;
    CHAR_FORWARD_SLASH$1 = 47;
    CHAR_LOWERCASE_A$1 = 97;
    CHAR_LOWERCASE_Z$1 = 122;
    isWindows$1 = processPlatform$1 === "win32";
    forwardSlashRegEx$1 = /\//g;
    percentRegEx$1 = /%/g;
    backslashRegEx$1 = /\\/g;
    newlineRegEx$1 = /\n/g;
    carriageReturnRegEx$1 = /\r/g;
    tabRegEx$1 = /\t/g;
    processPlatform = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
    h7.URL = typeof URL !== "undefined" ? URL : null;
    h7.pathToFileURL = pathToFileURL;
    h7.fileURLToPath = fileURLToPath;
    Url = h7.Url;
    format4 = h7.format;
    resolve22 = h7.resolve;
    resolveObject = h7.resolveObject;
    parse22 = h7.parse;
    _URL = h7.URL;
    CHAR_BACKWARD_SLASH = 92;
    CHAR_FORWARD_SLASH = 47;
    CHAR_LOWERCASE_A = 97;
    CHAR_LOWERCASE_Z = 122;
    isWindows = processPlatform === "win32";
    forwardSlashRegEx = /\//g;
    percentRegEx = /%/g;
    backslashRegEx = /\\/g;
    newlineRegEx = /\n/g;
    carriageReturnRegEx = /\r/g;
    tabRegEx = /\t/g;
    exports$32 = {};
    _dewExec$22 = false;
    exports$22 = {};
    _dewExec$12 = false;
    exports$14 = {};
    _dewExec6 = false;
    exports6 = dew6();
    exports6["Buffer"];
    exports6["SlowBuffer"];
    exports6["INSPECT_MAX_BYTES"];
    exports6["kMaxLength"];
    Buffer2 = exports6.Buffer;
    INSPECT_MAX_BYTES = exports6.INSPECT_MAX_BYTES;
    kMaxLength = exports6.kMaxLength;
    exports$h = {};
    _dewExec$f2 = false;
    exports$g2 = {};
    _dewExec$e2 = false;
    exports$f2 = {};
    _dewExec$d2 = false;
    exports$e2 = {};
    _dewExec$c2 = false;
    exports$d2 = {};
    _dewExec$b2 = false;
    _global$3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$c2 = {};
    _dewExec$a2 = false;
    exports$b2 = {};
    _dewExec$92 = false;
    exports$a2 = {};
    _dewExec$82 = false;
    _global$22 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$92 = {};
    _dewExec$72 = false;
    exports$82 = {};
    _dewExec$62 = false;
    exports$72 = {};
    _dewExec$52 = false;
    _global$12 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$62 = {};
    _dewExec$42 = false;
    exports$52 = {};
    _dewExec$32 = false;
    exports$42 = {};
    _dewExec$23 = false;
    _global4 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$33 = {};
    _dewExec$13 = false;
    exports$23 = {};
    _dewExec7 = false;
    exports$15 = dew7();
    exports$15["__esModule"];
    exports$15["fs"];
    exports$15["createFsFromVolume"];
    exports$15["vol"];
    exports$15["Volume"];
    exports$15["semantic"];
    exports7 = dew$23();
    exports7["__esModule"];
    exports7["FSWatcher"];
    exports7["StatWatcher"];
    exports7["Volume"];
    exports7["toUnixTimestamp"];
    exports7["bufferToEncoding"];
    exports7["dataToBuffer"];
    exports7["dataToStr"];
    exports7["pathToSteps"];
    exports7["filenameToSteps"];
    exports7["pathToFilename"];
    exports7["flagsToNumber"];
    exports7["FLAGS"];
    exports7["ReadStream"];
    exports7["WriteStream"];
    ({ vol, createFsFromVolume } = exports$15);
    vol.fromNestedJSON({
      "/dev": { stdin: "", stdout: "", stderr: "" },
      "/usr/bin": {},
      "/home": {},
      "/tmp": {}
    });
    vol.releasedFds = [2, 1, 0];
    vol.openSync("/dev/stdin", "w");
    vol.openSync("/dev/stdout", "r");
    vol.openSync("/dev/stderr", "r");
    watchStdo("/dev/stdout", 1, console.log);
    watchStdo("/dev/stderr", 2, console.error);
    fs = createFsFromVolume(vol);
    fs.opendir = () => unimplemented2("opendir");
    fs.opendirSync = () => unimplemented2("opendirSync");
    fs.promises.opendir = () => unimplemented2("promises.opendir");
    fs.cp = () => unimplemented2("cp");
    fs.cpSync = () => unimplemented2("cpSync");
    fs.promises.cp = () => unimplemented2("promises.cp");
    fs.readv = () => unimplemented2("readv");
    fs.readvSync = () => unimplemented2("readvSync");
    fs.rm = () => unimplemented2("rm");
    fs.rmSync = () => unimplemented2("rmSync");
    fs.promises.rm = () => unimplemented2("promises.rm");
    fs.Dir = () => unimplemented2("Dir");
    fs.promises.watch = () => unimplemented2("promises.watch");
    fs.FileReadStream = fs.ReadStream;
    fs.FileWriteStream = fs.WriteStream;
    fs.promises.readFile = wrapFsPromise(fs.promises.readFile);
    fs.readFile = wrapFsCallback(fs.readFile);
    fs.readFileSync = wrapFsSync(fs.readFileSync);
    ({
      appendFile,
      appendFileSync,
      access,
      accessSync,
      chown,
      chownSync,
      chmod,
      chmodSync,
      close,
      closeSync,
      copyFile,
      copyFileSync,
      cp,
      cpSync,
      createReadStream,
      createWriteStream,
      exists,
      existsSync,
      fchown,
      fchownSync,
      fchmod,
      fchmodSync,
      fdatasync,
      fdatasyncSync,
      fstat,
      fstatSync,
      fsync,
      fsyncSync,
      ftruncate,
      ftruncateSync,
      futimes,
      futimesSync,
      lchown,
      lchownSync,
      lchmod,
      lchmodSync,
      link,
      linkSync,
      lstat,
      lstatSync,
      mkdir,
      mkdirSync,
      mkdtemp,
      mkdtempSync,
      open,
      openSync,
      opendir,
      opendirSync,
      readdir,
      readdirSync,
      read,
      readSync,
      readv,
      readvSync,
      readFile,
      readFileSync,
      readlink,
      readlinkSync,
      realpath,
      realpathSync,
      rename,
      renameSync,
      rm,
      rmSync,
      rmdir,
      rmdirSync,
      stat,
      statSync,
      symlink,
      symlinkSync,
      truncate,
      truncateSync,
      unwatchFile,
      unlink,
      unlinkSync,
      utimes,
      utimesSync,
      watch,
      watchFile,
      writeFile,
      writeFileSync,
      write,
      writeSync,
      writev,
      writevSync,
      Dir,
      Dirent,
      Stats,
      ReadStream,
      WriteStream,
      FileReadStream,
      FileWriteStream,
      _toUnixTimestamp,
      constants: { F_OK, R_OK, W_OK, X_OK },
      constants: constants2,
      promises: promises2
    } = fs);
  }
});

// node-modules-polyfills-commonjs:fs
var fs_exports = {};
__export(fs_exports, {
  Dir: () => Dir,
  Dirent: () => Dirent,
  F_OK: () => F_OK,
  FileReadStream: () => FileReadStream,
  FileWriteStream: () => FileWriteStream,
  R_OK: () => R_OK,
  ReadStream: () => ReadStream,
  Stats: () => Stats,
  W_OK: () => W_OK,
  WriteStream: () => WriteStream,
  X_OK: () => X_OK,
  _toUnixTimestamp: () => _toUnixTimestamp,
  access: () => access,
  accessSync: () => accessSync,
  appendFile: () => appendFile,
  appendFileSync: () => appendFileSync,
  chmod: () => chmod,
  chmodSync: () => chmodSync,
  chown: () => chown,
  chownSync: () => chownSync,
  close: () => close,
  closeSync: () => closeSync,
  constants: () => constants2,
  copyFile: () => copyFile,
  copyFileSync: () => copyFileSync,
  cp: () => cp,
  cpSync: () => cpSync,
  createReadStream: () => createReadStream,
  createWriteStream: () => createWriteStream,
  exists: () => exists,
  existsSync: () => existsSync,
  fchmod: () => fchmod,
  fchmodSync: () => fchmodSync,
  fchown: () => fchown,
  fchownSync: () => fchownSync,
  fdatasync: () => fdatasync,
  fdatasyncSync: () => fdatasyncSync,
  fstat: () => fstat,
  fstatSync: () => fstatSync,
  fsync: () => fsync,
  fsyncSync: () => fsyncSync,
  ftruncate: () => ftruncate,
  ftruncateSync: () => ftruncateSync,
  futimes: () => futimes,
  futimesSync: () => futimesSync,
  lchmod: () => lchmod,
  lchmodSync: () => lchmodSync,
  lchown: () => lchown,
  lchownSync: () => lchownSync,
  link: () => link,
  linkSync: () => linkSync,
  lstat: () => lstat,
  lstatSync: () => lstatSync,
  mkdir: () => mkdir,
  mkdirSync: () => mkdirSync,
  mkdtemp: () => mkdtemp,
  mkdtempSync: () => mkdtempSync,
  open: () => open,
  openSync: () => openSync,
  opendir: () => opendir,
  opendirSync: () => opendirSync,
  promises: () => promises2,
  read: () => read,
  readFile: () => readFile,
  readFileSync: () => readFileSync,
  readSync: () => readSync,
  readdir: () => readdir,
  readdirSync: () => readdirSync,
  readlink: () => readlink,
  readlinkSync: () => readlinkSync,
  readv: () => readv,
  readvSync: () => readvSync,
  realpath: () => realpath,
  realpathSync: () => realpathSync,
  rename: () => rename,
  renameSync: () => renameSync,
  rm: () => rm,
  rmSync: () => rmSync,
  rmdir: () => rmdir,
  rmdirSync: () => rmdirSync,
  stat: () => stat,
  statSync: () => statSync,
  symlink: () => symlink,
  symlinkSync: () => symlinkSync,
  truncate: () => truncate,
  truncateSync: () => truncateSync,
  unlink: () => unlink,
  unlinkSync: () => unlinkSync,
  unwatchFile: () => unwatchFile,
  utimes: () => utimes,
  utimesSync: () => utimesSync,
  watch: () => watch,
  watchFile: () => watchFile,
  write: () => write,
  writeFile: () => writeFile,
  writeFileSync: () => writeFileSync,
  writeSync: () => writeSync,
  writev: () => writev,
  writevSync: () => writevSync
});
var init_fs2 = __esm({
  "node-modules-polyfills-commonjs:fs"() {
    init_fs();
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/src/node/tryRequire.js
var require_tryRequire = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/src/node/tryRequire.js"(exports10, module2) {
    var fs2 = (init_fs2(), __toCommonJS(fs_exports));
    var tryRequireSync = (filePath) => {
      try {
        return fs2.existsSync(filePath) ? require(filePath) : null;
      } catch (err) {
        return null;
      }
    };
    var tryRequire = (filePath) => {
      return new Promise((resolve4) => {
        fs2.access(filePath, (err) => {
          if (err)
            return resolve4(null);
          try {
            const module3 = require(filePath);
            return resolve4(module3);
          } catch (err2) {
            return resolve4(null);
          }
        });
      });
    };
    module2.exports = { tryRequire, tryRequireSync };
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/src/node/loadModule.js
var require_loadModule = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/src/node/loadModule.js"(exports10, module2) {
    "use strict";
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var { isArr, isFunc, isObj, isStr, logData } = require_cjs();
    var getRelativePath = (pathToModule) => {
      const { filename } = module2.parent;
      const split = filename.split("/");
      split.pop();
      return path3.resolve(split.join("/"), pathToModule);
    };
    var requireModule = (pathToModule, config) => {
      const { rootDir, logErrors } = config;
      try {
        return rootDir ? (
          // If rootDir exists, use it to load the module
          require(path3.join(rootDir, pathToModule))
        ) : (
          // If no rootDir, try to load the module without it
          require(getRelativePath(pathToModule))
        );
      } catch (err) {
        logErrors && logData(err.message, `error`);
        return rootDir ? requireModule(pathToModule, null) : void 0;
      }
    };
    var loadByType = (foundModule, params) => {
      return isFunc(foundModule) ? (
        // If it's a function call it with params
        foundModule(...params)
      ) : (
        // If it's an object just return it
        isObj(foundModule) || isArr(foundModule) ? foundModule : (
          // If it's not a function or object, return undefined
          void 0
        )
      );
    };
    var loopLoad = (pathsToModule, config, params) => {
      try {
        const modulePath = pathsToModule.shift();
        const foundModule = requireModule(modulePath, config);
        const loadedModule = foundModule && loadByType(foundModule, params);
        if (!loadedModule)
          throw new Error(`No Module!`);
        return loadedModule;
      } catch (err) {
        if (!isArr(pathsToModule) || !pathsToModule.length)
          return void 0;
        return loopLoad(pathsToModule, config, params);
      }
    };
    var loadModule = (pathsToModule, config = {}, ...params) => {
      pathsToModule = isStr(pathsToModule) ? (
        // If it's a string, convert to an array
        [pathsToModule]
      ) : (
        // Otherwise check if it's and array
        isArr(pathsToModule) && pathsToModule
      );
      return pathsToModule ? (
        // Call loopLoad to load the module
        loopLoad(pathsToModule, config, params)
      ) : (
        // If not paths, log an error
        logData(
          `loadModule requires an array or string as the first argument.`,
          `error`
        )
      );
    };
    module2.exports = {
      loadModule
    };
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/src/node/resolvePath.js
var require_resolvePath = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/src/node/resolvePath.js"(exports10, module2) {
    var os = (init_os2(), __toCommonJS(os_exports));
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var homeDir = os.homedir();
    var resolvePath = (location2, rootDir = process.cwd()) => {
      return location2.startsWith(`~`) ? path3.resolve(path3.join(homeDir, location2.replace(`~`, ""))) : location2 === `.` ? rootDir : location2.startsWith(`./`) ? path3.resolve(path3.join(`${rootDir}/`, location2.replace(`./`, ``))) : location2.startsWith(`/`) ? path3.resolve(location2) : path3.resolve(path3.join(rootDir, location2));
    };
    module2.exports = {
      resolvePath
    };
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/src/node/inDocker.js
var require_inDocker = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/src/node/inDocker.js"(exports10, module2) {
    var fs2 = (init_fs2(), __toCommonJS(fs_exports));
    var inContainer;
    var tryCatch = (cb) => {
      try {
        return Boolean(cb());
      } catch (_8) {
        return false;
      }
    };
    var dockEnv = () => fs2.statSync("/.dockerenv") || true;
    var docGroup = () => fs2.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
    var inDocker = () => {
      inContainer === void 0 && (inContainer = tryCatch(dockEnv) || tryCatch(docGroup));
      return inContainer;
    };
    module2.exports = {
      inDocker
    };
  }
});

// node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/src/node/index.js
var require_node = __commonJS({
  "node_modules/.pnpm/@keg-hub+jsutils@9.6.1/node_modules/@keg-hub/jsutils/src/node/index.js"(exports10, module2) {
    module2.exports = {
      ...require_cjs(),
      ...require_findProc(),
      ...require_tryRequire(),
      ...require_loadModule(),
      ...require_resolvePath(),
      ...require_inDocker()
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/constants/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/constants/constants.js"(exports10, module2) {
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var homeDir = (init_os2(), __toCommonJS(os_exports)).homedir();
    var { deepFreeze, get: get2 } = require_cjs();
    var { tryRequireSync } = require_node();
    var { KEG_GLOBAL_CONFIG } = process.env;
    var GLOBAL_CONFIG_FOLDER = path3.join(homeDir, ".kegConfig");
    var GLOBAL_CONFIG_FILE = "cli.config.json";
    if (KEG_GLOBAL_CONFIG) {
      const configPathSplit = KEG_GLOBAL_CONFIG.split("/");
      GLOBAL_CONFIG_FILE = configPathSplit.pop();
      GLOBAL_CONFIG_FOLDER = configPathSplit.join("/");
    }
    var GLOBAL_INJECT_FOLDER = path3.join(GLOBAL_CONFIG_FOLDER, ".tmp");
    var ENV_MAP = {
      PRODUCTION: ["production", "prod", "p"],
      CI: ["ci", "c"],
      QA: ["qa", "q"],
      STAGING: ["staging", "st", "s"],
      DEVELOPMENT: ["development", "dev", "d"],
      LOCAL: ["local", "loc", "l"],
      TEST: ["test", "tst", "t"]
    };
    var ENV_OPTIONS = Object.entries(ENV_MAP).reduce((options, [main, shortcuts]) => {
      return options.concat(shortcuts);
    }, []);
    var getKegCliPath = () => {
      if (process.env.KEG_CLI_PATH)
        return process.env.KEG_CLI_PATH;
      const mainFile = require.main && require.main.filename;
      if (mainFile && path3.basename(mainFile) === `keg-cli.js`)
        return require.main.path;
      const globalConfig = tryRequireSync(path3.join(GLOBAL_CONFIG_FOLDER, GLOBAL_CONFIG_FILE));
      return get2(globalConfig, `cli.paths.cli`);
    };
    module2.exports = deepFreeze({
      /**
       * Path to the Keg-CLI if installed
       * <br/>Cache the root of the CLI for other file to reference
       * <br/>All other references to cli root should come from here
       * @string
       */
      CLI_ROOT: getKegCliPath(),
      // Should be moved to docker-lib
      /**
       * Docker Constants
       * <br/> Mapped prefixes for some tasks that add prefixes when running containers
       * @string
       */
      CONTAINER_PREFIXES: {
        PACKAGE: "package",
        IMAGE: "img"
      },
      /**
       * Keg Default .env file, stored in ~/.kegConfig folder
       * @string
       */
      DEFAULT_ENV: `defaults.env`,
      /**
       * Global config folder path
       * @string
       */
      GLOBAL_CONFIG_FOLDER,
      /**
       * Global config file path
       * @string
       */
      GLOBAL_CONFIG_FILE,
      /**
       * Global config injected docker-compose folder path
       * @string
       */
      GLOBAL_INJECT_FOLDER,
      /**
       * Default global config setting locations
       * @Object
       */
      GLOBAL_CONFIG_PATHS: {
        CLI: "cli",
        CLI_PATHS: "cli.paths",
        GIT: "cli.git",
        TAPS: `cli.taps`,
        TAP_LINKS: `cli.taps`,
        SETTINGS: "cli.settings",
        EDITOR_CMD: "cli.settings.editorCmd"
      },
      /**
       * Environment keys mapped to their shortcuts 
       * @Object
       * @example
       * PRODUCTION: [ 'production', 'prod', 'p' ],
       * CI: [ 'ci', 'c' ],
       * QA: [ 'qa', 'q' ],
       * STAGING: [ 'staging', 'st', 's' ],
       * DEVELOPMENT: [ 'development', 'dev', 'd' ],
       * LOCAL: [ 'local', 'loc', 'l' ],
       * TEST: [ 'test', 'tst', 't' ]
       */
      ENV_MAP,
      /**
       * All Environment keys as an array
       * @Object
       */
      ENV_OPTIONS,
      /**
       * Shortcuts to map env to real environment
       * @Array
       * @example
       * [ 'environment', 'env', 'e' ]
       */
      ENV_ALIAS: ["environment", "env", "e"],
      /**
       * Help options. when one is passed as an option, the help menu is printed
       * @Array
       * @example
       * ['help', '-help', '--help', 'h', '-h', '--h']
       */
      HELP_ARGS: [
        "help",
        "-help",
        "--help",
        "h",
        "-h",
        "--h"
      ],
      /**
       * Private ranges of ip addresses
       * @Object
       */
      PRIVATE_IPV4_CLASSES: {
        A: ["10.0.0.0", "10.255.255.255"],
        B: ["172.16.0.0", "172.31.255.255"],
        C: ["192.168.0.0", "192.168.255.255"]
      },
      /**
       * All supported tap config names
       * @Object
       * @example
       * [
       *  'tap.config.js',
       *  'tap.js',
       *  'tap.config.json',
       *  'tap.json',
       *  'keg.config.js',
       *  'keg.config.json',
       * ]
       */
      TAP_CONFIG_NAMES: [
        "tap.config.js",
        "tap.js",
        "tap.config.json",
        "tap.json",
        "keg.config.js",
        "keg.config.json"
      ],
      // Tasks settings
      TASK_REQUIRED: [
        "prefix",
        "name",
        "action",
        "description"
      ],
      /**
       * Supported semver types when using the keg-cli publishing tasks
       * @Object
       * @example
       * [
       *  'major',
       *  'minor',
       *  'patch',
       *  'meta',
       *  `premajor`,
       *  `preminor`,
       *  `prepatch`,
       *  `prerelease`,
       * ]
       */
      SEMVER_TYPES: [
        "major",
        "minor",
        "patch",
        "meta",
        `premajor`,
        `preminor`,
        `prepatch`,
        `prerelease`
      ]
    });
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/constants/index.js
var require_constants2 = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/constants/index.js"(exports10, module2) {
    module2.exports = {
      ...require_constants()
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/error/throwNoTapLoc.js
var require_throwNoTapLoc = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/error/throwNoTapLoc.js"(exports10, module2) {
    var { get: get2 } = require_cjs();
    var { throwTaskFailed } = require_error();
    var { Logger: Logger3 } = require_logger();
    var { GLOBAL_CONFIG_PATHS } = require_constants2();
    var throwNoTapLoc = (globalConfig, tap) => {
      Logger3.error(`Tap location could not be found for ${tap}!`);
      Logger3.highlight(`Ensure the linked tap path for`, `${tap}`, `exists!`);
      Logger3.empty();
      const linkPaths = {};
      mapObj(get2(globalConfig, `${GLOBAL_CONFIG_PATHS.TAP_LINKS}`, {}), (alias, tapConfig) => {
        linkPaths[alias] = tapConfig.path;
      });
      Logger3.cyan(`Global Config Linked Tap Paths:`);
      Logger3.data(linkPaths);
      Logger3.empty();
      throwTaskFailed();
    };
    module2.exports = {
      throwNoTapLoc
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/error/index.js
var require_error2 = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/error/index.js"(exports10, module2) {
    module2.exports = {
      ...require_error(),
      ...require_throwNoTapLoc()
    };
  }
});

// node_modules/.pnpm/universalify@1.0.0/node_modules/universalify/index.js
var require_universalify = __commonJS({
  "node_modules/.pnpm/universalify@1.0.0/node_modules/universalify/index.js"(exports10) {
    "use strict";
    exports10.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function")
          fn.apply(this, args);
        else {
          return new Promise((resolve4, reject) => {
            fn.apply(
              this,
              args.concat([(err, res) => err ? reject(err) : resolve4(res)])
            );
          });
        }
      }, "name", { value: fn.name });
    };
    exports10.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args);
        else
          fn.apply(this, args.slice(0, -1)).then((r14) => cb(null, r14), cb);
      }, "name", { value: fn.name });
    };
  }
});

// node-modules-polyfills:constants
var constants3, DH_CHECK_P_NOT_PRIME, DH_CHECK_P_NOT_SAFE_PRIME, DH_NOT_SUITABLE_GENERATOR, DH_UNABLE_TO_CHECK_GENERATOR, E2BIG, EACCES, EADDRINUSE, EADDRNOTAVAIL, EAFNOSUPPORT, EAGAIN, EALREADY, EBADF, EBADMSG, EBUSY, ECANCELED, ECHILD, ECONNABORTED, ECONNREFUSED, ECONNRESET, EDEADLK, EDESTADDRREQ, EDOM, EDQUOT, EEXIST, EFAULT, EFBIG, EHOSTUNREACH, EIDRM, EILSEQ, EINPROGRESS, EINTR, EINVAL, EIO, EISCONN, EISDIR, ELOOP, EMFILE, EMLINK, EMSGSIZE, EMULTIHOP, ENAMETOOLONG, ENETDOWN, ENETRESET, ENETUNREACH, ENFILE, ENGINE_METHOD_ALL, ENGINE_METHOD_CIPHERS, ENGINE_METHOD_DH, ENGINE_METHOD_DIGESTS, ENGINE_METHOD_DSA, ENGINE_METHOD_ECDH, ENGINE_METHOD_ECDSA, ENGINE_METHOD_NONE, ENGINE_METHOD_PKEY_ASN1_METHS, ENGINE_METHOD_PKEY_METHS, ENGINE_METHOD_RAND, ENGINE_METHOD_STORE, ENOBUFS, ENODATA, ENODEV, ENOENT, ENOEXEC, ENOLCK, ENOLINK, ENOMEM, ENOMSG, ENOPROTOOPT, ENOSPC, ENOSR, ENOSTR, ENOSYS, ENOTCONN, ENOTDIR, ENOTEMPTY, ENOTSOCK, ENOTSUP, ENOTTY, ENXIO, EOPNOTSUPP, EOVERFLOW, EPERM, EPIPE, EPROTO, EPROTONOSUPPORT, EPROTOTYPE, ERANGE, EROFS, ESPIPE, ESRCH, ESTALE, ETIME, ETIMEDOUT, ETXTBSY, EWOULDBLOCK, EXDEV, F_OK2, NPN_ENABLED, O_APPEND, O_CREAT, O_DIRECTORY, O_EXCL, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYMLINK, O_SYNC, O_TRUNC, O_WRONLY, POINT_CONVERSION_COMPRESSED, POINT_CONVERSION_HYBRID, POINT_CONVERSION_UNCOMPRESSED, RSA_NO_PADDING, RSA_PKCS1_OAEP_PADDING, RSA_PKCS1_PADDING, RSA_PKCS1_PSS_PADDING, RSA_SSLV23_PADDING, RSA_X931_PADDING, R_OK2, SIGABRT, SIGALRM, SIGBUS, SIGCHLD, SIGCONT, SIGFPE, SIGHUP, SIGILL, SIGINT, SIGIO, SIGIOT, SIGKILL, SIGPIPE, SIGPROF, SIGQUIT, SIGSEGV, SIGSTOP, SIGSYS, SIGTERM, SIGTRAP, SIGTSTP, SIGTTIN, SIGTTOU, SIGURG, SIGUSR1, SIGUSR2, SIGVTALRM, SIGWINCH, SIGXCPU, SIGXFSZ, SSL_OP_ALL, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION, SSL_OP_CIPHER_SERVER_PREFERENCE, SSL_OP_CISCO_ANYCONNECT, SSL_OP_COOKIE_EXCHANGE, SSL_OP_CRYPTOPRO_TLSEXT_BUG, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS, SSL_OP_EPHEMERAL_RSA, SSL_OP_LEGACY_SERVER_CONNECT, SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER, SSL_OP_MICROSOFT_SESS_ID_BUG, SSL_OP_MSIE_SSLV2_RSA_PADDING, SSL_OP_NETSCAPE_CA_DN_BUG, SSL_OP_NETSCAPE_CHALLENGE_BUG, SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG, SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG, SSL_OP_NO_COMPRESSION, SSL_OP_NO_QUERY_MTU, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION, SSL_OP_NO_SSLv2, SSL_OP_NO_SSLv3, SSL_OP_NO_TICKET, SSL_OP_NO_TLSv1, SSL_OP_NO_TLSv1_1, SSL_OP_NO_TLSv1_2, SSL_OP_PKCS1_CHECK_1, SSL_OP_PKCS1_CHECK_2, SSL_OP_SINGLE_DH_USE, SSL_OP_SINGLE_ECDH_USE, SSL_OP_SSLEAY_080_CLIENT_DH_BUG, SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG, SSL_OP_TLS_BLOCK_PADDING_BUG, SSL_OP_TLS_D5_BUG, SSL_OP_TLS_ROLLBACK_BUG, S_IFBLK, S_IFCHR, S_IFDIR, S_IFIFO, S_IFLNK, S_IFMT, S_IFREG, S_IFSOCK, S_IRGRP, S_IROTH, S_IRUSR, S_IRWXG, S_IRWXO, S_IRWXU, S_IWGRP, S_IWOTH, S_IWUSR, S_IXGRP, S_IXOTH, S_IXUSR, UV_UDP_REUSEADDR, W_OK2, X_OK2;
var init_constants = __esm({
  "node-modules-polyfills:constants"() {
    constants3 = {
      "O_RDONLY": 0,
      "O_WRONLY": 1,
      "O_RDWR": 2,
      "S_IFMT": 61440,
      "S_IFREG": 32768,
      "S_IFDIR": 16384,
      "S_IFCHR": 8192,
      "S_IFBLK": 24576,
      "S_IFIFO": 4096,
      "S_IFLNK": 40960,
      "S_IFSOCK": 49152,
      "O_CREAT": 512,
      "O_EXCL": 2048,
      "O_NOCTTY": 131072,
      "O_TRUNC": 1024,
      "O_APPEND": 8,
      "O_DIRECTORY": 1048576,
      "O_NOFOLLOW": 256,
      "O_SYNC": 128,
      "O_SYMLINK": 2097152,
      "O_NONBLOCK": 4,
      "S_IRWXU": 448,
      "S_IRUSR": 256,
      "S_IWUSR": 128,
      "S_IXUSR": 64,
      "S_IRWXG": 56,
      "S_IRGRP": 32,
      "S_IWGRP": 16,
      "S_IXGRP": 8,
      "S_IRWXO": 7,
      "S_IROTH": 4,
      "S_IWOTH": 2,
      "S_IXOTH": 1,
      "E2BIG": 7,
      "EACCES": 13,
      "EADDRINUSE": 48,
      "EADDRNOTAVAIL": 49,
      "EAFNOSUPPORT": 47,
      "EAGAIN": 35,
      "EALREADY": 37,
      "EBADF": 9,
      "EBADMSG": 94,
      "EBUSY": 16,
      "ECANCELED": 89,
      "ECHILD": 10,
      "ECONNABORTED": 53,
      "ECONNREFUSED": 61,
      "ECONNRESET": 54,
      "EDEADLK": 11,
      "EDESTADDRREQ": 39,
      "EDOM": 33,
      "EDQUOT": 69,
      "EEXIST": 17,
      "EFAULT": 14,
      "EFBIG": 27,
      "EHOSTUNREACH": 65,
      "EIDRM": 90,
      "EILSEQ": 92,
      "EINPROGRESS": 36,
      "EINTR": 4,
      "EINVAL": 22,
      "EIO": 5,
      "EISCONN": 56,
      "EISDIR": 21,
      "ELOOP": 62,
      "EMFILE": 24,
      "EMLINK": 31,
      "EMSGSIZE": 40,
      "EMULTIHOP": 95,
      "ENAMETOOLONG": 63,
      "ENETDOWN": 50,
      "ENETRESET": 52,
      "ENETUNREACH": 51,
      "ENFILE": 23,
      "ENOBUFS": 55,
      "ENODATA": 96,
      "ENODEV": 19,
      "ENOENT": 2,
      "ENOEXEC": 8,
      "ENOLCK": 77,
      "ENOLINK": 97,
      "ENOMEM": 12,
      "ENOMSG": 91,
      "ENOPROTOOPT": 42,
      "ENOSPC": 28,
      "ENOSR": 98,
      "ENOSTR": 99,
      "ENOSYS": 78,
      "ENOTCONN": 57,
      "ENOTDIR": 20,
      "ENOTEMPTY": 66,
      "ENOTSOCK": 38,
      "ENOTSUP": 45,
      "ENOTTY": 25,
      "ENXIO": 6,
      "EOPNOTSUPP": 102,
      "EOVERFLOW": 84,
      "EPERM": 1,
      "EPIPE": 32,
      "EPROTO": 100,
      "EPROTONOSUPPORT": 43,
      "EPROTOTYPE": 41,
      "ERANGE": 34,
      "EROFS": 30,
      "ESPIPE": 29,
      "ESRCH": 3,
      "ESTALE": 70,
      "ETIME": 101,
      "ETIMEDOUT": 60,
      "ETXTBSY": 26,
      "EWOULDBLOCK": 35,
      "EXDEV": 18,
      "SIGHUP": 1,
      "SIGINT": 2,
      "SIGQUIT": 3,
      "SIGILL": 4,
      "SIGTRAP": 5,
      "SIGABRT": 6,
      "SIGIOT": 6,
      "SIGBUS": 10,
      "SIGFPE": 8,
      "SIGKILL": 9,
      "SIGUSR1": 30,
      "SIGSEGV": 11,
      "SIGUSR2": 31,
      "SIGPIPE": 13,
      "SIGALRM": 14,
      "SIGTERM": 15,
      "SIGCHLD": 20,
      "SIGCONT": 19,
      "SIGSTOP": 17,
      "SIGTSTP": 18,
      "SIGTTIN": 21,
      "SIGTTOU": 22,
      "SIGURG": 16,
      "SIGXCPU": 24,
      "SIGXFSZ": 25,
      "SIGVTALRM": 26,
      "SIGPROF": 27,
      "SIGWINCH": 28,
      "SIGIO": 23,
      "SIGSYS": 12,
      "SSL_OP_ALL": 2147486719,
      "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION": 262144,
      "SSL_OP_CIPHER_SERVER_PREFERENCE": 4194304,
      "SSL_OP_CISCO_ANYCONNECT": 32768,
      "SSL_OP_COOKIE_EXCHANGE": 8192,
      "SSL_OP_CRYPTOPRO_TLSEXT_BUG": 2147483648,
      "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS": 2048,
      "SSL_OP_EPHEMERAL_RSA": 0,
      "SSL_OP_LEGACY_SERVER_CONNECT": 4,
      "SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER": 32,
      "SSL_OP_MICROSOFT_SESS_ID_BUG": 1,
      "SSL_OP_MSIE_SSLV2_RSA_PADDING": 0,
      "SSL_OP_NETSCAPE_CA_DN_BUG": 536870912,
      "SSL_OP_NETSCAPE_CHALLENGE_BUG": 2,
      "SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG": 1073741824,
      "SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG": 8,
      "SSL_OP_NO_COMPRESSION": 131072,
      "SSL_OP_NO_QUERY_MTU": 4096,
      "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION": 65536,
      "SSL_OP_NO_SSLv2": 16777216,
      "SSL_OP_NO_SSLv3": 33554432,
      "SSL_OP_NO_TICKET": 16384,
      "SSL_OP_NO_TLSv1": 67108864,
      "SSL_OP_NO_TLSv1_1": 268435456,
      "SSL_OP_NO_TLSv1_2": 134217728,
      "SSL_OP_PKCS1_CHECK_1": 0,
      "SSL_OP_PKCS1_CHECK_2": 0,
      "SSL_OP_SINGLE_DH_USE": 1048576,
      "SSL_OP_SINGLE_ECDH_USE": 524288,
      "SSL_OP_SSLEAY_080_CLIENT_DH_BUG": 128,
      "SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG": 0,
      "SSL_OP_TLS_BLOCK_PADDING_BUG": 512,
      "SSL_OP_TLS_D5_BUG": 256,
      "SSL_OP_TLS_ROLLBACK_BUG": 8388608,
      "ENGINE_METHOD_DSA": 2,
      "ENGINE_METHOD_DH": 4,
      "ENGINE_METHOD_RAND": 8,
      "ENGINE_METHOD_ECDH": 16,
      "ENGINE_METHOD_ECDSA": 32,
      "ENGINE_METHOD_CIPHERS": 64,
      "ENGINE_METHOD_DIGESTS": 128,
      "ENGINE_METHOD_STORE": 256,
      "ENGINE_METHOD_PKEY_METHS": 512,
      "ENGINE_METHOD_PKEY_ASN1_METHS": 1024,
      "ENGINE_METHOD_ALL": 65535,
      "ENGINE_METHOD_NONE": 0,
      "DH_CHECK_P_NOT_SAFE_PRIME": 2,
      "DH_CHECK_P_NOT_PRIME": 1,
      "DH_UNABLE_TO_CHECK_GENERATOR": 4,
      "DH_NOT_SUITABLE_GENERATOR": 8,
      "NPN_ENABLED": 1,
      "RSA_PKCS1_PADDING": 1,
      "RSA_SSLV23_PADDING": 2,
      "RSA_NO_PADDING": 3,
      "RSA_PKCS1_OAEP_PADDING": 4,
      "RSA_X931_PADDING": 5,
      "RSA_PKCS1_PSS_PADDING": 6,
      "POINT_CONVERSION_COMPRESSED": 2,
      "POINT_CONVERSION_UNCOMPRESSED": 4,
      "POINT_CONVERSION_HYBRID": 6,
      "F_OK": 0,
      "R_OK": 4,
      "W_OK": 2,
      "X_OK": 1,
      "UV_UDP_REUSEADDR": 4
    };
    DH_CHECK_P_NOT_PRIME = constants3.DH_CHECK_P_NOT_PRIME;
    DH_CHECK_P_NOT_SAFE_PRIME = constants3.DH_CHECK_P_NOT_SAFE_PRIME;
    DH_NOT_SUITABLE_GENERATOR = constants3.DH_NOT_SUITABLE_GENERATOR;
    DH_UNABLE_TO_CHECK_GENERATOR = constants3.DH_UNABLE_TO_CHECK_GENERATOR;
    E2BIG = constants3.E2BIG;
    EACCES = constants3.EACCES;
    EADDRINUSE = constants3.EADDRINUSE;
    EADDRNOTAVAIL = constants3.EADDRNOTAVAIL;
    EAFNOSUPPORT = constants3.EAFNOSUPPORT;
    EAGAIN = constants3.EAGAIN;
    EALREADY = constants3.EALREADY;
    EBADF = constants3.EBADF;
    EBADMSG = constants3.EBADMSG;
    EBUSY = constants3.EBUSY;
    ECANCELED = constants3.ECANCELED;
    ECHILD = constants3.ECHILD;
    ECONNABORTED = constants3.ECONNABORTED;
    ECONNREFUSED = constants3.ECONNREFUSED;
    ECONNRESET = constants3.ECONNRESET;
    EDEADLK = constants3.EDEADLK;
    EDESTADDRREQ = constants3.EDESTADDRREQ;
    EDOM = constants3.EDOM;
    EDQUOT = constants3.EDQUOT;
    EEXIST = constants3.EEXIST;
    EFAULT = constants3.EFAULT;
    EFBIG = constants3.EFBIG;
    EHOSTUNREACH = constants3.EHOSTUNREACH;
    EIDRM = constants3.EIDRM;
    EILSEQ = constants3.EILSEQ;
    EINPROGRESS = constants3.EINPROGRESS;
    EINTR = constants3.EINTR;
    EINVAL = constants3.EINVAL;
    EIO = constants3.EIO;
    EISCONN = constants3.EISCONN;
    EISDIR = constants3.EISDIR;
    ELOOP = constants3.ELOOP;
    EMFILE = constants3.EMFILE;
    EMLINK = constants3.EMLINK;
    EMSGSIZE = constants3.EMSGSIZE;
    EMULTIHOP = constants3.EMULTIHOP;
    ENAMETOOLONG = constants3.ENAMETOOLONG;
    ENETDOWN = constants3.ENETDOWN;
    ENETRESET = constants3.ENETRESET;
    ENETUNREACH = constants3.ENETUNREACH;
    ENFILE = constants3.ENFILE;
    ENGINE_METHOD_ALL = constants3.ENGINE_METHOD_ALL;
    ENGINE_METHOD_CIPHERS = constants3.ENGINE_METHOD_CIPHERS;
    ENGINE_METHOD_DH = constants3.ENGINE_METHOD_DH;
    ENGINE_METHOD_DIGESTS = constants3.ENGINE_METHOD_DIGESTS;
    ENGINE_METHOD_DSA = constants3.ENGINE_METHOD_DSA;
    ENGINE_METHOD_ECDH = constants3.ENGINE_METHOD_ECDH;
    ENGINE_METHOD_ECDSA = constants3.ENGINE_METHOD_ECDSA;
    ENGINE_METHOD_NONE = constants3.ENGINE_METHOD_NONE;
    ENGINE_METHOD_PKEY_ASN1_METHS = constants3.ENGINE_METHOD_PKEY_ASN1_METHS;
    ENGINE_METHOD_PKEY_METHS = constants3.ENGINE_METHOD_PKEY_METHS;
    ENGINE_METHOD_RAND = constants3.ENGINE_METHOD_RAND;
    ENGINE_METHOD_STORE = constants3.ENGINE_METHOD_STORE;
    ENOBUFS = constants3.ENOBUFS;
    ENODATA = constants3.ENODATA;
    ENODEV = constants3.ENODEV;
    ENOENT = constants3.ENOENT;
    ENOEXEC = constants3.ENOEXEC;
    ENOLCK = constants3.ENOLCK;
    ENOLINK = constants3.ENOLINK;
    ENOMEM = constants3.ENOMEM;
    ENOMSG = constants3.ENOMSG;
    ENOPROTOOPT = constants3.ENOPROTOOPT;
    ENOSPC = constants3.ENOSPC;
    ENOSR = constants3.ENOSR;
    ENOSTR = constants3.ENOSTR;
    ENOSYS = constants3.ENOSYS;
    ENOTCONN = constants3.ENOTCONN;
    ENOTDIR = constants3.ENOTDIR;
    ENOTEMPTY = constants3.ENOTEMPTY;
    ENOTSOCK = constants3.ENOTSOCK;
    ENOTSUP = constants3.ENOTSUP;
    ENOTTY = constants3.ENOTTY;
    ENXIO = constants3.ENXIO;
    EOPNOTSUPP = constants3.EOPNOTSUPP;
    EOVERFLOW = constants3.EOVERFLOW;
    EPERM = constants3.EPERM;
    EPIPE = constants3.EPIPE;
    EPROTO = constants3.EPROTO;
    EPROTONOSUPPORT = constants3.EPROTONOSUPPORT;
    EPROTOTYPE = constants3.EPROTOTYPE;
    ERANGE = constants3.ERANGE;
    EROFS = constants3.EROFS;
    ESPIPE = constants3.ESPIPE;
    ESRCH = constants3.ESRCH;
    ESTALE = constants3.ESTALE;
    ETIME = constants3.ETIME;
    ETIMEDOUT = constants3.ETIMEDOUT;
    ETXTBSY = constants3.ETXTBSY;
    EWOULDBLOCK = constants3.EWOULDBLOCK;
    EXDEV = constants3.EXDEV;
    F_OK2 = constants3.F_OK;
    NPN_ENABLED = constants3.NPN_ENABLED;
    O_APPEND = constants3.O_APPEND;
    O_CREAT = constants3.O_CREAT;
    O_DIRECTORY = constants3.O_DIRECTORY;
    O_EXCL = constants3.O_EXCL;
    O_NOCTTY = constants3.O_NOCTTY;
    O_NOFOLLOW = constants3.O_NOFOLLOW;
    O_NONBLOCK = constants3.O_NONBLOCK;
    O_RDONLY = constants3.O_RDONLY;
    O_RDWR = constants3.O_RDWR;
    O_SYMLINK = constants3.O_SYMLINK;
    O_SYNC = constants3.O_SYNC;
    O_TRUNC = constants3.O_TRUNC;
    O_WRONLY = constants3.O_WRONLY;
    POINT_CONVERSION_COMPRESSED = constants3.POINT_CONVERSION_COMPRESSED;
    POINT_CONVERSION_HYBRID = constants3.POINT_CONVERSION_HYBRID;
    POINT_CONVERSION_UNCOMPRESSED = constants3.POINT_CONVERSION_UNCOMPRESSED;
    RSA_NO_PADDING = constants3.RSA_NO_PADDING;
    RSA_PKCS1_OAEP_PADDING = constants3.RSA_PKCS1_OAEP_PADDING;
    RSA_PKCS1_PADDING = constants3.RSA_PKCS1_PADDING;
    RSA_PKCS1_PSS_PADDING = constants3.RSA_PKCS1_PSS_PADDING;
    RSA_SSLV23_PADDING = constants3.RSA_SSLV23_PADDING;
    RSA_X931_PADDING = constants3.RSA_X931_PADDING;
    R_OK2 = constants3.R_OK;
    SIGABRT = constants3.SIGABRT;
    SIGALRM = constants3.SIGALRM;
    SIGBUS = constants3.SIGBUS;
    SIGCHLD = constants3.SIGCHLD;
    SIGCONT = constants3.SIGCONT;
    SIGFPE = constants3.SIGFPE;
    SIGHUP = constants3.SIGHUP;
    SIGILL = constants3.SIGILL;
    SIGINT = constants3.SIGINT;
    SIGIO = constants3.SIGIO;
    SIGIOT = constants3.SIGIOT;
    SIGKILL = constants3.SIGKILL;
    SIGPIPE = constants3.SIGPIPE;
    SIGPROF = constants3.SIGPROF;
    SIGQUIT = constants3.SIGQUIT;
    SIGSEGV = constants3.SIGSEGV;
    SIGSTOP = constants3.SIGSTOP;
    SIGSYS = constants3.SIGSYS;
    SIGTERM = constants3.SIGTERM;
    SIGTRAP = constants3.SIGTRAP;
    SIGTSTP = constants3.SIGTSTP;
    SIGTTIN = constants3.SIGTTIN;
    SIGTTOU = constants3.SIGTTOU;
    SIGURG = constants3.SIGURG;
    SIGUSR1 = constants3.SIGUSR1;
    SIGUSR2 = constants3.SIGUSR2;
    SIGVTALRM = constants3.SIGVTALRM;
    SIGWINCH = constants3.SIGWINCH;
    SIGXCPU = constants3.SIGXCPU;
    SIGXFSZ = constants3.SIGXFSZ;
    SSL_OP_ALL = constants3.SSL_OP_ALL;
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = constants3.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION;
    SSL_OP_CIPHER_SERVER_PREFERENCE = constants3.SSL_OP_CIPHER_SERVER_PREFERENCE;
    SSL_OP_CISCO_ANYCONNECT = constants3.SSL_OP_CISCO_ANYCONNECT;
    SSL_OP_COOKIE_EXCHANGE = constants3.SSL_OP_COOKIE_EXCHANGE;
    SSL_OP_CRYPTOPRO_TLSEXT_BUG = constants3.SSL_OP_CRYPTOPRO_TLSEXT_BUG;
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = constants3.SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;
    SSL_OP_EPHEMERAL_RSA = constants3.SSL_OP_EPHEMERAL_RSA;
    SSL_OP_LEGACY_SERVER_CONNECT = constants3.SSL_OP_LEGACY_SERVER_CONNECT;
    SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER = constants3.SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER;
    SSL_OP_MICROSOFT_SESS_ID_BUG = constants3.SSL_OP_MICROSOFT_SESS_ID_BUG;
    SSL_OP_MSIE_SSLV2_RSA_PADDING = constants3.SSL_OP_MSIE_SSLV2_RSA_PADDING;
    SSL_OP_NETSCAPE_CA_DN_BUG = constants3.SSL_OP_NETSCAPE_CA_DN_BUG;
    SSL_OP_NETSCAPE_CHALLENGE_BUG = constants3.SSL_OP_NETSCAPE_CHALLENGE_BUG;
    SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = constants3.SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG;
    SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = constants3.SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;
    SSL_OP_NO_COMPRESSION = constants3.SSL_OP_NO_COMPRESSION;
    SSL_OP_NO_QUERY_MTU = constants3.SSL_OP_NO_QUERY_MTU;
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION = constants3.SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION;
    SSL_OP_NO_SSLv2 = constants3.SSL_OP_NO_SSLv2;
    SSL_OP_NO_SSLv3 = constants3.SSL_OP_NO_SSLv3;
    SSL_OP_NO_TICKET = constants3.SSL_OP_NO_TICKET;
    SSL_OP_NO_TLSv1 = constants3.SSL_OP_NO_TLSv1;
    SSL_OP_NO_TLSv1_1 = constants3.SSL_OP_NO_TLSv1_1;
    SSL_OP_NO_TLSv1_2 = constants3.SSL_OP_NO_TLSv1_2;
    SSL_OP_PKCS1_CHECK_1 = constants3.SSL_OP_PKCS1_CHECK_1;
    SSL_OP_PKCS1_CHECK_2 = constants3.SSL_OP_PKCS1_CHECK_2;
    SSL_OP_SINGLE_DH_USE = constants3.SSL_OP_SINGLE_DH_USE;
    SSL_OP_SINGLE_ECDH_USE = constants3.SSL_OP_SINGLE_ECDH_USE;
    SSL_OP_SSLEAY_080_CLIENT_DH_BUG = constants3.SSL_OP_SSLEAY_080_CLIENT_DH_BUG;
    SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG = constants3.SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG;
    SSL_OP_TLS_BLOCK_PADDING_BUG = constants3.SSL_OP_TLS_BLOCK_PADDING_BUG;
    SSL_OP_TLS_D5_BUG = constants3.SSL_OP_TLS_D5_BUG;
    SSL_OP_TLS_ROLLBACK_BUG = constants3.SSL_OP_TLS_ROLLBACK_BUG;
    S_IFBLK = constants3.S_IFBLK;
    S_IFCHR = constants3.S_IFCHR;
    S_IFDIR = constants3.S_IFDIR;
    S_IFIFO = constants3.S_IFIFO;
    S_IFLNK = constants3.S_IFLNK;
    S_IFMT = constants3.S_IFMT;
    S_IFREG = constants3.S_IFREG;
    S_IFSOCK = constants3.S_IFSOCK;
    S_IRGRP = constants3.S_IRGRP;
    S_IROTH = constants3.S_IROTH;
    S_IRUSR = constants3.S_IRUSR;
    S_IRWXG = constants3.S_IRWXG;
    S_IRWXO = constants3.S_IRWXO;
    S_IRWXU = constants3.S_IRWXU;
    S_IWGRP = constants3.S_IWGRP;
    S_IWOTH = constants3.S_IWOTH;
    S_IWUSR = constants3.S_IWUSR;
    S_IXGRP = constants3.S_IXGRP;
    S_IXOTH = constants3.S_IXOTH;
    S_IXUSR = constants3.S_IXUSR;
    UV_UDP_REUSEADDR = constants3.UV_UDP_REUSEADDR;
    W_OK2 = constants3.W_OK;
    X_OK2 = constants3.X_OK;
  }
});

// node-modules-polyfills-commonjs:constants
var constants_exports = {};
__export(constants_exports, {
  DH_CHECK_P_NOT_PRIME: () => DH_CHECK_P_NOT_PRIME,
  DH_CHECK_P_NOT_SAFE_PRIME: () => DH_CHECK_P_NOT_SAFE_PRIME,
  DH_NOT_SUITABLE_GENERATOR: () => DH_NOT_SUITABLE_GENERATOR,
  DH_UNABLE_TO_CHECK_GENERATOR: () => DH_UNABLE_TO_CHECK_GENERATOR,
  E2BIG: () => E2BIG,
  EACCES: () => EACCES,
  EADDRINUSE: () => EADDRINUSE,
  EADDRNOTAVAIL: () => EADDRNOTAVAIL,
  EAFNOSUPPORT: () => EAFNOSUPPORT,
  EAGAIN: () => EAGAIN,
  EALREADY: () => EALREADY,
  EBADF: () => EBADF,
  EBADMSG: () => EBADMSG,
  EBUSY: () => EBUSY,
  ECANCELED: () => ECANCELED,
  ECHILD: () => ECHILD,
  ECONNABORTED: () => ECONNABORTED,
  ECONNREFUSED: () => ECONNREFUSED,
  ECONNRESET: () => ECONNRESET,
  EDEADLK: () => EDEADLK,
  EDESTADDRREQ: () => EDESTADDRREQ,
  EDOM: () => EDOM,
  EDQUOT: () => EDQUOT,
  EEXIST: () => EEXIST,
  EFAULT: () => EFAULT,
  EFBIG: () => EFBIG,
  EHOSTUNREACH: () => EHOSTUNREACH,
  EIDRM: () => EIDRM,
  EILSEQ: () => EILSEQ,
  EINPROGRESS: () => EINPROGRESS,
  EINTR: () => EINTR,
  EINVAL: () => EINVAL,
  EIO: () => EIO,
  EISCONN: () => EISCONN,
  EISDIR: () => EISDIR,
  ELOOP: () => ELOOP,
  EMFILE: () => EMFILE,
  EMLINK: () => EMLINK,
  EMSGSIZE: () => EMSGSIZE,
  EMULTIHOP: () => EMULTIHOP,
  ENAMETOOLONG: () => ENAMETOOLONG,
  ENETDOWN: () => ENETDOWN,
  ENETRESET: () => ENETRESET,
  ENETUNREACH: () => ENETUNREACH,
  ENFILE: () => ENFILE,
  ENGINE_METHOD_ALL: () => ENGINE_METHOD_ALL,
  ENGINE_METHOD_CIPHERS: () => ENGINE_METHOD_CIPHERS,
  ENGINE_METHOD_DH: () => ENGINE_METHOD_DH,
  ENGINE_METHOD_DIGESTS: () => ENGINE_METHOD_DIGESTS,
  ENGINE_METHOD_DSA: () => ENGINE_METHOD_DSA,
  ENGINE_METHOD_ECDH: () => ENGINE_METHOD_ECDH,
  ENGINE_METHOD_ECDSA: () => ENGINE_METHOD_ECDSA,
  ENGINE_METHOD_NONE: () => ENGINE_METHOD_NONE,
  ENGINE_METHOD_PKEY_ASN1_METHS: () => ENGINE_METHOD_PKEY_ASN1_METHS,
  ENGINE_METHOD_PKEY_METHS: () => ENGINE_METHOD_PKEY_METHS,
  ENGINE_METHOD_RAND: () => ENGINE_METHOD_RAND,
  ENGINE_METHOD_STORE: () => ENGINE_METHOD_STORE,
  ENOBUFS: () => ENOBUFS,
  ENODATA: () => ENODATA,
  ENODEV: () => ENODEV,
  ENOENT: () => ENOENT,
  ENOEXEC: () => ENOEXEC,
  ENOLCK: () => ENOLCK,
  ENOLINK: () => ENOLINK,
  ENOMEM: () => ENOMEM,
  ENOMSG: () => ENOMSG,
  ENOPROTOOPT: () => ENOPROTOOPT,
  ENOSPC: () => ENOSPC,
  ENOSR: () => ENOSR,
  ENOSTR: () => ENOSTR,
  ENOSYS: () => ENOSYS,
  ENOTCONN: () => ENOTCONN,
  ENOTDIR: () => ENOTDIR,
  ENOTEMPTY: () => ENOTEMPTY,
  ENOTSOCK: () => ENOTSOCK,
  ENOTSUP: () => ENOTSUP,
  ENOTTY: () => ENOTTY,
  ENXIO: () => ENXIO,
  EOPNOTSUPP: () => EOPNOTSUPP,
  EOVERFLOW: () => EOVERFLOW,
  EPERM: () => EPERM,
  EPIPE: () => EPIPE,
  EPROTO: () => EPROTO,
  EPROTONOSUPPORT: () => EPROTONOSUPPORT,
  EPROTOTYPE: () => EPROTOTYPE,
  ERANGE: () => ERANGE,
  EROFS: () => EROFS,
  ESPIPE: () => ESPIPE,
  ESRCH: () => ESRCH,
  ESTALE: () => ESTALE,
  ETIME: () => ETIME,
  ETIMEDOUT: () => ETIMEDOUT,
  ETXTBSY: () => ETXTBSY,
  EWOULDBLOCK: () => EWOULDBLOCK,
  EXDEV: () => EXDEV,
  F_OK: () => F_OK2,
  NPN_ENABLED: () => NPN_ENABLED,
  O_APPEND: () => O_APPEND,
  O_CREAT: () => O_CREAT,
  O_DIRECTORY: () => O_DIRECTORY,
  O_EXCL: () => O_EXCL,
  O_NOCTTY: () => O_NOCTTY,
  O_NOFOLLOW: () => O_NOFOLLOW,
  O_NONBLOCK: () => O_NONBLOCK,
  O_RDONLY: () => O_RDONLY,
  O_RDWR: () => O_RDWR,
  O_SYMLINK: () => O_SYMLINK,
  O_SYNC: () => O_SYNC,
  O_TRUNC: () => O_TRUNC,
  O_WRONLY: () => O_WRONLY,
  POINT_CONVERSION_COMPRESSED: () => POINT_CONVERSION_COMPRESSED,
  POINT_CONVERSION_HYBRID: () => POINT_CONVERSION_HYBRID,
  POINT_CONVERSION_UNCOMPRESSED: () => POINT_CONVERSION_UNCOMPRESSED,
  RSA_NO_PADDING: () => RSA_NO_PADDING,
  RSA_PKCS1_OAEP_PADDING: () => RSA_PKCS1_OAEP_PADDING,
  RSA_PKCS1_PADDING: () => RSA_PKCS1_PADDING,
  RSA_PKCS1_PSS_PADDING: () => RSA_PKCS1_PSS_PADDING,
  RSA_SSLV23_PADDING: () => RSA_SSLV23_PADDING,
  RSA_X931_PADDING: () => RSA_X931_PADDING,
  R_OK: () => R_OK2,
  SIGABRT: () => SIGABRT,
  SIGALRM: () => SIGALRM,
  SIGBUS: () => SIGBUS,
  SIGCHLD: () => SIGCHLD,
  SIGCONT: () => SIGCONT,
  SIGFPE: () => SIGFPE,
  SIGHUP: () => SIGHUP,
  SIGILL: () => SIGILL,
  SIGINT: () => SIGINT,
  SIGIO: () => SIGIO,
  SIGIOT: () => SIGIOT,
  SIGKILL: () => SIGKILL,
  SIGPIPE: () => SIGPIPE,
  SIGPROF: () => SIGPROF,
  SIGQUIT: () => SIGQUIT,
  SIGSEGV: () => SIGSEGV,
  SIGSTOP: () => SIGSTOP,
  SIGSYS: () => SIGSYS,
  SIGTERM: () => SIGTERM,
  SIGTRAP: () => SIGTRAP,
  SIGTSTP: () => SIGTSTP,
  SIGTTIN: () => SIGTTIN,
  SIGTTOU: () => SIGTTOU,
  SIGURG: () => SIGURG,
  SIGUSR1: () => SIGUSR1,
  SIGUSR2: () => SIGUSR2,
  SIGVTALRM: () => SIGVTALRM,
  SIGWINCH: () => SIGWINCH,
  SIGXCPU: () => SIGXCPU,
  SIGXFSZ: () => SIGXFSZ,
  SSL_OP_ALL: () => SSL_OP_ALL,
  SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: () => SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION,
  SSL_OP_CIPHER_SERVER_PREFERENCE: () => SSL_OP_CIPHER_SERVER_PREFERENCE,
  SSL_OP_CISCO_ANYCONNECT: () => SSL_OP_CISCO_ANYCONNECT,
  SSL_OP_COOKIE_EXCHANGE: () => SSL_OP_COOKIE_EXCHANGE,
  SSL_OP_CRYPTOPRO_TLSEXT_BUG: () => SSL_OP_CRYPTOPRO_TLSEXT_BUG,
  SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: () => SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS,
  SSL_OP_EPHEMERAL_RSA: () => SSL_OP_EPHEMERAL_RSA,
  SSL_OP_LEGACY_SERVER_CONNECT: () => SSL_OP_LEGACY_SERVER_CONNECT,
  SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: () => SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER,
  SSL_OP_MICROSOFT_SESS_ID_BUG: () => SSL_OP_MICROSOFT_SESS_ID_BUG,
  SSL_OP_MSIE_SSLV2_RSA_PADDING: () => SSL_OP_MSIE_SSLV2_RSA_PADDING,
  SSL_OP_NETSCAPE_CA_DN_BUG: () => SSL_OP_NETSCAPE_CA_DN_BUG,
  SSL_OP_NETSCAPE_CHALLENGE_BUG: () => SSL_OP_NETSCAPE_CHALLENGE_BUG,
  SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: () => SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG,
  SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: () => SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG,
  SSL_OP_NO_COMPRESSION: () => SSL_OP_NO_COMPRESSION,
  SSL_OP_NO_QUERY_MTU: () => SSL_OP_NO_QUERY_MTU,
  SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: () => SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION,
  SSL_OP_NO_SSLv2: () => SSL_OP_NO_SSLv2,
  SSL_OP_NO_SSLv3: () => SSL_OP_NO_SSLv3,
  SSL_OP_NO_TICKET: () => SSL_OP_NO_TICKET,
  SSL_OP_NO_TLSv1: () => SSL_OP_NO_TLSv1,
  SSL_OP_NO_TLSv1_1: () => SSL_OP_NO_TLSv1_1,
  SSL_OP_NO_TLSv1_2: () => SSL_OP_NO_TLSv1_2,
  SSL_OP_PKCS1_CHECK_1: () => SSL_OP_PKCS1_CHECK_1,
  SSL_OP_PKCS1_CHECK_2: () => SSL_OP_PKCS1_CHECK_2,
  SSL_OP_SINGLE_DH_USE: () => SSL_OP_SINGLE_DH_USE,
  SSL_OP_SINGLE_ECDH_USE: () => SSL_OP_SINGLE_ECDH_USE,
  SSL_OP_SSLEAY_080_CLIENT_DH_BUG: () => SSL_OP_SSLEAY_080_CLIENT_DH_BUG,
  SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: () => SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG,
  SSL_OP_TLS_BLOCK_PADDING_BUG: () => SSL_OP_TLS_BLOCK_PADDING_BUG,
  SSL_OP_TLS_D5_BUG: () => SSL_OP_TLS_D5_BUG,
  SSL_OP_TLS_ROLLBACK_BUG: () => SSL_OP_TLS_ROLLBACK_BUG,
  S_IFBLK: () => S_IFBLK,
  S_IFCHR: () => S_IFCHR,
  S_IFDIR: () => S_IFDIR,
  S_IFIFO: () => S_IFIFO,
  S_IFLNK: () => S_IFLNK,
  S_IFMT: () => S_IFMT,
  S_IFREG: () => S_IFREG,
  S_IFSOCK: () => S_IFSOCK,
  S_IRGRP: () => S_IRGRP,
  S_IROTH: () => S_IROTH,
  S_IRUSR: () => S_IRUSR,
  S_IRWXG: () => S_IRWXG,
  S_IRWXO: () => S_IRWXO,
  S_IRWXU: () => S_IRWXU,
  S_IWGRP: () => S_IWGRP,
  S_IWOTH: () => S_IWOTH,
  S_IWUSR: () => S_IWUSR,
  S_IXGRP: () => S_IXGRP,
  S_IXOTH: () => S_IXOTH,
  S_IXUSR: () => S_IXUSR,
  UV_UDP_REUSEADDR: () => UV_UDP_REUSEADDR,
  W_OK: () => W_OK2,
  X_OK: () => X_OK2
});
var init_constants2 = __esm({
  "node-modules-polyfills-commonjs:constants"() {
    init_constants();
  }
});

// node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js"(exports10, module2) {
    var constants4 = (init_constants2(), __toCommonJS(constants_exports));
    var origCwd = process.cwd;
    var cwd = null;
    var platform2 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d10) {
        cwd = null;
        chdir.call(process, d10);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs2) {
      if (constants4.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs2);
      }
      if (!fs2.lutimes) {
        patchLutimes(fs2);
      }
      fs2.chown = chownFix(fs2.chown);
      fs2.fchown = chownFix(fs2.fchown);
      fs2.lchown = chownFix(fs2.lchown);
      fs2.chmod = chmodFix(fs2.chmod);
      fs2.fchmod = chmodFix(fs2.fchmod);
      fs2.lchmod = chmodFix(fs2.lchmod);
      fs2.chownSync = chownFixSync(fs2.chownSync);
      fs2.fchownSync = chownFixSync(fs2.fchownSync);
      fs2.lchownSync = chownFixSync(fs2.lchownSync);
      fs2.chmodSync = chmodFixSync(fs2.chmodSync);
      fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
      fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
      fs2.stat = statFix(fs2.stat);
      fs2.fstat = statFix(fs2.fstat);
      fs2.lstat = statFix(fs2.lstat);
      fs2.statSync = statFixSync(fs2.statSync);
      fs2.fstatSync = statFixSync(fs2.fstatSync);
      fs2.lstatSync = statFixSync(fs2.lstatSync);
      if (fs2.chmod && !fs2.lchmod) {
        fs2.lchmod = function(path3, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchmodSync = function() {
        };
      }
      if (fs2.chown && !fs2.lchown) {
        fs2.lchown = function(path3, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchownSync = function() {
        };
      }
      if (platform2 === "win32") {
        fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
          function rename2(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs2.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename2, fs$rename);
          return rename2;
        }(fs2.rename);
      }
      fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
        function read2(fd, buffer4, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _8, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs2, fd, buffer4, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs2, fd, buffer4, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read2, fs$read);
        return read2;
      }(fs2.read);
      fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : function(fs$readSync) {
        return function(fd, buffer4, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs2, fd, buffer4, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs2.readSync);
      function patchLchmod(fs3) {
        fs3.lchmod = function(path3, mode, callback) {
          fs3.open(
            path3,
            constants4.O_WRONLY | constants4.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs3.fchmod(fd, mode, function(err2) {
                fs3.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs3.lchmodSync = function(path3, mode) {
          var fd = fs3.openSync(path3, constants4.O_WRONLY | constants4.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs3.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs3.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs3.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs3) {
        if (constants4.hasOwnProperty("O_SYMLINK") && fs3.futimes) {
          fs3.lutimes = function(path3, at, mt, cb) {
            fs3.open(path3, constants4.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs3.futimes(fd, at, mt, function(er2) {
                fs3.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs3.lutimesSync = function(path3, at, mt) {
            var fd = fs3.openSync(path3, constants4.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs3.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs3.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs3.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs3.futimes) {
          fs3.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs3.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs2, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs2, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs2, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs2, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node-modules-polyfills:stream
function o9() {
  o9.init.call(this);
}
function u8(e53) {
  if ("function" != typeof e53)
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e53);
}
function f8(e53) {
  return void 0 === e53._maxListeners ? o9.defaultMaxListeners : e53._maxListeners;
}
function v6(e53, t53, n53, r53) {
  var i53, o53, s53, v43;
  if (u8(n53), void 0 === (o53 = e53._events) ? (o53 = e53._events = /* @__PURE__ */ Object.create(null), e53._eventsCount = 0) : (void 0 !== o53.newListener && (e53.emit("newListener", t53, n53.listener ? n53.listener : n53), o53 = e53._events), s53 = o53[t53]), void 0 === s53)
    s53 = o53[t53] = n53, ++e53._eventsCount;
  else if ("function" == typeof s53 ? s53 = o53[t53] = r53 ? [n53, s53] : [s53, n53] : r53 ? s53.unshift(n53) : s53.push(n53), (i53 = f8(e53)) > 0 && s53.length > i53 && !s53.warned) {
    s53.warned = true;
    var a53 = new Error("Possible EventEmitter memory leak detected. " + s53.length + " " + String(t53) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a53.name = "MaxListenersExceededWarning", a53.emitter = e53, a53.type = t53, a53.count = s53.length, v43 = a53, console && console.warn && console.warn(v43);
  }
  return e53;
}
function a8() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function l8(e53, t53, n53) {
  var r53 = { fired: false, wrapFn: void 0, target: e53, type: t53, listener: n53 }, i53 = a8.bind(r53);
  return i53.listener = n53, r53.wrapFn = i53, i53;
}
function h8(e53, t53, n53) {
  var r53 = e53._events;
  if (void 0 === r53)
    return [];
  var i53 = r53[t53];
  return void 0 === i53 ? [] : "function" == typeof i53 ? n53 ? [i53.listener || i53] : [i53] : n53 ? function(e63) {
    for (var t63 = new Array(e63.length), n63 = 0; n63 < t63.length; ++n63)
      t63[n63] = e63[n63].listener || e63[n63];
    return t63;
  }(i53) : c8(i53, i53.length);
}
function p8(e53) {
  var t53 = this._events;
  if (void 0 !== t53) {
    var n53 = t53[e53];
    if ("function" == typeof n53)
      return 1;
    if (void 0 !== n53)
      return n53.length;
  }
  return 0;
}
function c8(e53, t53) {
  for (var n53 = new Array(t53), r53 = 0; r53 < t53; ++r53)
    n53[r53] = e53[r53];
  return n53;
}
function i22() {
  throw new Error("setTimeout has not been defined");
}
function u22() {
  throw new Error("clearTimeout has not been defined");
}
function c22(e53) {
  if (t22 === setTimeout)
    return setTimeout(e53, 0);
  if ((t22 === i22 || !t22) && setTimeout)
    return t22 = setTimeout, setTimeout(e53, 0);
  try {
    return t22(e53, 0);
  } catch (n53) {
    try {
      return t22.call(null, e53, 0);
    } catch (n63) {
      return t22.call(this || r22, e53, 0);
    }
  }
}
function h22() {
  f22 && l22 && (f22 = false, l22.length ? s22 = l22.concat(s22) : a22 = -1, s22.length && d6());
}
function d6() {
  if (!f22) {
    var e53 = c22(h22);
    f22 = true;
    for (var t53 = s22.length; t53; ) {
      for (l22 = s22, s22 = []; ++a22 < t53; )
        l22 && l22[a22].run();
      a22 = -1, t53 = s22.length;
    }
    l22 = null, f22 = false, function(e63) {
      if (n22 === clearTimeout)
        return clearTimeout(e63);
      if ((n22 === u22 || !n22) && clearTimeout)
        return n22 = clearTimeout, clearTimeout(e63);
      try {
        n22(e63);
      } catch (t63) {
        try {
          return n22.call(null, e63);
        } catch (t72) {
          return n22.call(this || r22, e63);
        }
      }
    }(e53);
  }
}
function m6(e53, t53) {
  (this || r22).fun = e53, (this || r22).array = t53;
}
function p22() {
}
function c$14(e53) {
  return e53.call.bind(e53);
}
function O5(e53, t53) {
  if ("object" != typeof e53)
    return false;
  try {
    return t53(e53), true;
  } catch (e63) {
    return false;
  }
}
function S4(e53) {
  return l$14 && y22 ? void 0 !== b5(e53) : B4(e53) || k4(e53) || E4(e53) || D4(e53) || U4(e53) || P4(e53) || x4(e53) || I4(e53) || M4(e53) || z4(e53) || F4(e53);
}
function B4(e53) {
  return l$14 && y22 ? "Uint8Array" === b5(e53) : "[object Uint8Array]" === m22(e53) || u$14(e53) && void 0 !== e53.buffer;
}
function k4(e53) {
  return l$14 && y22 ? "Uint8ClampedArray" === b5(e53) : "[object Uint8ClampedArray]" === m22(e53);
}
function E4(e53) {
  return l$14 && y22 ? "Uint16Array" === b5(e53) : "[object Uint16Array]" === m22(e53);
}
function D4(e53) {
  return l$14 && y22 ? "Uint32Array" === b5(e53) : "[object Uint32Array]" === m22(e53);
}
function U4(e53) {
  return l$14 && y22 ? "Int8Array" === b5(e53) : "[object Int8Array]" === m22(e53);
}
function P4(e53) {
  return l$14 && y22 ? "Int16Array" === b5(e53) : "[object Int16Array]" === m22(e53);
}
function x4(e53) {
  return l$14 && y22 ? "Int32Array" === b5(e53) : "[object Int32Array]" === m22(e53);
}
function I4(e53) {
  return l$14 && y22 ? "Float32Array" === b5(e53) : "[object Float32Array]" === m22(e53);
}
function M4(e53) {
  return l$14 && y22 ? "Float64Array" === b5(e53) : "[object Float64Array]" === m22(e53);
}
function z4(e53) {
  return l$14 && y22 ? "BigInt64Array" === b5(e53) : "[object BigInt64Array]" === m22(e53);
}
function F4(e53) {
  return l$14 && y22 ? "BigUint64Array" === b5(e53) : "[object BigUint64Array]" === m22(e53);
}
function T22(e53) {
  return "[object Map]" === m22(e53);
}
function N4(e53) {
  return "[object Set]" === m22(e53);
}
function W3(e53) {
  return "[object WeakMap]" === m22(e53);
}
function $3(e53) {
  return "[object WeakSet]" === m22(e53);
}
function C4(e53) {
  return "[object ArrayBuffer]" === m22(e53);
}
function V3(e53) {
  return "undefined" != typeof ArrayBuffer && (C4.working ? C4(e53) : e53 instanceof ArrayBuffer);
}
function G3(e53) {
  return "[object DataView]" === m22(e53);
}
function R4(e53) {
  return "undefined" != typeof DataView && (G3.working ? G3(e53) : e53 instanceof DataView);
}
function J3(e53) {
  return "[object SharedArrayBuffer]" === m22(e53);
}
function _4(e53) {
  return "undefined" != typeof SharedArrayBuffer && (J3.working ? J3(e53) : e53 instanceof SharedArrayBuffer);
}
function H3(e53) {
  return O5(e53, h32);
}
function Z3(e53) {
  return O5(e53, j4);
}
function q3(e53) {
  return O5(e53, A4);
}
function K3(e53) {
  return s32 && O5(e53, w4);
}
function L4(e53) {
  return p32 && O5(e53, v22);
}
function oe2(e53, t53) {
  var r53 = { seen: [], stylize: fe2 };
  return arguments.length >= 3 && (r53.depth = arguments[2]), arguments.length >= 4 && (r53.colors = arguments[3]), ye2(t53) ? r53.showHidden = t53 : t53 && X3._extend(r53, t53), be2(r53.showHidden) && (r53.showHidden = false), be2(r53.depth) && (r53.depth = 2), be2(r53.colors) && (r53.colors = false), be2(r53.customInspect) && (r53.customInspect = true), r53.colors && (r53.stylize = ue2), ae2(r53, e53, r53.depth);
}
function ue2(e53, t53) {
  var r53 = oe2.styles[t53];
  return r53 ? "\x1B[" + oe2.colors[r53][0] + "m" + e53 + "\x1B[" + oe2.colors[r53][1] + "m" : e53;
}
function fe2(e53, t53) {
  return e53;
}
function ae2(e53, t53, r53) {
  if (e53.customInspect && t53 && we2(t53.inspect) && t53.inspect !== X3.inspect && (!t53.constructor || t53.constructor.prototype !== t53)) {
    var n53 = t53.inspect(r53, e53);
    return ge2(n53) || (n53 = ae2(e53, n53, r53)), n53;
  }
  var i53 = function(e63, t63) {
    if (be2(t63))
      return e63.stylize("undefined", "undefined");
    if (ge2(t63)) {
      var r63 = "'" + JSON.stringify(t63).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return e63.stylize(r63, "string");
    }
    if (de2(t63))
      return e63.stylize("" + t63, "number");
    if (ye2(t63))
      return e63.stylize("" + t63, "boolean");
    if (le2(t63))
      return e63.stylize("null", "null");
  }(e53, t53);
  if (i53)
    return i53;
  var o53 = Object.keys(t53), u53 = function(e63) {
    var t63 = {};
    return e63.forEach(function(e73, r63) {
      t63[e73] = true;
    }), t63;
  }(o53);
  if (e53.showHidden && (o53 = Object.getOwnPropertyNames(t53)), Ae2(t53) && (o53.indexOf("message") >= 0 || o53.indexOf("description") >= 0))
    return ce2(t53);
  if (0 === o53.length) {
    if (we2(t53)) {
      var f53 = t53.name ? ": " + t53.name : "";
      return e53.stylize("[Function" + f53 + "]", "special");
    }
    if (me2(t53))
      return e53.stylize(RegExp.prototype.toString.call(t53), "regexp");
    if (je2(t53))
      return e53.stylize(Date.prototype.toString.call(t53), "date");
    if (Ae2(t53))
      return ce2(t53);
  }
  var a53, c53 = "", s53 = false, p53 = ["{", "}"];
  (pe2(t53) && (s53 = true, p53 = ["[", "]"]), we2(t53)) && (c53 = " [Function" + (t53.name ? ": " + t53.name : "") + "]");
  return me2(t53) && (c53 = " " + RegExp.prototype.toString.call(t53)), je2(t53) && (c53 = " " + Date.prototype.toUTCString.call(t53)), Ae2(t53) && (c53 = " " + ce2(t53)), 0 !== o53.length || s53 && 0 != t53.length ? r53 < 0 ? me2(t53) ? e53.stylize(RegExp.prototype.toString.call(t53), "regexp") : e53.stylize("[Object]", "special") : (e53.seen.push(t53), a53 = s53 ? function(e63, t63, r63, n63, i63) {
    for (var o63 = [], u63 = 0, f63 = t63.length; u63 < f63; ++u63)
      ke2(t63, String(u63)) ? o63.push(se2(e63, t63, r63, n63, String(u63), true)) : o63.push("");
    return i63.forEach(function(i72) {
      i72.match(/^\d+$/) || o63.push(se2(e63, t63, r63, n63, i72, true));
    }), o63;
  }(e53, t53, r53, u53, o53) : o53.map(function(n63) {
    return se2(e53, t53, r53, u53, n63, s53);
  }), e53.seen.pop(), function(e63, t63, r63) {
    var n63 = 0;
    if (e63.reduce(function(e73, t72) {
      return n63++, t72.indexOf("\n") >= 0 && n63++, e73 + t72.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0) > 60)
      return r63[0] + ("" === t63 ? "" : t63 + "\n ") + " " + e63.join(",\n  ") + " " + r63[1];
    return r63[0] + t63 + " " + e63.join(", ") + " " + r63[1];
  }(a53, c53, p53)) : p53[0] + c53 + p53[1];
}
function ce2(e53) {
  return "[" + Error.prototype.toString.call(e53) + "]";
}
function se2(e53, t53, r53, n53, i53, o53) {
  var u53, f53, a53;
  if ((a53 = Object.getOwnPropertyDescriptor(t53, i53) || { value: t53[i53] }).get ? f53 = a53.set ? e53.stylize("[Getter/Setter]", "special") : e53.stylize("[Getter]", "special") : a53.set && (f53 = e53.stylize("[Setter]", "special")), ke2(n53, i53) || (u53 = "[" + i53 + "]"), f53 || (e53.seen.indexOf(a53.value) < 0 ? (f53 = le2(r53) ? ae2(e53, a53.value, null) : ae2(e53, a53.value, r53 - 1)).indexOf("\n") > -1 && (f53 = o53 ? f53.split("\n").map(function(e63) {
    return "  " + e63;
  }).join("\n").substr(2) : "\n" + f53.split("\n").map(function(e63) {
    return "   " + e63;
  }).join("\n")) : f53 = e53.stylize("[Circular]", "special")), be2(u53)) {
    if (o53 && i53.match(/^\d+$/))
      return f53;
    (u53 = JSON.stringify("" + i53)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u53 = u53.substr(1, u53.length - 2), u53 = e53.stylize(u53, "name")) : (u53 = u53.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u53 = e53.stylize(u53, "string"));
  }
  return u53 + ": " + f53;
}
function pe2(e53) {
  return Array.isArray(e53);
}
function ye2(e53) {
  return "boolean" == typeof e53;
}
function le2(e53) {
  return null === e53;
}
function de2(e53) {
  return "number" == typeof e53;
}
function ge2(e53) {
  return "string" == typeof e53;
}
function be2(e53) {
  return void 0 === e53;
}
function me2(e53) {
  return he2(e53) && "[object RegExp]" === ve2(e53);
}
function he2(e53) {
  return "object" == typeof e53 && null !== e53;
}
function je2(e53) {
  return he2(e53) && "[object Date]" === ve2(e53);
}
function Ae2(e53) {
  return he2(e53) && ("[object Error]" === ve2(e53) || e53 instanceof Error);
}
function we2(e53) {
  return "function" == typeof e53;
}
function ve2(e53) {
  return Object.prototype.toString.call(e53);
}
function Oe2(e53) {
  return e53 < 10 ? "0" + e53.toString(10) : e53.toString(10);
}
function Be2() {
  var e53 = /* @__PURE__ */ new Date(), t53 = [Oe2(e53.getHours()), Oe2(e53.getMinutes()), Oe2(e53.getSeconds())].join(":");
  return [e53.getDate(), Se2[e53.getMonth()], t53].join(" ");
}
function ke2(e53, t53) {
  return Object.prototype.hasOwnProperty.call(e53, t53);
}
function De2(e53, t53) {
  if (!e53) {
    var r53 = new Error("Promise was rejected with a falsy value");
    r53.reason = e53, e53 = r53;
  }
  return t53(e53);
}
function dew8() {
  if (_dewExec8)
    return exports8;
  _dewExec8 = true;
  var process22 = exports8 = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e53) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e53) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e53) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e63) {
        return cachedSetTimeout.call(this || _global5, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e53) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e63) {
        return cachedClearTimeout.call(this || _global5, marker);
      }
    }
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  process22.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i53 = 1; i53 < arguments.length; i53++) {
        args[i53 - 1] = arguments[i53];
      }
    }
    queue.push(new Item2(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  };
  function Item2(fun, array) {
    (this || _global5).fun = fun;
    (this || _global5).array = array;
  }
  Item2.prototype.run = function() {
    (this || _global5).fun.apply(null, (this || _global5).array);
  };
  process22.title = "browser";
  process22.browser = true;
  process22.env = {};
  process22.argv = [];
  process22.version = "";
  process22.versions = {};
  function noop() {
  }
  process22.on = noop;
  process22.addListener = noop;
  process22.once = noop;
  process22.off = noop;
  process22.removeListener = noop;
  process22.removeAllListeners = noop;
  process22.emit = noop;
  process22.prependListener = noop;
  process22.prependOnceListener = noop;
  process22.listeners = function(name2) {
    return [];
  };
  process22.binding = function(name2) {
    throw new Error("process.binding is not supported");
  };
  process22.cwd = function() {
    return "/";
  };
  process22.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process22.umask = function() {
    return 0;
  };
  return exports8;
}
function u$23(r53) {
  var t53 = r53.length;
  if (t53 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var e53 = r53.indexOf("=");
  return -1 === e53 && (e53 = t53), [e53, e53 === t53 ? 0 : 4 - e53 % 4];
}
function c$122(r53, e53, n53) {
  for (var o53, a53, h53 = [], u53 = e53; u53 < n53; u53 += 3)
    o53 = (r53[u53] << 16 & 16711680) + (r53[u53 + 1] << 8 & 65280) + (255 & r53[u53 + 2]), h53.push(t$122[(a53 = o53) >> 18 & 63] + t$122[a53 >> 12 & 63] + t$122[a53 >> 6 & 63] + t$122[63 & a53]);
  return h53.join("");
}
function f$23(t53) {
  if (t53 > 2147483647)
    throw new RangeError('The value "' + t53 + '" is invalid for option "size"');
  var r53 = new Uint8Array(t53);
  return Object.setPrototypeOf(r53, u$1$12.prototype), r53;
}
function u$1$12(t53, r53, e53) {
  if ("number" == typeof t53) {
    if ("string" == typeof r53)
      throw new TypeError('The "string" argument must be of type string. Received type number');
    return a$23(t53);
  }
  return s$13(t53, r53, e53);
}
function s$13(t53, r53, e53) {
  if ("string" == typeof t53)
    return function(t63, r63) {
      "string" == typeof r63 && "" !== r63 || (r63 = "utf8");
      if (!u$1$12.isEncoding(r63))
        throw new TypeError("Unknown encoding: " + r63);
      var e63 = 0 | y32(t63, r63), n63 = f$23(e63), i63 = n63.write(t63, r63);
      i63 !== e63 && (n63 = n63.slice(0, i63));
      return n63;
    }(t53, r53);
  if (ArrayBuffer.isView(t53))
    return p42(t53);
  if (null == t53)
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t53);
  if (F22(t53, ArrayBuffer) || t53 && F22(t53.buffer, ArrayBuffer))
    return c$1$12(t53, r53, e53);
  if ("undefined" != typeof SharedArrayBuffer && (F22(t53, SharedArrayBuffer) || t53 && F22(t53.buffer, SharedArrayBuffer)))
    return c$1$12(t53, r53, e53);
  if ("number" == typeof t53)
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  var n53 = t53.valueOf && t53.valueOf();
  if (null != n53 && n53 !== t53)
    return u$1$12.from(n53, r53, e53);
  var i53 = function(t63) {
    if (u$1$12.isBuffer(t63)) {
      var r63 = 0 | l$122(t63.length), e63 = f$23(r63);
      return 0 === e63.length || t63.copy(e63, 0, 0, r63), e63;
    }
    if (void 0 !== t63.length)
      return "number" != typeof t63.length || N22(t63.length) ? f$23(0) : p42(t63);
    if ("Buffer" === t63.type && Array.isArray(t63.data))
      return p42(t63.data);
  }(t53);
  if (i53)
    return i53;
  if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t53[Symbol.toPrimitive])
    return u$1$12.from(t53[Symbol.toPrimitive]("string"), r53, e53);
  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t53);
}
function h$1$12(t53) {
  if ("number" != typeof t53)
    throw new TypeError('"size" argument must be of type number');
  if (t53 < 0)
    throw new RangeError('The value "' + t53 + '" is invalid for option "size"');
}
function a$23(t53) {
  return h$1$12(t53), f$23(t53 < 0 ? 0 : 0 | l$122(t53));
}
function p42(t53) {
  for (var r53 = t53.length < 0 ? 0 : 0 | l$122(t53.length), e53 = f$23(r53), n53 = 0; n53 < r53; n53 += 1)
    e53[n53] = 255 & t53[n53];
  return e53;
}
function c$1$12(t53, r53, e53) {
  if (r53 < 0 || t53.byteLength < r53)
    throw new RangeError('"offset" is outside of buffer bounds');
  if (t53.byteLength < r53 + (e53 || 0))
    throw new RangeError('"length" is outside of buffer bounds');
  var n53;
  return n53 = void 0 === r53 && void 0 === e53 ? new Uint8Array(t53) : void 0 === e53 ? new Uint8Array(t53, r53) : new Uint8Array(t53, r53, e53), Object.setPrototypeOf(n53, u$1$12.prototype), n53;
}
function l$122(t53) {
  if (t53 >= 2147483647)
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
  return 0 | t53;
}
function y32(t53, r53) {
  if (u$1$12.isBuffer(t53))
    return t53.length;
  if (ArrayBuffer.isView(t53) || F22(t53, ArrayBuffer))
    return t53.byteLength;
  if ("string" != typeof t53)
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t53);
  var e53 = t53.length, n53 = arguments.length > 2 && true === arguments[2];
  if (!n53 && 0 === e53)
    return 0;
  for (var i53 = false; ; )
    switch (r53) {
      case "ascii":
      case "latin1":
      case "binary":
        return e53;
      case "utf8":
      case "utf-8":
        return _22(t53).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * e53;
      case "hex":
        return e53 >>> 1;
      case "base64":
        return z22(t53).length;
      default:
        if (i53)
          return n53 ? -1 : _22(t53).length;
        r53 = ("" + r53).toLowerCase(), i53 = true;
    }
}
function g22(t53, r53, e53) {
  var n53 = false;
  if ((void 0 === r53 || r53 < 0) && (r53 = 0), r53 > this.length)
    return "";
  if ((void 0 === e53 || e53 > this.length) && (e53 = this.length), e53 <= 0)
    return "";
  if ((e53 >>>= 0) <= (r53 >>>= 0))
    return "";
  for (t53 || (t53 = "utf8"); ; )
    switch (t53) {
      case "hex":
        return O22(this, r53, e53);
      case "utf8":
      case "utf-8":
        return I22(this, r53, e53);
      case "ascii":
        return S22(this, r53, e53);
      case "latin1":
      case "binary":
        return R22(this, r53, e53);
      case "base64":
        return T32(this, r53, e53);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return L22(this, r53, e53);
      default:
        if (n53)
          throw new TypeError("Unknown encoding: " + t53);
        t53 = (t53 + "").toLowerCase(), n53 = true;
    }
}
function w22(t53, r53, e53) {
  var n53 = t53[r53];
  t53[r53] = t53[e53], t53[e53] = n53;
}
function d32(t53, r53, e53, n53, i53) {
  if (0 === t53.length)
    return -1;
  if ("string" == typeof e53 ? (n53 = e53, e53 = 0) : e53 > 2147483647 ? e53 = 2147483647 : e53 < -2147483648 && (e53 = -2147483648), N22(e53 = +e53) && (e53 = i53 ? 0 : t53.length - 1), e53 < 0 && (e53 = t53.length + e53), e53 >= t53.length) {
    if (i53)
      return -1;
    e53 = t53.length - 1;
  } else if (e53 < 0) {
    if (!i53)
      return -1;
    e53 = 0;
  }
  if ("string" == typeof r53 && (r53 = u$1$12.from(r53, n53)), u$1$12.isBuffer(r53))
    return 0 === r53.length ? -1 : v32(t53, r53, e53, n53, i53);
  if ("number" == typeof r53)
    return r53 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i53 ? Uint8Array.prototype.indexOf.call(t53, r53, e53) : Uint8Array.prototype.lastIndexOf.call(t53, r53, e53) : v32(t53, [r53], e53, n53, i53);
  throw new TypeError("val must be string, number or Buffer");
}
function v32(t53, r53, e53, n53, i53) {
  var o53, f53 = 1, u53 = t53.length, s53 = r53.length;
  if (void 0 !== n53 && ("ucs2" === (n53 = String(n53).toLowerCase()) || "ucs-2" === n53 || "utf16le" === n53 || "utf-16le" === n53)) {
    if (t53.length < 2 || r53.length < 2)
      return -1;
    f53 = 2, u53 /= 2, s53 /= 2, e53 /= 2;
  }
  function h53(t63, r63) {
    return 1 === f53 ? t63[r63] : t63.readUInt16BE(r63 * f53);
  }
  if (i53) {
    var a53 = -1;
    for (o53 = e53; o53 < u53; o53++)
      if (h53(t53, o53) === h53(r53, -1 === a53 ? 0 : o53 - a53)) {
        if (-1 === a53 && (a53 = o53), o53 - a53 + 1 === s53)
          return a53 * f53;
      } else
        -1 !== a53 && (o53 -= o53 - a53), a53 = -1;
  } else
    for (e53 + s53 > u53 && (e53 = u53 - s53), o53 = e53; o53 >= 0; o53--) {
      for (var p53 = true, c53 = 0; c53 < s53; c53++)
        if (h53(t53, o53 + c53) !== h53(r53, c53)) {
          p53 = false;
          break;
        }
      if (p53)
        return o53;
    }
  return -1;
}
function b22(t53, r53, e53, n53) {
  e53 = Number(e53) || 0;
  var i53 = t53.length - e53;
  n53 ? (n53 = Number(n53)) > i53 && (n53 = i53) : n53 = i53;
  var o53 = r53.length;
  n53 > o53 / 2 && (n53 = o53 / 2);
  for (var f53 = 0; f53 < n53; ++f53) {
    var u53 = parseInt(r53.substr(2 * f53, 2), 16);
    if (N22(u53))
      return f53;
    t53[e53 + f53] = u53;
  }
  return f53;
}
function m32(t53, r53, e53, n53) {
  return D22(_22(r53, t53.length - e53), t53, e53, n53);
}
function E22(t53, r53, e53, n53) {
  return D22(function(t63) {
    for (var r63 = [], e63 = 0; e63 < t63.length; ++e63)
      r63.push(255 & t63.charCodeAt(e63));
    return r63;
  }(r53), t53, e53, n53);
}
function B22(t53, r53, e53, n53) {
  return E22(t53, r53, e53, n53);
}
function A22(t53, r53, e53, n53) {
  return D22(z22(r53), t53, e53, n53);
}
function U22(t53, r53, e53, n53) {
  return D22(function(t63, r63) {
    for (var e63, n63, i53, o53 = [], f53 = 0; f53 < t63.length && !((r63 -= 2) < 0); ++f53)
      e63 = t63.charCodeAt(f53), n63 = e63 >> 8, i53 = e63 % 256, o53.push(i53), o53.push(n63);
    return o53;
  }(r53, t53.length - e53), t53, e53, n53);
}
function T32(t53, r53, e53) {
  return 0 === r53 && e53 === t53.length ? n$1$12.fromByteArray(t53) : n$1$12.fromByteArray(t53.slice(r53, e53));
}
function I22(t53, r53, e53) {
  e53 = Math.min(t53.length, e53);
  for (var n53 = [], i53 = r53; i53 < e53; ) {
    var o53, f53, u53, s53, h53 = t53[i53], a53 = null, p53 = h53 > 239 ? 4 : h53 > 223 ? 3 : h53 > 191 ? 2 : 1;
    if (i53 + p53 <= e53)
      switch (p53) {
        case 1:
          h53 < 128 && (a53 = h53);
          break;
        case 2:
          128 == (192 & (o53 = t53[i53 + 1])) && (s53 = (31 & h53) << 6 | 63 & o53) > 127 && (a53 = s53);
          break;
        case 3:
          o53 = t53[i53 + 1], f53 = t53[i53 + 2], 128 == (192 & o53) && 128 == (192 & f53) && (s53 = (15 & h53) << 12 | (63 & o53) << 6 | 63 & f53) > 2047 && (s53 < 55296 || s53 > 57343) && (a53 = s53);
          break;
        case 4:
          o53 = t53[i53 + 1], f53 = t53[i53 + 2], u53 = t53[i53 + 3], 128 == (192 & o53) && 128 == (192 & f53) && 128 == (192 & u53) && (s53 = (15 & h53) << 18 | (63 & o53) << 12 | (63 & f53) << 6 | 63 & u53) > 65535 && s53 < 1114112 && (a53 = s53);
      }
    null === a53 ? (a53 = 65533, p53 = 1) : a53 > 65535 && (a53 -= 65536, n53.push(a53 >>> 10 & 1023 | 55296), a53 = 56320 | 1023 & a53), n53.push(a53), i53 += p53;
  }
  return function(t63) {
    var r63 = t63.length;
    if (r63 <= 4096)
      return String.fromCharCode.apply(String, t63);
    var e63 = "", n63 = 0;
    for (; n63 < r63; )
      e63 += String.fromCharCode.apply(String, t63.slice(n63, n63 += 4096));
    return e63;
  }(n53);
}
function S22(t53, r53, e53) {
  var n53 = "";
  e53 = Math.min(t53.length, e53);
  for (var i53 = r53; i53 < e53; ++i53)
    n53 += String.fromCharCode(127 & t53[i53]);
  return n53;
}
function R22(t53, r53, e53) {
  var n53 = "";
  e53 = Math.min(t53.length, e53);
  for (var i53 = r53; i53 < e53; ++i53)
    n53 += String.fromCharCode(t53[i53]);
  return n53;
}
function O22(t53, r53, e53) {
  var n53 = t53.length;
  (!r53 || r53 < 0) && (r53 = 0), (!e53 || e53 < 0 || e53 > n53) && (e53 = n53);
  for (var i53 = "", o53 = r53; o53 < e53; ++o53)
    i53 += Y22[t53[o53]];
  return i53;
}
function L22(t53, r53, e53) {
  for (var n53 = t53.slice(r53, e53), i53 = "", o53 = 0; o53 < n53.length; o53 += 2)
    i53 += String.fromCharCode(n53[o53] + 256 * n53[o53 + 1]);
  return i53;
}
function x22(t53, r53, e53) {
  if (t53 % 1 != 0 || t53 < 0)
    throw new RangeError("offset is not uint");
  if (t53 + r53 > e53)
    throw new RangeError("Trying to access beyond buffer length");
}
function C22(t53, r53, e53, n53, i53, o53) {
  if (!u$1$12.isBuffer(t53))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (r53 > i53 || r53 < o53)
    throw new RangeError('"value" argument is out of bounds');
  if (e53 + n53 > t53.length)
    throw new RangeError("Index out of range");
}
function P22(t53, r53, e53, n53, i53, o53) {
  if (e53 + n53 > t53.length)
    throw new RangeError("Index out of range");
  if (e53 < 0)
    throw new RangeError("Index out of range");
}
function k22(t53, r53, e53, n53, o53) {
  return r53 = +r53, e53 >>>= 0, o53 || P22(t53, 0, e53, 4), i$122.write(t53, r53, e53, n53, 23, 4), e53 + 4;
}
function M22(t53, r53, e53, n53, o53) {
  return r53 = +r53, e53 >>>= 0, o53 || P22(t53, 0, e53, 8), i$122.write(t53, r53, e53, n53, 52, 8), e53 + 8;
}
function _22(t53, r53) {
  var e53;
  r53 = r53 || 1 / 0;
  for (var n53 = t53.length, i53 = null, o53 = [], f53 = 0; f53 < n53; ++f53) {
    if ((e53 = t53.charCodeAt(f53)) > 55295 && e53 < 57344) {
      if (!i53) {
        if (e53 > 56319) {
          (r53 -= 3) > -1 && o53.push(239, 191, 189);
          continue;
        }
        if (f53 + 1 === n53) {
          (r53 -= 3) > -1 && o53.push(239, 191, 189);
          continue;
        }
        i53 = e53;
        continue;
      }
      if (e53 < 56320) {
        (r53 -= 3) > -1 && o53.push(239, 191, 189), i53 = e53;
        continue;
      }
      e53 = 65536 + (i53 - 55296 << 10 | e53 - 56320);
    } else
      i53 && (r53 -= 3) > -1 && o53.push(239, 191, 189);
    if (i53 = null, e53 < 128) {
      if ((r53 -= 1) < 0)
        break;
      o53.push(e53);
    } else if (e53 < 2048) {
      if ((r53 -= 2) < 0)
        break;
      o53.push(e53 >> 6 | 192, 63 & e53 | 128);
    } else if (e53 < 65536) {
      if ((r53 -= 3) < 0)
        break;
      o53.push(e53 >> 12 | 224, e53 >> 6 & 63 | 128, 63 & e53 | 128);
    } else {
      if (!(e53 < 1114112))
        throw new Error("Invalid code point");
      if ((r53 -= 4) < 0)
        break;
      o53.push(e53 >> 18 | 240, e53 >> 12 & 63 | 128, e53 >> 6 & 63 | 128, 63 & e53 | 128);
    }
  }
  return o53;
}
function z22(t53) {
  return n$1$12.toByteArray(function(t63) {
    if ((t63 = (t63 = t63.split("=")[0]).trim().replace(j22, "")).length < 2)
      return "";
    for (; t63.length % 4 != 0; )
      t63 += "=";
    return t63;
  }(t53));
}
function D22(t53, r53, e53, n53) {
  for (var i53 = 0; i53 < n53 && !(i53 + e53 >= r53.length || i53 >= t53.length); ++i53)
    r53[i53 + e53] = t53[i53];
  return i53;
}
function F22(t53, r53) {
  return t53 instanceof r53 || null != t53 && null != t53.constructor && null != t53.constructor.name && t53.constructor.name === r53.name;
}
function N22(t53) {
  return t53 != t53;
}
function t42(r53, e53) {
  for (var n53 in r53)
    e53[n53] = r53[n53];
}
function f42(r53, e53, n53) {
  return o42(r53, e53, n53);
}
function a42(t53) {
  var e53;
  switch (this.encoding = function(t63) {
    var e63 = function(t72) {
      if (!t72)
        return "utf8";
      for (var e73; ; )
        switch (t72) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return t72;
          default:
            if (e73)
              return;
            t72 = ("" + t72).toLowerCase(), e73 = true;
        }
    }(t63);
    if ("string" != typeof e63 && (s42.isEncoding === i42 || !i42(t63)))
      throw new Error("Unknown encoding: " + t63);
    return e63 || t63;
  }(t53), this.encoding) {
    case "utf16le":
      this.text = h42, this.end = l42, e53 = 4;
      break;
    case "utf8":
      this.fillLast = n$122, e53 = 4;
      break;
    case "base64":
      this.text = u$122, this.end = o$122, e53 = 3;
      break;
    default:
      return this.write = f$13, this.end = c42, void 0;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = s42.allocUnsafe(e53);
}
function r42(t53) {
  return t53 <= 127 ? 0 : t53 >> 5 == 6 ? 2 : t53 >> 4 == 14 ? 3 : t53 >> 3 == 30 ? 4 : t53 >> 6 == 2 ? -1 : -2;
}
function n$122(t53) {
  var e53 = this.lastTotal - this.lastNeed, s53 = function(t63, e63, s62) {
    if (128 != (192 & e63[0]))
      return t63.lastNeed = 0, "\uFFFD";
    if (t63.lastNeed > 1 && e63.length > 1) {
      if (128 != (192 & e63[1]))
        return t63.lastNeed = 1, "\uFFFD";
      if (t63.lastNeed > 2 && e63.length > 2 && 128 != (192 & e63[2]))
        return t63.lastNeed = 2, "\uFFFD";
    }
  }(this, t53);
  return void 0 !== s53 ? s53 : this.lastNeed <= t53.length ? (t53.copy(this.lastChar, e53, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t53.copy(this.lastChar, e53, 0, t53.length), this.lastNeed -= t53.length, void 0);
}
function h42(t53, e53) {
  if ((t53.length - e53) % 2 == 0) {
    var s53 = t53.toString("utf16le", e53);
    if (s53) {
      var i53 = s53.charCodeAt(s53.length - 1);
      if (i53 >= 55296 && i53 <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t53[t53.length - 2], this.lastChar[1] = t53[t53.length - 1], s53.slice(0, -1);
    }
    return s53;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t53[t53.length - 1], t53.toString("utf16le", e53, t53.length - 1);
}
function l42(t53) {
  var e53 = t53 && t53.length ? this.write(t53) : "";
  if (this.lastNeed) {
    var s53 = this.lastTotal - this.lastNeed;
    return e53 + this.lastChar.toString("utf16le", 0, s53);
  }
  return e53;
}
function u$122(t53, e53) {
  var s53 = (t53.length - e53) % 3;
  return 0 === s53 ? t53.toString("base64", e53) : (this.lastNeed = 3 - s53, this.lastTotal = 3, 1 === s53 ? this.lastChar[0] = t53[t53.length - 1] : (this.lastChar[0] = t53[t53.length - 2], this.lastChar[1] = t53[t53.length - 1]), t53.toString("base64", e53, t53.length - s53));
}
function o$122(t53) {
  var e53 = t53 && t53.length ? this.write(t53) : "";
  return this.lastNeed ? e53 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e53;
}
function f$13(t53) {
  return t53.toString(this.encoding);
}
function c42(t53) {
  return t53 && t53.length ? this.write(t53) : "";
}
function dew$2$12() {
  if (_dewExec$2$12)
    return exports$2$12;
  _dewExec$2$12 = true;
  exports$2$12.byteLength = byteLength;
  exports$2$12.toByteArray = toByteArray;
  exports$2$12.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i53 = 0, len = code.length; i53 < len; ++i53) {
    lookup[i53] = code[i53];
    revLookup[code.charCodeAt(i53)] = i53;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i63;
    for (i63 = 0; i63 < len2; i63 += 4) {
      tmp = revLookup[b64.charCodeAt(i63)] << 18 | revLookup[b64.charCodeAt(i63 + 1)] << 12 | revLookup[b64.charCodeAt(i63 + 2)] << 6 | revLookup[b64.charCodeAt(i63 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i63)] << 2 | revLookup[b64.charCodeAt(i63 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i63)] << 10 | revLookup[b64.charCodeAt(i63 + 1)] << 4 | revLookup[b64.charCodeAt(i63 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i63 = start; i63 < end; i63 += 3) {
      tmp = (uint8[i63] << 16 & 16711680) + (uint8[i63 + 1] << 8 & 65280) + (uint8[i63 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i63 = 0, len22 = len2 - extraBytes; i63 < len22; i63 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i63, i63 + maxChunkLength > len22 ? len22 : i63 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  return exports$2$12;
}
function dew$1$12() {
  if (_dewExec$1$12)
    return exports$1$12;
  _dewExec$1$12 = true;
  exports$1$12.read = function(buffer22, offset, isLE, mLen, nBytes) {
    var e53, m43;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i53 = isLE ? nBytes - 1 : 0;
    var d43 = isLE ? -1 : 1;
    var s53 = buffer22[offset + i53];
    i53 += d43;
    e53 = s53 & (1 << -nBits) - 1;
    s53 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e53 = e53 * 256 + buffer22[offset + i53], i53 += d43, nBits -= 8) {
    }
    m43 = e53 & (1 << -nBits) - 1;
    e53 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m43 = m43 * 256 + buffer22[offset + i53], i53 += d43, nBits -= 8) {
    }
    if (e53 === 0) {
      e53 = 1 - eBias;
    } else if (e53 === eMax) {
      return m43 ? NaN : (s53 ? -1 : 1) * Infinity;
    } else {
      m43 = m43 + Math.pow(2, mLen);
      e53 = e53 - eBias;
    }
    return (s53 ? -1 : 1) * m43 * Math.pow(2, e53 - mLen);
  };
  exports$1$12.write = function(buffer22, value, offset, isLE, mLen, nBytes) {
    var e53, m43, c53;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i53 = isLE ? 0 : nBytes - 1;
    var d43 = isLE ? 1 : -1;
    var s53 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m43 = isNaN(value) ? 1 : 0;
      e53 = eMax;
    } else {
      e53 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c53 = Math.pow(2, -e53)) < 1) {
        e53--;
        c53 *= 2;
      }
      if (e53 + eBias >= 1) {
        value += rt / c53;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c53 >= 2) {
        e53++;
        c53 /= 2;
      }
      if (e53 + eBias >= eMax) {
        m43 = 0;
        e53 = eMax;
      } else if (e53 + eBias >= 1) {
        m43 = (value * c53 - 1) * Math.pow(2, mLen);
        e53 = e53 + eBias;
      } else {
        m43 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e53 = 0;
      }
    }
    for (; mLen >= 8; buffer22[offset + i53] = m43 & 255, i53 += d43, m43 /= 256, mLen -= 8) {
    }
    e53 = e53 << mLen | m43;
    eLen += mLen;
    for (; eLen > 0; buffer22[offset + i53] = e53 & 255, i53 += d43, e53 /= 256, eLen -= 8) {
    }
    buffer22[offset + i53 - d43] |= s53 * 128;
  };
  return exports$1$12;
}
function dew$g2() {
  if (_dewExec$g2)
    return exports$g3;
  _dewExec$g2 = true;
  const base64 = dew$2$12();
  const ieee754 = dew$1$12();
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$g3.Buffer = Buffer3;
  exports$g3.SlowBuffer = SlowBuffer;
  exports$g3.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$g3.kMaxLength = K_MAX_LENGTH;
  Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e53) {
      return false;
    }
  }
  Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function Buffer3(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer3.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer3.from(valueOf, encodingOrOffset, length);
    }
    const b33 = fromObject(value);
    if (b33)
      return b33;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer3.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer3, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer3.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer3.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer3.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i53 = 0; i53 < length; i53 += 1) {
      buf[i53] = array[i53] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer3.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer3.alloc(+length);
  }
  Buffer3.isBuffer = function isBuffer32(b33) {
    return b33 != null && b33._isBuffer === true && b33 !== Buffer3.prototype;
  };
  Buffer3.compare = function compare(a53, b33) {
    if (isInstance(a53, Uint8Array))
      a53 = Buffer3.from(a53, a53.offset, a53.byteLength);
    if (isInstance(b33, Uint8Array))
      b33 = Buffer3.from(b33, b33.offset, b33.byteLength);
    if (!Buffer3.isBuffer(a53) || !Buffer3.isBuffer(b33)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a53 === b33)
      return 0;
    let x32 = a53.length;
    let y43 = b33.length;
    for (let i53 = 0, len = Math.min(x32, y43); i53 < len; ++i53) {
      if (a53[i53] !== b33[i53]) {
        x32 = a53[i53];
        y43 = b33[i53];
        break;
      }
    }
    if (x32 < y43)
      return -1;
    if (y43 < x32)
      return 1;
    return 0;
  };
  Buffer3.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer3.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer3.alloc(0);
    }
    let i53;
    if (length === void 0) {
      length = 0;
      for (i53 = 0; i53 < list.length; ++i53) {
        length += list[i53].length;
      }
    }
    const buffer22 = Buffer3.allocUnsafe(length);
    let pos = 0;
    for (i53 = 0; i53 < list.length; ++i53) {
      let buf = list[i53];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer22.length) {
          if (!Buffer3.isBuffer(buf))
            buf = Buffer3.from(buf);
          buf.copy(buffer22, pos);
        } else {
          Uint8Array.prototype.set.call(buffer22, buf, pos);
        }
      } else if (!Buffer3.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer22, pos);
      }
      pos += buf.length;
    }
    return buffer22;
  };
  function byteLength(string, encoding) {
    if (Buffer3.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.prototype._isBuffer = true;
  function swap(b33, n53, m43) {
    const i53 = b33[n53];
    b33[n53] = b33[m43];
    b33[m43] = i53;
  }
  Buffer3.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i53 = 0; i53 < len; i53 += 2) {
      swap(this, i53, i53 + 1);
    }
    return this;
  };
  Buffer3.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i53 = 0; i53 < len; i53 += 4) {
      swap(this, i53, i53 + 3);
      swap(this, i53 + 1, i53 + 2);
    }
    return this;
  };
  Buffer3.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i53 = 0; i53 < len; i53 += 8) {
      swap(this, i53, i53 + 7);
      swap(this, i53 + 1, i53 + 6);
      swap(this, i53 + 2, i53 + 5);
      swap(this, i53 + 3, i53 + 4);
    }
    return this;
  };
  Buffer3.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
  Buffer3.prototype.equals = function equals(b33) {
    if (!Buffer3.isBuffer(b33))
      throw new TypeError("Argument must be a Buffer");
    if (this === b33)
      return true;
    return Buffer3.compare(this, b33) === 0;
  };
  Buffer3.prototype.inspect = function inspect32() {
    let str = "";
    const max = exports$g3.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
  }
  Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x32 = thisEnd - thisStart;
    let y43 = end - start;
    const len = Math.min(x32, y43);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i53 = 0; i53 < len; ++i53) {
      if (thisCopy[i53] !== targetCopy[i53]) {
        x32 = thisCopy[i53];
        y43 = targetCopy[i53];
        break;
      }
    }
    if (x32 < y43)
      return -1;
    if (y43 < x32)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer22, val, byteOffset, encoding, dir) {
    if (buffer22.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer22.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer22.length + byteOffset;
    if (byteOffset >= buffer22.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer22.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (Buffer3.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer22, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer22, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer22, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer22, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i63) {
      if (indexSize === 1) {
        return buf[i63];
      } else {
        return buf.readUInt16BE(i63 * indexSize);
      }
    }
    let i53;
    if (dir) {
      let foundIndex = -1;
      for (i53 = byteOffset; i53 < arrLength; i53++) {
        if (read2(arr, i53) === read2(val, foundIndex === -1 ? 0 : i53 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i53;
          if (i53 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i53 -= i53 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i53 = byteOffset; i53 >= 0; i53--) {
        let found = true;
        for (let j32 = 0; j32 < valLength; j32++) {
          if (read2(arr, i53 + j32) !== read2(val, j32)) {
            found = false;
            break;
          }
        }
        if (found)
          return i53;
      }
    }
    return -1;
  }
  Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i53;
    for (i53 = 0; i53 < length; ++i53) {
      const parsed = parseInt(string.substr(i53 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i53;
      buf[offset + i53] = parsed;
    }
    return i53;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer3.prototype.write = function write2(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer3.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i53 = start;
    while (i53 < end) {
      const firstByte = buf[i53];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i53 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i53 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i53 + 1];
            thirdByte = buf[i53 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i53 + 1];
            thirdByte = buf[i53 + 2];
            fourthByte = buf[i53 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i53 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i53 = 0;
    while (i53 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i53, i53 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i53 = start; i53 < end; ++i53) {
      ret += String.fromCharCode(buf[i53] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i53 = start; i53 < end; ++i53) {
      ret += String.fromCharCode(buf[i53]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i53 = start; i53 < end; ++i53) {
      out += hexSliceLookupTable[buf[i53]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i53 = 0; i53 < bytes.length - 1; i53 += 2) {
      res += String.fromCharCode(bytes[i53] + bytes[i53 + 1] * 256);
    }
    return res;
  }
  Buffer3.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i53 = 0;
    while (++i53 < byteLength2 && (mul *= 256)) {
      val += this[offset + i53] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    let val = this[offset + --byteLength2];
    let mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i53 = 0;
    while (++i53 < byteLength2 && (mul *= 256)) {
      val += this[offset + i53] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let i53 = byteLength2;
    let mul = 1;
    let val = this[offset + --i53];
    while (i53 > 0 && (mul *= 256)) {
      val += this[offset + --i53] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer3.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1;
    let i53 = 0;
    this[offset] = value & 255;
    while (++i53 < byteLength2 && (mul *= 256)) {
      this[offset + i53] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i53 = byteLength2 - 1;
    let mul = 1;
    this[offset + i53] = value & 255;
    while (--i53 >= 0 && (mul *= 256)) {
      this[offset + i53] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i53 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i53 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i53 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i53] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i53 = byteLength2 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i53] = value & 255;
    while (--i53 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i53 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i53] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer3.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer3.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code = val.charCodeAt(0);
        if (encoding === "utf8" && code < 128 || encoding === "latin1") {
          val = code;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i53;
    if (typeof val === "number") {
      for (i53 = start; i53 < end; ++i53) {
        this[i53] = val;
      }
    } else {
      const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i53 = 0; i53 < end - start; ++i53) {
        this[i53 + start] = bytes[i53 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E32(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E32("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
    if (name2) {
      return `${name2} is outside of buffer bounds`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E32("ERR_INVALID_ARG_TYPE", function(name2, actual) {
    return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  E32("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i53 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i53 >= start + 4; i53 -= 3) {
      res = `_${val.slice(i53 - 3, i53)}${res}`;
    }
    return `${val.slice(0, i53)}${res}`;
  }
  function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
      boundsError(offset, buf.length - (byteLength2 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
      const n53 = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength2 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n53} and < 2${n53} ** ${(byteLength2 + 1) * 8}${n53}`;
        } else {
          range = `>= -(2${n53} ** ${(byteLength2 + 1) * 8 - 1}${n53}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n53}`;
        }
      } else {
        range = `>= ${min}${n53} and <= ${max}${n53}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", `>= ${type2 ? 1 : 0} and <= ${length}`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i53 = 0; i53 < length; ++i53) {
      codePoint = string.charCodeAt(i53);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i53 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i53 = 0; i53 < str.length; ++i53) {
      byteArray.push(str.charCodeAt(i53) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c53, hi, lo;
    const byteArray = [];
    for (let i53 = 0; i53 < str.length; ++i53) {
      if ((units -= 2) < 0)
        break;
      c53 = str.charCodeAt(i53);
      hi = c53 >> 8;
      lo = c53 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i53;
    for (i53 = 0; i53 < length; ++i53) {
      if (i53 + offset >= dst.length || i53 >= src.length)
        break;
      dst[i53 + offset] = src[i53];
    }
    return i53;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i53 = 0; i53 < 16; ++i53) {
      const i16 = i53 * 16;
      for (let j32 = 0; j32 < 16; ++j32) {
        table[i16 + j32] = alphabet[i53] + alphabet[j32];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
  return exports$g3;
}
function dew$f3() {
  if (_dewExec$f3)
    return exports$f3;
  _dewExec$f3 = true;
  if (typeof Object.create === "function") {
    exports$f3 = function inherits32(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    exports$f3 = function inherits32(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return exports$f3;
}
function dew$e3() {
  if (_dewExec$e3)
    return exports$e3;
  _dewExec$e3 = true;
  exports$e3 = y6.EventEmitter;
  return exports$e3;
}
function dew$d3() {
  if (_dewExec$d3)
    return exports$d3;
  _dewExec$d3 = true;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i53 = 1; i53 < arguments.length; i53++) {
      var source = arguments[i53] != null ? arguments[i53] : {};
      if (i53 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i53 = 0; i53 < props.length; i53++) {
      var descriptor = props[i53];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var _require = buffer2, Buffer3 = _require.Buffer;
  var _require2 = X3, inspect32 = _require2.inspect;
  var custom = inspect32 && inspect32.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer3.prototype.copy.call(src, target, offset);
  }
  exports$d3 = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v43) {
        var entry = {
          data: v43,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v43) {
        var entry = {
          data: v43,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join3(s53) {
        if (this.length === 0)
          return "";
        var p53 = this.head;
        var ret = "" + p53.data;
        while (p53 = p53.next) {
          ret += s53 + p53.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n53) {
        if (this.length === 0)
          return Buffer3.alloc(0);
        var ret = Buffer3.allocUnsafe(n53 >>> 0);
        var p53 = this.head;
        var i53 = 0;
        while (p53) {
          copyBuffer(p53.data, ret, i53);
          i53 += p53.data.length;
          p53 = p53.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n53, hasStrings) {
        var ret;
        if (n53 < this.head.data.length) {
          ret = this.head.data.slice(0, n53);
          this.head.data = this.head.data.slice(n53);
        } else if (n53 === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n53) : this._getBuffer(n53);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n53) {
        var p53 = this.head;
        var c53 = 1;
        var ret = p53.data;
        n53 -= ret.length;
        while (p53 = p53.next) {
          var str = p53.data;
          var nb = n53 > str.length ? str.length : n53;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n53);
          n53 -= nb;
          if (n53 === 0) {
            if (nb === str.length) {
              ++c53;
              if (p53.next)
                this.head = p53.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p53;
              p53.data = str.slice(nb);
            }
            break;
          }
          ++c53;
        }
        this.length -= c53;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n53) {
        var ret = Buffer3.allocUnsafe(n53);
        var p53 = this.head;
        var c53 = 1;
        p53.data.copy(ret);
        n53 -= p53.data.length;
        while (p53 = p53.next) {
          var buf = p53.data;
          var nb = n53 > buf.length ? buf.length : n53;
          buf.copy(ret, ret.length - n53, 0, nb);
          n53 -= nb;
          if (n53 === 0) {
            if (nb === buf.length) {
              ++c53;
              if (p53.next)
                this.head = p53.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p53;
              p53.data = buf.slice(nb);
            }
            break;
          }
          ++c53;
        }
        this.length -= c53;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_32, options) {
        return inspect32(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
  return exports$d3;
}
function dew$c3() {
  if (_dewExec$c3)
    return exports$c3;
  _dewExec$c3 = true;
  var process$1 = process4;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process$1.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process$1.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream.destroy(err);
    else
      stream.emit("error", err);
  }
  exports$c3 = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return exports$c3;
}
function dew$b3() {
  if (_dewExec$b3)
    return exports$b3;
  _dewExec$b3 = true;
  const codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i53) => String(i53));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
    return 'The value "' + value + '" is invalid for option "' + name2 + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name2, " argument")) {
      msg = `The ${name2} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type2 = includes(name2, ".") ? "property" : "argument";
      msg = `The "${name2}" ${type2} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
    return "The " + name2 + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name2) {
    return "Cannot call " + name2 + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  exports$b3.codes = codes;
  return exports$b3;
}
function dew$a3() {
  if (_dewExec$a3)
    return exports$a3;
  _dewExec$a3 = true;
  var ERR_INVALID_OPT_VALUE = dew$b3().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name2 = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name2, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  }
  exports$a3 = {
    getHighWaterMark
  };
  return exports$a3;
}
function dew$93() {
  if (_dewExec$93)
    return exports$93;
  _dewExec$93 = true;
  exports$93 = deprecate32;
  function deprecate32(fn, msg) {
    if (config("noDeprecation")) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config("throwDeprecation")) {
          throw new Error(msg);
        } else if (config("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this || _global$23, arguments);
    }
    return deprecated;
  }
  function config(name2) {
    try {
      if (!_global$23.localStorage)
        return false;
    } catch (_32) {
      return false;
    }
    var val = _global$23.localStorage[name2];
    if (null == val)
      return false;
    return String(val).toLowerCase() === "true";
  }
  return exports$93;
}
function dew$83() {
  if (_dewExec$83)
    return exports$83;
  _dewExec$83 = true;
  var process$1 = process4;
  exports$83 = Writable22;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var Duplex22;
  Writable22.WritableState = WritableState;
  var internalUtil = {
    deprecate: dew$93()
  };
  var Stream22 = dew$e3();
  var Buffer3 = buffer2.Buffer;
  var OurUint8Array = _global$13.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer3.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = dew$c3();
  var _require = dew$a3(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = dew$b3().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  dew$f3()(Writable22, Stream22);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex22 = Duplex22 || dew$73();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex22;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_32) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable22, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable22)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable22(options) {
    Duplex22 = Duplex22 || dew$73();
    var isDuplex = this instanceof Duplex22;
    if (!isDuplex && !realHasInstance.call(Writable22, this))
      return new Writable22(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream22.call(this);
  }
  Writable22.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process$1.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable22.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer3.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable22.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable22.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable22.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable22.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer3.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable22.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev2, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev2)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      process$1.nextTick(cb, er);
      process$1.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished22 = needFinish(state) || stream.destroyed;
      if (!finished22 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        process$1.nextTick(afterWrite, stream, state, finished22, cb);
      } else {
        afterWrite(stream, state, finished22, cb);
      }
    }
  }
  function afterWrite(stream, state, finished22, cb) {
    if (!finished22)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l53 = state.bufferedRequestCount;
      var buffer22 = new Array(l53);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer22[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer22.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer22, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable22.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable22.prototype._writev = null;
  Writable22.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable22.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process$1.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
        if (state.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        process$1.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable22.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable22.prototype.destroy = destroyImpl.destroy;
  Writable22.prototype._undestroy = destroyImpl.undestroy;
  Writable22.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return exports$83;
}
function dew$73() {
  if (_dewExec$73)
    return exports$73;
  _dewExec$73 = true;
  var process$1 = process4;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  exports$73 = Duplex22;
  var Readable22 = dew$33();
  var Writable22 = dew$83();
  dew$f3()(Duplex22, Readable22);
  {
    var keys = objectKeys(Writable22.prototype);
    for (var v43 = 0; v43 < keys.length; v43++) {
      var method = keys[v43];
      if (!Duplex22.prototype[method])
        Duplex22.prototype[method] = Writable22.prototype[method];
    }
  }
  function Duplex22(options) {
    if (!(this instanceof Duplex22))
      return new Duplex22(options);
    Readable22.call(this, options);
    Writable22.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex22.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex22.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex22.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process$1.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex22.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return exports$73;
}
function dew$63() {
  if (_dewExec$63)
    return exports$63;
  _dewExec$63 = true;
  var ERR_STREAM_PREMATURE_CLOSE = dew$b3().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once22(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts2, callback) {
    if (typeof opts2 === "function")
      return eos(stream, null, opts2);
    if (!opts2)
      opts2 = {};
    callback = once22(callback || noop);
    var readable = opts2.readable || opts2.readable !== false && stream.readable;
    var writable = opts2.writable || opts2.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable)
        onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts2.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  exports$63 = eos;
  return exports$63;
}
function dew$53() {
  if (_dewExec$53)
    return exports$53;
  _dewExec$53 = true;
  var process$1 = process4;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var finished22 = dew$63();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult2(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve4 = iter[kLastResolve];
    if (resolve4 !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve4(createIterResult2(data, false));
      }
    }
  }
  function onReadable(iter) {
    process$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve4, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve4(createIterResult2(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve4, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult2(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve4, reject) {
          process$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve4(createIterResult2(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult2(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve4, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve4(createIterResult2(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve4, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve4(createIterResult2(data, false));
        } else {
          iterator[kLastResolve] = resolve4;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished22(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve4 = iterator[kLastResolve];
      if (resolve4 !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve4(createIterResult2(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  exports$53 = createReadableStreamAsyncIterator;
  return exports$53;
}
function dew$43() {
  if (_dewExec$43)
    return exports$43;
  _dewExec$43 = true;
  exports$43 = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return exports$43;
}
function dew$33() {
  if (_dewExec$33)
    return exports$34;
  _dewExec$33 = true;
  var process$1 = process4;
  exports$34 = Readable22;
  var Duplex22;
  Readable22.ReadableState = ReadableState;
  y6.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream22 = dew$e3();
  var Buffer3 = buffer2.Buffer;
  var OurUint8Array = _global23.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer3.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = X3;
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList = dew$d3();
  var destroyImpl = dew$c3();
  var _require = dew$a3(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = dew$b3().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  dew$f3()(Readable22, Stream22);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex22 = Duplex22 || dew$73();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex22;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = e$122.StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable22(options) {
    Duplex22 = Duplex22 || dew$73();
    if (!(this instanceof Readable22))
      return new Readable22(options);
    var isDuplex = this instanceof Duplex22;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream22.call(this);
  }
  Object.defineProperty(Readable22.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable22.prototype.destroy = destroyImpl.destroy;
  Readable22.prototype._undestroy = destroyImpl.undestroy;
  Readable22.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable22.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer3.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable22.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable22.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable22.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = e$122.StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p53 = this._readableState.buffer.head;
    var content = "";
    while (p53 !== null) {
      content += decoder.write(p53.data);
      p53 = p53.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n53) {
    if (n53 >= MAX_HWM) {
      n53 = MAX_HWM;
    } else {
      n53--;
      n53 |= n53 >>> 1;
      n53 |= n53 >>> 2;
      n53 |= n53 >>> 4;
      n53 |= n53 >>> 8;
      n53 |= n53 >>> 16;
      n53++;
    }
    return n53;
  }
  function howMuchToRead(n53, state) {
    if (n53 <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n53 !== n53) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n53 > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n53);
    if (n53 <= state.length)
      return n53;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable22.prototype.read = function(n53) {
    debug("read", n53);
    n53 = parseInt(n53, 10);
    var state = this._readableState;
    var nOrig = n53;
    if (n53 !== 0)
      state.emittedReadable = false;
    if (n53 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n53 = howMuchToRead(n53, state);
    if (n53 === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n53 < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n53 = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n53 > 0)
      ret = fromList(n53, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n53 = 0;
    } else {
      state.length -= n53;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n53 && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process$1.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process$1.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable22.prototype._read = function(n53) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable22.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process$1.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable22.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i53 = 0; i53 < len; i53++) {
        dests[i53].emit("unpipe", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable22.prototype.on = function(ev, fn) {
    var res = Stream22.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process$1.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable22.prototype.addListener = Readable22.prototype.on;
  Readable22.prototype.removeListener = function(ev, fn) {
    var res = Stream22.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable22.prototype.removeAllListeners = function(ev) {
    var res = Stream22.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable22.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process$1.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable22.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
  }
  Readable22.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i53 in stream) {
      if (this[i53] === void 0 && typeof stream[i53] === "function") {
        this[i53] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i53);
      }
    }
    for (var n53 = 0; n53 < kProxyEvents.length; n53++) {
      stream.on(kProxyEvents[n53], this.emit.bind(this, kProxyEvents[n53]));
    }
    this._read = function(n63) {
      debug("wrapped _read", n63);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable22.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = dew$53();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable22.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable22.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable22.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable22._fromList = fromList;
  Object.defineProperty(Readable22.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.length;
    }
  });
  function fromList(n53, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n53 || n53 >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n53, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process$1.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable22.from = function(iterable, opts2) {
      if (from === void 0) {
        from = dew$43();
      }
      return from(Readable22, iterable, opts2);
    };
  }
  function indexOf(xs, x32) {
    for (var i53 = 0, l53 = xs.length; i53 < l53; i53++) {
      if (xs[i53] === x32)
        return i53;
    }
    return -1;
  }
  return exports$34;
}
function dew$24() {
  if (_dewExec$24)
    return exports$24;
  _dewExec$24 = true;
  exports$24 = Transform22;
  var _require$codes = dew$b3().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex22 = dew$73();
  dew$f3()(Transform22, Duplex22);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform22(options) {
    if (!(this instanceof Transform22))
      return new Transform22(options);
    Duplex22.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform22.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex22.prototype.push.call(this, chunk, encoding);
  };
  Transform22.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform22.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform22.prototype._read = function(n53) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform22.prototype._destroy = function(err, cb) {
    Duplex22.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
  return exports$24;
}
function dew$14() {
  if (_dewExec$14)
    return exports$16;
  _dewExec$14 = true;
  exports$16 = PassThrough22;
  var Transform22 = dew$24();
  dew$f3()(PassThrough22, Transform22);
  function PassThrough22(options) {
    if (!(this instanceof PassThrough22))
      return new PassThrough22(options);
    Transform22.call(this, options);
  }
  PassThrough22.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return exports$16;
}
function dew23() {
  if (_dewExec23)
    return exports23;
  _dewExec23 = true;
  var eos;
  function once22(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = dew$b3().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop(err) {
    if (err)
      throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once22(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0)
      eos = dew$63();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream))
        return stream.abort();
      if (typeof stream.destroy === "function")
        return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length)
      return noop;
    if (typeof streams[streams.length - 1] !== "function")
      return noop;
    return streams.pop();
  }
  function pipeline22() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i53) {
      var reading = i53 < streams.length - 1;
      var writing = i53 > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  exports23 = pipeline22;
  return exports23;
}
function dew33() {
  if (_dewExec33)
    return exports$123;
  _dewExec33 = true;
  exports$123 = Stream22;
  var EE = y6.EventEmitter;
  var inherits32 = dew$f3();
  inherits32(Stream22, EE);
  Stream22.Readable = dew$33();
  Stream22.Writable = dew$83();
  Stream22.Duplex = dew$73();
  Stream22.Transform = dew$24();
  Stream22.PassThrough = dew$14();
  Stream22.finished = dew$63();
  Stream22.pipeline = dew23();
  Stream22.Stream = Stream22;
  function Stream22() {
    EE.call(this || _global32);
  }
  Stream22.prototype.pipe = function(dest, options) {
    var source = this || _global32;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      if (typeof dest.destroy === "function")
        dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this || _global32, "error") === 0) {
        throw er;
      }
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  return exports$123;
}
var e9, t8, n9, r9, i8, s7, y6, EventEmitter2, defaultMaxListeners2, init2, listenerCount2, on2, once2, e22, t22, n22, r22, o22, l22, s22, f22, a22, T5, t32, e32, o32, n32, r32, l32, t$14, o$14, n$14, e$14, r$14, c32, u32, i32, t$23, i$14, o$24, u$14, f32, a32, s32, p32, y22, l$14, d22, m22, h32, j4, A4, Q3, X3, Y4, ee2, te2, re2, ne2, ie2, Se2, Ee2, _extend3, callbackify3, debuglog3, deprecate3, format5, inherits3, inspect3, isArray3, isBoolean3, isBuffer3, isDate3, isError3, isFunction3, isNull3, isNullOrUndefined3, isNumber3, isObject3, isPrimitive3, isRegExp3, isString3, isSymbol3, isUndefined3, log3, promisify3, types3, TextEncoder3, TextDecoder4, exports8, _dewExec8, _global5, process4, r$122, t$122, e$23, n$23, o$222, a$13, h$13, a$1$12, e$1$12, n$1$12, i$122, o$1$12, j22, Y22, e42, n42, o42, u42, e$122, s42, i42, exports$2$12, _dewExec$2$12, exports$1$12, _dewExec$1$12, exports$g3, _dewExec$g2, buffer2, exports$f3, _dewExec$f3, exports$e3, _dewExec$e3, exports$d3, _dewExec$d3, exports$c3, _dewExec$c3, exports$b3, _dewExec$b3, exports$a3, _dewExec$a3, exports$93, _dewExec$93, _global$23, exports$83, _dewExec$83, _global$13, exports$73, _dewExec$73, exports$63, _dewExec$63, exports$53, _dewExec$53, exports$43, _dewExec$43, exports$34, _dewExec$33, _global23, exports$24, _dewExec$24, exports$16, _dewExec$14, exports23, _dewExec23, exports$123, _dewExec33, _global32, exports33, _extend22, callbackify22, debuglog22, deprecate22, format23, inherits22, inspect22, isArray22, isBoolean22, isBuffer22, isDate22, isError22, isFunction22, isNull22, isNullOrUndefined22, isNumber22, isObject22, isPrimitive22, isRegExp22, isString22, isSymbol22, isUndefined22, log22, promisify22, types22, TextEncoder22, TextDecoder22, Readable2, Writable2, Duplex2, Transform2, PassThrough2, finished2, pipeline2, Stream2, promises3;
var init_stream = __esm({
  "node-modules-polyfills:stream"() {
    n9 = "object" == typeof Reflect ? Reflect : null;
    r9 = n9 && "function" == typeof n9.apply ? n9.apply : function(e53, t53, n53) {
      return Function.prototype.apply.call(e53, t53, n53);
    };
    t8 = n9 && "function" == typeof n9.ownKeys ? n9.ownKeys : Object.getOwnPropertySymbols ? function(e53) {
      return Object.getOwnPropertyNames(e53).concat(Object.getOwnPropertySymbols(e53));
    } : function(e53) {
      return Object.getOwnPropertyNames(e53);
    };
    i8 = Number.isNaN || function(e53) {
      return e53 != e53;
    };
    e9 = o9, o9.EventEmitter = o9, o9.prototype._events = void 0, o9.prototype._eventsCount = 0, o9.prototype._maxListeners = void 0;
    s7 = 10;
    Object.defineProperty(o9, "defaultMaxListeners", { enumerable: true, get: function() {
      return s7;
    }, set: function(e53) {
      if ("number" != typeof e53 || e53 < 0 || i8(e53))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e53 + ".");
      s7 = e53;
    } }), o9.init = function() {
      void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    }, o9.prototype.setMaxListeners = function(e53) {
      if ("number" != typeof e53 || e53 < 0 || i8(e53))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e53 + ".");
      return this._maxListeners = e53, this;
    }, o9.prototype.getMaxListeners = function() {
      return f8(this);
    }, o9.prototype.emit = function(e53) {
      for (var t53 = [], n53 = 1; n53 < arguments.length; n53++)
        t53.push(arguments[n53]);
      var i53 = "error" === e53, o53 = this._events;
      if (void 0 !== o53)
        i53 = i53 && void 0 === o53.error;
      else if (!i53)
        return false;
      if (i53) {
        var s53;
        if (t53.length > 0 && (s53 = t53[0]), s53 instanceof Error)
          throw s53;
        var u53 = new Error("Unhandled error." + (s53 ? " (" + s53.message + ")" : ""));
        throw u53.context = s53, u53;
      }
      var f53 = o53[e53];
      if (void 0 === f53)
        return false;
      if ("function" == typeof f53)
        r9(f53, this, t53);
      else {
        var v43 = f53.length, a53 = c8(f53, v43);
        for (n53 = 0; n53 < v43; ++n53)
          r9(a53[n53], this, t53);
      }
      return true;
    }, o9.prototype.addListener = function(e53, t53) {
      return v6(this, e53, t53, false);
    }, o9.prototype.on = o9.prototype.addListener, o9.prototype.prependListener = function(e53, t53) {
      return v6(this, e53, t53, true);
    }, o9.prototype.once = function(e53, t53) {
      return u8(t53), this.on(e53, l8(this, e53, t53)), this;
    }, o9.prototype.prependOnceListener = function(e53, t53) {
      return u8(t53), this.prependListener(e53, l8(this, e53, t53)), this;
    }, o9.prototype.removeListener = function(e53, t53) {
      var n53, r53, i53, o53, s53;
      if (u8(t53), void 0 === (r53 = this._events))
        return this;
      if (void 0 === (n53 = r53[e53]))
        return this;
      if (n53 === t53 || n53.listener === t53)
        0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r53[e53], r53.removeListener && this.emit("removeListener", e53, n53.listener || t53));
      else if ("function" != typeof n53) {
        for (i53 = -1, o53 = n53.length - 1; o53 >= 0; o53--)
          if (n53[o53] === t53 || n53[o53].listener === t53) {
            s53 = n53[o53].listener, i53 = o53;
            break;
          }
        if (i53 < 0)
          return this;
        0 === i53 ? n53.shift() : !function(e63, t63) {
          for (; t63 + 1 < e63.length; t63++)
            e63[t63] = e63[t63 + 1];
          e63.pop();
        }(n53, i53), 1 === n53.length && (r53[e53] = n53[0]), void 0 !== r53.removeListener && this.emit("removeListener", e53, s53 || t53);
      }
      return this;
    }, o9.prototype.off = o9.prototype.removeListener, o9.prototype.removeAllListeners = function(e53) {
      var t53, n53, r53;
      if (void 0 === (n53 = this._events))
        return this;
      if (void 0 === n53.removeListener)
        return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n53[e53] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n53[e53]), this;
      if (0 === arguments.length) {
        var i53, o53 = Object.keys(n53);
        for (r53 = 0; r53 < o53.length; ++r53)
          "removeListener" !== (i53 = o53[r53]) && this.removeAllListeners(i53);
        return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
      }
      if ("function" == typeof (t53 = n53[e53]))
        this.removeListener(e53, t53);
      else if (void 0 !== t53)
        for (r53 = t53.length - 1; r53 >= 0; r53--)
          this.removeListener(e53, t53[r53]);
      return this;
    }, o9.prototype.listeners = function(e53) {
      return h8(this, e53, true);
    }, o9.prototype.rawListeners = function(e53) {
      return h8(this, e53, false);
    }, o9.listenerCount = function(e53, t53) {
      return "function" == typeof e53.listenerCount ? e53.listenerCount(t53) : p8.call(e53, t53);
    }, o9.prototype.listenerCount = p8, o9.prototype.eventNames = function() {
      return this._eventsCount > 0 ? t8(this._events) : [];
    };
    y6 = e9;
    y6.EventEmitter;
    y6.defaultMaxListeners;
    y6.init;
    y6.listenerCount;
    y6.EventEmitter;
    y6.defaultMaxListeners;
    y6.init;
    y6.listenerCount;
    y6.once = function(emitter, event) {
      return new Promise((resolve4, reject) => {
        function eventListener(...args) {
          if (errorListener !== void 0) {
            emitter.removeListener("error", errorListener);
          }
          resolve4(args);
        }
        let errorListener;
        if (event !== "error") {
          errorListener = (err) => {
            emitter.removeListener(name, eventListener);
            reject(err);
          };
          emitter.once("error", errorListener);
        }
        emitter.once(event, eventListener);
      });
    };
    y6.on = function(emitter, event) {
      const unconsumedEventValues = [];
      const unconsumedPromises = [];
      let error = null;
      let finished22 = false;
      const iterator = {
        async next() {
          const value = unconsumedEventValues.shift();
          if (value) {
            return createIterResult(value, false);
          }
          if (error) {
            const p53 = Promise.reject(error);
            error = null;
            return p53;
          }
          if (finished22) {
            return createIterResult(void 0, true);
          }
          return new Promise((resolve4, reject) => unconsumedPromises.push({ resolve: resolve4, reject }));
        },
        async return() {
          emitter.removeListener(event, eventHandler);
          emitter.removeListener("error", errorHandler);
          finished22 = true;
          for (const promise of unconsumedPromises) {
            promise.resolve(createIterResult(void 0, true));
          }
          return createIterResult(void 0, true);
        },
        throw(err) {
          error = err;
          emitter.removeListener(event, eventHandler);
          emitter.removeListener("error", errorHandler);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
      emitter.on(event, eventHandler);
      emitter.on("error", errorHandler);
      return iterator;
      function eventHandler(...args) {
        const promise = unconsumedPromises.shift();
        if (promise) {
          promise.resolve(createIterResult(args, false));
        } else {
          unconsumedEventValues.push(args);
        }
      }
      function errorHandler(err) {
        finished22 = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
          toError.reject(err);
        } else {
          error = err;
        }
        iterator.return();
      }
    };
    ({
      EventEmitter: EventEmitter2,
      defaultMaxListeners: defaultMaxListeners2,
      init: init2,
      listenerCount: listenerCount2,
      on: on2,
      once: once2
    } = y6);
    r22 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis;
    o22 = e22 = {};
    !function() {
      try {
        t22 = "function" == typeof setTimeout ? setTimeout : i22;
      } catch (e53) {
        t22 = i22;
      }
      try {
        n22 = "function" == typeof clearTimeout ? clearTimeout : u22;
      } catch (e53) {
        n22 = u22;
      }
    }();
    s22 = [];
    f22 = false;
    a22 = -1;
    o22.nextTick = function(e53) {
      var t53 = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var n53 = 1; n53 < arguments.length; n53++)
          t53[n53 - 1] = arguments[n53];
      s22.push(new m6(e53, t53)), 1 !== s22.length || f22 || c22(d6);
    }, m6.prototype.run = function() {
      (this || r22).fun.apply(null, (this || r22).array);
    }, o22.title = "browser", o22.browser = true, o22.env = {}, o22.argv = [], o22.version = "", o22.versions = {}, o22.on = p22, o22.addListener = p22, o22.once = p22, o22.off = p22, o22.removeListener = p22, o22.removeAllListeners = p22, o22.emit = p22, o22.prependListener = p22, o22.prependOnceListener = p22, o22.listeners = function(e53) {
      return [];
    }, o22.binding = function(e53) {
      throw new Error("process.binding is not supported");
    }, o22.cwd = function() {
      return "/";
    }, o22.chdir = function(e53) {
      throw new Error("process.chdir is not supported");
    }, o22.umask = function() {
      return 0;
    };
    T5 = e22;
    T5.addListener;
    T5.argv;
    T5.binding;
    T5.browser;
    T5.chdir;
    T5.cwd;
    T5.emit;
    T5.env;
    T5.listeners;
    T5.nextTick;
    T5.off;
    T5.on;
    T5.once;
    T5.prependListener;
    T5.prependOnceListener;
    T5.removeAllListeners;
    T5.removeListener;
    T5.title;
    T5.umask;
    T5.version;
    T5.versions;
    t32 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
    e32 = Object.prototype.toString;
    o32 = function(o53) {
      return !(t32 && o53 && "object" == typeof o53 && Symbol.toStringTag in o53) && "[object Arguments]" === e32.call(o53);
    };
    n32 = function(t53) {
      return !!o32(t53) || null !== t53 && "object" == typeof t53 && "number" == typeof t53.length && t53.length >= 0 && "[object Array]" !== e32.call(t53) && "[object Function]" === e32.call(t53.callee);
    };
    r32 = function() {
      return o32(arguments);
    }();
    o32.isLegacyArguments = n32;
    l32 = r32 ? o32 : n32;
    t$14 = Object.prototype.toString;
    o$14 = Function.prototype.toString;
    n$14 = /^\s*(?:function)?\*/;
    e$14 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
    r$14 = Object.getPrototypeOf;
    c32 = function() {
      if (!e$14)
        return false;
      try {
        return Function("return function*() {}")();
      } catch (t53) {
      }
    }();
    u32 = c32 ? r$14(c32) : {};
    i32 = function(c53) {
      return "function" == typeof c53 && (!!n$14.test(o$14.call(c53)) || (e$14 ? r$14(c53) === u32 : "[object GeneratorFunction]" === t$14.call(c53)));
    };
    t$23 = "function" == typeof Object.create ? function(t53, e53) {
      e53 && (t53.super_ = e53, t53.prototype = Object.create(e53.prototype, { constructor: { value: t53, enumerable: false, writable: true, configurable: true } }));
    } : function(t53, e53) {
      if (e53) {
        t53.super_ = e53;
        var o53 = function() {
        };
        o53.prototype = e53.prototype, t53.prototype = new o53(), t53.prototype.constructor = t53;
      }
    };
    i$14 = function(e53) {
      return e53 && "object" == typeof e53 && "function" == typeof e53.copy && "function" == typeof e53.fill && "function" == typeof e53.readUInt8;
    };
    o$24 = {};
    u$14 = i$14;
    f32 = l32;
    a32 = i32;
    s32 = "undefined" != typeof BigInt;
    p32 = "undefined" != typeof Symbol;
    y22 = p32 && void 0 !== Symbol.toStringTag;
    l$14 = "undefined" != typeof Uint8Array;
    d22 = "undefined" != typeof ArrayBuffer;
    if (l$14 && y22)
      var g5 = Object.getPrototypeOf(Uint8Array.prototype), b5 = c$14(Object.getOwnPropertyDescriptor(g5, Symbol.toStringTag).get);
    m22 = c$14(Object.prototype.toString);
    h32 = c$14(Number.prototype.valueOf);
    j4 = c$14(String.prototype.valueOf);
    A4 = c$14(Boolean.prototype.valueOf);
    if (s32)
      var w4 = c$14(BigInt.prototype.valueOf);
    if (p32)
      var v22 = c$14(Symbol.prototype.valueOf);
    o$24.isArgumentsObject = f32, o$24.isGeneratorFunction = a32, o$24.isPromise = function(e53) {
      return "undefined" != typeof Promise && e53 instanceof Promise || null !== e53 && "object" == typeof e53 && "function" == typeof e53.then && "function" == typeof e53.catch;
    }, o$24.isArrayBufferView = function(e53) {
      return d22 && ArrayBuffer.isView ? ArrayBuffer.isView(e53) : S4(e53) || R4(e53);
    }, o$24.isTypedArray = S4, o$24.isUint8Array = B4, o$24.isUint8ClampedArray = k4, o$24.isUint16Array = E4, o$24.isUint32Array = D4, o$24.isInt8Array = U4, o$24.isInt16Array = P4, o$24.isInt32Array = x4, o$24.isFloat32Array = I4, o$24.isFloat64Array = M4, o$24.isBigInt64Array = z4, o$24.isBigUint64Array = F4, T22.working = "undefined" != typeof Map && T22(/* @__PURE__ */ new Map()), o$24.isMap = function(e53) {
      return "undefined" != typeof Map && (T22.working ? T22(e53) : e53 instanceof Map);
    }, N4.working = "undefined" != typeof Set && N4(/* @__PURE__ */ new Set()), o$24.isSet = function(e53) {
      return "undefined" != typeof Set && (N4.working ? N4(e53) : e53 instanceof Set);
    }, W3.working = "undefined" != typeof WeakMap && W3(/* @__PURE__ */ new WeakMap()), o$24.isWeakMap = function(e53) {
      return "undefined" != typeof WeakMap && (W3.working ? W3(e53) : e53 instanceof WeakMap);
    }, $3.working = "undefined" != typeof WeakSet && $3(/* @__PURE__ */ new WeakSet()), o$24.isWeakSet = function(e53) {
      return $3(e53);
    }, C4.working = "undefined" != typeof ArrayBuffer && C4(new ArrayBuffer()), o$24.isArrayBuffer = V3, G3.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && G3(new DataView(new ArrayBuffer(1), 0, 1)), o$24.isDataView = R4, J3.working = "undefined" != typeof SharedArrayBuffer && J3(new SharedArrayBuffer()), o$24.isSharedArrayBuffer = _4, o$24.isAsyncFunction = function(e53) {
      return "[object AsyncFunction]" === m22(e53);
    }, o$24.isMapIterator = function(e53) {
      return "[object Map Iterator]" === m22(e53);
    }, o$24.isSetIterator = function(e53) {
      return "[object Set Iterator]" === m22(e53);
    }, o$24.isGeneratorObject = function(e53) {
      return "[object Generator]" === m22(e53);
    }, o$24.isWebAssemblyCompiledModule = function(e53) {
      return "[object WebAssembly.Module]" === m22(e53);
    }, o$24.isNumberObject = H3, o$24.isStringObject = Z3, o$24.isBooleanObject = q3, o$24.isBigIntObject = K3, o$24.isSymbolObject = L4, o$24.isBoxedPrimitive = function(e53) {
      return H3(e53) || Z3(e53) || q3(e53) || K3(e53) || L4(e53);
    }, o$24.isAnyArrayBuffer = function(e53) {
      return l$14 && (V3(e53) || _4(e53));
    }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e53) {
      Object.defineProperty(o$24, e53, { enumerable: false, value: function() {
        throw new Error(e53 + " is not supported in userland");
      } });
    });
    Q3 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis;
    X3 = {};
    Y4 = T5;
    ee2 = Object.getOwnPropertyDescriptors || function(e53) {
      for (var t53 = Object.keys(e53), r53 = {}, n53 = 0; n53 < t53.length; n53++)
        r53[t53[n53]] = Object.getOwnPropertyDescriptor(e53, t53[n53]);
      return r53;
    };
    te2 = /%[sdj%]/g;
    X3.format = function(e53) {
      if (!ge2(e53)) {
        for (var t53 = [], r53 = 0; r53 < arguments.length; r53++)
          t53.push(oe2(arguments[r53]));
        return t53.join(" ");
      }
      r53 = 1;
      for (var n53 = arguments, i53 = n53.length, o53 = String(e53).replace(te2, function(e63) {
        if ("%%" === e63)
          return "%";
        if (r53 >= i53)
          return e63;
        switch (e63) {
          case "%s":
            return String(n53[r53++]);
          case "%d":
            return Number(n53[r53++]);
          case "%j":
            try {
              return JSON.stringify(n53[r53++]);
            } catch (e73) {
              return "[Circular]";
            }
          default:
            return e63;
        }
      }), u53 = n53[r53]; r53 < i53; u53 = n53[++r53])
        le2(u53) || !he2(u53) ? o53 += " " + u53 : o53 += " " + oe2(u53);
      return o53;
    }, X3.deprecate = function(e53, t53) {
      if (void 0 !== Y4 && true === Y4.noDeprecation)
        return e53;
      if (void 0 === Y4)
        return function() {
          return X3.deprecate(e53, t53).apply(this || Q3, arguments);
        };
      var r53 = false;
      return function() {
        if (!r53) {
          if (Y4.throwDeprecation)
            throw new Error(t53);
          Y4.traceDeprecation ? console.trace(t53) : console.error(t53), r53 = true;
        }
        return e53.apply(this || Q3, arguments);
      };
    };
    re2 = {};
    ne2 = /^$/;
    if (Y4.env.NODE_DEBUG) {
      ie2 = Y4.env.NODE_DEBUG;
      ie2 = ie2.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne2 = new RegExp("^" + ie2 + "$", "i");
    }
    X3.debuglog = function(e53) {
      if (e53 = e53.toUpperCase(), !re2[e53])
        if (ne2.test(e53)) {
          var t53 = Y4.pid;
          re2[e53] = function() {
            var r53 = X3.format.apply(X3, arguments);
            console.error("%s %d: %s", e53, t53, r53);
          };
        } else
          re2[e53] = function() {
          };
      return re2[e53];
    }, X3.inspect = oe2, oe2.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe2.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X3.types = o$24, X3.isArray = pe2, X3.isBoolean = ye2, X3.isNull = le2, X3.isNullOrUndefined = function(e53) {
      return null == e53;
    }, X3.isNumber = de2, X3.isString = ge2, X3.isSymbol = function(e53) {
      return "symbol" == typeof e53;
    }, X3.isUndefined = be2, X3.isRegExp = me2, X3.types.isRegExp = me2, X3.isObject = he2, X3.isDate = je2, X3.types.isDate = je2, X3.isError = Ae2, X3.types.isNativeError = Ae2, X3.isFunction = we2, X3.isPrimitive = function(e53) {
      return null === e53 || "boolean" == typeof e53 || "number" == typeof e53 || "string" == typeof e53 || "symbol" == typeof e53 || void 0 === e53;
    }, X3.isBuffer = i$14;
    Se2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    X3.log = function() {
      console.log("%s - %s", Be2(), X3.format.apply(X3, arguments));
    }, X3.inherits = t$23, X3._extend = function(e53, t53) {
      if (!t53 || !he2(t53))
        return e53;
      for (var r53 = Object.keys(t53), n53 = r53.length; n53--; )
        e53[r53[n53]] = t53[r53[n53]];
      return e53;
    };
    Ee2 = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
    X3.promisify = function(e53) {
      if ("function" != typeof e53)
        throw new TypeError('The "original" argument must be of type Function');
      if (Ee2 && e53[Ee2]) {
        var t53;
        if ("function" != typeof (t53 = e53[Ee2]))
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(t53, Ee2, { value: t53, enumerable: false, writable: false, configurable: true }), t53;
      }
      function t53() {
        for (var t63, r53, n53 = new Promise(function(e63, n63) {
          t63 = e63, r53 = n63;
        }), i53 = [], o53 = 0; o53 < arguments.length; o53++)
          i53.push(arguments[o53]);
        i53.push(function(e63, n63) {
          e63 ? r53(e63) : t63(n63);
        });
        try {
          e53.apply(this || Q3, i53);
        } catch (e63) {
          r53(e63);
        }
        return n53;
      }
      return Object.setPrototypeOf(t53, Object.getPrototypeOf(e53)), Ee2 && Object.defineProperty(t53, Ee2, { value: t53, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t53, ee2(e53));
    }, X3.promisify.custom = Ee2, X3.callbackify = function(e53) {
      if ("function" != typeof e53)
        throw new TypeError('The "original" argument must be of type Function');
      function t53() {
        for (var t63 = [], r53 = 0; r53 < arguments.length; r53++)
          t63.push(arguments[r53]);
        var n53 = t63.pop();
        if ("function" != typeof n53)
          throw new TypeError("The last argument must be of type Function");
        var i53 = this || Q3, o53 = function() {
          return n53.apply(i53, arguments);
        };
        e53.apply(this || Q3, t63).then(function(e63) {
          Y4.nextTick(o53.bind(null, null, e63));
        }, function(e63) {
          Y4.nextTick(De2.bind(null, e63, o53));
        });
      }
      return Object.setPrototypeOf(t53, Object.getPrototypeOf(e53)), Object.defineProperties(t53, ee2(e53)), t53;
    };
    X3._extend;
    X3.callbackify;
    X3.debuglog;
    X3.deprecate;
    X3.format;
    X3.inherits;
    X3.inspect;
    X3.isArray;
    X3.isBoolean;
    X3.isBuffer;
    X3.isDate;
    X3.isError;
    X3.isFunction;
    X3.isNull;
    X3.isNullOrUndefined;
    X3.isNumber;
    X3.isObject;
    X3.isPrimitive;
    X3.isRegExp;
    X3.isString;
    X3.isSymbol;
    X3.isUndefined;
    X3.log;
    X3.promisify;
    _extend3 = X3._extend;
    callbackify3 = X3.callbackify;
    debuglog3 = X3.debuglog;
    deprecate3 = X3.deprecate;
    format5 = X3.format;
    inherits3 = X3.inherits;
    inspect3 = X3.inspect;
    isArray3 = X3.isArray;
    isBoolean3 = X3.isBoolean;
    isBuffer3 = X3.isBuffer;
    isDate3 = X3.isDate;
    isError3 = X3.isError;
    isFunction3 = X3.isFunction;
    isNull3 = X3.isNull;
    isNullOrUndefined3 = X3.isNullOrUndefined;
    isNumber3 = X3.isNumber;
    isObject3 = X3.isObject;
    isPrimitive3 = X3.isPrimitive;
    isRegExp3 = X3.isRegExp;
    isString3 = X3.isString;
    isSymbol3 = X3.isSymbol;
    isUndefined3 = X3.isUndefined;
    log3 = X3.log;
    promisify3 = X3.promisify;
    types3 = X3.types;
    TextEncoder3 = self.TextEncoder;
    TextDecoder4 = self.TextDecoder;
    exports8 = {};
    _dewExec8 = false;
    _global5 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    process4 = dew8();
    process4.platform = "browser";
    process4.addListener;
    process4.argv;
    process4.binding;
    process4.browser;
    process4.chdir;
    process4.cwd;
    process4.emit;
    process4.env;
    process4.listeners;
    process4.nextTick;
    process4.off;
    process4.on;
    process4.once;
    process4.prependListener;
    process4.prependOnceListener;
    process4.removeAllListeners;
    process4.removeListener;
    process4.title;
    process4.umask;
    process4.version;
    process4.versions;
    for (r$122 = { byteLength: function(r53) {
      var t53 = u$23(r53), e53 = t53[0], n53 = t53[1];
      return 3 * (e53 + n53) / 4 - n53;
    }, toByteArray: function(r53) {
      var t53, o53, a53 = u$23(r53), h53 = a53[0], c53 = a53[1], d43 = new n$23(function(r63, t63, e53) {
        return 3 * (t63 + e53) / 4 - e53;
      }(0, h53, c53)), f53 = 0, A32 = c53 > 0 ? h53 - 4 : h53;
      for (o53 = 0; o53 < A32; o53 += 4)
        t53 = e$23[r53.charCodeAt(o53)] << 18 | e$23[r53.charCodeAt(o53 + 1)] << 12 | e$23[r53.charCodeAt(o53 + 2)] << 6 | e$23[r53.charCodeAt(o53 + 3)], d43[f53++] = t53 >> 16 & 255, d43[f53++] = t53 >> 8 & 255, d43[f53++] = 255 & t53;
      2 === c53 && (t53 = e$23[r53.charCodeAt(o53)] << 2 | e$23[r53.charCodeAt(o53 + 1)] >> 4, d43[f53++] = 255 & t53);
      1 === c53 && (t53 = e$23[r53.charCodeAt(o53)] << 10 | e$23[r53.charCodeAt(o53 + 1)] << 4 | e$23[r53.charCodeAt(o53 + 2)] >> 2, d43[f53++] = t53 >> 8 & 255, d43[f53++] = 255 & t53);
      return d43;
    }, fromByteArray: function(r53) {
      for (var e53, n53 = r53.length, o53 = n53 % 3, a53 = [], h53 = 0, u53 = n53 - o53; h53 < u53; h53 += 16383)
        a53.push(c$122(r53, h53, h53 + 16383 > u53 ? u53 : h53 + 16383));
      1 === o53 ? (e53 = r53[n53 - 1], a53.push(t$122[e53 >> 2] + t$122[e53 << 4 & 63] + "==")) : 2 === o53 && (e53 = (r53[n53 - 2] << 8) + r53[n53 - 1], a53.push(t$122[e53 >> 10] + t$122[e53 >> 4 & 63] + t$122[e53 << 2 & 63] + "="));
      return a53.join("");
    } }, t$122 = [], e$23 = [], n$23 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o$222 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a$13 = 0, h$13 = o$222.length; a$13 < h$13; ++a$13)
      t$122[a$13] = o$222[a$13], e$23[o$222.charCodeAt(a$13)] = a$13;
    e$23["-".charCodeAt(0)] = 62, e$23["_".charCodeAt(0)] = 63;
    a$1$12 = { read: function(a53, t53, o53, r53, h53) {
      var M32, f53, p53 = 8 * h53 - r53 - 1, w32 = (1 << p53) - 1, e53 = w32 >> 1, i53 = -7, N32 = o53 ? h53 - 1 : 0, n53 = o53 ? -1 : 1, u53 = a53[t53 + N32];
      for (N32 += n53, M32 = u53 & (1 << -i53) - 1, u53 >>= -i53, i53 += p53; i53 > 0; M32 = 256 * M32 + a53[t53 + N32], N32 += n53, i53 -= 8)
        ;
      for (f53 = M32 & (1 << -i53) - 1, M32 >>= -i53, i53 += r53; i53 > 0; f53 = 256 * f53 + a53[t53 + N32], N32 += n53, i53 -= 8)
        ;
      if (0 === M32)
        M32 = 1 - e53;
      else {
        if (M32 === w32)
          return f53 ? NaN : 1 / 0 * (u53 ? -1 : 1);
        f53 += Math.pow(2, r53), M32 -= e53;
      }
      return (u53 ? -1 : 1) * f53 * Math.pow(2, M32 - r53);
    }, write: function(a53, t53, o53, r53, h53, M32) {
      var f53, p53, w32, e53 = 8 * M32 - h53 - 1, i53 = (1 << e53) - 1, N32 = i53 >> 1, n53 = 23 === h53 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, u53 = r53 ? 0 : M32 - 1, l53 = r53 ? 1 : -1, s53 = t53 < 0 || 0 === t53 && 1 / t53 < 0 ? 1 : 0;
      for (t53 = Math.abs(t53), isNaN(t53) || t53 === 1 / 0 ? (p53 = isNaN(t53) ? 1 : 0, f53 = i53) : (f53 = Math.floor(Math.log(t53) / Math.LN2), t53 * (w32 = Math.pow(2, -f53)) < 1 && (f53--, w32 *= 2), (t53 += f53 + N32 >= 1 ? n53 / w32 : n53 * Math.pow(2, 1 - N32)) * w32 >= 2 && (f53++, w32 /= 2), f53 + N32 >= i53 ? (p53 = 0, f53 = i53) : f53 + N32 >= 1 ? (p53 = (t53 * w32 - 1) * Math.pow(2, h53), f53 += N32) : (p53 = t53 * Math.pow(2, N32 - 1) * Math.pow(2, h53), f53 = 0)); h53 >= 8; a53[o53 + u53] = 255 & p53, u53 += l53, p53 /= 256, h53 -= 8)
        ;
      for (f53 = f53 << h53 | p53, e53 += h53; e53 > 0; a53[o53 + u53] = 255 & f53, u53 += l53, f53 /= 256, e53 -= 8)
        ;
      a53[o53 + u53 - l53] |= 128 * s53;
    } };
    e$1$12 = {};
    n$1$12 = r$122;
    i$122 = a$1$12;
    o$1$12 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
    e$1$12.Buffer = u$1$12, e$1$12.SlowBuffer = function(t53) {
      +t53 != t53 && (t53 = 0);
      return u$1$12.alloc(+t53);
    }, e$1$12.INSPECT_MAX_BYTES = 50;
    e$1$12.kMaxLength = 2147483647, u$1$12.TYPED_ARRAY_SUPPORT = function() {
      try {
        var t53 = new Uint8Array(1), r53 = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(r53, Uint8Array.prototype), Object.setPrototypeOf(t53, r53), 42 === t53.foo();
      } catch (t63) {
        return false;
      }
    }(), u$1$12.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u$1$12.prototype, "parent", { enumerable: true, get: function() {
      if (u$1$12.isBuffer(this))
        return this.buffer;
    } }), Object.defineProperty(u$1$12.prototype, "offset", { enumerable: true, get: function() {
      if (u$1$12.isBuffer(this))
        return this.byteOffset;
    } }), u$1$12.poolSize = 8192, u$1$12.from = function(t53, r53, e53) {
      return s$13(t53, r53, e53);
    }, Object.setPrototypeOf(u$1$12.prototype, Uint8Array.prototype), Object.setPrototypeOf(u$1$12, Uint8Array), u$1$12.alloc = function(t53, r53, e53) {
      return function(t63, r63, e63) {
        return h$1$12(t63), t63 <= 0 ? f$23(t63) : void 0 !== r63 ? "string" == typeof e63 ? f$23(t63).fill(r63, e63) : f$23(t63).fill(r63) : f$23(t63);
      }(t53, r53, e53);
    }, u$1$12.allocUnsafe = function(t53) {
      return a$23(t53);
    }, u$1$12.allocUnsafeSlow = function(t53) {
      return a$23(t53);
    }, u$1$12.isBuffer = function(t53) {
      return null != t53 && true === t53._isBuffer && t53 !== u$1$12.prototype;
    }, u$1$12.compare = function(t53, r53) {
      if (F22(t53, Uint8Array) && (t53 = u$1$12.from(t53, t53.offset, t53.byteLength)), F22(r53, Uint8Array) && (r53 = u$1$12.from(r53, r53.offset, r53.byteLength)), !u$1$12.isBuffer(t53) || !u$1$12.isBuffer(r53))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t53 === r53)
        return 0;
      for (var e53 = t53.length, n53 = r53.length, i53 = 0, o53 = Math.min(e53, n53); i53 < o53; ++i53)
        if (t53[i53] !== r53[i53]) {
          e53 = t53[i53], n53 = r53[i53];
          break;
        }
      return e53 < n53 ? -1 : n53 < e53 ? 1 : 0;
    }, u$1$12.isEncoding = function(t53) {
      switch (String(t53).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, u$1$12.concat = function(t53, r53) {
      if (!Array.isArray(t53))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (0 === t53.length)
        return u$1$12.alloc(0);
      var e53;
      if (void 0 === r53)
        for (r53 = 0, e53 = 0; e53 < t53.length; ++e53)
          r53 += t53[e53].length;
      var n53 = u$1$12.allocUnsafe(r53), i53 = 0;
      for (e53 = 0; e53 < t53.length; ++e53) {
        var o53 = t53[e53];
        if (F22(o53, Uint8Array) && (o53 = u$1$12.from(o53)), !u$1$12.isBuffer(o53))
          throw new TypeError('"list" argument must be an Array of Buffers');
        o53.copy(n53, i53), i53 += o53.length;
      }
      return n53;
    }, u$1$12.byteLength = y32, u$1$12.prototype._isBuffer = true, u$1$12.prototype.swap16 = function() {
      var t53 = this.length;
      if (t53 % 2 != 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var r53 = 0; r53 < t53; r53 += 2)
        w22(this, r53, r53 + 1);
      return this;
    }, u$1$12.prototype.swap32 = function() {
      var t53 = this.length;
      if (t53 % 4 != 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var r53 = 0; r53 < t53; r53 += 4)
        w22(this, r53, r53 + 3), w22(this, r53 + 1, r53 + 2);
      return this;
    }, u$1$12.prototype.swap64 = function() {
      var t53 = this.length;
      if (t53 % 8 != 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var r53 = 0; r53 < t53; r53 += 8)
        w22(this, r53, r53 + 7), w22(this, r53 + 1, r53 + 6), w22(this, r53 + 2, r53 + 5), w22(this, r53 + 3, r53 + 4);
      return this;
    }, u$1$12.prototype.toString = function() {
      var t53 = this.length;
      return 0 === t53 ? "" : 0 === arguments.length ? I22(this, 0, t53) : g22.apply(this, arguments);
    }, u$1$12.prototype.toLocaleString = u$1$12.prototype.toString, u$1$12.prototype.equals = function(t53) {
      if (!u$1$12.isBuffer(t53))
        throw new TypeError("Argument must be a Buffer");
      return this === t53 || 0 === u$1$12.compare(this, t53);
    }, u$1$12.prototype.inspect = function() {
      var t53 = "", r53 = e$1$12.INSPECT_MAX_BYTES;
      return t53 = this.toString("hex", 0, r53).replace(/(.{2})/g, "$1 ").trim(), this.length > r53 && (t53 += " ... "), "<Buffer " + t53 + ">";
    }, o$1$12 && (u$1$12.prototype[o$1$12] = u$1$12.prototype.inspect), u$1$12.prototype.compare = function(t53, r53, e53, n53, i53) {
      if (F22(t53, Uint8Array) && (t53 = u$1$12.from(t53, t53.offset, t53.byteLength)), !u$1$12.isBuffer(t53))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t53);
      if (void 0 === r53 && (r53 = 0), void 0 === e53 && (e53 = t53 ? t53.length : 0), void 0 === n53 && (n53 = 0), void 0 === i53 && (i53 = this.length), r53 < 0 || e53 > t53.length || n53 < 0 || i53 > this.length)
        throw new RangeError("out of range index");
      if (n53 >= i53 && r53 >= e53)
        return 0;
      if (n53 >= i53)
        return -1;
      if (r53 >= e53)
        return 1;
      if (this === t53)
        return 0;
      for (var o53 = (i53 >>>= 0) - (n53 >>>= 0), f53 = (e53 >>>= 0) - (r53 >>>= 0), s53 = Math.min(o53, f53), h53 = this.slice(n53, i53), a53 = t53.slice(r53, e53), p53 = 0; p53 < s53; ++p53)
        if (h53[p53] !== a53[p53]) {
          o53 = h53[p53], f53 = a53[p53];
          break;
        }
      return o53 < f53 ? -1 : f53 < o53 ? 1 : 0;
    }, u$1$12.prototype.includes = function(t53, r53, e53) {
      return -1 !== this.indexOf(t53, r53, e53);
    }, u$1$12.prototype.indexOf = function(t53, r53, e53) {
      return d32(this, t53, r53, e53, true);
    }, u$1$12.prototype.lastIndexOf = function(t53, r53, e53) {
      return d32(this, t53, r53, e53, false);
    }, u$1$12.prototype.write = function(t53, r53, e53, n53) {
      if (void 0 === r53)
        n53 = "utf8", e53 = this.length, r53 = 0;
      else if (void 0 === e53 && "string" == typeof r53)
        n53 = r53, e53 = this.length, r53 = 0;
      else {
        if (!isFinite(r53))
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        r53 >>>= 0, isFinite(e53) ? (e53 >>>= 0, void 0 === n53 && (n53 = "utf8")) : (n53 = e53, e53 = void 0);
      }
      var i53 = this.length - r53;
      if ((void 0 === e53 || e53 > i53) && (e53 = i53), t53.length > 0 && (e53 < 0 || r53 < 0) || r53 > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      n53 || (n53 = "utf8");
      for (var o53 = false; ; )
        switch (n53) {
          case "hex":
            return b22(this, t53, r53, e53);
          case "utf8":
          case "utf-8":
            return m32(this, t53, r53, e53);
          case "ascii":
            return E22(this, t53, r53, e53);
          case "latin1":
          case "binary":
            return B22(this, t53, r53, e53);
          case "base64":
            return A22(this, t53, r53, e53);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return U22(this, t53, r53, e53);
          default:
            if (o53)
              throw new TypeError("Unknown encoding: " + n53);
            n53 = ("" + n53).toLowerCase(), o53 = true;
        }
    }, u$1$12.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    u$1$12.prototype.slice = function(t53, r53) {
      var e53 = this.length;
      (t53 = ~~t53) < 0 ? (t53 += e53) < 0 && (t53 = 0) : t53 > e53 && (t53 = e53), (r53 = void 0 === r53 ? e53 : ~~r53) < 0 ? (r53 += e53) < 0 && (r53 = 0) : r53 > e53 && (r53 = e53), r53 < t53 && (r53 = t53);
      var n53 = this.subarray(t53, r53);
      return Object.setPrototypeOf(n53, u$1$12.prototype), n53;
    }, u$1$12.prototype.readUIntLE = function(t53, r53, e53) {
      t53 >>>= 0, r53 >>>= 0, e53 || x22(t53, r53, this.length);
      for (var n53 = this[t53], i53 = 1, o53 = 0; ++o53 < r53 && (i53 *= 256); )
        n53 += this[t53 + o53] * i53;
      return n53;
    }, u$1$12.prototype.readUIntBE = function(t53, r53, e53) {
      t53 >>>= 0, r53 >>>= 0, e53 || x22(t53, r53, this.length);
      for (var n53 = this[t53 + --r53], i53 = 1; r53 > 0 && (i53 *= 256); )
        n53 += this[t53 + --r53] * i53;
      return n53;
    }, u$1$12.prototype.readUInt8 = function(t53, r53) {
      return t53 >>>= 0, r53 || x22(t53, 1, this.length), this[t53];
    }, u$1$12.prototype.readUInt16LE = function(t53, r53) {
      return t53 >>>= 0, r53 || x22(t53, 2, this.length), this[t53] | this[t53 + 1] << 8;
    }, u$1$12.prototype.readUInt16BE = function(t53, r53) {
      return t53 >>>= 0, r53 || x22(t53, 2, this.length), this[t53] << 8 | this[t53 + 1];
    }, u$1$12.prototype.readUInt32LE = function(t53, r53) {
      return t53 >>>= 0, r53 || x22(t53, 4, this.length), (this[t53] | this[t53 + 1] << 8 | this[t53 + 2] << 16) + 16777216 * this[t53 + 3];
    }, u$1$12.prototype.readUInt32BE = function(t53, r53) {
      return t53 >>>= 0, r53 || x22(t53, 4, this.length), 16777216 * this[t53] + (this[t53 + 1] << 16 | this[t53 + 2] << 8 | this[t53 + 3]);
    }, u$1$12.prototype.readIntLE = function(t53, r53, e53) {
      t53 >>>= 0, r53 >>>= 0, e53 || x22(t53, r53, this.length);
      for (var n53 = this[t53], i53 = 1, o53 = 0; ++o53 < r53 && (i53 *= 256); )
        n53 += this[t53 + o53] * i53;
      return n53 >= (i53 *= 128) && (n53 -= Math.pow(2, 8 * r53)), n53;
    }, u$1$12.prototype.readIntBE = function(t53, r53, e53) {
      t53 >>>= 0, r53 >>>= 0, e53 || x22(t53, r53, this.length);
      for (var n53 = r53, i53 = 1, o53 = this[t53 + --n53]; n53 > 0 && (i53 *= 256); )
        o53 += this[t53 + --n53] * i53;
      return o53 >= (i53 *= 128) && (o53 -= Math.pow(2, 8 * r53)), o53;
    }, u$1$12.prototype.readInt8 = function(t53, r53) {
      return t53 >>>= 0, r53 || x22(t53, 1, this.length), 128 & this[t53] ? -1 * (255 - this[t53] + 1) : this[t53];
    }, u$1$12.prototype.readInt16LE = function(t53, r53) {
      t53 >>>= 0, r53 || x22(t53, 2, this.length);
      var e53 = this[t53] | this[t53 + 1] << 8;
      return 32768 & e53 ? 4294901760 | e53 : e53;
    }, u$1$12.prototype.readInt16BE = function(t53, r53) {
      t53 >>>= 0, r53 || x22(t53, 2, this.length);
      var e53 = this[t53 + 1] | this[t53] << 8;
      return 32768 & e53 ? 4294901760 | e53 : e53;
    }, u$1$12.prototype.readInt32LE = function(t53, r53) {
      return t53 >>>= 0, r53 || x22(t53, 4, this.length), this[t53] | this[t53 + 1] << 8 | this[t53 + 2] << 16 | this[t53 + 3] << 24;
    }, u$1$12.prototype.readInt32BE = function(t53, r53) {
      return t53 >>>= 0, r53 || x22(t53, 4, this.length), this[t53] << 24 | this[t53 + 1] << 16 | this[t53 + 2] << 8 | this[t53 + 3];
    }, u$1$12.prototype.readFloatLE = function(t53, r53) {
      return t53 >>>= 0, r53 || x22(t53, 4, this.length), i$122.read(this, t53, true, 23, 4);
    }, u$1$12.prototype.readFloatBE = function(t53, r53) {
      return t53 >>>= 0, r53 || x22(t53, 4, this.length), i$122.read(this, t53, false, 23, 4);
    }, u$1$12.prototype.readDoubleLE = function(t53, r53) {
      return t53 >>>= 0, r53 || x22(t53, 8, this.length), i$122.read(this, t53, true, 52, 8);
    }, u$1$12.prototype.readDoubleBE = function(t53, r53) {
      return t53 >>>= 0, r53 || x22(t53, 8, this.length), i$122.read(this, t53, false, 52, 8);
    }, u$1$12.prototype.writeUIntLE = function(t53, r53, e53, n53) {
      (t53 = +t53, r53 >>>= 0, e53 >>>= 0, n53) || C22(this, t53, r53, e53, Math.pow(2, 8 * e53) - 1, 0);
      var i53 = 1, o53 = 0;
      for (this[r53] = 255 & t53; ++o53 < e53 && (i53 *= 256); )
        this[r53 + o53] = t53 / i53 & 255;
      return r53 + e53;
    }, u$1$12.prototype.writeUIntBE = function(t53, r53, e53, n53) {
      (t53 = +t53, r53 >>>= 0, e53 >>>= 0, n53) || C22(this, t53, r53, e53, Math.pow(2, 8 * e53) - 1, 0);
      var i53 = e53 - 1, o53 = 1;
      for (this[r53 + i53] = 255 & t53; --i53 >= 0 && (o53 *= 256); )
        this[r53 + i53] = t53 / o53 & 255;
      return r53 + e53;
    }, u$1$12.prototype.writeUInt8 = function(t53, r53, e53) {
      return t53 = +t53, r53 >>>= 0, e53 || C22(this, t53, r53, 1, 255, 0), this[r53] = 255 & t53, r53 + 1;
    }, u$1$12.prototype.writeUInt16LE = function(t53, r53, e53) {
      return t53 = +t53, r53 >>>= 0, e53 || C22(this, t53, r53, 2, 65535, 0), this[r53] = 255 & t53, this[r53 + 1] = t53 >>> 8, r53 + 2;
    }, u$1$12.prototype.writeUInt16BE = function(t53, r53, e53) {
      return t53 = +t53, r53 >>>= 0, e53 || C22(this, t53, r53, 2, 65535, 0), this[r53] = t53 >>> 8, this[r53 + 1] = 255 & t53, r53 + 2;
    }, u$1$12.prototype.writeUInt32LE = function(t53, r53, e53) {
      return t53 = +t53, r53 >>>= 0, e53 || C22(this, t53, r53, 4, 4294967295, 0), this[r53 + 3] = t53 >>> 24, this[r53 + 2] = t53 >>> 16, this[r53 + 1] = t53 >>> 8, this[r53] = 255 & t53, r53 + 4;
    }, u$1$12.prototype.writeUInt32BE = function(t53, r53, e53) {
      return t53 = +t53, r53 >>>= 0, e53 || C22(this, t53, r53, 4, 4294967295, 0), this[r53] = t53 >>> 24, this[r53 + 1] = t53 >>> 16, this[r53 + 2] = t53 >>> 8, this[r53 + 3] = 255 & t53, r53 + 4;
    }, u$1$12.prototype.writeIntLE = function(t53, r53, e53, n53) {
      if (t53 = +t53, r53 >>>= 0, !n53) {
        var i53 = Math.pow(2, 8 * e53 - 1);
        C22(this, t53, r53, e53, i53 - 1, -i53);
      }
      var o53 = 0, f53 = 1, u53 = 0;
      for (this[r53] = 255 & t53; ++o53 < e53 && (f53 *= 256); )
        t53 < 0 && 0 === u53 && 0 !== this[r53 + o53 - 1] && (u53 = 1), this[r53 + o53] = (t53 / f53 >> 0) - u53 & 255;
      return r53 + e53;
    }, u$1$12.prototype.writeIntBE = function(t53, r53, e53, n53) {
      if (t53 = +t53, r53 >>>= 0, !n53) {
        var i53 = Math.pow(2, 8 * e53 - 1);
        C22(this, t53, r53, e53, i53 - 1, -i53);
      }
      var o53 = e53 - 1, f53 = 1, u53 = 0;
      for (this[r53 + o53] = 255 & t53; --o53 >= 0 && (f53 *= 256); )
        t53 < 0 && 0 === u53 && 0 !== this[r53 + o53 + 1] && (u53 = 1), this[r53 + o53] = (t53 / f53 >> 0) - u53 & 255;
      return r53 + e53;
    }, u$1$12.prototype.writeInt8 = function(t53, r53, e53) {
      return t53 = +t53, r53 >>>= 0, e53 || C22(this, t53, r53, 1, 127, -128), t53 < 0 && (t53 = 255 + t53 + 1), this[r53] = 255 & t53, r53 + 1;
    }, u$1$12.prototype.writeInt16LE = function(t53, r53, e53) {
      return t53 = +t53, r53 >>>= 0, e53 || C22(this, t53, r53, 2, 32767, -32768), this[r53] = 255 & t53, this[r53 + 1] = t53 >>> 8, r53 + 2;
    }, u$1$12.prototype.writeInt16BE = function(t53, r53, e53) {
      return t53 = +t53, r53 >>>= 0, e53 || C22(this, t53, r53, 2, 32767, -32768), this[r53] = t53 >>> 8, this[r53 + 1] = 255 & t53, r53 + 2;
    }, u$1$12.prototype.writeInt32LE = function(t53, r53, e53) {
      return t53 = +t53, r53 >>>= 0, e53 || C22(this, t53, r53, 4, 2147483647, -2147483648), this[r53] = 255 & t53, this[r53 + 1] = t53 >>> 8, this[r53 + 2] = t53 >>> 16, this[r53 + 3] = t53 >>> 24, r53 + 4;
    }, u$1$12.prototype.writeInt32BE = function(t53, r53, e53) {
      return t53 = +t53, r53 >>>= 0, e53 || C22(this, t53, r53, 4, 2147483647, -2147483648), t53 < 0 && (t53 = 4294967295 + t53 + 1), this[r53] = t53 >>> 24, this[r53 + 1] = t53 >>> 16, this[r53 + 2] = t53 >>> 8, this[r53 + 3] = 255 & t53, r53 + 4;
    }, u$1$12.prototype.writeFloatLE = function(t53, r53, e53) {
      return k22(this, t53, r53, true, e53);
    }, u$1$12.prototype.writeFloatBE = function(t53, r53, e53) {
      return k22(this, t53, r53, false, e53);
    }, u$1$12.prototype.writeDoubleLE = function(t53, r53, e53) {
      return M22(this, t53, r53, true, e53);
    }, u$1$12.prototype.writeDoubleBE = function(t53, r53, e53) {
      return M22(this, t53, r53, false, e53);
    }, u$1$12.prototype.copy = function(t53, r53, e53, n53) {
      if (!u$1$12.isBuffer(t53))
        throw new TypeError("argument should be a Buffer");
      if (e53 || (e53 = 0), n53 || 0 === n53 || (n53 = this.length), r53 >= t53.length && (r53 = t53.length), r53 || (r53 = 0), n53 > 0 && n53 < e53 && (n53 = e53), n53 === e53)
        return 0;
      if (0 === t53.length || 0 === this.length)
        return 0;
      if (r53 < 0)
        throw new RangeError("targetStart out of bounds");
      if (e53 < 0 || e53 >= this.length)
        throw new RangeError("Index out of range");
      if (n53 < 0)
        throw new RangeError("sourceEnd out of bounds");
      n53 > this.length && (n53 = this.length), t53.length - r53 < n53 - e53 && (n53 = t53.length - r53 + e53);
      var i53 = n53 - e53;
      if (this === t53 && "function" == typeof Uint8Array.prototype.copyWithin)
        this.copyWithin(r53, e53, n53);
      else if (this === t53 && e53 < r53 && r53 < n53)
        for (var o53 = i53 - 1; o53 >= 0; --o53)
          t53[o53 + r53] = this[o53 + e53];
      else
        Uint8Array.prototype.set.call(t53, this.subarray(e53, n53), r53);
      return i53;
    }, u$1$12.prototype.fill = function(t53, r53, e53, n53) {
      if ("string" == typeof t53) {
        if ("string" == typeof r53 ? (n53 = r53, r53 = 0, e53 = this.length) : "string" == typeof e53 && (n53 = e53, e53 = this.length), void 0 !== n53 && "string" != typeof n53)
          throw new TypeError("encoding must be a string");
        if ("string" == typeof n53 && !u$1$12.isEncoding(n53))
          throw new TypeError("Unknown encoding: " + n53);
        if (1 === t53.length) {
          var i53 = t53.charCodeAt(0);
          ("utf8" === n53 && i53 < 128 || "latin1" === n53) && (t53 = i53);
        }
      } else
        "number" == typeof t53 ? t53 &= 255 : "boolean" == typeof t53 && (t53 = Number(t53));
      if (r53 < 0 || this.length < r53 || this.length < e53)
        throw new RangeError("Out of range index");
      if (e53 <= r53)
        return this;
      var o53;
      if (r53 >>>= 0, e53 = void 0 === e53 ? this.length : e53 >>> 0, t53 || (t53 = 0), "number" == typeof t53)
        for (o53 = r53; o53 < e53; ++o53)
          this[o53] = t53;
      else {
        var f53 = u$1$12.isBuffer(t53) ? t53 : u$1$12.from(t53, n53), s53 = f53.length;
        if (0 === s53)
          throw new TypeError('The value "' + t53 + '" is invalid for argument "value"');
        for (o53 = 0; o53 < e53 - r53; ++o53)
          this[o53 + r53] = f53[o53 % s53];
      }
      return this;
    };
    j22 = /[^+/0-9A-Za-z-_]/g;
    Y22 = function() {
      for (var t53 = new Array(256), r53 = 0; r53 < 16; ++r53)
        for (var e53 = 16 * r53, n53 = 0; n53 < 16; ++n53)
          t53[e53 + n53] = "0123456789abcdef"[r53] + "0123456789abcdef"[n53];
      return t53;
    }();
    e$1$12.Buffer;
    e$1$12.INSPECT_MAX_BYTES;
    e$1$12.kMaxLength;
    e42 = {};
    n42 = e$1$12;
    o42 = n42.Buffer;
    o42.from && o42.alloc && o42.allocUnsafe && o42.allocUnsafeSlow ? e42 = n42 : (t42(n42, e42), e42.Buffer = f42), f42.prototype = Object.create(o42.prototype), t42(o42, f42), f42.from = function(r53, e53, n53) {
      if ("number" == typeof r53)
        throw new TypeError("Argument must not be a number");
      return o42(r53, e53, n53);
    }, f42.alloc = function(r53, e53, n53) {
      if ("number" != typeof r53)
        throw new TypeError("Argument must be a number");
      var t53 = o42(r53);
      return void 0 !== e53 ? "string" == typeof n53 ? t53.fill(e53, n53) : t53.fill(e53) : t53.fill(0), t53;
    }, f42.allocUnsafe = function(r53) {
      if ("number" != typeof r53)
        throw new TypeError("Argument must be a number");
      return o42(r53);
    }, f42.allocUnsafeSlow = function(r53) {
      if ("number" != typeof r53)
        throw new TypeError("Argument must be a number");
      return n42.SlowBuffer(r53);
    };
    u42 = e42;
    e$122 = {};
    s42 = u42.Buffer;
    i42 = s42.isEncoding || function(t53) {
      switch ((t53 = "" + t53) && t53.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    e$122.StringDecoder = a42, a42.prototype.write = function(t53) {
      if (0 === t53.length)
        return "";
      var e53, s53;
      if (this.lastNeed) {
        if (void 0 === (e53 = this.fillLast(t53)))
          return "";
        s53 = this.lastNeed, this.lastNeed = 0;
      } else
        s53 = 0;
      return s53 < t53.length ? e53 ? e53 + this.text(t53, s53) : this.text(t53, s53) : e53 || "";
    }, a42.prototype.end = function(t53) {
      var e53 = t53 && t53.length ? this.write(t53) : "";
      return this.lastNeed ? e53 + "\uFFFD" : e53;
    }, a42.prototype.text = function(t53, e53) {
      var s53 = function(t63, e63, s62) {
        var i63 = e63.length - 1;
        if (i63 < s62)
          return 0;
        var a53 = r42(e63[i63]);
        if (a53 >= 0)
          return a53 > 0 && (t63.lastNeed = a53 - 1), a53;
        if (--i63 < s62 || -2 === a53)
          return 0;
        if ((a53 = r42(e63[i63])) >= 0)
          return a53 > 0 && (t63.lastNeed = a53 - 2), a53;
        if (--i63 < s62 || -2 === a53)
          return 0;
        if ((a53 = r42(e63[i63])) >= 0)
          return a53 > 0 && (2 === a53 ? a53 = 0 : t63.lastNeed = a53 - 3), a53;
        return 0;
      }(this, t53, e53);
      if (!this.lastNeed)
        return t53.toString("utf8", e53);
      this.lastTotal = s53;
      var i53 = t53.length - (s53 - this.lastNeed);
      return t53.copy(this.lastChar, 0, i53), t53.toString("utf8", e53, i53);
    }, a42.prototype.fillLast = function(t53) {
      if (this.lastNeed <= t53.length)
        return t53.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t53.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t53.length), this.lastNeed -= t53.length;
    };
    e$122.StringDecoder;
    e$122.StringDecoder;
    exports$2$12 = {};
    _dewExec$2$12 = false;
    exports$1$12 = {};
    _dewExec$1$12 = false;
    exports$g3 = {};
    _dewExec$g2 = false;
    buffer2 = dew$g2();
    buffer2.Buffer;
    buffer2.INSPECT_MAX_BYTES;
    buffer2.kMaxLength;
    exports$f3 = {};
    _dewExec$f3 = false;
    exports$e3 = {};
    _dewExec$e3 = false;
    exports$d3 = {};
    _dewExec$d3 = false;
    exports$c3 = {};
    _dewExec$c3 = false;
    exports$b3 = {};
    _dewExec$b3 = false;
    exports$a3 = {};
    _dewExec$a3 = false;
    exports$93 = {};
    _dewExec$93 = false;
    _global$23 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$83 = {};
    _dewExec$83 = false;
    _global$13 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$73 = {};
    _dewExec$73 = false;
    exports$63 = {};
    _dewExec$63 = false;
    exports$53 = {};
    _dewExec$53 = false;
    exports$43 = {};
    _dewExec$43 = false;
    exports$34 = {};
    _dewExec$33 = false;
    _global23 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$24 = {};
    _dewExec$24 = false;
    exports$16 = {};
    _dewExec$14 = false;
    exports23 = {};
    _dewExec23 = false;
    exports$123 = {};
    _dewExec33 = false;
    _global32 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports33 = dew33();
    _extend22 = X3._extend;
    callbackify22 = X3.callbackify;
    debuglog22 = X3.debuglog;
    deprecate22 = X3.deprecate;
    format23 = X3.format;
    inherits22 = X3.inherits;
    inspect22 = X3.inspect;
    isArray22 = X3.isArray;
    isBoolean22 = X3.isBoolean;
    isBuffer22 = X3.isBuffer;
    isDate22 = X3.isDate;
    isError22 = X3.isError;
    isFunction22 = X3.isFunction;
    isNull22 = X3.isNull;
    isNullOrUndefined22 = X3.isNullOrUndefined;
    isNumber22 = X3.isNumber;
    isObject22 = X3.isObject;
    isPrimitive22 = X3.isPrimitive;
    isRegExp22 = X3.isRegExp;
    isString22 = X3.isString;
    isSymbol22 = X3.isSymbol;
    isUndefined22 = X3.isUndefined;
    log22 = X3.log;
    promisify22 = X3.promisify;
    types22 = X3.types;
    TextEncoder22 = X3.TextEncoder = globalThis.TextEncoder;
    TextDecoder22 = X3.TextDecoder = globalThis.TextDecoder;
    Readable2 = exports33.Readable;
    Readable2.wrap = function(src, options) {
      options = Object.assign({ objectMode: src.readableObjectMode != null || src.objectMode != null || true }, options);
      options.destroy = function(err, callback) {
        src.destroy(err);
        callback(err);
      };
      return new Readable2(options).wrap(src);
    };
    Writable2 = exports33.Writable;
    Duplex2 = exports33.Duplex;
    Transform2 = exports33.Transform;
    PassThrough2 = exports33.PassThrough;
    finished2 = exports33.finished;
    pipeline2 = exports33.pipeline;
    Stream2 = exports33.Stream;
    promises3 = {
      finished: promisify22(exports33.finished),
      pipeline: promisify22(exports33.pipeline)
    };
  }
});

// node-modules-polyfills-commonjs:stream
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex2,
  PassThrough: () => PassThrough2,
  Readable: () => Readable2,
  Stream: () => Stream2,
  Transform: () => Transform2,
  Writable: () => Writable2,
  finished: () => finished2,
  pipeline: () => pipeline2,
  promises: () => promises3
});
var init_stream2 = __esm({
  "node-modules-polyfills-commonjs:stream"() {
    init_stream();
  }
});

// node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js"(exports10, module2) {
    var Stream3 = (init_stream2(), __toCommonJS(stream_exports)).Stream;
    module2.exports = legacy;
    function legacy(fs2) {
      return {
        ReadStream: ReadStream2,
        WriteStream: WriteStream2
      };
      function ReadStream2(path3, options) {
        if (!(this instanceof ReadStream2))
          return new ReadStream2(path3, options);
        Stream3.call(this);
        var self2 = this;
        this.path = path3;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs2.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream2(path3, options) {
        if (!(this instanceof WriteStream2))
          return new WriteStream2(path3, options);
        Stream3.call(this);
        this.path = path3;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs2.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js"(exports10, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// node-modules-polyfills:util
function i9() {
  throw new Error("setTimeout has not been defined");
}
function u9() {
  throw new Error("clearTimeout has not been defined");
}
function c9(e35) {
  if (t9 === setTimeout)
    return setTimeout(e35, 0);
  if ((t9 === i9 || !t9) && setTimeout)
    return t9 = setTimeout, setTimeout(e35, 0);
  try {
    return t9(e35, 0);
  } catch (n35) {
    try {
      return t9.call(null, e35, 0);
    } catch (n44) {
      return t9.call(this || r10, e35, 0);
    }
  }
}
function h9() {
  f9 && l9 && (f9 = false, l9.length ? s8 = l9.concat(s8) : a9 = -1, s8.length && d7());
}
function d7() {
  if (!f9) {
    var e35 = c9(h9);
    f9 = true;
    for (var t35 = s8.length; t35; ) {
      for (l9 = s8, s8 = []; ++a9 < t35; )
        l9 && l9[a9].run();
      a9 = -1, t35 = s8.length;
    }
    l9 = null, f9 = false, function(e44) {
      if (n10 === clearTimeout)
        return clearTimeout(e44);
      if ((n10 === u9 || !n10) && clearTimeout)
        return n10 = clearTimeout, clearTimeout(e44);
      try {
        n10(e44);
      } catch (t44) {
        try {
          return n10.call(null, e44);
        } catch (t53) {
          return n10.call(this || r10, e44);
        }
      }
    }(e35);
  }
}
function m7(e35, t35) {
  (this || r10).fun = e35, (this || r10).array = t35;
}
function p9() {
}
function c$15(e35) {
  return e35.call.bind(e35);
}
function O6(e35, t35) {
  if ("object" != typeof e35)
    return false;
  try {
    return t35(e35), true;
  } catch (e44) {
    return false;
  }
}
function S5(e35) {
  return l$15 && y7 ? void 0 !== b6(e35) : B5(e35) || k5(e35) || E5(e35) || D5(e35) || U5(e35) || P5(e35) || x5(e35) || I5(e35) || M5(e35) || z5(e35) || F5(e35);
}
function B5(e35) {
  return l$15 && y7 ? "Uint8Array" === b6(e35) : "[object Uint8Array]" === m23(e35) || u$15(e35) && void 0 !== e35.buffer;
}
function k5(e35) {
  return l$15 && y7 ? "Uint8ClampedArray" === b6(e35) : "[object Uint8ClampedArray]" === m23(e35);
}
function E5(e35) {
  return l$15 && y7 ? "Uint16Array" === b6(e35) : "[object Uint16Array]" === m23(e35);
}
function D5(e35) {
  return l$15 && y7 ? "Uint32Array" === b6(e35) : "[object Uint32Array]" === m23(e35);
}
function U5(e35) {
  return l$15 && y7 ? "Int8Array" === b6(e35) : "[object Int8Array]" === m23(e35);
}
function P5(e35) {
  return l$15 && y7 ? "Int16Array" === b6(e35) : "[object Int16Array]" === m23(e35);
}
function x5(e35) {
  return l$15 && y7 ? "Int32Array" === b6(e35) : "[object Int32Array]" === m23(e35);
}
function I5(e35) {
  return l$15 && y7 ? "Float32Array" === b6(e35) : "[object Float32Array]" === m23(e35);
}
function M5(e35) {
  return l$15 && y7 ? "Float64Array" === b6(e35) : "[object Float64Array]" === m23(e35);
}
function z5(e35) {
  return l$15 && y7 ? "BigInt64Array" === b6(e35) : "[object BigInt64Array]" === m23(e35);
}
function F5(e35) {
  return l$15 && y7 ? "BigUint64Array" === b6(e35) : "[object BigUint64Array]" === m23(e35);
}
function T23(e35) {
  return "[object Map]" === m23(e35);
}
function N5(e35) {
  return "[object Set]" === m23(e35);
}
function W4(e35) {
  return "[object WeakMap]" === m23(e35);
}
function $4(e35) {
  return "[object WeakSet]" === m23(e35);
}
function C5(e35) {
  return "[object ArrayBuffer]" === m23(e35);
}
function V4(e35) {
  return "undefined" != typeof ArrayBuffer && (C5.working ? C5(e35) : e35 instanceof ArrayBuffer);
}
function G4(e35) {
  return "[object DataView]" === m23(e35);
}
function R5(e35) {
  return "undefined" != typeof DataView && (G4.working ? G4(e35) : e35 instanceof DataView);
}
function J4(e35) {
  return "[object SharedArrayBuffer]" === m23(e35);
}
function _5(e35) {
  return "undefined" != typeof SharedArrayBuffer && (J4.working ? J4(e35) : e35 instanceof SharedArrayBuffer);
}
function H4(e35) {
  return O6(e35, h23);
}
function Z4(e35) {
  return O6(e35, j5);
}
function q4(e35) {
  return O6(e35, A5);
}
function K4(e35) {
  return s23 && O6(e35, w5);
}
function L5(e35) {
  return p23 && O6(e35, v7);
}
function oe3(e35, t35) {
  var r35 = { seen: [], stylize: fe3 };
  return arguments.length >= 3 && (r35.depth = arguments[2]), arguments.length >= 4 && (r35.colors = arguments[3]), ye3(t35) ? r35.showHidden = t35 : t35 && X4._extend(r35, t35), be3(r35.showHidden) && (r35.showHidden = false), be3(r35.depth) && (r35.depth = 2), be3(r35.colors) && (r35.colors = false), be3(r35.customInspect) && (r35.customInspect = true), r35.colors && (r35.stylize = ue3), ae3(r35, e35, r35.depth);
}
function ue3(e35, t35) {
  var r35 = oe3.styles[t35];
  return r35 ? "\x1B[" + oe3.colors[r35][0] + "m" + e35 + "\x1B[" + oe3.colors[r35][1] + "m" : e35;
}
function fe3(e35, t35) {
  return e35;
}
function ae3(e35, t35, r35) {
  if (e35.customInspect && t35 && we3(t35.inspect) && t35.inspect !== X4.inspect && (!t35.constructor || t35.constructor.prototype !== t35)) {
    var n35 = t35.inspect(r35, e35);
    return ge3(n35) || (n35 = ae3(e35, n35, r35)), n35;
  }
  var i35 = function(e44, t44) {
    if (be3(t44))
      return e44.stylize("undefined", "undefined");
    if (ge3(t44)) {
      var r44 = "'" + JSON.stringify(t44).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return e44.stylize(r44, "string");
    }
    if (de3(t44))
      return e44.stylize("" + t44, "number");
    if (ye3(t44))
      return e44.stylize("" + t44, "boolean");
    if (le3(t44))
      return e44.stylize("null", "null");
  }(e35, t35);
  if (i35)
    return i35;
  var o35 = Object.keys(t35), u35 = function(e44) {
    var t44 = {};
    return e44.forEach(function(e53, r44) {
      t44[e53] = true;
    }), t44;
  }(o35);
  if (e35.showHidden && (o35 = Object.getOwnPropertyNames(t35)), Ae3(t35) && (o35.indexOf("message") >= 0 || o35.indexOf("description") >= 0))
    return ce3(t35);
  if (0 === o35.length) {
    if (we3(t35)) {
      var f35 = t35.name ? ": " + t35.name : "";
      return e35.stylize("[Function" + f35 + "]", "special");
    }
    if (me3(t35))
      return e35.stylize(RegExp.prototype.toString.call(t35), "regexp");
    if (je3(t35))
      return e35.stylize(Date.prototype.toString.call(t35), "date");
    if (Ae3(t35))
      return ce3(t35);
  }
  var a35, c35 = "", s35 = false, p35 = ["{", "}"];
  (pe3(t35) && (s35 = true, p35 = ["[", "]"]), we3(t35)) && (c35 = " [Function" + (t35.name ? ": " + t35.name : "") + "]");
  return me3(t35) && (c35 = " " + RegExp.prototype.toString.call(t35)), je3(t35) && (c35 = " " + Date.prototype.toUTCString.call(t35)), Ae3(t35) && (c35 = " " + ce3(t35)), 0 !== o35.length || s35 && 0 != t35.length ? r35 < 0 ? me3(t35) ? e35.stylize(RegExp.prototype.toString.call(t35), "regexp") : e35.stylize("[Object]", "special") : (e35.seen.push(t35), a35 = s35 ? function(e44, t44, r44, n44, i44) {
    for (var o44 = [], u44 = 0, f44 = t44.length; u44 < f44; ++u44)
      ke3(t44, String(u44)) ? o44.push(se3(e44, t44, r44, n44, String(u44), true)) : o44.push("");
    return i44.forEach(function(i53) {
      i53.match(/^\d+$/) || o44.push(se3(e44, t44, r44, n44, i53, true));
    }), o44;
  }(e35, t35, r35, u35, o35) : o35.map(function(n44) {
    return se3(e35, t35, r35, u35, n44, s35);
  }), e35.seen.pop(), function(e44, t44, r44) {
    var n44 = 0;
    if (e44.reduce(function(e53, t53) {
      return n44++, t53.indexOf("\n") >= 0 && n44++, e53 + t53.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0) > 60)
      return r44[0] + ("" === t44 ? "" : t44 + "\n ") + " " + e44.join(",\n  ") + " " + r44[1];
    return r44[0] + t44 + " " + e44.join(", ") + " " + r44[1];
  }(a35, c35, p35)) : p35[0] + c35 + p35[1];
}
function ce3(e35) {
  return "[" + Error.prototype.toString.call(e35) + "]";
}
function se3(e35, t35, r35, n35, i35, o35) {
  var u35, f35, a35;
  if ((a35 = Object.getOwnPropertyDescriptor(t35, i35) || { value: t35[i35] }).get ? f35 = a35.set ? e35.stylize("[Getter/Setter]", "special") : e35.stylize("[Getter]", "special") : a35.set && (f35 = e35.stylize("[Setter]", "special")), ke3(n35, i35) || (u35 = "[" + i35 + "]"), f35 || (e35.seen.indexOf(a35.value) < 0 ? (f35 = le3(r35) ? ae3(e35, a35.value, null) : ae3(e35, a35.value, r35 - 1)).indexOf("\n") > -1 && (f35 = o35 ? f35.split("\n").map(function(e44) {
    return "  " + e44;
  }).join("\n").substr(2) : "\n" + f35.split("\n").map(function(e44) {
    return "   " + e44;
  }).join("\n")) : f35 = e35.stylize("[Circular]", "special")), be3(u35)) {
    if (o35 && i35.match(/^\d+$/))
      return f35;
    (u35 = JSON.stringify("" + i35)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u35 = u35.substr(1, u35.length - 2), u35 = e35.stylize(u35, "name")) : (u35 = u35.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u35 = e35.stylize(u35, "string"));
  }
  return u35 + ": " + f35;
}
function pe3(e35) {
  return Array.isArray(e35);
}
function ye3(e35) {
  return "boolean" == typeof e35;
}
function le3(e35) {
  return null === e35;
}
function de3(e35) {
  return "number" == typeof e35;
}
function ge3(e35) {
  return "string" == typeof e35;
}
function be3(e35) {
  return void 0 === e35;
}
function me3(e35) {
  return he3(e35) && "[object RegExp]" === ve3(e35);
}
function he3(e35) {
  return "object" == typeof e35 && null !== e35;
}
function je3(e35) {
  return he3(e35) && "[object Date]" === ve3(e35);
}
function Ae3(e35) {
  return he3(e35) && ("[object Error]" === ve3(e35) || e35 instanceof Error);
}
function we3(e35) {
  return "function" == typeof e35;
}
function ve3(e35) {
  return Object.prototype.toString.call(e35);
}
function Oe3(e35) {
  return e35 < 10 ? "0" + e35.toString(10) : e35.toString(10);
}
function Be3() {
  var e35 = /* @__PURE__ */ new Date(), t35 = [Oe3(e35.getHours()), Oe3(e35.getMinutes()), Oe3(e35.getSeconds())].join(":");
  return [e35.getDate(), Se3[e35.getMonth()], t35].join(" ");
}
function ke3(e35, t35) {
  return Object.prototype.hasOwnProperty.call(e35, t35);
}
function De3(e35, t35) {
  if (!e35) {
    var r35 = new Error("Promise was rejected with a falsy value");
    r35.reason = e35, e35 = r35;
  }
  return t35(e35);
}
var e10, t9, n10, r10, o10, l9, s8, f9, a9, T6, t23, e23, o23, n23, r23, l23, t$15, o$15, n$15, e$15, r$15, c23, u23, i23, t$24, i$15, o$25, u$15, f23, a23, s23, p23, y7, l$15, d23, m23, h23, j5, A5, Q4, X4, Y5, ee3, te3, re3, ne3, ie3, Se3, Ee3, _extend4, callbackify4, debuglog4, deprecate4, format6, inherits4, inspect4, isArray4, isBoolean4, isBuffer4, isDate4, isError4, isFunction4, isNull4, isNullOrUndefined4, isNumber4, isObject4, isPrimitive4, isRegExp4, isString4, isSymbol4, isUndefined4, log4, promisify4, types4, TextEncoder4, TextDecoder5, _extend23, callbackify23, debuglog23, deprecate23, format24, inherits23, inspect23, isArray23, isBoolean23, isBuffer23, isDate23, isError23, isFunction23, isNull23, isNullOrUndefined23, isNumber23, isObject23, isPrimitive23, isRegExp23, isString23, isSymbol23, isUndefined23, log23, promisify23, types23, TextEncoder23, TextDecoder23;
var init_util = __esm({
  "node-modules-polyfills:util"() {
    r10 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis;
    o10 = e10 = {};
    !function() {
      try {
        t9 = "function" == typeof setTimeout ? setTimeout : i9;
      } catch (e35) {
        t9 = i9;
      }
      try {
        n10 = "function" == typeof clearTimeout ? clearTimeout : u9;
      } catch (e35) {
        n10 = u9;
      }
    }();
    s8 = [];
    f9 = false;
    a9 = -1;
    o10.nextTick = function(e35) {
      var t35 = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var n35 = 1; n35 < arguments.length; n35++)
          t35[n35 - 1] = arguments[n35];
      s8.push(new m7(e35, t35)), 1 !== s8.length || f9 || c9(d7);
    }, m7.prototype.run = function() {
      (this || r10).fun.apply(null, (this || r10).array);
    }, o10.title = "browser", o10.browser = true, o10.env = {}, o10.argv = [], o10.version = "", o10.versions = {}, o10.on = p9, o10.addListener = p9, o10.once = p9, o10.off = p9, o10.removeListener = p9, o10.removeAllListeners = p9, o10.emit = p9, o10.prependListener = p9, o10.prependOnceListener = p9, o10.listeners = function(e35) {
      return [];
    }, o10.binding = function(e35) {
      throw new Error("process.binding is not supported");
    }, o10.cwd = function() {
      return "/";
    }, o10.chdir = function(e35) {
      throw new Error("process.chdir is not supported");
    }, o10.umask = function() {
      return 0;
    };
    T6 = e10;
    T6.addListener;
    T6.argv;
    T6.binding;
    T6.browser;
    T6.chdir;
    T6.cwd;
    T6.emit;
    T6.env;
    T6.listeners;
    T6.nextTick;
    T6.off;
    T6.on;
    T6.once;
    T6.prependListener;
    T6.prependOnceListener;
    T6.removeAllListeners;
    T6.removeListener;
    T6.title;
    T6.umask;
    T6.version;
    T6.versions;
    t23 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
    e23 = Object.prototype.toString;
    o23 = function(o35) {
      return !(t23 && o35 && "object" == typeof o35 && Symbol.toStringTag in o35) && "[object Arguments]" === e23.call(o35);
    };
    n23 = function(t35) {
      return !!o23(t35) || null !== t35 && "object" == typeof t35 && "number" == typeof t35.length && t35.length >= 0 && "[object Array]" !== e23.call(t35) && "[object Function]" === e23.call(t35.callee);
    };
    r23 = function() {
      return o23(arguments);
    }();
    o23.isLegacyArguments = n23;
    l23 = r23 ? o23 : n23;
    t$15 = Object.prototype.toString;
    o$15 = Function.prototype.toString;
    n$15 = /^\s*(?:function)?\*/;
    e$15 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
    r$15 = Object.getPrototypeOf;
    c23 = function() {
      if (!e$15)
        return false;
      try {
        return Function("return function*() {}")();
      } catch (t35) {
      }
    }();
    u23 = c23 ? r$15(c23) : {};
    i23 = function(c35) {
      return "function" == typeof c35 && (!!n$15.test(o$15.call(c35)) || (e$15 ? r$15(c35) === u23 : "[object GeneratorFunction]" === t$15.call(c35)));
    };
    t$24 = "function" == typeof Object.create ? function(t35, e35) {
      e35 && (t35.super_ = e35, t35.prototype = Object.create(e35.prototype, { constructor: { value: t35, enumerable: false, writable: true, configurable: true } }));
    } : function(t35, e35) {
      if (e35) {
        t35.super_ = e35;
        var o35 = function() {
        };
        o35.prototype = e35.prototype, t35.prototype = new o35(), t35.prototype.constructor = t35;
      }
    };
    i$15 = function(e35) {
      return e35 && "object" == typeof e35 && "function" == typeof e35.copy && "function" == typeof e35.fill && "function" == typeof e35.readUInt8;
    };
    o$25 = {};
    u$15 = i$15;
    f23 = l23;
    a23 = i23;
    s23 = "undefined" != typeof BigInt;
    p23 = "undefined" != typeof Symbol;
    y7 = p23 && void 0 !== Symbol.toStringTag;
    l$15 = "undefined" != typeof Uint8Array;
    d23 = "undefined" != typeof ArrayBuffer;
    if (l$15 && y7)
      var g6 = Object.getPrototypeOf(Uint8Array.prototype), b6 = c$15(Object.getOwnPropertyDescriptor(g6, Symbol.toStringTag).get);
    m23 = c$15(Object.prototype.toString);
    h23 = c$15(Number.prototype.valueOf);
    j5 = c$15(String.prototype.valueOf);
    A5 = c$15(Boolean.prototype.valueOf);
    if (s23)
      var w5 = c$15(BigInt.prototype.valueOf);
    if (p23)
      var v7 = c$15(Symbol.prototype.valueOf);
    o$25.isArgumentsObject = f23, o$25.isGeneratorFunction = a23, o$25.isPromise = function(e35) {
      return "undefined" != typeof Promise && e35 instanceof Promise || null !== e35 && "object" == typeof e35 && "function" == typeof e35.then && "function" == typeof e35.catch;
    }, o$25.isArrayBufferView = function(e35) {
      return d23 && ArrayBuffer.isView ? ArrayBuffer.isView(e35) : S5(e35) || R5(e35);
    }, o$25.isTypedArray = S5, o$25.isUint8Array = B5, o$25.isUint8ClampedArray = k5, o$25.isUint16Array = E5, o$25.isUint32Array = D5, o$25.isInt8Array = U5, o$25.isInt16Array = P5, o$25.isInt32Array = x5, o$25.isFloat32Array = I5, o$25.isFloat64Array = M5, o$25.isBigInt64Array = z5, o$25.isBigUint64Array = F5, T23.working = "undefined" != typeof Map && T23(/* @__PURE__ */ new Map()), o$25.isMap = function(e35) {
      return "undefined" != typeof Map && (T23.working ? T23(e35) : e35 instanceof Map);
    }, N5.working = "undefined" != typeof Set && N5(/* @__PURE__ */ new Set()), o$25.isSet = function(e35) {
      return "undefined" != typeof Set && (N5.working ? N5(e35) : e35 instanceof Set);
    }, W4.working = "undefined" != typeof WeakMap && W4(/* @__PURE__ */ new WeakMap()), o$25.isWeakMap = function(e35) {
      return "undefined" != typeof WeakMap && (W4.working ? W4(e35) : e35 instanceof WeakMap);
    }, $4.working = "undefined" != typeof WeakSet && $4(/* @__PURE__ */ new WeakSet()), o$25.isWeakSet = function(e35) {
      return $4(e35);
    }, C5.working = "undefined" != typeof ArrayBuffer && C5(new ArrayBuffer()), o$25.isArrayBuffer = V4, G4.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && G4(new DataView(new ArrayBuffer(1), 0, 1)), o$25.isDataView = R5, J4.working = "undefined" != typeof SharedArrayBuffer && J4(new SharedArrayBuffer()), o$25.isSharedArrayBuffer = _5, o$25.isAsyncFunction = function(e35) {
      return "[object AsyncFunction]" === m23(e35);
    }, o$25.isMapIterator = function(e35) {
      return "[object Map Iterator]" === m23(e35);
    }, o$25.isSetIterator = function(e35) {
      return "[object Set Iterator]" === m23(e35);
    }, o$25.isGeneratorObject = function(e35) {
      return "[object Generator]" === m23(e35);
    }, o$25.isWebAssemblyCompiledModule = function(e35) {
      return "[object WebAssembly.Module]" === m23(e35);
    }, o$25.isNumberObject = H4, o$25.isStringObject = Z4, o$25.isBooleanObject = q4, o$25.isBigIntObject = K4, o$25.isSymbolObject = L5, o$25.isBoxedPrimitive = function(e35) {
      return H4(e35) || Z4(e35) || q4(e35) || K4(e35) || L5(e35);
    }, o$25.isAnyArrayBuffer = function(e35) {
      return l$15 && (V4(e35) || _5(e35));
    }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e35) {
      Object.defineProperty(o$25, e35, { enumerable: false, value: function() {
        throw new Error(e35 + " is not supported in userland");
      } });
    });
    Q4 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis;
    X4 = {};
    Y5 = T6;
    ee3 = Object.getOwnPropertyDescriptors || function(e35) {
      for (var t35 = Object.keys(e35), r35 = {}, n35 = 0; n35 < t35.length; n35++)
        r35[t35[n35]] = Object.getOwnPropertyDescriptor(e35, t35[n35]);
      return r35;
    };
    te3 = /%[sdj%]/g;
    X4.format = function(e35) {
      if (!ge3(e35)) {
        for (var t35 = [], r35 = 0; r35 < arguments.length; r35++)
          t35.push(oe3(arguments[r35]));
        return t35.join(" ");
      }
      r35 = 1;
      for (var n35 = arguments, i35 = n35.length, o35 = String(e35).replace(te3, function(e44) {
        if ("%%" === e44)
          return "%";
        if (r35 >= i35)
          return e44;
        switch (e44) {
          case "%s":
            return String(n35[r35++]);
          case "%d":
            return Number(n35[r35++]);
          case "%j":
            try {
              return JSON.stringify(n35[r35++]);
            } catch (e53) {
              return "[Circular]";
            }
          default:
            return e44;
        }
      }), u35 = n35[r35]; r35 < i35; u35 = n35[++r35])
        le3(u35) || !he3(u35) ? o35 += " " + u35 : o35 += " " + oe3(u35);
      return o35;
    }, X4.deprecate = function(e35, t35) {
      if (void 0 !== Y5 && true === Y5.noDeprecation)
        return e35;
      if (void 0 === Y5)
        return function() {
          return X4.deprecate(e35, t35).apply(this || Q4, arguments);
        };
      var r35 = false;
      return function() {
        if (!r35) {
          if (Y5.throwDeprecation)
            throw new Error(t35);
          Y5.traceDeprecation ? console.trace(t35) : console.error(t35), r35 = true;
        }
        return e35.apply(this || Q4, arguments);
      };
    };
    re3 = {};
    ne3 = /^$/;
    if (Y5.env.NODE_DEBUG) {
      ie3 = Y5.env.NODE_DEBUG;
      ie3 = ie3.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne3 = new RegExp("^" + ie3 + "$", "i");
    }
    X4.debuglog = function(e35) {
      if (e35 = e35.toUpperCase(), !re3[e35])
        if (ne3.test(e35)) {
          var t35 = Y5.pid;
          re3[e35] = function() {
            var r35 = X4.format.apply(X4, arguments);
            console.error("%s %d: %s", e35, t35, r35);
          };
        } else
          re3[e35] = function() {
          };
      return re3[e35];
    }, X4.inspect = oe3, oe3.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe3.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X4.types = o$25, X4.isArray = pe3, X4.isBoolean = ye3, X4.isNull = le3, X4.isNullOrUndefined = function(e35) {
      return null == e35;
    }, X4.isNumber = de3, X4.isString = ge3, X4.isSymbol = function(e35) {
      return "symbol" == typeof e35;
    }, X4.isUndefined = be3, X4.isRegExp = me3, X4.types.isRegExp = me3, X4.isObject = he3, X4.isDate = je3, X4.types.isDate = je3, X4.isError = Ae3, X4.types.isNativeError = Ae3, X4.isFunction = we3, X4.isPrimitive = function(e35) {
      return null === e35 || "boolean" == typeof e35 || "number" == typeof e35 || "string" == typeof e35 || "symbol" == typeof e35 || void 0 === e35;
    }, X4.isBuffer = i$15;
    Se3 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    X4.log = function() {
      console.log("%s - %s", Be3(), X4.format.apply(X4, arguments));
    }, X4.inherits = t$24, X4._extend = function(e35, t35) {
      if (!t35 || !he3(t35))
        return e35;
      for (var r35 = Object.keys(t35), n35 = r35.length; n35--; )
        e35[r35[n35]] = t35[r35[n35]];
      return e35;
    };
    Ee3 = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
    X4.promisify = function(e35) {
      if ("function" != typeof e35)
        throw new TypeError('The "original" argument must be of type Function');
      if (Ee3 && e35[Ee3]) {
        var t35;
        if ("function" != typeof (t35 = e35[Ee3]))
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(t35, Ee3, { value: t35, enumerable: false, writable: false, configurable: true }), t35;
      }
      function t35() {
        for (var t44, r35, n35 = new Promise(function(e44, n44) {
          t44 = e44, r35 = n44;
        }), i35 = [], o35 = 0; o35 < arguments.length; o35++)
          i35.push(arguments[o35]);
        i35.push(function(e44, n44) {
          e44 ? r35(e44) : t44(n44);
        });
        try {
          e35.apply(this || Q4, i35);
        } catch (e44) {
          r35(e44);
        }
        return n35;
      }
      return Object.setPrototypeOf(t35, Object.getPrototypeOf(e35)), Ee3 && Object.defineProperty(t35, Ee3, { value: t35, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t35, ee3(e35));
    }, X4.promisify.custom = Ee3, X4.callbackify = function(e35) {
      if ("function" != typeof e35)
        throw new TypeError('The "original" argument must be of type Function');
      function t35() {
        for (var t44 = [], r35 = 0; r35 < arguments.length; r35++)
          t44.push(arguments[r35]);
        var n35 = t44.pop();
        if ("function" != typeof n35)
          throw new TypeError("The last argument must be of type Function");
        var i35 = this || Q4, o35 = function() {
          return n35.apply(i35, arguments);
        };
        e35.apply(this || Q4, t44).then(function(e44) {
          Y5.nextTick(o35.bind(null, null, e44));
        }, function(e44) {
          Y5.nextTick(De3.bind(null, e44, o35));
        });
      }
      return Object.setPrototypeOf(t35, Object.getPrototypeOf(e35)), Object.defineProperties(t35, ee3(e35)), t35;
    };
    X4._extend;
    X4.callbackify;
    X4.debuglog;
    X4.deprecate;
    X4.format;
    X4.inherits;
    X4.inspect;
    X4.isArray;
    X4.isBoolean;
    X4.isBuffer;
    X4.isDate;
    X4.isError;
    X4.isFunction;
    X4.isNull;
    X4.isNullOrUndefined;
    X4.isNumber;
    X4.isObject;
    X4.isPrimitive;
    X4.isRegExp;
    X4.isString;
    X4.isSymbol;
    X4.isUndefined;
    X4.log;
    X4.promisify;
    _extend4 = X4._extend;
    callbackify4 = X4.callbackify;
    debuglog4 = X4.debuglog;
    deprecate4 = X4.deprecate;
    format6 = X4.format;
    inherits4 = X4.inherits;
    inspect4 = X4.inspect;
    isArray4 = X4.isArray;
    isBoolean4 = X4.isBoolean;
    isBuffer4 = X4.isBuffer;
    isDate4 = X4.isDate;
    isError4 = X4.isError;
    isFunction4 = X4.isFunction;
    isNull4 = X4.isNull;
    isNullOrUndefined4 = X4.isNullOrUndefined;
    isNumber4 = X4.isNumber;
    isObject4 = X4.isObject;
    isPrimitive4 = X4.isPrimitive;
    isRegExp4 = X4.isRegExp;
    isString4 = X4.isString;
    isSymbol4 = X4.isSymbol;
    isUndefined4 = X4.isUndefined;
    log4 = X4.log;
    promisify4 = X4.promisify;
    types4 = X4.types;
    TextEncoder4 = self.TextEncoder;
    TextDecoder5 = self.TextDecoder;
    _extend23 = X4._extend;
    callbackify23 = X4.callbackify;
    debuglog23 = X4.debuglog;
    deprecate23 = X4.deprecate;
    format24 = X4.format;
    inherits23 = X4.inherits;
    inspect23 = X4.inspect;
    isArray23 = X4.isArray;
    isBoolean23 = X4.isBoolean;
    isBuffer23 = X4.isBuffer;
    isDate23 = X4.isDate;
    isError23 = X4.isError;
    isFunction23 = X4.isFunction;
    isNull23 = X4.isNull;
    isNullOrUndefined23 = X4.isNullOrUndefined;
    isNumber23 = X4.isNumber;
    isObject23 = X4.isObject;
    isPrimitive23 = X4.isPrimitive;
    isRegExp23 = X4.isRegExp;
    isString23 = X4.isString;
    isSymbol23 = X4.isSymbol;
    isUndefined23 = X4.isUndefined;
    log23 = X4.log;
    promisify23 = X4.promisify;
    types23 = X4.types;
    TextEncoder23 = X4.TextEncoder = globalThis.TextEncoder;
    TextDecoder23 = X4.TextDecoder = globalThis.TextDecoder;
  }
});

// node-modules-polyfills-commonjs:util
var util_exports = {};
__export(util_exports, {
  TextDecoder: () => TextDecoder23,
  TextEncoder: () => TextEncoder23,
  _extend: () => _extend23,
  callbackify: () => callbackify23,
  debuglog: () => debuglog23,
  deprecate: () => deprecate23,
  format: () => format24,
  inherits: () => inherits23,
  inspect: () => inspect23,
  isArray: () => isArray23,
  isBoolean: () => isBoolean23,
  isBuffer: () => isBuffer23,
  isDate: () => isDate23,
  isError: () => isError23,
  isFunction: () => isFunction23,
  isNull: () => isNull23,
  isNullOrUndefined: () => isNullOrUndefined23,
  isNumber: () => isNumber23,
  isObject: () => isObject23,
  isPrimitive: () => isPrimitive23,
  isRegExp: () => isRegExp23,
  isString: () => isString23,
  isSymbol: () => isSymbol23,
  isUndefined: () => isUndefined23,
  log: () => log23,
  promisify: () => promisify23,
  types: () => types23
});
var init_util2 = __esm({
  "node-modules-polyfills-commonjs:util"() {
    init_util();
  }
});

// node-modules-polyfills:assert
function i10() {
  throw new Error("setTimeout has not been defined");
}
function u10() {
  throw new Error("clearTimeout has not been defined");
}
function c10(e44) {
  if (t10 === setTimeout)
    return setTimeout(e44, 0);
  if ((t10 === i10 || !t10) && setTimeout)
    return t10 = setTimeout, setTimeout(e44, 0);
  try {
    return t10(e44, 0);
  } catch (n35) {
    try {
      return t10.call(null, e44, 0);
    } catch (n44) {
      return t10.call(this || r11, e44, 0);
    }
  }
}
function h10() {
  f10 && l10 && (f10 = false, l10.length ? s9 = l10.concat(s9) : a10 = -1, s9.length && d8());
}
function d8() {
  if (!f10) {
    var e44 = c10(h10);
    f10 = true;
    for (var t44 = s9.length; t44; ) {
      for (l10 = s9, s9 = []; ++a10 < t44; )
        l10 && l10[a10].run();
      a10 = -1, t44 = s9.length;
    }
    l10 = null, f10 = false, function(e53) {
      if (n11 === clearTimeout)
        return clearTimeout(e53);
      if ((n11 === u10 || !n11) && clearTimeout)
        return n11 = clearTimeout, clearTimeout(e53);
      try {
        n11(e53);
      } catch (t53) {
        try {
          return n11.call(null, e53);
        } catch (t63) {
          return n11.call(this || r11, e53);
        }
      }
    }(e44);
  }
}
function m8(e44, t44) {
  (this || r11).fun = e44, (this || r11).array = t44;
}
function p10() {
}
function c$16(e44) {
  return e44.call.bind(e44);
}
function O7(e44, t44) {
  if ("object" != typeof e44)
    return false;
  try {
    return t44(e44), true;
  } catch (e53) {
    return false;
  }
}
function S6(e44) {
  return l$16 && y8 ? void 0 !== b7(e44) : B6(e44) || k6(e44) || E6(e44) || D6(e44) || U6(e44) || P6(e44) || x6(e44) || I6(e44) || M6(e44) || z6(e44) || F6(e44);
}
function B6(e44) {
  return l$16 && y8 ? "Uint8Array" === b7(e44) : "[object Uint8Array]" === m24(e44) || u$16(e44) && void 0 !== e44.buffer;
}
function k6(e44) {
  return l$16 && y8 ? "Uint8ClampedArray" === b7(e44) : "[object Uint8ClampedArray]" === m24(e44);
}
function E6(e44) {
  return l$16 && y8 ? "Uint16Array" === b7(e44) : "[object Uint16Array]" === m24(e44);
}
function D6(e44) {
  return l$16 && y8 ? "Uint32Array" === b7(e44) : "[object Uint32Array]" === m24(e44);
}
function U6(e44) {
  return l$16 && y8 ? "Int8Array" === b7(e44) : "[object Int8Array]" === m24(e44);
}
function P6(e44) {
  return l$16 && y8 ? "Int16Array" === b7(e44) : "[object Int16Array]" === m24(e44);
}
function x6(e44) {
  return l$16 && y8 ? "Int32Array" === b7(e44) : "[object Int32Array]" === m24(e44);
}
function I6(e44) {
  return l$16 && y8 ? "Float32Array" === b7(e44) : "[object Float32Array]" === m24(e44);
}
function M6(e44) {
  return l$16 && y8 ? "Float64Array" === b7(e44) : "[object Float64Array]" === m24(e44);
}
function z6(e44) {
  return l$16 && y8 ? "BigInt64Array" === b7(e44) : "[object BigInt64Array]" === m24(e44);
}
function F6(e44) {
  return l$16 && y8 ? "BigUint64Array" === b7(e44) : "[object BigUint64Array]" === m24(e44);
}
function T24(e44) {
  return "[object Map]" === m24(e44);
}
function N6(e44) {
  return "[object Set]" === m24(e44);
}
function W5(e44) {
  return "[object WeakMap]" === m24(e44);
}
function $5(e44) {
  return "[object WeakSet]" === m24(e44);
}
function C6(e44) {
  return "[object ArrayBuffer]" === m24(e44);
}
function V5(e44) {
  return "undefined" != typeof ArrayBuffer && (C6.working ? C6(e44) : e44 instanceof ArrayBuffer);
}
function G5(e44) {
  return "[object DataView]" === m24(e44);
}
function R6(e44) {
  return "undefined" != typeof DataView && (G5.working ? G5(e44) : e44 instanceof DataView);
}
function J5(e44) {
  return "[object SharedArrayBuffer]" === m24(e44);
}
function _6(e44) {
  return "undefined" != typeof SharedArrayBuffer && (J5.working ? J5(e44) : e44 instanceof SharedArrayBuffer);
}
function H5(e44) {
  return O7(e44, h24);
}
function Z5(e44) {
  return O7(e44, j6);
}
function q5(e44) {
  return O7(e44, A6);
}
function K5(e44) {
  return s24 && O7(e44, w6);
}
function L6(e44) {
  return p24 && O7(e44, v8);
}
function oe4(e44, t44) {
  var r44 = { seen: [], stylize: fe4 };
  return arguments.length >= 3 && (r44.depth = arguments[2]), arguments.length >= 4 && (r44.colors = arguments[3]), ye4(t44) ? r44.showHidden = t44 : t44 && X5._extend(r44, t44), be4(r44.showHidden) && (r44.showHidden = false), be4(r44.depth) && (r44.depth = 2), be4(r44.colors) && (r44.colors = false), be4(r44.customInspect) && (r44.customInspect = true), r44.colors && (r44.stylize = ue4), ae4(r44, e44, r44.depth);
}
function ue4(e44, t44) {
  var r44 = oe4.styles[t44];
  return r44 ? "\x1B[" + oe4.colors[r44][0] + "m" + e44 + "\x1B[" + oe4.colors[r44][1] + "m" : e44;
}
function fe4(e44, t44) {
  return e44;
}
function ae4(e44, t44, r44) {
  if (e44.customInspect && t44 && we4(t44.inspect) && t44.inspect !== X5.inspect && (!t44.constructor || t44.constructor.prototype !== t44)) {
    var n35 = t44.inspect(r44, e44);
    return ge4(n35) || (n35 = ae4(e44, n35, r44)), n35;
  }
  var i35 = function(e53, t53) {
    if (be4(t53))
      return e53.stylize("undefined", "undefined");
    if (ge4(t53)) {
      var r53 = "'" + JSON.stringify(t53).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return e53.stylize(r53, "string");
    }
    if (de4(t53))
      return e53.stylize("" + t53, "number");
    if (ye4(t53))
      return e53.stylize("" + t53, "boolean");
    if (le4(t53))
      return e53.stylize("null", "null");
  }(e44, t44);
  if (i35)
    return i35;
  var o35 = Object.keys(t44), u35 = function(e53) {
    var t53 = {};
    return e53.forEach(function(e63, r53) {
      t53[e63] = true;
    }), t53;
  }(o35);
  if (e44.showHidden && (o35 = Object.getOwnPropertyNames(t44)), Ae4(t44) && (o35.indexOf("message") >= 0 || o35.indexOf("description") >= 0))
    return ce4(t44);
  if (0 === o35.length) {
    if (we4(t44)) {
      var f35 = t44.name ? ": " + t44.name : "";
      return e44.stylize("[Function" + f35 + "]", "special");
    }
    if (me4(t44))
      return e44.stylize(RegExp.prototype.toString.call(t44), "regexp");
    if (je4(t44))
      return e44.stylize(Date.prototype.toString.call(t44), "date");
    if (Ae4(t44))
      return ce4(t44);
  }
  var a35, c35 = "", s35 = false, p35 = ["{", "}"];
  (pe4(t44) && (s35 = true, p35 = ["[", "]"]), we4(t44)) && (c35 = " [Function" + (t44.name ? ": " + t44.name : "") + "]");
  return me4(t44) && (c35 = " " + RegExp.prototype.toString.call(t44)), je4(t44) && (c35 = " " + Date.prototype.toUTCString.call(t44)), Ae4(t44) && (c35 = " " + ce4(t44)), 0 !== o35.length || s35 && 0 != t44.length ? r44 < 0 ? me4(t44) ? e44.stylize(RegExp.prototype.toString.call(t44), "regexp") : e44.stylize("[Object]", "special") : (e44.seen.push(t44), a35 = s35 ? function(e53, t53, r53, n44, i44) {
    for (var o44 = [], u44 = 0, f44 = t53.length; u44 < f44; ++u44)
      ke4(t53, String(u44)) ? o44.push(se4(e53, t53, r53, n44, String(u44), true)) : o44.push("");
    return i44.forEach(function(i53) {
      i53.match(/^\d+$/) || o44.push(se4(e53, t53, r53, n44, i53, true));
    }), o44;
  }(e44, t44, r44, u35, o35) : o35.map(function(n44) {
    return se4(e44, t44, r44, u35, n44, s35);
  }), e44.seen.pop(), function(e53, t53, r53) {
    var n44 = 0;
    if (e53.reduce(function(e63, t63) {
      return n44++, t63.indexOf("\n") >= 0 && n44++, e63 + t63.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0) > 60)
      return r53[0] + ("" === t53 ? "" : t53 + "\n ") + " " + e53.join(",\n  ") + " " + r53[1];
    return r53[0] + t53 + " " + e53.join(", ") + " " + r53[1];
  }(a35, c35, p35)) : p35[0] + c35 + p35[1];
}
function ce4(e44) {
  return "[" + Error.prototype.toString.call(e44) + "]";
}
function se4(e44, t44, r44, n35, i35, o35) {
  var u35, f35, a35;
  if ((a35 = Object.getOwnPropertyDescriptor(t44, i35) || { value: t44[i35] }).get ? f35 = a35.set ? e44.stylize("[Getter/Setter]", "special") : e44.stylize("[Getter]", "special") : a35.set && (f35 = e44.stylize("[Setter]", "special")), ke4(n35, i35) || (u35 = "[" + i35 + "]"), f35 || (e44.seen.indexOf(a35.value) < 0 ? (f35 = le4(r44) ? ae4(e44, a35.value, null) : ae4(e44, a35.value, r44 - 1)).indexOf("\n") > -1 && (f35 = o35 ? f35.split("\n").map(function(e53) {
    return "  " + e53;
  }).join("\n").substr(2) : "\n" + f35.split("\n").map(function(e53) {
    return "   " + e53;
  }).join("\n")) : f35 = e44.stylize("[Circular]", "special")), be4(u35)) {
    if (o35 && i35.match(/^\d+$/))
      return f35;
    (u35 = JSON.stringify("" + i35)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u35 = u35.substr(1, u35.length - 2), u35 = e44.stylize(u35, "name")) : (u35 = u35.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u35 = e44.stylize(u35, "string"));
  }
  return u35 + ": " + f35;
}
function pe4(e44) {
  return Array.isArray(e44);
}
function ye4(e44) {
  return "boolean" == typeof e44;
}
function le4(e44) {
  return null === e44;
}
function de4(e44) {
  return "number" == typeof e44;
}
function ge4(e44) {
  return "string" == typeof e44;
}
function be4(e44) {
  return void 0 === e44;
}
function me4(e44) {
  return he4(e44) && "[object RegExp]" === ve4(e44);
}
function he4(e44) {
  return "object" == typeof e44 && null !== e44;
}
function je4(e44) {
  return he4(e44) && "[object Date]" === ve4(e44);
}
function Ae4(e44) {
  return he4(e44) && ("[object Error]" === ve4(e44) || e44 instanceof Error);
}
function we4(e44) {
  return "function" == typeof e44;
}
function ve4(e44) {
  return Object.prototype.toString.call(e44);
}
function Oe4(e44) {
  return e44 < 10 ? "0" + e44.toString(10) : e44.toString(10);
}
function Be4() {
  var e44 = /* @__PURE__ */ new Date(), t44 = [Oe4(e44.getHours()), Oe4(e44.getMinutes()), Oe4(e44.getSeconds())].join(":");
  return [e44.getDate(), Se4[e44.getMonth()], t44].join(" ");
}
function ke4(e44, t44) {
  return Object.prototype.hasOwnProperty.call(e44, t44);
}
function De4(e44, t44) {
  if (!e44) {
    var r44 = new Error("Promise was rejected with a falsy value");
    r44.reason = e44, e44 = r44;
  }
  return t44(e44);
}
function e33(e44, r44) {
  if (null == e44)
    throw new TypeError("Cannot convert first argument to object");
  for (var t44 = Object(e44), n35 = 1; n35 < arguments.length; n35++) {
    var o35 = arguments[n35];
    if (null != o35)
      for (var a35 = Object.keys(Object(o35)), l35 = 0, i35 = a35.length; l35 < i35; l35++) {
        var c35 = a35[l35], b33 = Object.getOwnPropertyDescriptor(o35, c35);
        void 0 !== b33 && b33.enumerable && (t44[c35] = o35[c35]);
      }
  }
  return t44;
}
function i$52() {
  if (a$62)
    return c$42;
  function e44(t44) {
    return (e44 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t53) {
      return typeof t53;
    } : function(t53) {
      return t53 && "function" == typeof Symbol && t53.constructor === Symbol && t53 !== Symbol.prototype ? "symbol" : typeof t53;
    })(t44);
  }
  function n35(t44, n44) {
    return !n44 || "object" !== e44(n44) && "function" != typeof n44 ? function(t53) {
      if (void 0 === t53)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t53;
    }(t44) : n44;
  }
  function r44(t44) {
    return (r44 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t53) {
      return t53.__proto__ || Object.getPrototypeOf(t53);
    })(t44);
  }
  function o35(t44, e53) {
    return (o35 = Object.setPrototypeOf || function(t53, e63) {
      return t53.__proto__ = e63, t53;
    })(t44, e53);
  }
  a$62 = true;
  var i35, u35, l35 = {};
  function f35(t44, e53, c35) {
    c35 || (c35 = Error);
    var a35 = function(c44) {
      function a44(o44, c53, i44) {
        var u44;
        return !function(t53, e63) {
          if (!(t53 instanceof e63))
            throw new TypeError("Cannot call a class as a function");
        }(this, a44), (u44 = n35(this, r44(a44).call(this, function(t53, n44, r53) {
          return "string" == typeof e53 ? e53 : e53(t53, n44, r53);
        }(o44, c53, i44)))).code = t44, u44;
      }
      return !function(t53, e63) {
        if ("function" != typeof e63 && null !== e63)
          throw new TypeError("Super expression must either be null or a function");
        t53.prototype = Object.create(e63 && e63.prototype, { constructor: { value: t53, writable: true, configurable: true } }), e63 && o35(t53, e63);
      }(a44, c44), a44;
    }(c35);
    l35[t44] = a35;
  }
  function s35(t44, e53) {
    if (Array.isArray(t44)) {
      var n44 = t44.length;
      return t44 = t44.map(function(t53) {
        return String(t53);
      }), n44 > 2 ? "one of ".concat(e53, " ").concat(t44.slice(0, n44 - 1).join(", "), ", or ") + t44[n44 - 1] : 2 === n44 ? "one of ".concat(e53, " ").concat(t44[0], " or ").concat(t44[1]) : "of ".concat(e53, " ").concat(t44[0]);
    }
    return "of ".concat(e53, " ").concat(String(t44));
  }
  return f35("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), f35("ERR_INVALID_ARG_TYPE", function(t44, n44, r53) {
    var o44, c35, u44;
    if (void 0 === i35 && (i35 = tt2()), i35("string" == typeof t44, "'name' must be a string"), "string" == typeof n44 && (c35 = "not ", n44.substr(0, c35.length) === c35) ? (o44 = "must not be", n44 = n44.replace(/^not /, "")) : o44 = "must be", function(t53, e53, n53) {
      return (void 0 === n53 || n53 > t53.length) && (n53 = t53.length), t53.substring(n53 - e53.length, n53) === e53;
    }(t44, " argument"))
      u44 = "The ".concat(t44, " ").concat(o44, " ").concat(s35(n44, "type"));
    else {
      var l44 = function(t53, e53, n53) {
        return "number" != typeof n53 && (n53 = 0), !(n53 + e53.length > t53.length) && -1 !== t53.indexOf(e53, n53);
      }(t44, ".") ? "property" : "argument";
      u44 = 'The "'.concat(t44, '" ').concat(l44, " ").concat(o44, " ").concat(s35(n44, "type"));
    }
    return u44 += ". Received type ".concat(e44(r53));
  }, TypeError), f35("ERR_INVALID_ARG_VALUE", function(e53, n44) {
    var r53 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "is invalid";
    void 0 === u35 && (u35 = X5);
    var o44 = u35.inspect(n44);
    return o44.length > 128 && (o44 = "".concat(o44.slice(0, 128), "...")), "The argument '".concat(e53, "' ").concat(r53, ". Received ").concat(o44);
  }, TypeError), f35("ERR_INVALID_RETURN_VALUE", function(t44, n44, r53) {
    var o44;
    return o44 = r53 && r53.constructor && r53.constructor.name ? "instance of ".concat(r53.constructor.name) : "type ".concat(e44(r53)), "Expected ".concat(t44, ' to be returned from the "').concat(n44, '"') + " function but got ".concat(o44, ".");
  }, TypeError), f35("ERR_MISSING_ARGS", function() {
    for (var t44 = arguments.length, e53 = new Array(t44), n44 = 0; n44 < t44; n44++)
      e53[n44] = arguments[n44];
    void 0 === i35 && (i35 = tt2()), i35(e53.length > 0, "At least one arg needs to be specified");
    var r53 = "The ", o44 = e53.length;
    switch (e53 = e53.map(function(t53) {
      return '"'.concat(t53, '"');
    }), o44) {
      case 1:
        r53 += "".concat(e53[0], " argument");
        break;
      case 2:
        r53 += "".concat(e53[0], " and ").concat(e53[1], " arguments");
        break;
      default:
        r53 += e53.slice(0, o44 - 1).join(", "), r53 += ", and ".concat(e53[o44 - 1], " arguments");
    }
    return "".concat(r53, " must be specified");
  }, TypeError), c$42.codes = l35, c$42;
}
function f$62() {
  if (l$62)
    return u$52;
  l$62 = true;
  var n35 = T7;
  function r44(t44, e44, n44) {
    return e44 in t44 ? Object.defineProperty(t44, e44, { value: n44, enumerable: true, configurable: true, writable: true }) : t44[e44] = n44, t44;
  }
  function o35(t44, e44) {
    for (var n44 = 0; n44 < e44.length; n44++) {
      var r53 = e44[n44];
      r53.enumerable = r53.enumerable || false, r53.configurable = true, "value" in r53 && (r53.writable = true), Object.defineProperty(t44, r53.key, r53);
    }
  }
  function c35(t44, e44) {
    return !e44 || "object" !== y34(e44) && "function" != typeof e44 ? a35(t44) : e44;
  }
  function a35(t44) {
    if (void 0 === t44)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t44;
  }
  function f35(t44) {
    var e44 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
    return (f35 = function(t53) {
      if (null === t53 || (n44 = t53, -1 === Function.toString.call(n44).indexOf("[native code]")))
        return t53;
      var n44;
      if ("function" != typeof t53)
        throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== e44) {
        if (e44.has(t53))
          return e44.get(t53);
        e44.set(t53, r53);
      }
      function r53() {
        return p35(t53, arguments, h44(this).constructor);
      }
      return r53.prototype = Object.create(t53.prototype, { constructor: { value: r53, enumerable: false, writable: true, configurable: true } }), g33(r53, t53);
    })(t44);
  }
  function s35() {
    if ("undefined" == typeof Reflect || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if ("function" == typeof Proxy)
      return true;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      })), true;
    } catch (t44) {
      return false;
    }
  }
  function p35(t44, e44, n44) {
    return (p35 = s35() ? Reflect.construct : function(t53, e53, n53) {
      var r53 = [null];
      r53.push.apply(r53, e53);
      var o44 = new (Function.bind.apply(t53, r53))();
      return n53 && g33(o44, n53.prototype), o44;
    }).apply(null, arguments);
  }
  function g33(t44, e44) {
    return (g33 = Object.setPrototypeOf || function(t53, e53) {
      return t53.__proto__ = e53, t53;
    })(t44, e44);
  }
  function h44(t44) {
    return (h44 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t53) {
      return t53.__proto__ || Object.getPrototypeOf(t53);
    })(t44);
  }
  function y34(t44) {
    return (y34 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t53) {
      return typeof t53;
    } : function(t53) {
      return t53 && "function" == typeof Symbol && t53.constructor === Symbol && t53 !== Symbol.prototype ? "symbol" : typeof t53;
    })(t44);
  }
  var b33 = X5.inspect, v34 = i$52().codes.ERR_INVALID_ARG_TYPE;
  function d43(t44, e44, n44) {
    return (void 0 === n44 || n44 > t44.length) && (n44 = t44.length), t44.substring(n44 - e44.length, n44) === e44;
  }
  var m43 = "", E32 = "", w32 = "", S32 = "", j32 = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" };
  function O33(t44) {
    var e44 = Object.keys(t44), n44 = Object.create(Object.getPrototypeOf(t44));
    return e44.forEach(function(e53) {
      n44[e53] = t44[e53];
    }), Object.defineProperty(n44, "message", { value: t44.message }), n44;
  }
  function x32(t44) {
    return b33(t44, { compact: false, customInspect: false, depth: 1e3, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
  }
  function q32(t44, e44, r53) {
    var o44 = "", c44 = "", a44 = 0, i35 = "", u35 = false, l35 = x32(t44), f44 = l35.split("\n"), s44 = x32(e44).split("\n"), p44 = 0, g42 = "";
    if ("strictEqual" === r53 && "object" === y34(t44) && "object" === y34(e44) && null !== t44 && null !== e44 && (r53 = "strictEqualObject"), 1 === f44.length && 1 === s44.length && f44[0] !== s44[0]) {
      var h53 = f44[0].length + s44[0].length;
      if (h53 <= 10) {
        if (!("object" === y34(t44) && null !== t44 || "object" === y34(e44) && null !== e44 || 0 === t44 && 0 === e44))
          return "".concat(j32[r53], "\n\n") + "".concat(f44[0], " !== ").concat(s44[0], "\n");
      } else if ("strictEqualObject" !== r53) {
        if (h53 < (n35.stderr && n35.stderr.isTTY ? n35.stderr.columns : 80)) {
          for (; f44[0][p44] === s44[0][p44]; )
            p44++;
          p44 > 2 && (g42 = "\n  ".concat(function(t53, e53) {
            if (e53 = Math.floor(e53), 0 == t53.length || 0 == e53)
              return "";
            var n44 = t53.length * e53;
            for (e53 = Math.floor(Math.log(e53) / Math.log(2)); e53; )
              t53 += t53, e53--;
            return t53 += t53.substring(0, n44 - t53.length);
          }(" ", p44), "^"), p44 = 0);
        }
      }
    }
    for (var b42 = f44[f44.length - 1], v43 = s44[s44.length - 1]; b42 === v43 && (p44++ < 2 ? i35 = "\n  ".concat(b42).concat(i35) : o44 = b42, f44.pop(), s44.pop(), 0 !== f44.length && 0 !== s44.length); )
      b42 = f44[f44.length - 1], v43 = s44[s44.length - 1];
    var O42 = Math.max(f44.length, s44.length);
    if (0 === O42) {
      var q42 = l35.split("\n");
      if (q42.length > 30)
        for (q42[26] = "".concat(m43, "...").concat(S32); q42.length > 27; )
          q42.pop();
      return "".concat(j32.notIdentical, "\n\n").concat(q42.join("\n"), "\n");
    }
    p44 > 3 && (i35 = "\n".concat(m43, "...").concat(S32).concat(i35), u35 = true), "" !== o44 && (i35 = "\n  ".concat(o44).concat(i35), o44 = "");
    var R42 = 0, A32 = j32[r53] + "\n".concat(E32, "+ actual").concat(S32, " ").concat(w32, "- expected").concat(S32), k32 = " ".concat(m43, "...").concat(S32, " Lines skipped");
    for (p44 = 0; p44 < O42; p44++) {
      var _32 = p44 - a44;
      if (f44.length < p44 + 1)
        _32 > 1 && p44 > 2 && (_32 > 4 ? (c44 += "\n".concat(m43, "...").concat(S32), u35 = true) : _32 > 3 && (c44 += "\n  ".concat(s44[p44 - 2]), R42++), c44 += "\n  ".concat(s44[p44 - 1]), R42++), a44 = p44, o44 += "\n".concat(w32, "-").concat(S32, " ").concat(s44[p44]), R42++;
      else if (s44.length < p44 + 1)
        _32 > 1 && p44 > 2 && (_32 > 4 ? (c44 += "\n".concat(m43, "...").concat(S32), u35 = true) : _32 > 3 && (c44 += "\n  ".concat(f44[p44 - 2]), R42++), c44 += "\n  ".concat(f44[p44 - 1]), R42++), a44 = p44, c44 += "\n".concat(E32, "+").concat(S32, " ").concat(f44[p44]), R42++;
      else {
        var T42 = s44[p44], P32 = f44[p44], I32 = P32 !== T42 && (!d43(P32, ",") || P32.slice(0, -1) !== T42);
        I32 && d43(T42, ",") && T42.slice(0, -1) === P32 && (I32 = false, P32 += ","), I32 ? (_32 > 1 && p44 > 2 && (_32 > 4 ? (c44 += "\n".concat(m43, "...").concat(S32), u35 = true) : _32 > 3 && (c44 += "\n  ".concat(f44[p44 - 2]), R42++), c44 += "\n  ".concat(f44[p44 - 1]), R42++), a44 = p44, c44 += "\n".concat(E32, "+").concat(S32, " ").concat(P32), o44 += "\n".concat(w32, "-").concat(S32, " ").concat(T42), R42 += 2) : (c44 += o44, o44 = "", 1 !== _32 && 0 !== p44 || (c44 += "\n  ".concat(P32), R42++));
      }
      if (R42 > 20 && p44 < O42 - 2)
        return "".concat(A32).concat(k32, "\n").concat(c44, "\n").concat(m43, "...").concat(S32).concat(o44, "\n") + "".concat(m43, "...").concat(S32);
    }
    return "".concat(A32).concat(u35 ? k32 : "", "\n").concat(c44).concat(o44).concat(i35).concat(g42);
  }
  var R32 = function(t44) {
    function e44(t53) {
      var r53;
      if (!function(t63, e53) {
        if (!(t63 instanceof e53))
          throw new TypeError("Cannot call a class as a function");
      }(this, e44), "object" !== y34(t53) || null === t53)
        throw new v34("options", "Object", t53);
      var o44 = t53.message, i44 = t53.operator, u44 = t53.stackStartFn, l35 = t53.actual, f44 = t53.expected, s44 = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, null != o44)
        r53 = c35(this, h44(e44).call(this, String(o44)));
      else if (n35.stderr && n35.stderr.isTTY && (n35.stderr && n35.stderr.getColorDepth && 1 !== n35.stderr.getColorDepth() ? (m43 = "\x1B[34m", E32 = "\x1B[32m", S32 = "\x1B[39m", w32 = "\x1B[31m") : (m43 = "", E32 = "", S32 = "", w32 = "")), "object" === y34(l35) && null !== l35 && "object" === y34(f44) && null !== f44 && "stack" in l35 && l35 instanceof Error && "stack" in f44 && f44 instanceof Error && (l35 = O33(l35), f44 = O33(f44)), "deepStrictEqual" === i44 || "strictEqual" === i44)
        r53 = c35(this, h44(e44).call(this, q32(l35, f44, i44)));
      else if ("notDeepStrictEqual" === i44 || "notStrictEqual" === i44) {
        var p44 = j32[i44], g42 = x32(l35).split("\n");
        if ("notStrictEqual" === i44 && "object" === y34(l35) && null !== l35 && (p44 = j32.notStrictEqualObject), g42.length > 30)
          for (g42[26] = "".concat(m43, "...").concat(S32); g42.length > 27; )
            g42.pop();
        r53 = 1 === g42.length ? c35(this, h44(e44).call(this, "".concat(p44, " ").concat(g42[0]))) : c35(this, h44(e44).call(this, "".concat(p44, "\n\n").concat(g42.join("\n"), "\n")));
      } else {
        var b42 = x32(l35), d52 = "", R42 = j32[i44];
        "notDeepEqual" === i44 || "notEqual" === i44 ? (b42 = "".concat(j32[i44], "\n\n").concat(b42)).length > 1024 && (b42 = "".concat(b42.slice(0, 1021), "...")) : (d52 = "".concat(x32(f44)), b42.length > 512 && (b42 = "".concat(b42.slice(0, 509), "...")), d52.length > 512 && (d52 = "".concat(d52.slice(0, 509), "...")), "deepEqual" === i44 || "equal" === i44 ? b42 = "".concat(R42, "\n\n").concat(b42, "\n\nshould equal\n\n") : d52 = " ".concat(i44, " ").concat(d52)), r53 = c35(this, h44(e44).call(this, "".concat(b42).concat(d52)));
      }
      return Error.stackTraceLimit = s44, r53.generatedMessage = !o44, Object.defineProperty(a35(r53), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), r53.code = "ERR_ASSERTION", r53.actual = l35, r53.expected = f44, r53.operator = i44, Error.captureStackTrace && Error.captureStackTrace(a35(r53), u44), r53.stack, r53.name = "AssertionError", c35(r53);
    }
    var i35, u35;
    return !function(t53, e53) {
      if ("function" != typeof e53 && null !== e53)
        throw new TypeError("Super expression must either be null or a function");
      t53.prototype = Object.create(e53 && e53.prototype, { constructor: { value: t53, writable: true, configurable: true } }), e53 && g33(t53, e53);
    }(e44, t44), i35 = e44, (u35 = [{ key: "toString", value: function() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    } }, { key: b33.custom, value: function(t53, e53) {
      return b33(this, function(t63) {
        for (var e63 = 1; e63 < arguments.length; e63++) {
          var n44 = null != arguments[e63] ? arguments[e63] : {}, o44 = Object.keys(n44);
          "function" == typeof Object.getOwnPropertySymbols && (o44 = o44.concat(Object.getOwnPropertySymbols(n44).filter(function(t72) {
            return Object.getOwnPropertyDescriptor(n44, t72).enumerable;
          }))), o44.forEach(function(e73) {
            r44(t63, e73, n44[e73]);
          });
        }
        return t63;
      }({}, e53, { customInspect: false, depth: 0 }));
    } }]) && o35(i35.prototype, u35), e44;
  }(f35(Error));
  return u$52 = R32;
}
function s$32(t44, e44) {
  return function(t53) {
    if (Array.isArray(t53))
      return t53;
  }(t44) || function(t53, e53) {
    var n35 = [], r44 = true, o35 = false, c35 = void 0;
    try {
      for (var a35, i35 = t53[Symbol.iterator](); !(r44 = (a35 = i35.next()).done) && (n35.push(a35.value), !e53 || n35.length !== e53); r44 = true)
        ;
    } catch (t63) {
      o35 = true, c35 = t63;
    } finally {
      try {
        r44 || null == i35.return || i35.return();
      } finally {
        if (o35)
          throw c35;
      }
    }
    return n35;
  }(t44, e44) || function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }();
}
function p$32(t44) {
  return (p$32 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t53) {
    return typeof t53;
  } : function(t53) {
    return t53 && "function" == typeof Symbol && t53.constructor === Symbol && t53 !== Symbol.prototype ? "symbol" : typeof t53;
  })(t44);
}
function m$22(t44) {
  return t44.call.bind(t44);
}
function U23(t44) {
  if (0 === t44.length || t44.length > 10)
    return true;
  for (var e44 = 0; e44 < t44.length; e44++) {
    var n35 = t44.charCodeAt(e44);
    if (n35 < 48 || n35 > 57)
      return true;
  }
  return 10 === t44.length && t44 >= Math.pow(2, 32);
}
function G22(t44) {
  return Object.keys(t44).filter(U23).concat(v$12(t44).filter(Object.prototype.propertyIsEnumerable.bind(t44)));
}
function V22(t44, e44) {
  if (t44 === e44)
    return 0;
  for (var n35 = t44.length, r44 = e44.length, o35 = 0, c35 = Math.min(n35, r44); o35 < c35; ++o35)
    if (t44[o35] !== e44[o35]) {
      n35 = t44[o35], r44 = e44[o35];
      break;
    }
  return n35 < r44 ? -1 : r44 < n35 ? 1 : 0;
}
function B23(t44, e44, n35, r44) {
  if (t44 === e44)
    return 0 !== t44 || (!n35 || b$12(t44, e44));
  if (n35) {
    if ("object" !== p$32(t44))
      return "number" == typeof t44 && d$12(t44) && d$12(e44);
    if ("object" !== p$32(e44) || null === t44 || null === e44)
      return false;
    if (Object.getPrototypeOf(t44) !== Object.getPrototypeOf(e44))
      return false;
  } else {
    if (null === t44 || "object" !== p$32(t44))
      return (null === e44 || "object" !== p$32(e44)) && t44 == e44;
    if (null === e44 || "object" !== p$32(e44))
      return false;
  }
  var o35, c35, a35, i35, u35 = S23(t44);
  if (u35 !== S23(e44))
    return false;
  if (Array.isArray(t44)) {
    if (t44.length !== e44.length)
      return false;
    var l35 = G22(t44), f35 = G22(e44);
    return l35.length === f35.length && C23(t44, e44, n35, r44, 1, l35);
  }
  if ("[object Object]" === u35 && (!R23(t44) && R23(e44) || !k23(t44) && k23(e44)))
    return false;
  if (q22(t44)) {
    if (!q22(e44) || Date.prototype.getTime.call(t44) !== Date.prototype.getTime.call(e44))
      return false;
  } else if (A$12(t44)) {
    if (!A$12(e44) || (a35 = t44, i35 = e44, !(g$12 ? a35.source === i35.source && a35.flags === i35.flags : RegExp.prototype.toString.call(a35) === RegExp.prototype.toString.call(i35))))
      return false;
  } else if (_23(t44) || t44 instanceof Error) {
    if (t44.message !== e44.message || t44.name !== e44.name)
      return false;
  } else {
    if (x23(t44)) {
      if (n35 || !L23(t44) && !M23(t44)) {
        if (!function(t53, e53) {
          return t53.byteLength === e53.byteLength && 0 === V22(new Uint8Array(t53.buffer, t53.byteOffset, t53.byteLength), new Uint8Array(e53.buffer, e53.byteOffset, e53.byteLength));
        }(t44, e44))
          return false;
      } else if (!function(t53, e53) {
        if (t53.byteLength !== e53.byteLength)
          return false;
        for (var n44 = 0; n44 < t53.byteLength; n44++)
          if (t53[n44] !== e53[n44])
            return false;
        return true;
      }(t44, e44))
        return false;
      var s35 = G22(t44), h44 = G22(e44);
      return s35.length === h44.length && C23(t44, e44, n35, r44, 0, s35);
    }
    if (k23(t44))
      return !(!k23(e44) || t44.size !== e44.size) && C23(t44, e44, n35, r44, 2);
    if (R23(t44))
      return !(!R23(e44) || t44.size !== e44.size) && C23(t44, e44, n35, r44, 3);
    if (O23(t44)) {
      if (c35 = e44, (o35 = t44).byteLength !== c35.byteLength || 0 !== V22(new Uint8Array(o35), new Uint8Array(c35)))
        return false;
    } else if (T33(t44) && !function(t53, e53) {
      return P$12(t53) ? P$12(e53) && b$12(Number.prototype.valueOf.call(t53), Number.prototype.valueOf.call(e53)) : I23(t53) ? I23(e53) && String.prototype.valueOf.call(t53) === String.prototype.valueOf.call(e53) : D23(t53) ? D23(e53) && Boolean.prototype.valueOf.call(t53) === Boolean.prototype.valueOf.call(e53) : F23(t53) ? F23(e53) && BigInt.prototype.valueOf.call(t53) === BigInt.prototype.valueOf.call(e53) : N$12(e53) && Symbol.prototype.valueOf.call(t53) === Symbol.prototype.valueOf.call(e53);
    }(t44, e44))
      return false;
  }
  return C23(t44, e44, n35, r44, 0);
}
function z23(t44, e44) {
  return e44.filter(function(e53) {
    return w$12(t44, e53);
  });
}
function C23(t44, e44, n35, r44, o35, c35) {
  if (5 === arguments.length) {
    c35 = Object.keys(t44);
    var a35 = Object.keys(e44);
    if (c35.length !== a35.length)
      return false;
  }
  for (var i35 = 0; i35 < c35.length; i35++)
    if (!E23(e44, c35[i35]))
      return false;
  if (n35 && 5 === arguments.length) {
    var u35 = v$12(t44);
    if (0 !== u35.length) {
      var l35 = 0;
      for (i35 = 0; i35 < u35.length; i35++) {
        var f35 = u35[i35];
        if (w$12(t44, f35)) {
          if (!w$12(e44, f35))
            return false;
          c35.push(f35), l35++;
        } else if (w$12(e44, f35))
          return false;
      }
      var s35 = v$12(e44);
      if (u35.length !== s35.length && z23(e44, s35).length !== l35)
        return false;
    } else {
      var p35 = v$12(e44);
      if (0 !== p35.length && 0 !== z23(e44, p35).length)
        return false;
    }
  }
  if (0 === c35.length && (0 === o35 || 1 === o35 && 0 === t44.length || 0 === t44.size))
    return true;
  if (void 0 === r44)
    r44 = { val1: /* @__PURE__ */ new Map(), val2: /* @__PURE__ */ new Map(), position: 0 };
  else {
    var g33 = r44.val1.get(t44);
    if (void 0 !== g33) {
      var h44 = r44.val2.get(e44);
      if (void 0 !== h44)
        return g33 === h44;
    }
    r44.position++;
  }
  r44.val1.set(t44, r44.position), r44.val2.set(e44, r44.position);
  var y34 = Q22(t44, e44, n35, c35, r44, o35);
  return r44.val1.delete(t44), r44.val2.delete(e44), y34;
}
function Y23(t44, e44, n35, r44) {
  for (var o35 = h$14(t44), c35 = 0; c35 < o35.length; c35++) {
    var a35 = o35[c35];
    if (B23(e44, a35, n35, r44))
      return t44.delete(a35), true;
  }
  return false;
}
function W22(t44) {
  switch (p$32(t44)) {
    case "undefined":
      return null;
    case "object":
      return;
    case "symbol":
      return false;
    case "string":
      t44 = +t44;
    case "number":
      if (d$12(t44))
        return false;
  }
  return true;
}
function H22(t44, e44, n35) {
  var r44 = W22(n35);
  return null != r44 ? r44 : e44.has(r44) && !t44.has(r44);
}
function J22(t44, e44, n35, r44, o35) {
  var c35 = W22(n35);
  if (null != c35)
    return c35;
  var a35 = e44.get(c35);
  return !(void 0 === a35 && !e44.has(c35) || !B23(r44, a35, false, o35)) && (!t44.has(c35) && B23(r44, a35, false, o35));
}
function K22(t44, e44, n35, r44, o35, c35) {
  for (var a35 = h$14(t44), i35 = 0; i35 < a35.length; i35++) {
    var u35 = a35[i35];
    if (B23(n35, u35, o35, c35) && B23(r44, e44.get(u35), o35, c35))
      return t44.delete(u35), true;
  }
  return false;
}
function Q22(t44, e44, n35, r44, o35, c35) {
  var a35 = 0;
  if (2 === c35) {
    if (!function(t53, e53, n44, r53) {
      for (var o44 = null, c44 = h$14(t53), a44 = 0; a44 < c44.length; a44++) {
        var i44 = c44[a44];
        if ("object" === p$32(i44) && null !== i44)
          null === o44 && (o44 = /* @__PURE__ */ new Set()), o44.add(i44);
        else if (!e53.has(i44)) {
          if (n44)
            return false;
          if (!H22(t53, e53, i44))
            return false;
          null === o44 && (o44 = /* @__PURE__ */ new Set()), o44.add(i44);
        }
      }
      if (null !== o44) {
        for (var u44 = h$14(e53), l44 = 0; l44 < u44.length; l44++) {
          var f35 = u44[l44];
          if ("object" === p$32(f35) && null !== f35) {
            if (!Y23(o44, f35, n44, r53))
              return false;
          } else if (!n44 && !t53.has(f35) && !Y23(o44, f35, n44, r53))
            return false;
        }
        return 0 === o44.size;
      }
      return true;
    }(t44, e44, n35, o35))
      return false;
  } else if (3 === c35) {
    if (!function(t53, e53, n44, r53) {
      for (var o44 = null, c44 = y$22(t53), a44 = 0; a44 < c44.length; a44++) {
        var i44 = s$32(c44[a44], 2), u44 = i44[0], l44 = i44[1];
        if ("object" === p$32(u44) && null !== u44)
          null === o44 && (o44 = /* @__PURE__ */ new Set()), o44.add(u44);
        else {
          var f35 = e53.get(u44);
          if (void 0 === f35 && !e53.has(u44) || !B23(l44, f35, n44, r53)) {
            if (n44)
              return false;
            if (!J22(t53, e53, u44, l44, r53))
              return false;
            null === o44 && (o44 = /* @__PURE__ */ new Set()), o44.add(u44);
          }
        }
      }
      if (null !== o44) {
        for (var g33 = y$22(e53), h44 = 0; h44 < g33.length; h44++) {
          var b33 = s$32(g33[h44], 2), v34 = (u44 = b33[0], b33[1]);
          if ("object" === p$32(u44) && null !== u44) {
            if (!K22(o44, t53, u44, v34, n44, r53))
              return false;
          } else if (!(n44 || t53.has(u44) && B23(t53.get(u44), v34, false, r53) || K22(o44, t53, u44, v34, false, r53)))
            return false;
        }
        return 0 === o44.size;
      }
      return true;
    }(t44, e44, n35, o35))
      return false;
  } else if (1 === c35)
    for (; a35 < t44.length; a35++) {
      if (!E23(t44, a35)) {
        if (E23(e44, a35))
          return false;
        for (var i35 = Object.keys(t44); a35 < i35.length; a35++) {
          var u35 = i35[a35];
          if (!E23(e44, u35) || !B23(t44[u35], e44[u35], n35, o35))
            return false;
        }
        return i35.length === Object.keys(e44).length;
      }
      if (!E23(e44, a35) || !B23(t44[a35], e44[a35], n35, o35))
        return false;
    }
  for (a35 = 0; a35 < r44.length; a35++) {
    var l35 = r44[a35];
    if (!B23(t44[l35], e44[l35], n35, o35))
      return false;
  }
  return true;
}
function tt2() {
  if ($$12)
    return Z22;
  $$12 = true;
  var o35 = T7;
  function c35(t44) {
    return (c35 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t53) {
      return typeof t53;
    } : function(t53) {
      return t53 && "function" == typeof Symbol && t53.constructor === Symbol && t53 !== Symbol.prototype ? "symbol" : typeof t53;
    })(t44);
  }
  var a35, u35, l35 = i$52().codes, s35 = l35.ERR_AMBIGUOUS_ARGUMENT, p35 = l35.ERR_INVALID_ARG_TYPE, g33 = l35.ERR_INVALID_ARG_VALUE, h44 = l35.ERR_INVALID_RETURN_VALUE, y34 = l35.ERR_MISSING_ARGS, b33 = f$62(), v34 = X5.inspect, d43 = X5.types, m$122 = d43.isPromise, E32 = d43.isRegExp, w32 = Object.assign ? Object.assign : r33.assign, S32 = Object.is ? Object.is : m33;
  function j32() {
    a35 = X22.isDeepEqual, u35 = X22.isDeepStrictEqual;
  }
  var O33 = false, x32 = Z22 = k32, q32 = {};
  function R32(t44) {
    if (t44.message instanceof Error)
      throw t44.message;
    throw new b33(t44);
  }
  function A32(t44, e44, n35, r44) {
    if (!n35) {
      var o44 = false;
      if (0 === e44)
        o44 = true, r44 = "No value argument passed to `assert.ok()`";
      else if (r44 instanceof Error)
        throw r44;
      var c44 = new b33({ actual: n35, expected: true, message: r44, operator: "==", stackStartFn: t44 });
      throw c44.generatedMessage = o44, c44;
    }
  }
  function k32() {
    for (var t44 = arguments.length, e44 = new Array(t44), n35 = 0; n35 < t44; n35++)
      e44[n35] = arguments[n35];
    A32.apply(void 0, [k32, e44.length].concat(e44));
  }
  x32.fail = function t44(e44, n35, r44, c44, a44) {
    var i35, u44 = arguments.length;
    if (0 === u44)
      i35 = "Failed";
    else if (1 === u44)
      r44 = e44, e44 = void 0;
    else {
      if (false === O33) {
        O33 = true;
        var l44 = o35.emitWarning ? o35.emitWarning : console.warn.bind(console);
        l44("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      2 === u44 && (c44 = "!=");
    }
    if (r44 instanceof Error)
      throw r44;
    var f35 = { actual: e44, expected: n35, operator: void 0 === c44 ? "fail" : c44, stackStartFn: a44 || t44 };
    void 0 !== r44 && (f35.message = r44);
    var s44 = new b33(f35);
    throw i35 && (s44.message = i35, s44.generatedMessage = true), s44;
  }, x32.AssertionError = b33, x32.ok = k32, x32.equal = function t44(e44, n35, r44) {
    if (arguments.length < 2)
      throw new y34("actual", "expected");
    e44 != n35 && R32({ actual: e44, expected: n35, message: r44, operator: "==", stackStartFn: t44 });
  }, x32.notEqual = function t44(e44, n35, r44) {
    if (arguments.length < 2)
      throw new y34("actual", "expected");
    e44 == n35 && R32({ actual: e44, expected: n35, message: r44, operator: "!=", stackStartFn: t44 });
  }, x32.deepEqual = function t44(e44, n35, r44) {
    if (arguments.length < 2)
      throw new y34("actual", "expected");
    void 0 === a35 && j32(), a35(e44, n35) || R32({ actual: e44, expected: n35, message: r44, operator: "deepEqual", stackStartFn: t44 });
  }, x32.notDeepEqual = function t44(e44, n35, r44) {
    if (arguments.length < 2)
      throw new y34("actual", "expected");
    void 0 === a35 && j32(), a35(e44, n35) && R32({ actual: e44, expected: n35, message: r44, operator: "notDeepEqual", stackStartFn: t44 });
  }, x32.deepStrictEqual = function t44(e44, n35, r44) {
    if (arguments.length < 2)
      throw new y34("actual", "expected");
    void 0 === a35 && j32(), u35(e44, n35) || R32({ actual: e44, expected: n35, message: r44, operator: "deepStrictEqual", stackStartFn: t44 });
  }, x32.notDeepStrictEqual = function t44(e44, n35, r44) {
    if (arguments.length < 2)
      throw new y34("actual", "expected");
    void 0 === a35 && j32();
    u35(e44, n35) && R32({ actual: e44, expected: n35, message: r44, operator: "notDeepStrictEqual", stackStartFn: t44 });
  }, x32.strictEqual = function t44(e44, n35, r44) {
    if (arguments.length < 2)
      throw new y34("actual", "expected");
    S32(e44, n35) || R32({ actual: e44, expected: n35, message: r44, operator: "strictEqual", stackStartFn: t44 });
  }, x32.notStrictEqual = function t44(e44, n35, r44) {
    if (arguments.length < 2)
      throw new y34("actual", "expected");
    S32(e44, n35) && R32({ actual: e44, expected: n35, message: r44, operator: "notStrictEqual", stackStartFn: t44 });
  };
  var _32 = function t44(e44, n35, r44) {
    var o44 = this;
    !function(t53, e53) {
      if (!(t53 instanceof e53))
        throw new TypeError("Cannot call a class as a function");
    }(this, t44), n35.forEach(function(t53) {
      t53 in e44 && (void 0 !== r44 && "string" == typeof r44[t53] && E32(e44[t53]) && e44[t53].test(r44[t53]) ? o44[t53] = r44[t53] : o44[t53] = e44[t53]);
    });
  };
  function T42(t44, e44, n35, r44, o44, c44) {
    if (!(n35 in t44) || !u35(t44[n35], e44[n35])) {
      if (!r44) {
        var a44 = new _32(t44, o44), i35 = new _32(e44, o44, t44), l44 = new b33({ actual: a44, expected: i35, operator: "deepStrictEqual", stackStartFn: c44 });
        throw l44.actual = t44, l44.expected = e44, l44.operator = c44.name, l44;
      }
      R32({ actual: t44, expected: e44, message: r44, operator: c44.name, stackStartFn: c44 });
    }
  }
  function P32(t44, e44, n35, r44) {
    if ("function" != typeof e44) {
      if (E32(e44))
        return e44.test(t44);
      if (2 === arguments.length)
        throw new p35("expected", ["Function", "RegExp"], e44);
      if ("object" !== c35(t44) || null === t44) {
        var o44 = new b33({ actual: t44, expected: e44, message: n35, operator: "deepStrictEqual", stackStartFn: r44 });
        throw o44.operator = r44.name, o44;
      }
      var i35 = Object.keys(e44);
      if (e44 instanceof Error)
        i35.push("name", "message");
      else if (0 === i35.length)
        throw new g33("error", e44, "may not be an empty object");
      return void 0 === a35 && j32(), i35.forEach(function(o53) {
        "string" == typeof t44[o53] && E32(e44[o53]) && e44[o53].test(t44[o53]) || T42(t44, e44, o53, n35, i35, r44);
      }), true;
    }
    return void 0 !== e44.prototype && t44 instanceof e44 || !Error.isPrototypeOf(e44) && true === e44.call({}, t44);
  }
  function I32(t44) {
    if ("function" != typeof t44)
      throw new p35("fn", "Function", t44);
    try {
      t44();
    } catch (t53) {
      return t53;
    }
    return q32;
  }
  function D32(t44) {
    return m$122(t44) || null !== t44 && "object" === c35(t44) && "function" == typeof t44.then && "function" == typeof t44.catch;
  }
  function F32(t44) {
    return Promise.resolve().then(function() {
      var e44;
      if ("function" == typeof t44) {
        if (!D32(e44 = t44()))
          throw new h44("instance of Promise", "promiseFn", e44);
      } else {
        if (!D32(t44))
          throw new p35("promiseFn", ["Function", "Promise"], t44);
        e44 = t44;
      }
      return Promise.resolve().then(function() {
        return e44;
      }).then(function() {
        return q32;
      }).catch(function(t53) {
        return t53;
      });
    });
  }
  function N32(t44, e44, n35, r44) {
    if ("string" == typeof n35) {
      if (4 === arguments.length)
        throw new p35("error", ["Object", "Error", "Function", "RegExp"], n35);
      if ("object" === c35(e44) && null !== e44) {
        if (e44.message === n35)
          throw new s35("error/message", 'The error message "'.concat(e44.message, '" is identical to the message.'));
      } else if (e44 === n35)
        throw new s35("error/message", 'The error "'.concat(e44, '" is identical to the message.'));
      r44 = n35, n35 = void 0;
    } else if (null != n35 && "object" !== c35(n35) && "function" != typeof n35)
      throw new p35("error", ["Object", "Error", "Function", "RegExp"], n35);
    if (e44 === q32) {
      var o44 = "";
      n35 && n35.name && (o44 += " (".concat(n35.name, ")")), o44 += r44 ? ": ".concat(r44) : ".";
      var a44 = "rejects" === t44.name ? "rejection" : "exception";
      R32({ actual: void 0, expected: n35, operator: t44.name, message: "Missing expected ".concat(a44).concat(o44), stackStartFn: t44 });
    }
    if (n35 && !P32(e44, n35, r44, t44))
      throw e44;
  }
  function L32(t44, e44, n35, r44) {
    if (e44 !== q32) {
      if ("string" == typeof n35 && (r44 = n35, n35 = void 0), !n35 || P32(e44, n35)) {
        var o44 = r44 ? ": ".concat(r44) : ".", c44 = "doesNotReject" === t44.name ? "rejection" : "exception";
        R32({ actual: e44, expected: n35, operator: t44.name, message: "Got unwanted ".concat(c44).concat(o44, "\n") + 'Actual message: "'.concat(e44 && e44.message, '"'), stackStartFn: t44 });
      }
      throw e44;
    }
  }
  function M32() {
    for (var t44 = arguments.length, e44 = new Array(t44), n35 = 0; n35 < t44; n35++)
      e44[n35] = arguments[n35];
    A32.apply(void 0, [M32, e44.length].concat(e44));
  }
  return x32.throws = function t44(e44) {
    for (var n35 = arguments.length, r44 = new Array(n35 > 1 ? n35 - 1 : 0), o44 = 1; o44 < n35; o44++)
      r44[o44 - 1] = arguments[o44];
    N32.apply(void 0, [t44, I32(e44)].concat(r44));
  }, x32.rejects = function t44(e44) {
    for (var n35 = arguments.length, r44 = new Array(n35 > 1 ? n35 - 1 : 0), o44 = 1; o44 < n35; o44++)
      r44[o44 - 1] = arguments[o44];
    return F32(e44).then(function(e53) {
      return N32.apply(void 0, [t44, e53].concat(r44));
    });
  }, x32.doesNotThrow = function t44(e44) {
    for (var n35 = arguments.length, r44 = new Array(n35 > 1 ? n35 - 1 : 0), o44 = 1; o44 < n35; o44++)
      r44[o44 - 1] = arguments[o44];
    L32.apply(void 0, [t44, I32(e44)].concat(r44));
  }, x32.doesNotReject = function t44(e44) {
    for (var n35 = arguments.length, r44 = new Array(n35 > 1 ? n35 - 1 : 0), o44 = 1; o44 < n35; o44++)
      r44[o44 - 1] = arguments[o44];
    return F32(e44).then(function(e53) {
      return L32.apply(void 0, [t44, e53].concat(r44));
    });
  }, x32.ifError = function t44(e44) {
    if (null != e44) {
      var n35 = "ifError got unwanted exception: ";
      "object" === c35(e44) && "string" == typeof e44.message ? 0 === e44.message.length && e44.constructor ? n35 += e44.constructor.name : n35 += e44.message : n35 += v34(e44);
      var r44 = new b33({ actual: e44, expected: null, operator: "ifError", message: n35, stackStartFn: t44 }), o44 = e44.stack;
      if ("string" == typeof o44) {
        var a44 = o44.split("\n");
        a44.shift();
        for (var i35 = r44.stack.split("\n"), u44 = 0; u44 < a44.length; u44++) {
          var l44 = i35.indexOf(a44[u44]);
          if (-1 !== l44) {
            i35 = i35.slice(0, l44);
            break;
          }
        }
        r44.stack = "".concat(i35.join("\n"), "\n").concat(a44.join("\n"));
      }
      throw r44;
    }
  }, x32.strict = w32(M32, x32, { equal: x32.strictEqual, deepEqual: x32.deepStrictEqual, notEqual: x32.notStrictEqual, notDeepEqual: x32.notDeepStrictEqual }), x32.strict.strict = x32.strict, Z22;
}
var e11, t10, n11, r11, o11, l10, s9, f10, a10, T7, t24, e24, o24, n24, r24, l24, t$16, o$16, n$16, e$16, r$16, c24, u24, i24, t$25, i$16, o$26, u$16, f24, a24, s24, p24, y8, l$16, d24, m24, h24, j6, A6, Q5, X5, Y6, ee4, te4, re4, ne4, ie4, Se4, Ee4, r33, t33, e$123, r$123, n33, o33, c33, l33, i33, a33, u33, f33, p33, s33, y23, b23, g23, h33, $22, j23, w23, r$22, e$24, o$123, n$123, a$14, c$123, l$123, u$123, f$14, t$123, f$24, e$32, l$22, t$222, n$24, o$223, r$32, e$42, o$32, t$32, n$32, y$12, a$24, i$123, d33, f$32, u$24, A23, l$32, v23, P23, c$22, t$42, p$12, o$42, i$22, a$32, l$42, r$42, n$42, i$32, o$52, c$32, f$42, u$32, s$14, a$42, l$52, p$22, m33, N23, e$52, i$42, n$52, t$52, u$42, a$52, m$12, o$62, s$22, f$52, c$42, a$62, u$52, l$62, g$12, h$14, y$22, b$12, v$12, d$12, E23, w$12, S23, j$12, O23, x23, q22, R23, A$12, k23, _23, T33, P$12, I23, D23, F23, N$12, L23, M23, X22, Z22, $$12, et2, AssertionError2, deepEqual2, deepStrictEqual2, doesNotReject2, doesNotThrow2, equal2, fail2, ifError2, notDeepEqual2, notDeepStrictEqual2, notEqual2, notStrictEqual2, ok2, rejects2, strict2, strictEqual2, throws2;
var init_assert = __esm({
  "node-modules-polyfills:assert"() {
    r11 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis;
    o11 = e11 = {};
    !function() {
      try {
        t10 = "function" == typeof setTimeout ? setTimeout : i10;
      } catch (e44) {
        t10 = i10;
      }
      try {
        n11 = "function" == typeof clearTimeout ? clearTimeout : u10;
      } catch (e44) {
        n11 = u10;
      }
    }();
    s9 = [];
    f10 = false;
    a10 = -1;
    o11.nextTick = function(e44) {
      var t44 = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var n35 = 1; n35 < arguments.length; n35++)
          t44[n35 - 1] = arguments[n35];
      s9.push(new m8(e44, t44)), 1 !== s9.length || f10 || c10(d8);
    }, m8.prototype.run = function() {
      (this || r11).fun.apply(null, (this || r11).array);
    }, o11.title = "browser", o11.browser = true, o11.env = {}, o11.argv = [], o11.version = "", o11.versions = {}, o11.on = p10, o11.addListener = p10, o11.once = p10, o11.off = p10, o11.removeListener = p10, o11.removeAllListeners = p10, o11.emit = p10, o11.prependListener = p10, o11.prependOnceListener = p10, o11.listeners = function(e44) {
      return [];
    }, o11.binding = function(e44) {
      throw new Error("process.binding is not supported");
    }, o11.cwd = function() {
      return "/";
    }, o11.chdir = function(e44) {
      throw new Error("process.chdir is not supported");
    }, o11.umask = function() {
      return 0;
    };
    T7 = e11;
    T7.addListener;
    T7.argv;
    T7.binding;
    T7.browser;
    T7.chdir;
    T7.cwd;
    T7.emit;
    T7.env;
    T7.listeners;
    T7.nextTick;
    T7.off;
    T7.on;
    T7.once;
    T7.prependListener;
    T7.prependOnceListener;
    T7.removeAllListeners;
    T7.removeListener;
    T7.title;
    T7.umask;
    T7.version;
    T7.versions;
    t24 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
    e24 = Object.prototype.toString;
    o24 = function(o35) {
      return !(t24 && o35 && "object" == typeof o35 && Symbol.toStringTag in o35) && "[object Arguments]" === e24.call(o35);
    };
    n24 = function(t44) {
      return !!o24(t44) || null !== t44 && "object" == typeof t44 && "number" == typeof t44.length && t44.length >= 0 && "[object Array]" !== e24.call(t44) && "[object Function]" === e24.call(t44.callee);
    };
    r24 = function() {
      return o24(arguments);
    }();
    o24.isLegacyArguments = n24;
    l24 = r24 ? o24 : n24;
    t$16 = Object.prototype.toString;
    o$16 = Function.prototype.toString;
    n$16 = /^\s*(?:function)?\*/;
    e$16 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
    r$16 = Object.getPrototypeOf;
    c24 = function() {
      if (!e$16)
        return false;
      try {
        return Function("return function*() {}")();
      } catch (t44) {
      }
    }();
    u24 = c24 ? r$16(c24) : {};
    i24 = function(c35) {
      return "function" == typeof c35 && (!!n$16.test(o$16.call(c35)) || (e$16 ? r$16(c35) === u24 : "[object GeneratorFunction]" === t$16.call(c35)));
    };
    t$25 = "function" == typeof Object.create ? function(t44, e44) {
      e44 && (t44.super_ = e44, t44.prototype = Object.create(e44.prototype, { constructor: { value: t44, enumerable: false, writable: true, configurable: true } }));
    } : function(t44, e44) {
      if (e44) {
        t44.super_ = e44;
        var o35 = function() {
        };
        o35.prototype = e44.prototype, t44.prototype = new o35(), t44.prototype.constructor = t44;
      }
    };
    i$16 = function(e44) {
      return e44 && "object" == typeof e44 && "function" == typeof e44.copy && "function" == typeof e44.fill && "function" == typeof e44.readUInt8;
    };
    o$26 = {};
    u$16 = i$16;
    f24 = l24;
    a24 = i24;
    s24 = "undefined" != typeof BigInt;
    p24 = "undefined" != typeof Symbol;
    y8 = p24 && void 0 !== Symbol.toStringTag;
    l$16 = "undefined" != typeof Uint8Array;
    d24 = "undefined" != typeof ArrayBuffer;
    if (l$16 && y8)
      var g7 = Object.getPrototypeOf(Uint8Array.prototype), b7 = c$16(Object.getOwnPropertyDescriptor(g7, Symbol.toStringTag).get);
    m24 = c$16(Object.prototype.toString);
    h24 = c$16(Number.prototype.valueOf);
    j6 = c$16(String.prototype.valueOf);
    A6 = c$16(Boolean.prototype.valueOf);
    if (s24)
      var w6 = c$16(BigInt.prototype.valueOf);
    if (p24)
      var v8 = c$16(Symbol.prototype.valueOf);
    o$26.isArgumentsObject = f24, o$26.isGeneratorFunction = a24, o$26.isPromise = function(e44) {
      return "undefined" != typeof Promise && e44 instanceof Promise || null !== e44 && "object" == typeof e44 && "function" == typeof e44.then && "function" == typeof e44.catch;
    }, o$26.isArrayBufferView = function(e44) {
      return d24 && ArrayBuffer.isView ? ArrayBuffer.isView(e44) : S6(e44) || R6(e44);
    }, o$26.isTypedArray = S6, o$26.isUint8Array = B6, o$26.isUint8ClampedArray = k6, o$26.isUint16Array = E6, o$26.isUint32Array = D6, o$26.isInt8Array = U6, o$26.isInt16Array = P6, o$26.isInt32Array = x6, o$26.isFloat32Array = I6, o$26.isFloat64Array = M6, o$26.isBigInt64Array = z6, o$26.isBigUint64Array = F6, T24.working = "undefined" != typeof Map && T24(/* @__PURE__ */ new Map()), o$26.isMap = function(e44) {
      return "undefined" != typeof Map && (T24.working ? T24(e44) : e44 instanceof Map);
    }, N6.working = "undefined" != typeof Set && N6(/* @__PURE__ */ new Set()), o$26.isSet = function(e44) {
      return "undefined" != typeof Set && (N6.working ? N6(e44) : e44 instanceof Set);
    }, W5.working = "undefined" != typeof WeakMap && W5(/* @__PURE__ */ new WeakMap()), o$26.isWeakMap = function(e44) {
      return "undefined" != typeof WeakMap && (W5.working ? W5(e44) : e44 instanceof WeakMap);
    }, $5.working = "undefined" != typeof WeakSet && $5(/* @__PURE__ */ new WeakSet()), o$26.isWeakSet = function(e44) {
      return $5(e44);
    }, C6.working = "undefined" != typeof ArrayBuffer && C6(new ArrayBuffer()), o$26.isArrayBuffer = V5, G5.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && G5(new DataView(new ArrayBuffer(1), 0, 1)), o$26.isDataView = R6, J5.working = "undefined" != typeof SharedArrayBuffer && J5(new SharedArrayBuffer()), o$26.isSharedArrayBuffer = _6, o$26.isAsyncFunction = function(e44) {
      return "[object AsyncFunction]" === m24(e44);
    }, o$26.isMapIterator = function(e44) {
      return "[object Map Iterator]" === m24(e44);
    }, o$26.isSetIterator = function(e44) {
      return "[object Set Iterator]" === m24(e44);
    }, o$26.isGeneratorObject = function(e44) {
      return "[object Generator]" === m24(e44);
    }, o$26.isWebAssemblyCompiledModule = function(e44) {
      return "[object WebAssembly.Module]" === m24(e44);
    }, o$26.isNumberObject = H5, o$26.isStringObject = Z5, o$26.isBooleanObject = q5, o$26.isBigIntObject = K5, o$26.isSymbolObject = L6, o$26.isBoxedPrimitive = function(e44) {
      return H5(e44) || Z5(e44) || q5(e44) || K5(e44) || L6(e44);
    }, o$26.isAnyArrayBuffer = function(e44) {
      return l$16 && (V5(e44) || _6(e44));
    }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e44) {
      Object.defineProperty(o$26, e44, { enumerable: false, value: function() {
        throw new Error(e44 + " is not supported in userland");
      } });
    });
    Q5 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis;
    X5 = {};
    Y6 = T7;
    ee4 = Object.getOwnPropertyDescriptors || function(e44) {
      for (var t44 = Object.keys(e44), r44 = {}, n35 = 0; n35 < t44.length; n35++)
        r44[t44[n35]] = Object.getOwnPropertyDescriptor(e44, t44[n35]);
      return r44;
    };
    te4 = /%[sdj%]/g;
    X5.format = function(e44) {
      if (!ge4(e44)) {
        for (var t44 = [], r44 = 0; r44 < arguments.length; r44++)
          t44.push(oe4(arguments[r44]));
        return t44.join(" ");
      }
      r44 = 1;
      for (var n35 = arguments, i35 = n35.length, o35 = String(e44).replace(te4, function(e53) {
        if ("%%" === e53)
          return "%";
        if (r44 >= i35)
          return e53;
        switch (e53) {
          case "%s":
            return String(n35[r44++]);
          case "%d":
            return Number(n35[r44++]);
          case "%j":
            try {
              return JSON.stringify(n35[r44++]);
            } catch (e63) {
              return "[Circular]";
            }
          default:
            return e53;
        }
      }), u35 = n35[r44]; r44 < i35; u35 = n35[++r44])
        le4(u35) || !he4(u35) ? o35 += " " + u35 : o35 += " " + oe4(u35);
      return o35;
    }, X5.deprecate = function(e44, t44) {
      if (void 0 !== Y6 && true === Y6.noDeprecation)
        return e44;
      if (void 0 === Y6)
        return function() {
          return X5.deprecate(e44, t44).apply(this || Q5, arguments);
        };
      var r44 = false;
      return function() {
        if (!r44) {
          if (Y6.throwDeprecation)
            throw new Error(t44);
          Y6.traceDeprecation ? console.trace(t44) : console.error(t44), r44 = true;
        }
        return e44.apply(this || Q5, arguments);
      };
    };
    re4 = {};
    ne4 = /^$/;
    if (Y6.env.NODE_DEBUG) {
      ie4 = Y6.env.NODE_DEBUG;
      ie4 = ie4.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne4 = new RegExp("^" + ie4 + "$", "i");
    }
    X5.debuglog = function(e44) {
      if (e44 = e44.toUpperCase(), !re4[e44])
        if (ne4.test(e44)) {
          var t44 = Y6.pid;
          re4[e44] = function() {
            var r44 = X5.format.apply(X5, arguments);
            console.error("%s %d: %s", e44, t44, r44);
          };
        } else
          re4[e44] = function() {
          };
      return re4[e44];
    }, X5.inspect = oe4, oe4.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe4.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X5.types = o$26, X5.isArray = pe4, X5.isBoolean = ye4, X5.isNull = le4, X5.isNullOrUndefined = function(e44) {
      return null == e44;
    }, X5.isNumber = de4, X5.isString = ge4, X5.isSymbol = function(e44) {
      return "symbol" == typeof e44;
    }, X5.isUndefined = be4, X5.isRegExp = me4, X5.types.isRegExp = me4, X5.isObject = he4, X5.isDate = je4, X5.types.isDate = je4, X5.isError = Ae4, X5.types.isNativeError = Ae4, X5.isFunction = we4, X5.isPrimitive = function(e44) {
      return null === e44 || "boolean" == typeof e44 || "number" == typeof e44 || "string" == typeof e44 || "symbol" == typeof e44 || void 0 === e44;
    }, X5.isBuffer = i$16;
    Se4 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    X5.log = function() {
      console.log("%s - %s", Be4(), X5.format.apply(X5, arguments));
    }, X5.inherits = t$25, X5._extend = function(e44, t44) {
      if (!t44 || !he4(t44))
        return e44;
      for (var r44 = Object.keys(t44), n35 = r44.length; n35--; )
        e44[r44[n35]] = t44[r44[n35]];
      return e44;
    };
    Ee4 = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
    X5.promisify = function(e44) {
      if ("function" != typeof e44)
        throw new TypeError('The "original" argument must be of type Function');
      if (Ee4 && e44[Ee4]) {
        var t44;
        if ("function" != typeof (t44 = e44[Ee4]))
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(t44, Ee4, { value: t44, enumerable: false, writable: false, configurable: true }), t44;
      }
      function t44() {
        for (var t53, r44, n35 = new Promise(function(e53, n44) {
          t53 = e53, r44 = n44;
        }), i35 = [], o35 = 0; o35 < arguments.length; o35++)
          i35.push(arguments[o35]);
        i35.push(function(e53, n44) {
          e53 ? r44(e53) : t53(n44);
        });
        try {
          e44.apply(this || Q5, i35);
        } catch (e53) {
          r44(e53);
        }
        return n35;
      }
      return Object.setPrototypeOf(t44, Object.getPrototypeOf(e44)), Ee4 && Object.defineProperty(t44, Ee4, { value: t44, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t44, ee4(e44));
    }, X5.promisify.custom = Ee4, X5.callbackify = function(e44) {
      if ("function" != typeof e44)
        throw new TypeError('The "original" argument must be of type Function');
      function t44() {
        for (var t53 = [], r44 = 0; r44 < arguments.length; r44++)
          t53.push(arguments[r44]);
        var n35 = t53.pop();
        if ("function" != typeof n35)
          throw new TypeError("The last argument must be of type Function");
        var i35 = this || Q5, o35 = function() {
          return n35.apply(i35, arguments);
        };
        e44.apply(this || Q5, t53).then(function(e53) {
          Y6.nextTick(o35.bind(null, null, e53));
        }, function(e53) {
          Y6.nextTick(De4.bind(null, e53, o35));
        });
      }
      return Object.setPrototypeOf(t44, Object.getPrototypeOf(e44)), Object.defineProperties(t44, ee4(e44)), t44;
    };
    r33 = { assign: e33, polyfill: function() {
      Object.assign || Object.defineProperty(Object, "assign", { enumerable: false, configurable: true, writable: true, value: e33 });
    } };
    e$123 = Object.prototype.toString;
    r$123 = function(t44) {
      var r44 = e$123.call(t44), n35 = "[object Arguments]" === r44;
      return n35 || (n35 = "[object Array]" !== r44 && null !== t44 && "object" == typeof t44 && "number" == typeof t44.length && t44.length >= 0 && "[object Function]" === e$123.call(t44.callee)), n35;
    };
    if (!Object.keys) {
      n33 = Object.prototype.hasOwnProperty, o33 = Object.prototype.toString, c33 = r$123, l33 = Object.prototype.propertyIsEnumerable, i33 = !l33.call({ toString: null }, "toString"), a33 = l33.call(function() {
      }, "prototype"), u33 = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], f33 = function(t44) {
        var e44 = t44.constructor;
        return e44 && e44.prototype === t44;
      }, p33 = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, s33 = function() {
        if ("undefined" == typeof window)
          return false;
        for (var t44 in window)
          try {
            if (!p33["$" + t44] && n33.call(window, t44) && null !== window[t44] && "object" == typeof window[t44])
              try {
                f33(window[t44]);
              } catch (t53) {
                return true;
              }
          } catch (t53) {
            return true;
          }
        return false;
      }();
      t33 = function(t44) {
        var e44 = null !== t44 && "object" == typeof t44, r44 = "[object Function]" === o33.call(t44), l44 = c33(t44), p44 = e44 && "[object String]" === o33.call(t44), y34 = [];
        if (!e44 && !r44 && !l44)
          throw new TypeError("Object.keys called on a non-object");
        var b33 = a33 && r44;
        if (p44 && t44.length > 0 && !n33.call(t44, 0))
          for (var g33 = 0; g33 < t44.length; ++g33)
            y34.push(String(g33));
        if (l44 && t44.length > 0)
          for (var h44 = 0; h44 < t44.length; ++h44)
            y34.push(String(h44));
        else
          for (var $32 in t44)
            b33 && "prototype" === $32 || !n33.call(t44, $32) || y34.push(String($32));
        if (i33)
          for (var j32 = function(t53) {
            if ("undefined" == typeof window || !s33)
              return f33(t53);
            try {
              return f33(t53);
            } catch (t63) {
              return false;
            }
          }(t44), w32 = 0; w32 < u33.length; ++w32)
            j32 && "constructor" === u33[w32] || !n33.call(t44, u33[w32]) || y34.push(u33[w32]);
        return y34;
      };
    }
    y23 = t33;
    b23 = Array.prototype.slice;
    g23 = r$123;
    h33 = Object.keys;
    $22 = h33 ? function(t44) {
      return h33(t44);
    } : y23;
    j23 = Object.keys;
    $22.shim = function() {
      Object.keys ? function() {
        var t44 = Object.keys(arguments);
        return t44 && t44.length === arguments.length;
      }(1, 2) || (Object.keys = function(t44) {
        return g23(t44) ? j23(b23.call(t44)) : j23(t44);
      }) : Object.keys = $22;
      return Object.keys || $22;
    };
    w23 = $22;
    r$22 = w23;
    e$24 = "function" == typeof Symbol && "symbol" == typeof Symbol("foo");
    o$123 = Object.prototype.toString;
    n$123 = Array.prototype.concat;
    a$14 = Object.defineProperty;
    c$123 = a$14 && function() {
      var t44 = {};
      try {
        for (var r44 in a$14(t44, "x", { enumerable: false, value: t44 }), t44)
          return false;
        return t44.x === t44;
      } catch (t53) {
        return false;
      }
    }();
    l$123 = function(t44, r44, e44, n35) {
      var l35;
      (!(r44 in t44) || "function" == typeof (l35 = n35) && "[object Function]" === o$123.call(l35) && n35()) && (c$123 ? a$14(t44, r44, { configurable: true, enumerable: false, value: e44, writable: true }) : t44[r44] = e44);
    };
    u$123 = function(t44, o35) {
      var a35 = arguments.length > 2 ? arguments[2] : {}, c35 = r$22(o35);
      e$24 && (c35 = n$123.call(c35, Object.getOwnPropertySymbols(o35)));
      for (var u35 = 0; u35 < c35.length; u35 += 1)
        l$123(t44, c35[u35], o35[c35[u35]], a35[c35[u35]]);
    };
    u$123.supportsDescriptors = !!c$123;
    f$14 = u$123;
    t$123 = function() {
      if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols)
        return false;
      if ("symbol" == typeof Symbol.iterator)
        return true;
      var t44 = {}, e44 = Symbol("test"), r44 = Object(e44);
      if ("string" == typeof e44)
        return false;
      if ("[object Symbol]" !== Object.prototype.toString.call(e44))
        return false;
      if ("[object Symbol]" !== Object.prototype.toString.call(r44))
        return false;
      for (e44 in t44[e44] = 42, t44)
        return false;
      if ("function" == typeof Object.keys && 0 !== Object.keys(t44).length)
        return false;
      if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t44).length)
        return false;
      var o35 = Object.getOwnPropertySymbols(t44);
      if (1 !== o35.length || o35[0] !== e44)
        return false;
      if (!Object.prototype.propertyIsEnumerable.call(t44, e44))
        return false;
      if ("function" == typeof Object.getOwnPropertyDescriptor) {
        var n35 = Object.getOwnPropertyDescriptor(t44, e44);
        if (42 !== n35.value || true !== n35.enumerable)
          return false;
      }
      return true;
    };
    f$24 = ("undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis).Symbol;
    e$32 = t$123;
    l$22 = function() {
      return "function" == typeof f$24 && ("function" == typeof Symbol && ("symbol" == typeof f$24("foo") && ("symbol" == typeof Symbol("bar") && e$32())));
    };
    t$222 = "Function.prototype.bind called on incompatible ";
    n$24 = Array.prototype.slice;
    o$223 = Object.prototype.toString;
    r$32 = function(r44) {
      var e44 = this;
      if ("function" != typeof e44 || "[object Function]" !== o$223.call(e44))
        throw new TypeError(t$222 + e44);
      for (var p35, i35 = n$24.call(arguments, 1), c35 = function() {
        if (this instanceof p35) {
          var t44 = e44.apply(this, i35.concat(n$24.call(arguments)));
          return Object(t44) === t44 ? t44 : this;
        }
        return e44.apply(r44, i35.concat(n$24.call(arguments)));
      }, a35 = Math.max(0, e44.length - i35.length), l35 = [], u35 = 0; u35 < a35; u35++)
        l35.push("$" + u35);
      if (p35 = Function("binder", "return function (" + l35.join(",") + "){ return binder.apply(this,arguments); }")(c35), e44.prototype) {
        var y34 = function() {
        };
        y34.prototype = e44.prototype, p35.prototype = new y34(), y34.prototype = null;
      }
      return p35;
    };
    e$42 = Function.prototype.bind || r$32;
    o$32 = TypeError;
    t$32 = Object.getOwnPropertyDescriptor;
    if (t$32)
      try {
        t$32({}, "");
      } catch (r44) {
        t$32 = null;
      }
    n$32 = function() {
      throw new o$32();
    };
    y$12 = t$32 ? function() {
      try {
        return arguments.callee, n$32;
      } catch (r44) {
        try {
          return t$32(arguments, "callee").get;
        } catch (r53) {
          return n$32;
        }
      }
    }() : n$32;
    a$24 = l$22();
    i$123 = Object.getPrototypeOf || function(r44) {
      return r44.__proto__;
    };
    d33 = "undefined" == typeof Uint8Array ? void 0 : i$123(Uint8Array);
    f$32 = { "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer, "%ArrayBufferPrototype%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer.prototype, "%ArrayIteratorPrototype%": a$24 ? i$123([][Symbol.iterator]()) : void 0, "%ArrayPrototype%": Array.prototype, "%ArrayProto_entries%": Array.prototype.entries, "%ArrayProto_forEach%": Array.prototype.forEach, "%ArrayProto_keys%": Array.prototype.keys, "%ArrayProto_values%": Array.prototype.values, "%AsyncFromSyncIteratorPrototype%": void 0, "%AsyncFunction%": void 0, "%AsyncFunctionPrototype%": void 0, "%AsyncGenerator%": void 0, "%AsyncGeneratorFunction%": void 0, "%AsyncGeneratorPrototype%": void 0, "%AsyncIteratorPrototype%": void 0, "%Atomics%": "undefined" == typeof Atomics ? void 0 : Atomics, "%Boolean%": Boolean, "%BooleanPrototype%": Boolean.prototype, "%DataView%": "undefined" == typeof DataView ? void 0 : DataView, "%DataViewPrototype%": "undefined" == typeof DataView ? void 0 : DataView.prototype, "%Date%": Date, "%DatePrototype%": Date.prototype, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%ErrorPrototype%": Error.prototype, "%eval%": eval, "%EvalError%": EvalError, "%EvalErrorPrototype%": EvalError.prototype, "%Float32Array%": "undefined" == typeof Float32Array ? void 0 : Float32Array, "%Float32ArrayPrototype%": "undefined" == typeof Float32Array ? void 0 : Float32Array.prototype, "%Float64Array%": "undefined" == typeof Float64Array ? void 0 : Float64Array, "%Float64ArrayPrototype%": "undefined" == typeof Float64Array ? void 0 : Float64Array.prototype, "%Function%": Function, "%FunctionPrototype%": Function.prototype, "%Generator%": void 0, "%GeneratorFunction%": void 0, "%GeneratorPrototype%": void 0, "%Int8Array%": "undefined" == typeof Int8Array ? void 0 : Int8Array, "%Int8ArrayPrototype%": "undefined" == typeof Int8Array ? void 0 : Int8Array.prototype, "%Int16Array%": "undefined" == typeof Int16Array ? void 0 : Int16Array, "%Int16ArrayPrototype%": "undefined" == typeof Int16Array ? void 0 : Int8Array.prototype, "%Int32Array%": "undefined" == typeof Int32Array ? void 0 : Int32Array, "%Int32ArrayPrototype%": "undefined" == typeof Int32Array ? void 0 : Int32Array.prototype, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": a$24 ? i$123(i$123([][Symbol.iterator]())) : void 0, "%JSON%": "object" == typeof JSON ? JSON : void 0, "%JSONParse%": "object" == typeof JSON ? JSON.parse : void 0, "%Map%": "undefined" == typeof Map ? void 0 : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && a$24 ? i$123((/* @__PURE__ */ new Map())[Symbol.iterator]()) : void 0, "%MapPrototype%": "undefined" == typeof Map ? void 0 : Map.prototype, "%Math%": Math, "%Number%": Number, "%NumberPrototype%": Number.prototype, "%Object%": Object, "%ObjectPrototype%": Object.prototype, "%ObjProto_toString%": Object.prototype.toString, "%ObjProto_valueOf%": Object.prototype.valueOf, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? void 0 : Promise, "%PromisePrototype%": "undefined" == typeof Promise ? void 0 : Promise.prototype, "%PromiseProto_then%": "undefined" == typeof Promise ? void 0 : Promise.prototype.then, "%Promise_all%": "undefined" == typeof Promise ? void 0 : Promise.all, "%Promise_reject%": "undefined" == typeof Promise ? void 0 : Promise.reject, "%Promise_resolve%": "undefined" == typeof Promise ? void 0 : Promise.resolve, "%Proxy%": "undefined" == typeof Proxy ? void 0 : Proxy, "%RangeError%": RangeError, "%RangeErrorPrototype%": RangeError.prototype, "%ReferenceError%": ReferenceError, "%ReferenceErrorPrototype%": ReferenceError.prototype, "%Reflect%": "undefined" == typeof Reflect ? void 0 : Reflect, "%RegExp%": RegExp, "%RegExpPrototype%": RegExp.prototype, "%Set%": "undefined" == typeof Set ? void 0 : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && a$24 ? i$123((/* @__PURE__ */ new Set())[Symbol.iterator]()) : void 0, "%SetPrototype%": "undefined" == typeof Set ? void 0 : Set.prototype, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer, "%SharedArrayBufferPrototype%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer.prototype, "%String%": String, "%StringIteratorPrototype%": a$24 ? i$123(""[Symbol.iterator]()) : void 0, "%StringPrototype%": String.prototype, "%Symbol%": a$24 ? Symbol : void 0, "%SymbolPrototype%": a$24 ? Symbol.prototype : void 0, "%SyntaxError%": SyntaxError, "%SyntaxErrorPrototype%": SyntaxError.prototype, "%ThrowTypeError%": y$12, "%TypedArray%": d33, "%TypedArrayPrototype%": d33 ? d33.prototype : void 0, "%TypeError%": o$32, "%TypeErrorPrototype%": o$32.prototype, "%Uint8Array%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array, "%Uint8ArrayPrototype%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array.prototype, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray, "%Uint8ClampedArrayPrototype%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray.prototype, "%Uint16Array%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array, "%Uint16ArrayPrototype%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array.prototype, "%Uint32Array%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array, "%Uint32ArrayPrototype%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array.prototype, "%URIError%": URIError, "%URIErrorPrototype%": URIError.prototype, "%WeakMap%": "undefined" == typeof WeakMap ? void 0 : WeakMap, "%WeakMapPrototype%": "undefined" == typeof WeakMap ? void 0 : WeakMap.prototype, "%WeakSet%": "undefined" == typeof WeakSet ? void 0 : WeakSet, "%WeakSetPrototype%": "undefined" == typeof WeakSet ? void 0 : WeakSet.prototype };
    u$24 = e$42.call(Function.call, String.prototype.replace);
    A23 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    l$32 = /\\(\\)?/g;
    v23 = function(r44) {
      var e44 = [];
      return u$24(r44, A23, function(r53, o35, t44, n35) {
        e44[e44.length] = t44 ? u$24(n35, l$32, "$1") : o35 || r53;
      }), e44;
    };
    P23 = function(r44, e44) {
      if (!(r44 in f$32))
        throw new SyntaxError("intrinsic " + r44 + " does not exist!");
      if (void 0 === f$32[r44] && !e44)
        throw new o$32("intrinsic " + r44 + " exists, but is not available. Please file an issue!");
      return f$32[r44];
    };
    c$22 = function(r44, e44) {
      if ("string" != typeof r44 || 0 === r44.length)
        throw new TypeError("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && "boolean" != typeof e44)
        throw new TypeError('"allowMissing" argument must be a boolean');
      for (var n35 = v23(r44), y34 = P23("%" + (n35.length > 0 ? n35[0] : "") + "%", e44), a35 = 1; a35 < n35.length; a35 += 1)
        if (null != y34)
          if (t$32 && a35 + 1 >= n35.length) {
            var i35 = t$32(y34, n35[a35]);
            if (!e44 && !(n35[a35] in y34))
              throw new o$32("base intrinsic for " + r44 + " exists, but the property is not available.");
            y34 = i35 ? i35.get || i35.value : y34[n35[a35]];
          } else
            y34 = y34[n35[a35]];
      return y34;
    };
    p$12 = e$42;
    o$42 = c$22("%Function%");
    i$22 = o$42.apply;
    a$32 = o$42.call;
    (t$42 = function() {
      return p$12.apply(a$32, arguments);
    }).apply = function() {
      return p$12.apply(i$22, arguments);
    };
    l$42 = t$42;
    i$32 = function(t44) {
      return t44 != t44;
    };
    o$52 = (r$42 = function(t44, e44) {
      return 0 === t44 && 0 === e44 ? 1 / t44 == 1 / e44 : t44 === e44 || !(!i$32(t44) || !i$32(e44));
    }, r$42);
    c$32 = (n$42 = function() {
      return "function" == typeof Object.is ? Object.is : o$52;
    }, n$42);
    f$42 = f$14;
    u$32 = f$14;
    s$14 = r$42;
    a$42 = n$42;
    l$52 = function() {
      var t44 = c$32();
      return f$42(Object, { is: t44 }, { is: function() {
        return Object.is !== t44;
      } }), t44;
    };
    p$22 = l$42(a$42(), Object);
    u$32(p$22, { getPolyfill: a$42, implementation: s$14, shim: l$52 });
    m33 = p$22;
    N23 = function(r44) {
      return r44 != r44;
    };
    i$42 = N23;
    n$52 = (e$52 = function() {
      return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : i$42;
    }, f$14);
    t$52 = e$52;
    u$42 = f$14;
    a$52 = N23;
    m$12 = e$52;
    o$62 = function() {
      var r44 = t$52();
      return n$52(Number, { isNaN: r44 }, { isNaN: function() {
        return Number.isNaN !== r44;
      } }), r44;
    };
    s$22 = m$12();
    u$42(s$22, { getPolyfill: m$12, implementation: a$52, shim: o$62 });
    f$52 = s$22;
    c$42 = {};
    a$62 = false;
    u$52 = {};
    l$62 = false;
    g$12 = void 0 !== /a/g.flags;
    h$14 = function(t44) {
      var e44 = [];
      return t44.forEach(function(t53) {
        return e44.push(t53);
      }), e44;
    };
    y$22 = function(t44) {
      var e44 = [];
      return t44.forEach(function(t53, n35) {
        return e44.push([n35, t53]);
      }), e44;
    };
    b$12 = Object.is ? Object.is : m33;
    v$12 = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
      return [];
    };
    d$12 = Number.isNaN ? Number.isNaN : f$52;
    E23 = m$22(Object.prototype.hasOwnProperty);
    w$12 = m$22(Object.prototype.propertyIsEnumerable);
    S23 = m$22(Object.prototype.toString);
    j$12 = X5.types;
    O23 = j$12.isAnyArrayBuffer;
    x23 = j$12.isArrayBufferView;
    q22 = j$12.isDate;
    R23 = j$12.isMap;
    A$12 = j$12.isRegExp;
    k23 = j$12.isSet;
    _23 = j$12.isNativeError;
    T33 = j$12.isBoxedPrimitive;
    P$12 = j$12.isNumberObject;
    I23 = j$12.isStringObject;
    D23 = j$12.isBooleanObject;
    F23 = j$12.isBigIntObject;
    N$12 = j$12.isSymbolObject;
    L23 = j$12.isFloat32Array;
    M23 = j$12.isFloat64Array;
    X22 = { isDeepEqual: function(t44, e44) {
      return B23(t44, e44, false);
    }, isDeepStrictEqual: function(t44, e44) {
      return B23(t44, e44, true);
    } };
    Z22 = {};
    $$12 = false;
    et2 = tt2();
    et2.AssertionError;
    et2.deepEqual;
    et2.deepStrictEqual;
    et2.doesNotReject;
    et2.doesNotThrow;
    et2.equal;
    et2.fail;
    et2.ifError;
    et2.notDeepEqual;
    et2.notDeepStrictEqual;
    et2.notEqual;
    et2.notStrictEqual;
    et2.ok;
    et2.rejects;
    et2.strict;
    et2.strictEqual;
    et2.throws;
    et2.AssertionError;
    et2.deepEqual;
    et2.deepStrictEqual;
    et2.doesNotReject;
    et2.doesNotThrow;
    et2.equal;
    et2.fail;
    et2.ifError;
    et2.notDeepEqual;
    et2.notDeepStrictEqual;
    et2.notEqual;
    et2.notStrictEqual;
    et2.ok;
    et2.rejects;
    et2.strict;
    et2.strictEqual;
    et2.throws;
    AssertionError2 = et2.AssertionError;
    deepEqual2 = et2.deepEqual;
    deepStrictEqual2 = et2.deepStrictEqual;
    doesNotReject2 = et2.doesNotReject;
    doesNotThrow2 = et2.doesNotThrow;
    equal2 = et2.equal;
    fail2 = et2.fail;
    ifError2 = et2.ifError;
    notDeepEqual2 = et2.notDeepEqual;
    notDeepStrictEqual2 = et2.notDeepStrictEqual;
    notEqual2 = et2.notEqual;
    notStrictEqual2 = et2.notStrictEqual;
    ok2 = et2.ok;
    rejects2 = et2.rejects;
    strict2 = et2.strict;
    strictEqual2 = et2.strictEqual;
    throws2 = et2.throws;
  }
});

// node-modules-polyfills-commonjs:assert
var assert_exports = {};
__export(assert_exports, {
  AssertionError: () => AssertionError2,
  deepEqual: () => deepEqual2,
  deepStrictEqual: () => deepStrictEqual2,
  doesNotReject: () => doesNotReject2,
  doesNotThrow: () => doesNotThrow2,
  equal: () => equal2,
  fail: () => fail2,
  ifError: () => ifError2,
  notDeepEqual: () => notDeepEqual2,
  notDeepStrictEqual: () => notDeepStrictEqual2,
  notEqual: () => notEqual2,
  notStrictEqual: () => notStrictEqual2,
  ok: () => ok2,
  rejects: () => rejects2,
  strict: () => strict2,
  strictEqual: () => strictEqual2,
  throws: () => throws2
});
var init_assert2 = __esm({
  "node-modules-polyfills-commonjs:assert"() {
    init_assert();
  }
});

// node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js"(exports10, module2) {
    var fs2 = (init_fs2(), __toCommonJS(fs_exports));
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = (init_util2(), __toCommonJS(util_exports));
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m10 = util.format.apply(util, arguments);
        m10 = "GFS4: " + m10.split(/\n/).join("\nGFS4: ");
        console.error(m10);
      };
    if (!fs2[gracefulQueue]) {
      queue = globalThis[gracefulQueue] || [];
      publishQueue(fs2, queue);
      fs2.close = function(fs$close) {
        function close2(fd, cb) {
          return fs$close.call(fs2, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close2, previousSymbol, {
          value: fs$close
        });
        return close2;
      }(fs2.close);
      fs2.closeSync = function(fs$closeSync) {
        function closeSync2(fd) {
          fs$closeSync.apply(fs2, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync2, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync2;
      }(fs2.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs2[gracefulQueue]);
          (init_assert2(), __toCommonJS(assert_exports)).equal(fs2[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!globalThis[gracefulQueue]) {
      publishQueue(globalThis, fs2[gracefulQueue]);
    }
    module2.exports = patch(clone(fs2));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
      module2.exports = patch(fs2);
      fs2.__patched = true;
    }
    function patch(fs3) {
      polyfills(fs3);
      fs3.gracefulify = patch;
      fs3.createReadStream = createReadStream2;
      fs3.createWriteStream = createWriteStream2;
      var fs$readFile = fs3.readFile;
      fs3.readFile = readFile2;
      function readFile2(path3, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path3, options, cb);
        function go$readFile(path4, options2, cb2, startTime) {
          return fs$readFile(path4, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path4, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs3.writeFile;
      fs3.writeFile = writeFile2;
      function writeFile2(path3, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path3, data, options, cb);
        function go$writeFile(path4, data2, options2, cb2, startTime) {
          return fs$writeFile(path4, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path4, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs3.appendFile;
      if (fs$appendFile)
        fs3.appendFile = appendFile2;
      function appendFile2(path3, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path3, data, options, cb);
        function go$appendFile(path4, data2, options2, cb2, startTime) {
          return fs$appendFile(path4, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path4, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs3.copyFile;
      if (fs$copyFile)
        fs3.copyFile = copyFile2;
      function copyFile2(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs3.readdir;
      fs3.readdir = readdir2;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir2(path3, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path4, options2, cb2, startTime) {
          return fs$readdir(path4, fs$readdirCallback(
            path4,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path4, options2, cb2, startTime) {
          return fs$readdir(path4, options2, fs$readdirCallback(
            path4,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path3, options, cb);
        function fs$readdirCallback(path4, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path4, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs3);
        ReadStream2 = legStreams.ReadStream;
        WriteStream2 = legStreams.WriteStream;
      }
      var fs$ReadStream = fs3.ReadStream;
      if (fs$ReadStream) {
        ReadStream2.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream2.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs3.WriteStream;
      if (fs$WriteStream) {
        WriteStream2.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream2.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs3, "ReadStream", {
        get: function() {
          return ReadStream2;
        },
        set: function(val) {
          ReadStream2 = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs3, "WriteStream", {
        get: function() {
          return WriteStream2;
        },
        set: function(val) {
          WriteStream2 = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream2 = ReadStream2;
      Object.defineProperty(fs3, "FileReadStream", {
        get: function() {
          return FileReadStream2;
        },
        set: function(val) {
          FileReadStream2 = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream2 = WriteStream2;
      Object.defineProperty(fs3, "FileWriteStream", {
        get: function() {
          return FileWriteStream2;
        },
        set: function(val) {
          FileWriteStream2 = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream2(path3, options) {
        if (this instanceof ReadStream2)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream2.apply(Object.create(ReadStream2.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open2(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream2(path3, options) {
        if (this instanceof WriteStream2)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream2.apply(Object.create(WriteStream2.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open2(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream2(path3, options) {
        return new fs3.ReadStream(path3, options);
      }
      function createWriteStream2(path3, options) {
        return new fs3.WriteStream(path3, options);
      }
      var fs$open = fs3.open;
      fs3.open = open2;
      function open2(path3, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path3, flags, mode, cb);
        function go$open(path4, flags2, mode2, cb2, startTime) {
          return fs$open(path4, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path4, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs3;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs2[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i13 = 0; i13 < fs2[gracefulQueue].length; ++i13) {
        if (fs2[gracefulQueue][i13].length > 2) {
          fs2[gracefulQueue][i13][3] = now;
          fs2[gracefulQueue][i13][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs2[gracefulQueue].length === 0)
        return;
      var elem = fs2[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs2[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/fs/index.js"(exports10) {
    "use strict";
    var u13 = require_universalify().fromCallback;
    var fs2 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs2[key] === "function";
    });
    Object.keys(fs2).forEach((key) => {
      if (key === "promises") {
        return;
      }
      exports10[key] = fs2[key];
    });
    api.forEach((method) => {
      exports10[method] = u13(fs2[method]);
    });
    exports10.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs2.exists(filename, callback);
      }
      return new Promise((resolve4) => {
        return fs2.exists(filename, resolve4);
      });
    };
    exports10.read = function(fd, buffer4, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs2.read(fd, buffer4, offset, length, position, callback);
      }
      return new Promise((resolve4, reject) => {
        fs2.read(fd, buffer4, offset, length, position, (err, bytesRead, buffer5) => {
          if (err)
            return reject(err);
          resolve4({ bytesRead, buffer: buffer5 });
        });
      });
    };
    exports10.write = function(fd, buffer4, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs2.write(fd, buffer4, ...args);
      }
      return new Promise((resolve4, reject) => {
        fs2.write(fd, buffer4, ...args, (err, bytesWritten, buffer5) => {
          if (err)
            return reject(err);
          resolve4({ bytesWritten, buffer: buffer5 });
        });
      });
    };
    if (typeof fs2.writev === "function") {
      exports10.writev = function(fd, buffers, ...args) {
        if (typeof args[args.length - 1] === "function") {
          return fs2.writev(fd, buffers, ...args);
        }
        return new Promise((resolve4, reject) => {
          fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
            if (err)
              return reject(err);
            resolve4({ bytesWritten, buffers: buffers2 });
          });
        });
      };
    }
    if (typeof fs2.realpath.native === "function") {
      exports10.realpath.native = u13(fs2.realpath.native);
    }
  }
});

// node_modules/.pnpm/at-least-node@1.0.0/node_modules/at-least-node/index.js
var require_at_least_node = __commonJS({
  "node_modules/.pnpm/at-least-node@1.0.0/node_modules/at-least-node/index.js"(exports10, module2) {
    module2.exports = (r14) => {
      const n14 = process.versions.node.split(".").map((x8) => parseInt(x8, 10));
      r14 = r14.split(".").map((x8) => parseInt(x8, 10));
      return n14[0] > r14[0] || n14[0] === r14[0] && (n14[1] > r14[1] || n14[1] === r14[1] && n14[2] >= r14[2]);
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports10, module2) {
    "use strict";
    var fs2 = require_fs();
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var atLeastNode = require_at_least_node();
    var useNativeRecursiveOption = atLeastNode("10.12.0");
    var checkPath = (pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path3.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
    var processOptions = (options) => {
      const defaults = { mode: 511 };
      if (typeof options === "number")
        options = { mode: options };
      return { ...defaults, ...options };
    };
    var permissionError = (pth) => {
      const error = new Error(`operation not permitted, mkdir '${pth}'`);
      error.code = "EPERM";
      error.errno = -4048;
      error.path = pth;
      error.syscall = "mkdir";
      return error;
    };
    module2.exports.makeDir = async (input, options) => {
      checkPath(input);
      options = processOptions(options);
      if (useNativeRecursiveOption) {
        const pth = path3.resolve(input);
        return fs2.mkdir(pth, {
          mode: options.mode,
          recursive: true
        });
      }
      const make = async (pth) => {
        try {
          await fs2.mkdir(pth, options.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path3.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            await make(path3.dirname(pth));
            return make(pth);
          }
          try {
            const stats = await fs2.stat(pth);
            if (!stats.isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch {
            throw error;
          }
        }
      };
      return make(path3.resolve(input));
    };
    module2.exports.makeDirSync = (input, options) => {
      checkPath(input);
      options = processOptions(options);
      if (useNativeRecursiveOption) {
        const pth = path3.resolve(input);
        return fs2.mkdirSync(pth, {
          mode: options.mode,
          recursive: true
        });
      }
      const make = (pth) => {
        try {
          fs2.mkdirSync(pth, options.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path3.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            make(path3.dirname(pth));
            return make(pth);
          }
          try {
            if (!fs2.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch {
            throw error;
          }
        }
      };
      return make(path3.resolve(input));
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/mkdirs/index.js"(exports10, module2) {
    "use strict";
    var u13 = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u13(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/util/utimes.js"(exports10, module2) {
    "use strict";
    var fs2 = require_graceful_fs();
    function utimesMillis(path3, atime, mtime, callback) {
      fs2.open(path3, "r+", (err, fd) => {
        if (err)
          return callback(err);
        fs2.futimes(fd, atime, mtime, (futimesErr) => {
          fs2.close(fd, (closeErr) => {
            if (callback)
              callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path3, atime, mtime) {
      const fd = fs2.openSync(path3, "r+");
      fs2.futimesSync(fd, atime, mtime);
      return fs2.closeSync(fd);
    }
    module2.exports = {
      utimesMillis,
      utimesMillisSync
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/util/stat.js"(exports10, module2) {
    "use strict";
    var fs2 = require_fs();
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var util = (init_util2(), __toCommonJS(util_exports));
    var atLeastNode = require_at_least_node();
    var nodeSupportsBigInt = atLeastNode("10.5.0");
    var stat2 = (file) => nodeSupportsBigInt ? fs2.stat(file, { bigint: true }) : fs2.stat(file);
    var statSync2 = (file) => nodeSupportsBigInt ? fs2.statSync(file, { bigint: true }) : fs2.statSync(file);
    function getStats(src, dest) {
      return Promise.all([
        stat2(src),
        stat2(dest).catch((err) => {
          if (err.code === "ENOENT")
            return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest) {
      let destStat;
      const srcStat = statSync2(src);
      try {
        destStat = statSync2(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest, funcName, cb) {
      util.callbackify(getStats)(src, dest, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        if (destStat && areIdentical(srcStat, destStat)) {
          return cb(new Error("Source and destination must not be the same."));
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return cb(null, { srcStat, destStat });
      });
    }
    function checkPathsSync(src, dest, funcName) {
      const { srcStat, destStat } = getStatsSync(src, dest);
      if (destStat && areIdentical(srcStat, destStat)) {
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
      const srcParent = path3.resolve(path3.dirname(src));
      const destParent = path3.resolve(path3.dirname(dest));
      if (destParent === srcParent || destParent === path3.parse(destParent).root)
        return cb();
      const callback = (err, destStat) => {
        if (err) {
          if (err.code === "ENOENT")
            return cb();
          return cb(err);
        }
        if (areIdentical(srcStat, destStat)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return checkParentPaths(src, srcStat, destParent, funcName, cb);
      };
      if (nodeSupportsBigInt)
        fs2.stat(destParent, { bigint: true }, callback);
      else
        fs2.stat(destParent, callback);
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path3.resolve(path3.dirname(src));
      const destParent = path3.resolve(path3.dirname(dest));
      if (destParent === srcParent || destParent === path3.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = statSync2(destParent);
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {
          return true;
        }
        if (destStat.size === srcStat.size && destStat.mode === srcStat.mode && destStat.nlink === srcStat.nlink && destStat.atimeMs === srcStat.atimeMs && destStat.mtimeMs === srcStat.mtimeMs && destStat.ctimeMs === srcStat.ctimeMs && destStat.birthtimeMs === srcStat.birthtimeMs) {
          return true;
        }
      }
      return false;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path3.resolve(src).split(path3.sep).filter((i13) => i13);
      const destArr = path3.resolve(dest).split(path3.sep).filter((i13) => i13);
      return srcArr.reduce((acc, cur, i13) => acc && destArr[i13] === cur, true);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/copy-sync/copy-sync.js
var require_copy_sync = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/copy-sync/copy-sync.js"(exports10, module2) {
    "use strict";
    var fs2 = require_graceful_fs();
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var mkdirsSync = require_mkdirs().mkdirsSync;
    var utimesMillisSync = require_utimes().utimesMillisSync;
    var stat2 = require_stat();
    function copySync(src, dest, opts2) {
      if (typeof opts2 === "function") {
        opts2 = { filter: opts2 };
      }
      opts2 = opts2 || {};
      opts2.clobber = "clobber" in opts2 ? !!opts2.clobber : true;
      opts2.overwrite = "overwrite" in opts2 ? !!opts2.overwrite : opts2.clobber;
      if (opts2.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      const { srcStat, destStat } = stat2.checkPathsSync(src, dest, "copy");
      stat2.checkParentPathsSync(src, srcStat, dest, "copy");
      return handleFilterAndCopy(destStat, src, dest, opts2);
    }
    function handleFilterAndCopy(destStat, src, dest, opts2) {
      if (opts2.filter && !opts2.filter(src, dest))
        return;
      const destParent = path3.dirname(dest);
      if (!fs2.existsSync(destParent))
        mkdirsSync(destParent);
      return startCopy(destStat, src, dest, opts2);
    }
    function startCopy(destStat, src, dest, opts2) {
      if (opts2.filter && !opts2.filter(src, dest))
        return;
      return getStats(destStat, src, dest, opts2);
    }
    function getStats(destStat, src, dest, opts2) {
      const statSync2 = opts2.dereference ? fs2.statSync : fs2.lstatSync;
      const srcStat = statSync2(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts2);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts2);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts2);
    }
    function onFile(srcStat, destStat, src, dest, opts2) {
      if (!destStat)
        return copyFile2(srcStat, src, dest, opts2);
      return mayCopyFile(srcStat, src, dest, opts2);
    }
    function mayCopyFile(srcStat, src, dest, opts2) {
      if (opts2.overwrite) {
        fs2.unlinkSync(dest);
        return copyFile2(srcStat, src, dest, opts2);
      } else if (opts2.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile2(srcStat, src, dest, opts2) {
      fs2.copyFileSync(src, dest);
      if (opts2.preserveTimestamps)
        handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode))
        makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs2.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs2.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts2) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts2);
      if (destStat && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      return copyDir(src, dest, opts2);
    }
    function mkDirAndCopy(srcMode, src, dest, opts2) {
      fs2.mkdirSync(dest);
      copyDir(src, dest, opts2);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts2) {
      fs2.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts2));
    }
    function copyDirItem(item, src, dest, opts2) {
      const srcItem = path3.join(src, item);
      const destItem = path3.join(dest, item);
      const { destStat } = stat2.checkPathsSync(srcItem, destItem, "copy");
      return startCopy(destStat, srcItem, destItem, opts2);
    }
    function onLink(destStat, src, dest, opts2) {
      let resolvedSrc = fs2.readlinkSync(src);
      if (opts2.dereference) {
        resolvedSrc = path3.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs2.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs2.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs2.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts2.dereference) {
          resolvedDest = path3.resolve(process.cwd(), resolvedDest);
        }
        if (stat2.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (fs2.statSync(dest).isDirectory() && stat2.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs2.unlinkSync(dest);
      return fs2.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/copy-sync/index.js
var require_copy_sync2 = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/copy-sync/index.js"(exports10, module2) {
    "use strict";
    module2.exports = {
      copySync: require_copy_sync()
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/path-exists/index.js"(exports10, module2) {
    "use strict";
    var u13 = require_universalify().fromPromise;
    var fs2 = require_fs();
    function pathExists(path3) {
      return fs2.access(path3).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u13(pathExists),
      pathExistsSync: fs2.existsSync
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/copy/copy.js"(exports10, module2) {
    "use strict";
    var fs2 = require_graceful_fs();
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var mkdirs = require_mkdirs().mkdirs;
    var pathExists = require_path_exists().pathExists;
    var utimesMillis = require_utimes().utimesMillis;
    var stat2 = require_stat();
    function copy(src, dest, opts2, cb) {
      if (typeof opts2 === "function" && !cb) {
        cb = opts2;
        opts2 = {};
      } else if (typeof opts2 === "function") {
        opts2 = { filter: opts2 };
      }
      cb = cb || function() {
      };
      opts2 = opts2 || {};
      opts2.clobber = "clobber" in opts2 ? !!opts2.clobber : true;
      opts2.overwrite = "overwrite" in opts2 ? !!opts2.overwrite : opts2.clobber;
      if (opts2.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      stat2.checkPaths(src, dest, "copy", (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        stat2.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
          if (err2)
            return cb(err2);
          if (opts2.filter)
            return handleFilter(checkParentDir, destStat, src, dest, opts2, cb);
          return checkParentDir(destStat, src, dest, opts2, cb);
        });
      });
    }
    function checkParentDir(destStat, src, dest, opts2, cb) {
      const destParent = path3.dirname(dest);
      pathExists(destParent, (err, dirExists) => {
        if (err)
          return cb(err);
        if (dirExists)
          return startCopy(destStat, src, dest, opts2, cb);
        mkdirs(destParent, (err2) => {
          if (err2)
            return cb(err2);
          return startCopy(destStat, src, dest, opts2, cb);
        });
      });
    }
    function handleFilter(onInclude, destStat, src, dest, opts2, cb) {
      Promise.resolve(opts2.filter(src, dest)).then((include) => {
        if (include)
          return onInclude(destStat, src, dest, opts2, cb);
        return cb();
      }, (error) => cb(error));
    }
    function startCopy(destStat, src, dest, opts2, cb) {
      if (opts2.filter)
        return handleFilter(getStats, destStat, src, dest, opts2, cb);
      return getStats(destStat, src, dest, opts2, cb);
    }
    function getStats(destStat, src, dest, opts2, cb) {
      const stat3 = opts2.dereference ? fs2.stat : fs2.lstat;
      stat3(src, (err, srcStat) => {
        if (err)
          return cb(err);
        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts2, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
          return onFile(srcStat, destStat, src, dest, opts2, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts2, cb);
      });
    }
    function onFile(srcStat, destStat, src, dest, opts2, cb) {
      if (!destStat)
        return copyFile2(srcStat, src, dest, opts2, cb);
      return mayCopyFile(srcStat, src, dest, opts2, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts2, cb) {
      if (opts2.overwrite) {
        fs2.unlink(dest, (err) => {
          if (err)
            return cb(err);
          return copyFile2(srcStat, src, dest, opts2, cb);
        });
      } else if (opts2.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else
        return cb();
    }
    function copyFile2(srcStat, src, dest, opts2, cb) {
      fs2.copyFile(src, dest, (err) => {
        if (err)
          return cb(err);
        if (opts2.preserveTimestamps)
          return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
        return setDestMode(dest, srcStat.mode, cb);
      });
    }
    function handleTimestampsAndMode(srcMode, src, dest, cb) {
      if (fileIsNotWritable(srcMode)) {
        return makeFileWritable(dest, srcMode, (err) => {
          if (err)
            return cb(err);
          return setDestTimestampsAndMode(srcMode, src, dest, cb);
        });
      }
      return setDestTimestampsAndMode(srcMode, src, dest, cb);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode, cb) {
      return setDestMode(dest, srcMode | 128, cb);
    }
    function setDestTimestampsAndMode(srcMode, src, dest, cb) {
      setDestTimestamps(src, dest, (err) => {
        if (err)
          return cb(err);
        return setDestMode(dest, srcMode, cb);
      });
    }
    function setDestMode(dest, srcMode, cb) {
      return fs2.chmod(dest, srcMode, cb);
    }
    function setDestTimestamps(src, dest, cb) {
      fs2.stat(src, (err, updatedSrcStat) => {
        if (err)
          return cb(err);
        return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
      });
    }
    function onDir(srcStat, destStat, src, dest, opts2, cb) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts2, cb);
      if (destStat && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
      }
      return copyDir(src, dest, opts2, cb);
    }
    function mkDirAndCopy(srcMode, src, dest, opts2, cb) {
      fs2.mkdir(dest, (err) => {
        if (err)
          return cb(err);
        copyDir(src, dest, opts2, (err2) => {
          if (err2)
            return cb(err2);
          return setDestMode(dest, srcMode, cb);
        });
      });
    }
    function copyDir(src, dest, opts2, cb) {
      fs2.readdir(src, (err, items) => {
        if (err)
          return cb(err);
        return copyDirItems(items, src, dest, opts2, cb);
      });
    }
    function copyDirItems(items, src, dest, opts2, cb) {
      const item = items.pop();
      if (!item)
        return cb();
      return copyDirItem(items, item, src, dest, opts2, cb);
    }
    function copyDirItem(items, item, src, dest, opts2, cb) {
      const srcItem = path3.join(src, item);
      const destItem = path3.join(dest, item);
      stat2.checkPaths(srcItem, destItem, "copy", (err, stats) => {
        if (err)
          return cb(err);
        const { destStat } = stats;
        startCopy(destStat, srcItem, destItem, opts2, (err2) => {
          if (err2)
            return cb(err2);
          return copyDirItems(items, src, dest, opts2, cb);
        });
      });
    }
    function onLink(destStat, src, dest, opts2, cb) {
      fs2.readlink(src, (err, resolvedSrc) => {
        if (err)
          return cb(err);
        if (opts2.dereference) {
          resolvedSrc = path3.resolve(process.cwd(), resolvedSrc);
        }
        if (!destStat) {
          return fs2.symlink(resolvedSrc, dest, cb);
        } else {
          fs2.readlink(dest, (err2, resolvedDest) => {
            if (err2) {
              if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                return fs2.symlink(resolvedSrc, dest, cb);
              return cb(err2);
            }
            if (opts2.dereference) {
              resolvedDest = path3.resolve(process.cwd(), resolvedDest);
            }
            if (stat2.isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
            }
            if (destStat.isDirectory() && stat2.isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs2.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return fs2.symlink(resolvedSrc, dest, cb);
      });
    }
    module2.exports = copy;
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/copy/index.js"(exports10, module2) {
    "use strict";
    var u13 = require_universalify().fromCallback;
    module2.exports = {
      copy: u13(require_copy())
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/remove/rimraf.js"(exports10, module2) {
    "use strict";
    var fs2 = require_graceful_fs();
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var assert = (init_assert2(), __toCommonJS(assert_exports));
    var isWindows3 = process.platform === "win32";
    function defaults(options) {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m10) => {
        options[m10] = options[m10] || fs2[m10];
        m10 = m10 + "Sync";
        options[m10] = options[m10] || fs2[m10];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
    }
    function rimraf(p13, options, cb) {
      let busyTries = 0;
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p13, "rimraf: missing path");
      assert.strictEqual(typeof p13, "string", "rimraf: path should be a string");
      assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      rimraf_(p13, options, function CB(er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
            busyTries++;
            const time = busyTries * 100;
            return setTimeout(() => rimraf_(p13, options, CB), time);
          }
          if (er.code === "ENOENT")
            er = null;
        }
        cb(er);
      });
    }
    function rimraf_(p13, options, cb) {
      assert(p13);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p13, (er, st) => {
        if (er && er.code === "ENOENT") {
          return cb(null);
        }
        if (er && er.code === "EPERM" && isWindows3) {
          return fixWinEPERM(p13, options, er, cb);
        }
        if (st && st.isDirectory()) {
          return rmdir2(p13, options, er, cb);
        }
        options.unlink(p13, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT") {
              return cb(null);
            }
            if (er2.code === "EPERM") {
              return isWindows3 ? fixWinEPERM(p13, options, er2, cb) : rmdir2(p13, options, er2, cb);
            }
            if (er2.code === "EISDIR") {
              return rmdir2(p13, options, er2, cb);
            }
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p13, options, er, cb) {
      assert(p13);
      assert(options);
      assert(typeof cb === "function");
      options.chmod(p13, 438, (er2) => {
        if (er2) {
          cb(er2.code === "ENOENT" ? null : er);
        } else {
          options.stat(p13, (er3, stats) => {
            if (er3) {
              cb(er3.code === "ENOENT" ? null : er);
            } else if (stats.isDirectory()) {
              rmdir2(p13, options, er, cb);
            } else {
              options.unlink(p13, cb);
            }
          });
        }
      });
    }
    function fixWinEPERMSync(p13, options, er) {
      let stats;
      assert(p13);
      assert(options);
      try {
        options.chmodSync(p13, 438);
      } catch (er2) {
        if (er2.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      try {
        stats = options.statSync(p13);
      } catch (er3) {
        if (er3.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      if (stats.isDirectory()) {
        rmdirSync2(p13, options, er);
      } else {
        options.unlinkSync(p13);
      }
    }
    function rmdir2(p13, options, originalEr, cb) {
      assert(p13);
      assert(options);
      assert(typeof cb === "function");
      options.rmdir(p13, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
          rmkids(p13, options, cb);
        } else if (er && er.code === "ENOTDIR") {
          cb(originalEr);
        } else {
          cb(er);
        }
      });
    }
    function rmkids(p13, options, cb) {
      assert(p13);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p13, (er, files) => {
        if (er)
          return cb(er);
        let n14 = files.length;
        let errState;
        if (n14 === 0)
          return options.rmdir(p13, cb);
        files.forEach((f13) => {
          rimraf(path3.join(p13, f13), options, (er2) => {
            if (errState) {
              return;
            }
            if (er2)
              return cb(errState = er2);
            if (--n14 === 0) {
              options.rmdir(p13, cb);
            }
          });
        });
      });
    }
    function rimrafSync(p13, options) {
      let st;
      options = options || {};
      defaults(options);
      assert(p13, "rimraf: missing path");
      assert.strictEqual(typeof p13, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      try {
        st = options.lstatSync(p13);
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        }
        if (er.code === "EPERM" && isWindows3) {
          fixWinEPERMSync(p13, options, er);
        }
      }
      try {
        if (st && st.isDirectory()) {
          rmdirSync2(p13, options, null);
        } else {
          options.unlinkSync(p13);
        }
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        } else if (er.code === "EPERM") {
          return isWindows3 ? fixWinEPERMSync(p13, options, er) : rmdirSync2(p13, options, er);
        } else if (er.code !== "EISDIR") {
          throw er;
        }
        rmdirSync2(p13, options, er);
      }
    }
    function rmdirSync2(p13, options, originalEr) {
      assert(p13);
      assert(options);
      try {
        options.rmdirSync(p13);
      } catch (er) {
        if (er.code === "ENOTDIR") {
          throw originalEr;
        } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
          rmkidsSync(p13, options);
        } else if (er.code !== "ENOENT") {
          throw er;
        }
      }
    }
    function rmkidsSync(p13, options) {
      assert(p13);
      assert(options);
      options.readdirSync(p13).forEach((f13) => rimrafSync(path3.join(p13, f13), options));
      if (isWindows3) {
        const startTime = Date.now();
        do {
          try {
            const ret = options.rmdirSync(p13, options);
            return ret;
          } catch {
          }
        } while (Date.now() - startTime < 500);
      } else {
        const ret = options.rmdirSync(p13, options);
        return ret;
      }
    }
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/remove/index.js"(exports10, module2) {
    "use strict";
    var u13 = require_universalify().fromCallback;
    var rimraf = require_rimraf();
    module2.exports = {
      remove: u13(rimraf),
      removeSync: rimraf.sync
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/empty/index.js"(exports10, module2) {
    "use strict";
    var u13 = require_universalify().fromCallback;
    var fs2 = require_graceful_fs();
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var mkdir2 = require_mkdirs();
    var remove = require_remove();
    var emptyDir = u13(function emptyDir2(dir, callback) {
      callback = callback || function() {
      };
      fs2.readdir(dir, (err, items) => {
        if (err)
          return mkdir2.mkdirs(dir, callback);
        items = items.map((item) => path3.join(dir, item));
        deleteItem();
        function deleteItem() {
          const item = items.pop();
          if (!item)
            return callback();
          remove.remove(item, (err2) => {
            if (err2)
              return callback(err2);
            deleteItem();
          });
        }
      });
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs2.readdirSync(dir);
      } catch {
        return mkdir2.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path3.join(dir, item);
        remove.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/ensure/file.js"(exports10, module2) {
    "use strict";
    var u13 = require_universalify().fromCallback;
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var fs2 = require_graceful_fs();
    var mkdir2 = require_mkdirs();
    function createFile(file, callback) {
      function makeFile() {
        fs2.writeFile(file, "", (err) => {
          if (err)
            return callback(err);
          callback();
        });
      }
      fs2.stat(file, (err, stats) => {
        if (!err && stats.isFile())
          return callback();
        const dir = path3.dirname(file);
        fs2.stat(dir, (err2, stats2) => {
          if (err2) {
            if (err2.code === "ENOENT") {
              return mkdir2.mkdirs(dir, (err3) => {
                if (err3)
                  return callback(err3);
                makeFile();
              });
            }
            return callback(err2);
          }
          if (stats2.isDirectory())
            makeFile();
          else {
            fs2.readdir(dir, (err3) => {
              if (err3)
                return callback(err3);
            });
          }
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs2.statSync(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path3.dirname(file);
      try {
        if (!fs2.statSync(dir).isDirectory()) {
          fs2.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT")
          mkdir2.mkdirsSync(dir);
        else
          throw err;
      }
      fs2.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u13(createFile),
      createFileSync
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/ensure/link.js"(exports10, module2) {
    "use strict";
    var u13 = require_universalify().fromCallback;
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var fs2 = require_graceful_fs();
    var mkdir2 = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs2.link(srcpath2, dstpath2, (err) => {
          if (err)
            return callback(err);
          callback(null);
        });
      }
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        fs2.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureLink");
            return callback(err2);
          }
          const dir = path3.dirname(dstpath);
          pathExists(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir2.mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      const destinationExists = fs2.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      try {
        fs2.lstatSync(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path3.dirname(dstpath);
      const dirExists = fs2.existsSync(dir);
      if (dirExists)
        return fs2.linkSync(srcpath, dstpath);
      mkdir2.mkdirsSync(dir);
      return fs2.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u13(createLink),
      createLinkSync
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports10, module2) {
    "use strict";
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var fs2 = require_graceful_fs();
    var pathExists = require_path_exists().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path3.isAbsolute(srcpath)) {
        return fs2.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureSymlink");
            return callback(err);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: srcpath
          });
        });
      } else {
        const dstdir = path3.dirname(dstpath);
        const relativeToDst = path3.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err, exists2) => {
          if (err)
            return callback(err);
          if (exists2) {
            return callback(null, {
              toCwd: relativeToDst,
              toDst: srcpath
            });
          } else {
            return fs2.lstat(srcpath, (err2) => {
              if (err2) {
                err2.message = err2.message.replace("lstat", "ensureSymlink");
                return callback(err2);
              }
              return callback(null, {
                toCwd: srcpath,
                toDst: path3.relative(dstdir, srcpath)
              });
            });
          }
        });
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists2;
      if (path3.isAbsolute(srcpath)) {
        exists2 = fs2.existsSync(srcpath);
        if (!exists2)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      } else {
        const dstdir = path3.dirname(dstpath);
        const relativeToDst = path3.join(dstdir, srcpath);
        exists2 = fs2.existsSync(relativeToDst);
        if (exists2) {
          return {
            toCwd: relativeToDst,
            toDst: srcpath
          };
        } else {
          exists2 = fs2.existsSync(srcpath);
          if (!exists2)
            throw new Error("relative srcpath does not exist");
          return {
            toCwd: srcpath,
            toDst: path3.relative(dstdir, srcpath)
          };
        }
      }
    }
    module2.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports10, module2) {
    "use strict";
    var fs2 = require_graceful_fs();
    function symlinkType(srcpath, type2, callback) {
      callback = typeof type2 === "function" ? type2 : callback;
      type2 = typeof type2 === "function" ? false : type2;
      if (type2)
        return callback(null, type2);
      fs2.lstat(srcpath, (err, stats) => {
        if (err)
          return callback(null, "file");
        type2 = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type2);
      });
    }
    function symlinkTypeSync(srcpath, type2) {
      let stats;
      if (type2)
        return type2;
      try {
        stats = fs2.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/ensure/symlink.js"(exports10, module2) {
    "use strict";
    var u13 = require_universalify().fromCallback;
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var fs2 = require_graceful_fs();
    var _mkdirs = require_mkdirs();
    var mkdirs = _mkdirs.mkdirs;
    var mkdirsSync = _mkdirs.mkdirsSync;
    var _symlinkPaths = require_symlink_paths();
    var symlinkPaths = _symlinkPaths.symlinkPaths;
    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    var _symlinkType = require_symlink_type();
    var symlinkType = _symlinkType.symlinkType;
    var symlinkTypeSync = _symlinkType.symlinkTypeSync;
    var pathExists = require_path_exists().pathExists;
    function createSymlink(srcpath, dstpath, type2, callback) {
      callback = typeof type2 === "function" ? type2 : callback;
      type2 = typeof type2 === "function" ? false : type2;
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        symlinkPaths(srcpath, dstpath, (err2, relative3) => {
          if (err2)
            return callback(err2);
          srcpath = relative3.toDst;
          symlinkType(relative3.toCwd, type2, (err3, type3) => {
            if (err3)
              return callback(err3);
            const dir = path3.dirname(dstpath);
            pathExists(dir, (err4, dirExists) => {
              if (err4)
                return callback(err4);
              if (dirExists)
                return fs2.symlink(srcpath, dstpath, type3, callback);
              mkdirs(dir, (err5) => {
                if (err5)
                  return callback(err5);
                fs2.symlink(srcpath, dstpath, type3, callback);
              });
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type2) {
      const destinationExists = fs2.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      const relative3 = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative3.toDst;
      type2 = symlinkTypeSync(relative3.toCwd, type2);
      const dir = path3.dirname(dstpath);
      const exists2 = fs2.existsSync(dir);
      if (exists2)
        return fs2.symlinkSync(srcpath, dstpath, type2);
      mkdirsSync(dir);
      return fs2.symlinkSync(srcpath, dstpath, type2);
    }
    module2.exports = {
      createSymlink: u13(createSymlink),
      createSymlinkSync
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/ensure/index.js"(exports10, module2) {
    "use strict";
    var file = require_file();
    var link2 = require_link();
    var symlink2 = require_symlink();
    module2.exports = {
      // file
      createFile: file.createFile,
      createFileSync: file.createFileSync,
      ensureFile: file.createFile,
      ensureFileSync: file.createFileSync,
      // link
      createLink: link2.createLink,
      createLinkSync: link2.createLinkSync,
      ensureLink: link2.createLink,
      ensureLinkSync: link2.createLinkSync,
      // symlink
      createSymlink: symlink2.createSymlink,
      createSymlinkSync: symlink2.createSymlinkSync,
      ensureSymlink: symlink2.createSymlink,
      ensureSymlinkSync: symlink2.createSymlinkSync
    };
  }
});

// node_modules/.pnpm/universalify@2.0.0/node_modules/universalify/index.js
var require_universalify2 = __commonJS({
  "node_modules/.pnpm/universalify@2.0.0/node_modules/universalify/index.js"(exports10) {
    "use strict";
    exports10.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function")
          fn.apply(this, args);
        else {
          return new Promise((resolve4, reject) => {
            fn.call(
              this,
              ...args,
              (err, res) => err != null ? reject(err) : resolve4(res)
            );
          });
        }
      }, "name", { value: fn.name });
    };
    exports10.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args);
        else
          fn.apply(this, args.slice(0, -1)).then((r14) => cb(null, r14), cb);
      }, "name", { value: fn.name });
    };
  }
});

// node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js"(exports10, module2) {
    function stringify(obj, { EOL: EOL2 = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF2 = finalEOL ? EOL2 : "";
      const str = JSON.stringify(obj, replacer, spaces);
      return str.replace(/\n/g, EOL2) + EOF2;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module2.exports = { stringify, stripBom };
  }
});

// node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js"(exports10, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_8) {
      _fs = (init_fs2(), __toCommonJS(fs_exports));
    }
    var universalify = require_universalify2();
    var { stringify, stripBom } = require_utils();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs2 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs2.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile2 = universalify.fromPromise(_readFile);
    function readFileSync2(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs2 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs2.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs2 = options.fs || _fs;
      const str = stringify(obj, options);
      await universalify.fromCallback(fs2.writeFile)(file, str, options);
    }
    var writeFile2 = universalify.fromPromise(_writeFile);
    function writeFileSync2(file, obj, options = {}) {
      const fs2 = options.fs || _fs;
      const str = stringify(obj, options);
      return fs2.writeFileSync(file, str, options);
    }
    var jsonfile = {
      readFile: readFile2,
      readFileSync: readFileSync2,
      writeFile: writeFile2,
      writeFileSync: writeFileSync2
    };
    module2.exports = jsonfile;
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/json/jsonfile.js"(exports10, module2) {
    "use strict";
    var jsonFile = require_jsonfile();
    module2.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/output/index.js
var require_output = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/output/index.js"(exports10, module2) {
    "use strict";
    var u13 = require_universalify().fromCallback;
    var fs2 = require_graceful_fs();
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var mkdir2 = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    function outputFile(file, data, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }
      const dir = path3.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return fs2.writeFile(file, data, encoding, callback);
        mkdir2.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          fs2.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args) {
      const dir = path3.dirname(file);
      if (fs2.existsSync(dir)) {
        return fs2.writeFileSync(file, ...args);
      }
      mkdir2.mkdirsSync(dir);
      fs2.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u13(outputFile),
      outputFileSync
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/json/output-json.js"(exports10, module2) {
    "use strict";
    var { stringify } = require_utils();
    var { outputFile } = require_output();
    async function outputJson(file, data, options = {}) {
      const str = stringify(data, options);
      await outputFile(file, str, options);
    }
    module2.exports = outputJson;
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/json/output-json-sync.js"(exports10, module2) {
    "use strict";
    var { stringify } = require_utils();
    var { outputFileSync } = require_output();
    function outputJsonSync(file, data, options) {
      const str = stringify(data, options);
      outputFileSync(file, str, options);
    }
    module2.exports = outputJsonSync;
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/json/index.js"(exports10, module2) {
    "use strict";
    var u13 = require_universalify().fromPromise;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u13(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/move-sync/move-sync.js
var require_move_sync = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/move-sync/move-sync.js"(exports10, module2) {
    "use strict";
    var fs2 = require_graceful_fs();
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var copySync = require_copy_sync2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs().mkdirpSync;
    var stat2 = require_stat();
    function moveSync(src, dest, opts2) {
      opts2 = opts2 || {};
      const overwrite = opts2.overwrite || opts2.clobber || false;
      const { srcStat } = stat2.checkPathsSync(src, dest, "move");
      stat2.checkParentPathsSync(src, srcStat, dest, "move");
      mkdirpSync(path3.dirname(dest));
      return doRename(src, dest, overwrite);
    }
    function doRename(src, dest, overwrite) {
      if (overwrite) {
        removeSync(dest);
        return rename2(src, dest, overwrite);
      }
      if (fs2.existsSync(dest))
        throw new Error("dest already exists.");
      return rename2(src, dest, overwrite);
    }
    function rename2(src, dest, overwrite) {
      try {
        fs2.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts2 = {
        overwrite,
        errorOnExist: true
      };
      copySync(src, dest, opts2);
      return removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/move-sync/index.js
var require_move_sync2 = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/move-sync/index.js"(exports10, module2) {
    "use strict";
    module2.exports = {
      moveSync: require_move_sync()
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/move/move.js"(exports10, module2) {
    "use strict";
    var fs2 = require_graceful_fs();
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var copy = require_copy2().copy;
    var remove = require_remove().remove;
    var mkdirp = require_mkdirs().mkdirp;
    var pathExists = require_path_exists().pathExists;
    var stat2 = require_stat();
    function move(src, dest, opts2, cb) {
      if (typeof opts2 === "function") {
        cb = opts2;
        opts2 = {};
      }
      const overwrite = opts2.overwrite || opts2.clobber || false;
      stat2.checkPaths(src, dest, "move", (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat } = stats;
        stat2.checkParentPaths(src, srcStat, dest, "move", (err2) => {
          if (err2)
            return cb(err2);
          mkdirp(path3.dirname(dest), (err3) => {
            if (err3)
              return cb(err3);
            return doRename(src, dest, overwrite, cb);
          });
        });
      });
    }
    function doRename(src, dest, overwrite, cb) {
      if (overwrite) {
        return remove(dest, (err) => {
          if (err)
            return cb(err);
          return rename2(src, dest, overwrite, cb);
        });
      }
      pathExists(dest, (err, destExists) => {
        if (err)
          return cb(err);
        if (destExists)
          return cb(new Error("dest already exists."));
        return rename2(src, dest, overwrite, cb);
      });
    }
    function rename2(src, dest, overwrite, cb) {
      fs2.rename(src, dest, (err) => {
        if (!err)
          return cb();
        if (err.code !== "EXDEV")
          return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
      });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      const opts2 = {
        overwrite,
        errorOnExist: true
      };
      copy(src, dest, opts2, (err) => {
        if (err)
          return cb(err);
        return remove(src, cb);
      });
    }
    module2.exports = move;
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/move/index.js"(exports10, module2) {
    "use strict";
    var u13 = require_universalify().fromCallback;
    module2.exports = {
      move: u13(require_move())
    };
  }
});

// node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/fs-extra@9.0.1/node_modules/fs-extra/lib/index.js"(exports10, module2) {
    "use strict";
    module2.exports = {
      // Export promiseified graceful-fs:
      ...require_fs(),
      // Export extra methods:
      ...require_copy_sync2(),
      ...require_copy2(),
      ...require_empty(),
      ...require_ensure(),
      ...require_json(),
      ...require_mkdirs(),
      ...require_move_sync2(),
      ...require_move2(),
      ...require_output(),
      ...require_path_exists(),
      ...require_remove()
    };
    var fs2 = (init_fs2(), __toCommonJS(fs_exports));
    if (Object.getOwnPropertyDescriptor(fs2, "promises")) {
      Object.defineProperty(module2.exports, "promises", {
        get() {
          return fs2.promises;
        }
      });
    }
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/fileSys/fileSys.js
var require_fileSys = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/fileSys/fileSys.js"(exports10, module2) {
    var fs2 = require_lib();
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var { checkCall, limbo, isFunc } = require_cjs();
    var { throwError } = require_error2();
    var defaultFileExclude = [
      `.DS_Store`,
      `.gitignore`,
      `.gitkeep`
    ];
    var limboify = (cb, ...args) => {
      return limbo(
        new Promise(
          (res, rej) => cb(...args, (err, success) => err ? rej(err) : res(success || true))
        )
      );
    };
    var movePath = (oldPath, newPath) => {
      return limboify(fs2.rename, oldPath, newPath);
    };
    var mkDir = (filePath) => {
      return limboify(fs2.mkdir, filePath, { recursive: true });
    };
    var writeFile2 = (filePath, data, format8 = "utf8") => {
      return limboify(fs2.writeFile, filePath, data, format8);
    };
    var writeFileSync2 = (filePath, data, format8 = "utf8") => {
      return fs2.writeFileSync(filePath, data, format8);
    };
    var readDir = (dirPath) => {
      return limboify(fs2.readdir, dirPath);
    };
    var stat2 = (path4) => {
      return limboify(fs2.stat, path4);
    };
    var buildFoundArray = ({
      allFound,
      recurCall,
      file,
      fromPath,
      opts: opts2 = {}
    }) => {
      const { exclude = defaultFileExclude, full, include = [], recursive, type: type2 } = opts2;
      if (!file || exclude.indexOf(file) !== -1)
        return allFound;
      const fullPath = path3.join(fromPath, file);
      const found = full ? fullPath : file;
      const isDir = fs2.statSync(fullPath).isDirectory();
      (!type2 || type2 === "folder" && isDir || type2 !== "folder" && !isDir) && (!include.length || include.indexOf(file) !== -1) && allFound.push(found);
      return !isDir || !recursive || !isFunc(recurCall) ? allFound : recurCall(fullPath, opts2, allFound);
    };
    var getFolderContent = async (fromPath, opts2 = {}, foundPaths = []) => {
      const [err, allFiles] = await readDir(fromPath);
      err && throwError(err);
      return allFiles.reduce(async (toResolve, file) => {
        const allFound = await toResolve;
        return buildFoundArray({
          opts: opts2,
          file,
          fromPath,
          allFound,
          recurCall: getFolderContent
        });
      }, Promise.resolve(foundPaths));
    };
    var getFolderContentSync = (fromPath, opts2 = {}, foundPaths = []) => {
      return fs2.readdirSync(fromPath).reduce(
        (allFound, file) => buildFoundArray({
          opts: opts2,
          file,
          fromPath,
          allFound,
          recurCall: getFolderContentSync
        }),
        foundPaths
      );
    };
    var getFiles = (fromPath, opts2) => {
      return getFolderContent(fromPath, { ...opts2, type: "file" });
    };
    var getFolders = (fromPath, opts2) => {
      return getFolderContent(fromPath, { ...opts2, type: "folder" });
    };
    var getFoldersSync = (fromPath, opts2 = {}) => {
      return getFolderContentSync(fromPath, { ...opts2, type: "folder" });
    };
    var getFilesSync = (fromPath, opts2) => {
      return getFolderContentSync(fromPath, { ...opts2, type: "file" });
    };
    var pathExists = (checkPath) => {
      return limboify(fs2.access, checkPath, fs2.constants.F_OK);
    };
    var pathExistsSync = (checkPath) => fs2.existsSync(checkPath);
    var readFile2 = (filePath, format8 = "utf8") => {
      return limboify(fs2.readFile, filePath, format8);
    };
    var readFileSync2 = (filePath, format8 = "utf8") => {
      return fs2.readFileSync(filePath, format8 = "utf8");
    };
    var copyStream = (from, to, cb, format8 = "utf8") => {
      const writeStream = fs2.createWriteStream(to);
      const readStream = fs2.createReadStream(from, { encoding: format8 });
      writeStream.on("finish", () => checkCall(cb));
      readStream.pipe(writeStream);
      return { readStream, writeStream };
    };
    var copyFile2 = (to, from, mode) => {
      return limboify(fs2.copyFile, to, from, mode);
    };
    var copyFileSync2 = (from, to, mode) => fs2.copyFileSync(from, to, mode);
    var removeFile = (file) => limboify(fs2.unlink, file);
    var removeFileSync = (file) => fs2.unlinkSync(file, callbackFunction);
    var requireFile = (folder = "", file = "", logError) => {
      const location2 = path3.join(folder, file);
      try {
        const data = require(location2);
        return { data, location: location2 };
      } catch (err) {
        logError && console.error(`requireFile error for path "${location2}"`, err.stack);
        return {};
      }
    };
    var ensureDirSync = (dirPath = "", logError) => {
      try {
        !fs2.existsSync(dirPath) && fs2.mkdirSync(dirPath);
        return dirPath;
      } catch (err) {
        logError && console.error(`ensureDirSync error for path "${dirPath}"`, err.stack);
        return false;
      }
    };
    var copySync = (from, to, logError = false) => {
      try {
        fs2.copySync(from, to);
        return true;
      } catch (err) {
        logError && console.error(`copySync error for path "${from} to ${to}"`, err.stack);
        return false;
      }
    };
    var emptyDirSync = (path4, logError = false) => {
      try {
        fs2.emptyDirSync(path4);
        return true;
      } catch (err) {
        logError && console.error(`emptyDirSync error for path "${path4}"`, err.stack);
        return false;
      }
    };
    module2.exports = {
      copyFile: copyFile2,
      copySync,
      copyFileSync: copyFileSync2,
      copyStream,
      emptyDirSync,
      ensureDirSync,
      getFiles,
      getFilesSync,
      getFolders,
      getFoldersSync,
      getFolderContent,
      getFolderContentSync,
      mkDir,
      movePath,
      pathExists,
      pathExistsSync,
      readFile: readFile2,
      readFileSync: readFileSync2,
      removeFile,
      removeFileSync,
      requireFile,
      stat: stat2,
      writeFile: writeFile2,
      writeFileSync: writeFileSync2
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/fileSys/index.js
var require_fileSys2 = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/fileSys/index.js"(exports10, module2) {
    module2.exports = require_fileSys();
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/findTask.js
var require_findTask = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/findTask.js"(exports10, module2) {
    var { throwExitError } = require_error2();
    var { noOpArr, isArr, isObj } = require_cjs();
    var getTaskRef = (tasks, task) => {
      const found = Object.entries(tasks).find(([key, definition]) => key === task || definition.name === task || isArr(definition.alias) && definition.alias.includes(task));
      return found ? found[1] : void 0;
    };
    var findTaskFromOptions = (task, options) => {
      const opt = options.shift();
      const subTasks = isObj(task) && task.tasks;
      const subTask = opt && subTasks && getTaskRef(subTasks, opt);
      return !subTask ? { task, options: opt ? [opt, ...options] : options } : findTaskFromOptions(subTask, options);
    };
    var findTask = (tasks, opts2 = noOpArr, throwError = true) => {
      const options = [...opts2];
      const taskName = options.shift();
      const task = getTaskRef(tasks, taskName);
      const foundTask = task && findTaskFromOptions(task, options);
      return foundTask && foundTask.task ? { ...foundTask, tasks } : throwExitError(new Error(`Task not found for argument: ${taskName}`));
    };
    module2.exports = {
      findTask,
      getTask: findTask
    };
  }
});

// node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/styles.js
var require_styles = __commonJS({
  "node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/styles.js"(exports10, module2) {
    var styles = {};
    module2["exports"] = styles;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      brightRed: [91, 39],
      brightGreen: [92, 39],
      brightYellow: [93, 39],
      brightBlue: [94, 39],
      brightMagenta: [95, 39],
      brightCyan: [96, 39],
      brightWhite: [97, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgBrightRed: [101, 49],
      bgBrightGreen: [102, 49],
      bgBrightYellow: [103, 49],
      bgBrightBlue: [104, 49],
      bgBrightMagenta: [105, 49],
      bgBrightCyan: [106, 49],
      bgBrightWhite: [107, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/system/has-flag.js
var require_has_flag = __commonJS({
  "node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/system/has-flag.js"(exports10, module2) {
    "use strict";
    module2.exports = function(flag, argv) {
      argv = argv || process.argv;
      var terminatorPos = argv.indexOf("--");
      var prefix = /^-{1,2}/.test(flag) ? "" : "--";
      var pos = argv.indexOf(prefix + flag);
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/system/supports-colors.js"(exports10, module2) {
    "use strict";
    var os = (init_os2(), __toCommonJS(os_exports));
    var hasFlag = require_has_flag();
    var env2 = process.env;
    var forceColor = void 0;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env2) {
      forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      var min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        var osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
          return sign in env2;
        }) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("TERM_PROGRAM" in env2) {
        var version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Hyper":
            return 3;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      if (env2.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      var level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/custom/trap.js"(exports10, module2) {
    module2["exports"] = function runTheTrap(text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c13) {
        c13 = c13.toLowerCase();
        var chars = trap[c13] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c13] !== "undefined") {
          result += trap[c13][rand];
        } else {
          result += c13;
        }
      });
      return result;
    };
  }
});

// node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/custom/zalgo.js"(exports10, module2) {
    module2["exports"] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r14 = Math.floor(Math.random() * range);
        return r14;
      }
      function isChar(character) {
        var bool = false;
        all.filter(function(i13) {
          bool = i13 === character;
        });
        return bool;
      }
      function heComes(text2, options2) {
        var result = "";
        var counts;
        var l13;
        options2 = options2 || {};
        options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
        options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
        options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
        options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
        text2 = text2.split("");
        for (l13 in text2) {
          if (isChar(l13)) {
            continue;
          }
          result = result + text2[l13];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d10 in arr) {
            var index = arr[d10];
            for (var i13 = 0; i13 <= counts[index]; i13++) {
              if (options2[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text, options);
    };
  }
});

// node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/maps/america.js
var require_america = __commonJS({
  "node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/maps/america.js"(exports10, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i13, exploded) {
        if (letter === " ")
          return letter;
        switch (i13 % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    };
  }
});

// node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/maps/zebra.js"(exports10, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i13, exploded) {
        return i13 % 2 === 0 ? letter : colors.inverse(letter);
      };
    };
  }
});

// node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/maps/rainbow.js"(exports10, module2) {
    module2["exports"] = function(colors) {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i13, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i13++ % rainbowColors.length]](letter);
        }
      };
    };
  }
});

// node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/maps/random.js
var require_random = __commonJS({
  "node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/maps/random.js"(exports10, module2) {
    module2["exports"] = function(colors) {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(letter, i13, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
      };
    };
  }
});

// node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/colors.js
var require_colors2 = __commonJS({
  "node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/colors.js"(exports10, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var util = (init_util2(), __toCommonJS(util_exports));
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors.supportsColor = require_supports_colors().supportsColor;
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor() !== false;
    }
    colors.enable = function() {
      colors.enabled = true;
    };
    colors.disable = function() {
      colors.enabled = false;
    };
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      if (!colors.enabled) {
        return str + "";
      }
      var styleMap = ansiStyles[style];
      if (!styleMap && style in colors) {
        return colors[style](str);
      }
      return styleMap.open + str + styleMap.close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles);
    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg != null && arg.constructor === String) {
          return arg;
        } else {
          return util.inspect(arg);
        }
      }).join(" ");
      if (!colors.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i13 = nestedStyles.length;
      while (i13--) {
        var code = ansiStyles[nestedStyles[i13]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, function(match) {
            return code.close + match + code.open;
          });
        }
      }
      return str;
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i13 in theme[style2]) {
                out = colors[theme[style2][i13]](out);
              }
              return out;
            }
            return colors[theme[style2]](str);
          };
        })(style);
      }
    };
    function init4() {
      var ret = {};
      Object.keys(styles).forEach(function(name2) {
        ret[name2] = {
          get: function() {
            return build([name2]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split("");
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america()(colors);
    colors.maps.zebra = require_zebra()(colors);
    colors.maps.rainbow = require_rainbow()(colors);
    colors.maps.random = require_random()(colors);
    for (map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    var map;
    defineProps(colors, init4());
  }
});

// node_modules/.pnpm/colors@1.4.0/node_modules/colors/safe.js
var require_safe = __commonJS({
  "node_modules/.pnpm/colors@1.4.0/node_modules/colors/safe.js"(exports10, module2) {
    var colors = require_colors2();
    module2["exports"] = colors;
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/logger/showHelp.js
var require_showHelp = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/logger/showHelp.js"(exports10, module2) {
    var { get: get2, isStr, isObj, mapObj: mapObj2, isArr } = require_cjs();
    var { Logger: Logger3 } = require_logger();
    var colors = require_safe();
    var getSpacers = (space, header) => {
      spacer = space || "  ";
      const dblSpacer = `${spacer}${spacer}`;
      const infoSpacer = header && dblSpacer || `${dblSpacer}  `;
      return { spacer, dblSpacer, infoSpacer };
    };
    var showHelpHeader = (header, subHeader) => {
      header = header === false ? header : header || `Keg-CLI Help`;
      if (!header)
        return;
      Logger3.header(header);
      subHeader && console.log(colors.brightBlue(subHeader));
      Logger3.empty();
    };
    var showTaskHeader = (key, header, spacer2, dblSpacer) => {
      const subSpacer = header && spacer2 || dblSpacer;
      Logger3.empty();
      console.log(
        colors.gray(`${subSpacer}Command:`),
        colors.brightGreen.bold(`${key}`)
      );
    };
    var showSubTasks = (task, opts2 = {}) => {
      Logger3.empty();
      if (!isObj(task) || !isObj(task.tasks) || !Object.keys(task.tasks).length)
        return;
      const { dblSpacer } = opts2;
      Logger3.log(colors.brightBlue(`${dblSpacer}  Sub Commands:`));
      showAllHelp(
        task.tasks,
        { ...opts2, header: false, space: `${dblSpacer}` }
      );
    };
    var showTaskInfo = (task, infoSpacer) => {
      showTaskInfoItem("Alias", get2(task, `alias`, []).join(" | "), infoSpacer);
      showTaskInfoItem("Description", get2(task, `description`, ""), infoSpacer);
      showTaskInfoItem("Example", get2(task, `example`, ""), infoSpacer);
    };
    var showTaskInfoItem = (name2, desc, infoSpacer) => {
      desc && Logger3.pair(`${infoSpacer}${name2}:`, desc);
    };
    var showTaskOptions = (task, infoSpacer, dblSpacer) => {
      if (!task.options)
        return;
      Logger3.empty();
      console.log(colors.brightBlue(`${infoSpacer}Options:`));
      mapObj2(task.options, (name2, meta) => {
        const { description, enforced, require: require2, required, alts } = isStr(meta) ? { description: meta } : meta;
        console.log(
          infoSpacer,
          (require2 || required || enforced) && colors.red(` *`) || "  ",
          colors.brightCyan(`${name2}:`),
          colors.brightWhite(meta.description)
        );
      });
    };
    var showAllHelp = (tasks, opts2 = {}) => {
      const { header, space } = opts2;
      showHelpHeader(header, `Available Commands: `);
      const { spacer: spacer2 } = getSpacers(space, header);
      Object.keys(tasks).map(
        (key) => !isStr(tasks[key]) && showTaskHelp(
          tasks[key],
          { ...opts2, spacer: spacer2, header: false, subtasks: false }
        )
      );
      Logger3.empty();
    };
    var showTaskOptionDetail = (task, option, infoSpacer, dblSpacer) => {
      if (!task.options)
        return;
      let validKey;
      mapObj2(task.options, (key) => {
        if (option.includes(key)) {
          return validKey = key;
        }
      });
      if (validKey) {
        Logger3.empty();
        console.log(colors.brightBlue(`${infoSpacer}Option: ${validKey}`));
        return showTaskInfo(task.options[validKey], `  ${infoSpacer}`);
      }
      showTaskOptions(task, infoSpacer, dblSpacer);
    };
    var showTaskHelp = (task, opts2 = {}) => {
      const { header, space, subtasks = true } = opts2;
      const { spacer: spacer2, dblSpacer, infoSpacer } = getSpacers(space);
      showHelpHeader(header);
      showTaskHeader(task.name, header, spacer2, dblSpacer);
      showTaskInfo(task, infoSpacer);
      isArr(opts2) && opts2.length > 1 ? showTaskOptionDetail(task, opts2[0], infoSpacer, dblSpacer) : showTaskOptions(task, infoSpacer, dblSpacer);
      subtasks && showSubTasks(task, { ...opts2, dblSpacer });
    };
    var showHelp = ({ tasks, task = false, options = {} }) => {
      task ? showTaskHelp(task, options) : showAllHelp(tasks, options);
      Logger3.empty();
      return true;
    };
    module2.exports = {
      showHelp
    };
  }
});

// node-modules-polyfills:module
function unimplemented3() {
  throw new Error("Node.js module module is not supported by JSPM core in the browser");
}
var builtinModules, _cache, _pathCache, _extensions, globalPaths;
var init_module = __esm({
  "node-modules-polyfills:module"() {
    builtinModules = [
      "_http_agent",
      "_http_client",
      "_http_common",
      "_http_incoming",
      "_http_outgoing",
      "_http_server",
      "_stream_duplex",
      "_stream_passthrough",
      "_stream_readable",
      "_stream_transform",
      "_stream_wrap",
      "_stream_writable",
      "_tls_common",
      "_tls_wrap",
      "assert",
      "assert/strict",
      "async_hooks",
      "buffer",
      "child_process",
      "cluster",
      "console",
      "constants",
      "crypto",
      "dgram",
      "diagnostics_channel",
      "dns",
      "dns/promises",
      "domain",
      "events",
      "fs",
      "fs/promises",
      "http",
      "http2",
      "https",
      "inspector",
      "module",
      "net",
      "os",
      "path",
      "path/posix",
      "path/win32",
      "perf_hooks",
      "process",
      "punycode",
      "querystring",
      "readline",
      "repl",
      "stream",
      "stream/consumers",
      "stream/promises",
      "stream/web",
      "string_decoder",
      "sys",
      "timers",
      "timers/promises",
      "tls",
      "trace_events",
      "tty",
      "url",
      "util",
      "util/types",
      "v8",
      "vm",
      "worker_threads",
      "zlib"
    ];
    _cache = null;
    _pathCache = null;
    _extensions = null;
    globalPaths = null;
  }
});

// node-modules-polyfills-commonjs:module
var module_exports = {};
__export(module_exports, {
  Module: () => unimplemented3,
  SourceMap: () => unimplemented3,
  _cache: () => _cache,
  _debug: () => unimplemented3,
  _extensions: () => _extensions,
  _findPath: () => unimplemented3,
  _initPaths: () => unimplemented3,
  _load: () => unimplemented3,
  _nodeModulePaths: () => unimplemented3,
  _pathCache: () => _pathCache,
  _preloadModules: () => unimplemented3,
  _resolveFilename: () => unimplemented3,
  _resolveLookupPaths: () => unimplemented3,
  builtinModules: () => builtinModules,
  createRequire: () => unimplemented3,
  createRequireFromPath: () => unimplemented3,
  findSourceMap: () => unimplemented3,
  globalPaths: () => globalPaths,
  runMain: () => unimplemented3,
  syncBuiltinESMExports: () => unimplemented3
});
var init_module2 = __esm({
  "node-modules-polyfills-commonjs:module"() {
    init_module();
  }
});

// node_modules/.pnpm/app-root-path@3.0.0/node_modules/app-root-path/lib/resolve.js
var require_resolve = __commonJS({
  "node_modules/.pnpm/app-root-path@3.0.0/node_modules/app-root-path/lib/resolve.js"(exports10, module2) {
    "use strict";
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var globalPaths2 = (init_module2(), __toCommonJS(module_exports)).globalPaths;
    var npmGlobalPrefix;
    if ("win32" === process.platform) {
      npmGlobalPrefix = path3.dirname(process.execPath);
    } else {
      npmGlobalPrefix = path3.dirname(path3.dirname(process.execPath));
    }
    var npmGlobalModuleDir = path3.resolve(npmGlobalPrefix, "lib", "node_modules");
    var sep3 = path3.sep;
    var requireFunction = "function" === typeof __webpack_require__ || "function" === typeof __non_webpack_require__ ? __non_webpack_require__ : require;
    var isInstalledWithPNPM = function(resolved) {
      const pnpmDir = sep3 + ".pnpm";
      for (const globalPath of globalPaths2) {
        if (-1 !== globalPath.indexOf(pnpmDir) && -1 !== resolved.indexOf(pnpmDir)) {
          return true;
        }
      }
      return false;
    };
    var getFirstPartFromNodeModules = function(resolved) {
      const nodeModulesDir = sep3 + "node_modules";
      if (-1 !== resolved.indexOf(nodeModulesDir)) {
        const parts = resolved.split(nodeModulesDir);
        if (parts.length) {
          return parts[0];
        }
      }
      return null;
    };
    module2.exports = function resolve4(dirname3) {
      if (process.env.APP_ROOT_PATH) {
        return path3.resolve(process.env.APP_ROOT_PATH);
      }
      if (process.versions.pnp) {
        try {
          var pnp = requireFunction("pnpapi");
          return pnp.getPackageInformation(pnp.topLevel).packageLocation;
        } catch (e14) {
        }
      }
      if ("undefined" !== typeof window && window.process && "renderer" === window.process.type) {
        try {
          var remote = requireFunction("electron").remote;
          return remote.require("app-root-path").path;
        } catch (e14) {
        }
      }
      if (process.env.LAMBDA_TASK_ROOT && process.env.AWS_EXECUTION_ENV) {
        return process.env.LAMBDA_TASK_ROOT;
      }
      var resolved = path3.resolve(dirname3);
      var alternateMethod = false;
      var appRootPath = null;
      if (isInstalledWithPNPM(resolved)) {
        appRootPath = getFirstPartFromNodeModules(resolved);
        if (appRootPath) {
          return appRootPath;
        }
      }
      globalPaths2.forEach(function(globalPath) {
        if (!alternateMethod && 0 === resolved.indexOf(globalPath)) {
          alternateMethod = true;
        }
      });
      if (!alternateMethod) {
        appRootPath = getFirstPartFromNodeModules(resolved);
      }
      if (alternateMethod || null == appRootPath) {
        appRootPath = path3.dirname(requireFunction.main.filename);
      }
      if (alternateMethod && -1 !== appRootPath.indexOf(npmGlobalModuleDir) && appRootPath.length - 4 === appRootPath.indexOf(sep3 + "bin")) {
        appRootPath = appRootPath.slice(0, -4);
      }
      return appRootPath;
    };
  }
});

// node_modules/.pnpm/app-root-path@3.0.0/node_modules/app-root-path/lib/app-root-path.js
var require_app_root_path = __commonJS({
  "node_modules/.pnpm/app-root-path@3.0.0/node_modules/app-root-path/lib/app-root-path.js"(exports10, module2) {
    "use strict";
    module2.exports = function(dirname3) {
      var path3 = (init_path2(), __toCommonJS(path_exports));
      var resolve4 = require_resolve();
      var appRootPath = resolve4(dirname3);
      var publicInterface = {
        resolve: function(pathToModule) {
          return path3.join(appRootPath, pathToModule);
        },
        require: function(pathToModule) {
          return require(publicInterface.resolve(pathToModule));
        },
        toString: function() {
          return appRootPath;
        },
        setPath: function(explicitlySetPath) {
          appRootPath = path3.resolve(explicitlySetPath);
          publicInterface.path = appRootPath;
        },
        path: appRootPath
      };
      return publicInterface;
    };
  }
});

// node_modules/.pnpm/app-root-path@3.0.0/node_modules/app-root-path/index.js
var require_app_root_path2 = __commonJS({
  "node_modules/.pnpm/app-root-path@3.0.0/node_modules/app-root-path/index.js"(exports10, module2) {
    "use strict";
    var lib = require_app_root_path();
    module2.exports = lib(__dirname);
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/appRoot.js
var require_appRoot = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/appRoot.js"(exports10, module2) {
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var appPath = require_app_root_path2().path;
    var cliUtilsRoot = path3.join(__dirname, "../").slice(0, -1);
    var __APP_ROOT;
    var setAppRoot = (location2) => {
      if (!__APP_ROOT && location2 !== appPath && location2 !== cliUtilsRoot)
        __APP_ROOT = location2;
    };
    var getRootParentModule = (parentModule) => {
      return parentModule.parent ? getRootParentModule(parentModule.parent) : path3.dirname(parentModule.path);
    };
    var getAppRoot = () => {
      return __APP_ROOT ? __APP_ROOT : cliUtilsRoot === appPath ? getRootParentModule(module2.parent) : appPath;
    };
    module2.exports = {
      getAppRoot,
      setAppRoot
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/tasks/tasks.js
var require_tasks = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/tasks/tasks.js"(exports10, module2) {
    var { getAppRoot } = require_appRoot();
    var { isObj, noOpObj } = require_cjs();
    var { getFolders, requireFile } = require_fileSys2();
    var __TASK_DEFINITIONS = {};
    var __TASK_FOLDER = "tasks";
    var registerTasks = (tasks) => {
      Object.assign(__TASK_DEFINITIONS, tasks);
    };
    var setTaskFolder = (folderName) => __TASK_FOLDER = folderName;
    var searchForTasks = async () => {
      const appRoot = getAppRoot();
      const [taskFolder] = await getFolders(appRoot, { include: [__TASK_FOLDER], full: true });
      if (!taskFolder)
        return noOpObj;
      try {
        const tasksModule = requireFile(taskFolder, "index", false);
        if (tasksModule)
          return tasksModule;
      } catch (err) {
      }
      return noOpObj;
    };
    var getTaskDefinitions = async (customTasks) => {
      isObj(customTasks) && registerTasks(customTasks);
      const { data: dynamicTasks } = await searchForTasks();
      dynamicTasks && registerTasks(dynamicTasks);
      return __TASK_DEFINITIONS;
    };
    module2.exports = {
      registerTasks,
      setTaskFolder,
      getTaskDefinitions
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/tasks/index.js
var require_tasks2 = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/tasks/index.js"(exports10, module2) {
    module2.exports = require_tasks();
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/hasHelpArg.js
var require_hasHelpArg = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/hasHelpArg.js"(exports10, module2) {
    var { HELP_ARGS } = require_constants2();
    var hasHelpArg = (arg) => HELP_ARGS.includes(arg);
    module2.exports = {
      hasHelpArg
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/utils/splitEqualsMatch.js
var require_splitEqualsMatch = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/utils/splitEqualsMatch.js"(exports10, module2) {
    var splitEqualsMatch = (arg, matchTypes, argument) => {
      const [key, value] = arg.split("=");
      return matchTypes.includes(key) ? value : argument;
    };
    module2.exports = {
      splitEqualsMatch
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/utils/buildMatchTypes.js
var require_buildMatchTypes = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/utils/buildMatchTypes.js"(exports10, module2) {
    var buildMatchTypes = (long, short, alias = []) => {
      return alias.reduce((matchTypes, type2) => {
        return matchTypes.concat([type2, `--${type2}`, `-${type2}`]);
      }, [long, `--${long}`, short, `-${short}`]);
    };
    module2.exports = {
      buildMatchTypes
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/utils/hasKeyIdentifier.js
var require_hasKeyIdentifier = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/utils/hasKeyIdentifier.js"(exports10, module2) {
    var { isStr } = require_cjs();
    var hasKeyIdentifier = (arg) => {
      return isStr(arg) && arg.length && (arg.includes("=") || arg.indexOf("--") === 0 || arg.indexOf("-") === 0 && arg.length === 2);
    };
    module2.exports = {
      hasKeyIdentifier
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/args/getArgValue.js
var require_getArgValue = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/args/getArgValue.js"(exports10, module2) {
    var {
      exists: exists2,
      isArr,
      isStr
    } = require_cjs();
    var { splitEqualsMatch } = require_splitEqualsMatch();
    var { buildMatchTypes } = require_buildMatchTypes();
    var { hasKeyIdentifier } = require_hasKeyIdentifier();
    var matchArgType = (matchTypes, option, value, optionSchemas) => {
      const match = matchTypes.includes(option);
      if (!match)
        return null;
      const possibleKey = isStr(value) && value.split("=")[0];
      return value && !hasKeyIdentifier(value) ? value : true;
    };
    var getArgValue = ({ options, long, short, alias, optionSchemas }) => {
      const matchTypes = buildMatchTypes(long, short, alias);
      return (isStr(long) || isStr(short)) && isArr(options) && options.reduce((argument, option, index) => {
        if (exists2(argument))
          return argument;
        const nextOpt = options[index + 1];
        let value = matchArgType(
          matchTypes,
          option,
          nextOpt,
          optionSchemas
        );
        if (!exists2(value) && option.includes("="))
          value = splitEqualsMatch(option, matchTypes, argument);
        if (value === nextOpt)
          options.splice(index, 2);
        return value;
      }, null);
    };
    module2.exports = {
      getArgValue,
      matchArgType
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/options/removeOption.js
var require_removeOption = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/options/removeOption.js"(exports10, module2) {
    var removeOption = (options, opt) => {
      options.splice(options.indexOf(opt), 1);
      return options;
    };
    module2.exports = {
      removeOption
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/args/findArg.js
var require_findArg = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/args/findArg.js"(exports10, module2) {
    var {
      exists: exists2,
      isArr
    } = require_cjs();
    var { getArgValue } = require_getArgValue();
    var { removeOption } = require_removeOption();
    var findArg = ({ key, meta = {}, index, task, ...args }) => {
      const value = getArgValue({
        ...args,
        long: key,
        short: key[0],
        alias: meta.alias,
        optionSchemas: task.options
      });
      if (exists2(value) || !isArr(meta.allowed))
        return value;
      const allowedMatch = meta.allowed.reduce((foundVal, allowed) => {
        return exists2(foundVal) ? foundVal : args.options.indexOf(allowed) === index ? allowed : foundVal;
      }, null);
      args.options = allowedMatch ? removeOption(args.options, allowedMatch) : args.options;
      return allowedMatch;
    };
    module2.exports = {
      findArg
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/configs/parse.config.js
var require_parse_config = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/configs/parse.config.js"(exports10, module2) {
    module2.exports = {
      // Option values that will be converted into booleans
      bools: {
        truthy: [
          true,
          "true",
          "t",
          "yes",
          "y",
          `1`,
          1
        ],
        falsy: [
          false,
          "false",
          "f",
          "no",
          "n",
          `0`,
          0
        ]
      },
      // Default environment argument to allow short cuts when setting an env
      environment: {
        options: ["environment", "env", "e"],
        map: {
          production: ["production", "prod", "p"],
          qa: ["qa", "q"],
          staging: ["staging", "st", "s"],
          development: ["development", "dev", "d"],
          local: ["local", "loc", "l"],
          test: ["test", "tst", "t"]
        }
      },
      // Global default task options that get added to every task
      defaultArgs: {
        env: {
          alias: ["environment"],
          description: "Environment to run the task in",
          example: "<command> --env staging",
          default: "development"
        }
      },
      // Task parsing settings
      settings: {
        fromEnv: `not-empty`,
        defaultEnv: "local",
        task: {}
      }
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/utils/getConfig.js
var require_getConfig = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/utils/getConfig.js"(exports10, module2) {
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var appRoot = require_app_root_path2().path;
    var defConfig = require_parse_config();
    var { deepMerge, get: get2, noOpObj, toBool, noPropArr, flatUnion } = require_cjs();
    var __CONFIG;
    var buildEnvironment = (customEnv = noOpObj, inlineEnv = noOpObj) => {
      var _a, _b;
      return {
        ...defConfig == null ? void 0 : defConfig.environment,
        ...customEnv,
        ...inlineEnv,
        options: flatUnion([
          ...(_a = defConfig.environment) == null ? void 0 : _a.options,
          ...(inlineEnv == null ? void 0 : inlineEnv.options) || noPropArr,
          ...(customEnv == null ? void 0 : customEnv.options) || noPropArr
        ]),
        map: {
          ...(_b = defConfig == null ? void 0 : defConfig.environment) == null ? void 0 : _b.map,
          ...(inlineEnv == null ? void 0 : inlineEnv.map) || noOpObj,
          ...(customEnv == null ? void 0 : customEnv.map) || noOpObj
        }
      };
    };
    var buildDefArgs = (customArgs = noOpObj, inlineArgs = noOpObj) => {
      var _a;
      const { env: env2, ...defArgs } = defConfig == null ? void 0 : defConfig.defaultArgs;
      return {
        ...deepMerge(defArgs, customArgs, inlineArgs),
        env: (inlineArgs == null ? void 0 : inlineArgs.env) || (customArgs == null ? void 0 : customArgs.env) || ((_a = defConfig == null ? void 0 : defConfig.defaultArgs) == null ? void 0 : _a.env)
      };
    };
    var buildBools = (customBools = noOpObj, inlineBools = noOpObj) => {
      var _a, _b;
      return {
        truthy: flatUnion([
          ...(_a = defConfig == null ? void 0 : defConfig.bools) == null ? void 0 : _a.truthy,
          ...(customBools == null ? void 0 : customBools.truthy) || noPropArr,
          ...(inlineBools == null ? void 0 : inlineBools.truthy) || noPropArr
        ]),
        falsy: flatUnion([
          ...(_b = defConfig == null ? void 0 : defConfig.bools) == null ? void 0 : _b.falsy,
          ...(customBools == null ? void 0 : customBools.falsy) || noPropArr,
          ...(inlineBools == null ? void 0 : inlineBools.falsy) || noPropArr
        ])
      };
    };
    var loadConfig = (inlineConfig = noOpObj) => {
      const { PARSE_CONFIG_PATH, KEG_TASKS_CONFIG, TASKS_CONFIG_PATH } = process.env;
      const envConfig = PARSE_CONFIG_PATH || TASKS_CONFIG_PATH || KEG_TASKS_CONFIG;
      const configPath = path3.join(
        appRoot,
        PARSE_CONFIG_PATH || TASKS_CONFIG_PATH || KEG_TASKS_CONFIG || "configs/parse.config.js"
      );
      let customConfig;
      try {
        customConfig = require(configPath);
      } catch (err) {
        toBool(envConfig) && console.error(err.stack);
        customConfig = noOpObj;
      }
      return {
        ...defConfig,
        ...inlineConfig,
        ...customConfig || noOpObj,
        settings: deepMerge(
          defConfig == null ? void 0 : defConfig.settings,
          get2(customConfig, "settings"),
          get2(inlineConfig, "settings")
        ),
        bools: buildBools(
          get2(customConfig, "bools"),
          get2(inlineConfig, "bools")
        ),
        environment: buildEnvironment(
          get2(customConfig, "environment"),
          get2(inlineConfig, "environment")
        ),
        defaultArgs: buildDefArgs(
          get2(customConfig, "defaultArgs"),
          get2(inlineConfig, "defaultArgs")
        )
      };
    };
    var getConfig = (inlineConfig) => {
      __CONFIG = __CONFIG || loadConfig(inlineConfig);
      return __CONFIG;
    };
    var clearConfig = () => __CONFIG = void 0;
    module2.exports = {
      getConfig,
      ...process.env.NODE_ENV === "test" && { clearConfig }
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/utils/parseQuotes.js
var require_parseQuotes = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/utils/parseQuotes.js"(exports10, module2) {
    var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
    var DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
    var BAREWORD = `(\\\\['"|&;()<> \\t]|[^\\s'"|&;()<> \\t])+`;
    var MATCHER = new RegExp(`(${BAREWORD}|${SINGLE_QUOTE}|${DOUBLE_QUOTE})*`, "g");
    var SQ = "'";
    var DQ = '"';
    var checkForObj = (match) => {
      const toCheck = match.indexOf("=") !== -1 ? match.split("=")[1] : match;
      if (!toCheck)
        return match;
      const isObject6 = toCheck.indexOf("{") === 0 && toCheck.indexOf("}") === toCheck.length - 1 && toCheck.includes(":");
      const isArr = toCheck.indexOf("[") === 0 && toCheck.indexOf("]") === toCheck.length - 1;
      return isObject6 || isArr;
    };
    var parseQuotes = (args) => {
      args = Array.isArray(args) ? args.join(" ") : args;
      const matches = args.match(MATCHER).filter(Boolean);
      if (!matches)
        return [];
      return Array.isArray(matches) && matches.map((match) => {
        if (checkForObj(match))
          return match;
        let quote = false;
        let out = "";
        for (let i13 = 0, length = match.length; i13 < length; i13++) {
          let char = match.charAt(i13);
          quote ? char === quote ? quote = false : out += char : char === DQ || char === SQ ? quote = char : out += char;
        }
        return out;
      }).reduce((prev, arg) => arg === void 0 ? prev : prev.concat(arg), []);
    };
    module2.exports = {
      parseQuotes
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/options/getOptionMeta.js
var require_getOptionMeta = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/options/getOptionMeta.js"(exports10, module2) {
    var { isObj } = require_cjs();
    var getOptionMeta = (task, key) => {
      return isObj(task.options[key]) ? task.options[key] : { description: task.options[key] };
    };
    module2.exports = {
      getOptionMeta
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/args/checkEnvArg.js
var require_checkEnvArg = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/args/checkEnvArg.js"(exports10, module2) {
    var { reduceObj } = require_cjs();
    var { getConfig } = require_getConfig();
    var mapEnv = (value, defaultEnv) => {
      const { environment } = getConfig();
      let foundEnv;
      return reduceObj(environment.map, (env2, shortcuts, defaultEnv2) => {
        !foundEnv && shortcuts.includes(value) && (foundEnv = env2);
        return foundEnv || defaultEnv2;
      }, value || defaultEnv);
    };
    var checkEnvArg = (key, value, defaultEnv) => {
      const { environment } = getConfig();
      return !environment.options.includes(key) ? value : mapEnv(value, defaultEnv);
    };
    module2.exports = {
      checkEnvArg,
      mapEnv
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/utils/throwRequired.js
var require_throwRequired = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/utils/throwRequired.js"(exports10, module2) {
    var logPair = (first, second) => console.log(first + " \x1B[0;36m" + second + "\x1B[0m");
    var wrapRed = (text) => "\x1B[0;31m" + text + "\x1B[0m";
    var wrapYellow = (text) => "\x1B[1;33m" + text + "\x1B[0m";
    var throwRequired = (task, key, meta = {}) => {
      try {
        throw new Error();
      } catch (err) {
        console.log(``);
        console.log(wrapRed(`Task failed!`));
        console.log(``);
        console.log(
          "Task " + wrapYellow(task.name) + " " + (meta.require || meta.required ? "requires" : "enforces a") + " " + wrapYellow(key) + " argument."
        );
        meta.alias && logPair(`  * Alias:`, [key[0]].concat(meta.alias).join(" | "));
        meta.description && logPair(`  * Description:`, meta.description);
        meta.allowed && logPair(`  * Allowed Values:`, meta.allowed.join(" | "));
        meta.example && logPair(`  * Example:`, meta.example);
        console.log(``);
        console.error(err.stack);
        console.log(``);
        process.exit(1);
      }
    };
    module2.exports = {
      throwRequired
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/utils/checkRequired.js
var require_checkRequired = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/utils/checkRequired.js"(exports10, module2) {
    var { throwRequired } = require_throwRequired();
    var checkRequired = (task, key, meta = {}) => {
      (meta.require || meta.required) && throwRequired(task, key, meta);
    };
    module2.exports = {
      checkRequired
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/options/checkENVValue.js
var require_checkENVValue = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/options/checkENVValue.js"(exports10, module2) {
    var { exists: exists2, get: get2 } = require_cjs();
    var { getConfig } = require_getConfig();
    var useENVValues = (metaEnv) => {
      if (!metaEnv)
        return false;
      const envName = metaEnv.trim();
      const envVal = process.env[envName];
      if (!envName || !exists2(envVal))
        return false;
      const envSetting = get2(getConfig(), "settings.fromEnv");
      return !envSetting || envSetting === false || envSetting === `not-empty` && envVal.trim() === `` ? false : true;
    };
    var checkENVValue = (value, metaEnv) => {
      return !exists2(value) && useENVValues(metaEnv) ? process.env[metaEnv] : value;
    };
    module2.exports = {
      checkENVValue
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/options/checkBoolValue.js
var require_checkBoolValue = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/options/checkBoolValue.js"(exports10, module2) {
    var { getConfig } = require_getConfig();
    var { exists: exists2, isStr, isBool } = require_cjs();
    var __BOOL_OPTS;
    var getBoolOptions = () => {
      const { bools } = getConfig();
      return {
        ...bools,
        all: bools.truthy.concat(bools.falsy)
      };
    };
    var checkBoolValue = (value, metaType) => {
      const notBoolType = exists2(metaType) && (metaType !== `boolean` && metaType !== `bool`);
      if (!exists2(value) || isBool(value) || notBoolType)
        return value;
      const lowerVal = isStr(value) && value.toLowerCase() || value;
      const boolOpts = __BOOL_OPTS || getBoolOptions();
      return !boolOpts.all.includes(lowerVal) ? value : boolOpts.truthy.includes(lowerVal) ? true : boolOpts.falsy.includes(lowerVal) ? false : value;
    };
    module2.exports = {
      getBoolOptions,
      checkBoolValue
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/options/checkValueType.js
var require_checkValueType = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/options/checkValueType.js"(exports10, module2) {
    var { checkBoolValue } = require_checkBoolValue();
    var { toBool, toNum, isArr, isStr, exists: exists2 } = require_cjs();
    var parseJSON = (str, logError = true) => {
      try {
        return JSON.parse(str);
      } catch (e14) {
        logError && console.error(e14.message);
        return null;
      }
    };
    var valueToArray = (value) => {
      const parsedArray = parseJSON(value, false);
      return isArr(parsedArray) ? parsedArray : isArr(value) ? value : isStr(value) ? value.split(",") : value ? [value] : [];
    };
    var colonStringToObject = (str) => {
      const pairs = str.trim().split(",");
      return pairs.reduce(
        (obj, pair) => {
          const [key, value] = pair.trim().split(":");
          obj[key] = value;
          return obj;
        },
        {}
      );
    };
    var valueToObject = (value) => {
      if (!isStr(value))
        return {};
      return value.trim().match(/^[^\s{}]+:[^\s{}]+$/g) ? colonStringToObject(value) : parseJSON(value, false) || {};
    };
    var checkValueType = (key, value, meta) => {
      if (!exists2(value) && exists2(meta.default))
        return meta.default;
      if (!meta.type)
        return value;
      switch (meta.type.toLowerCase()) {
        case "arr":
        case "array": {
          return valueToArray(value);
        }
        case "obj":
        case "object": {
          return valueToObject(value);
        }
        case "num":
        case "number": {
          return toNum(value);
        }
        case "boolean":
        case "bool": {
          const boolVal = checkBoolValue(value, meta.type);
          return exists2(boolVal) ? toBool(boolVal) : void 0;
        }
        default: {
          return value;
        }
      }
    };
    module2.exports = {
      checkValueType
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/args/ensureArgs.js
var require_ensureArgs = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/args/ensureArgs.js"(exports10, module2) {
    var { checkEnvArg } = require_checkEnvArg();
    var { exists: exists2, reduceObj } = require_cjs();
    var { checkRequired } = require_checkRequired();
    var { checkENVValue } = require_checkENVValue();
    var { checkBoolValue } = require_checkBoolValue();
    var { checkValueType } = require_checkValueType();
    var ensureArg = async (task, args, key, meta) => {
      let resolved = args[key];
      resolved = checkENVValue(resolved, meta.env);
      resolved = checkBoolValue(resolved, meta.type);
      resolved = checkEnvArg(key, resolved, meta.default);
      resolved = checkValueType(key, resolved, meta);
      if (exists2(resolved)) {
        args[key] = resolved;
        return args;
      }
      ;
      !exists2(resolved) || resolved === "" ? checkRequired(task, key, meta) : args[key] = checkBoolValue(resolved, meta.type);
      return args;
    };
    var ensureArgs = async (task, mappedParams = {}) => {
      return reduceObj(task.options, async (key, meta, toResolve) => {
        const params = await toResolve;
        return ensureArg(task, params, key, meta);
      }, Promise.resolve(mappedParams));
    };
    module2.exports = {
      ensureArg,
      ensureArgs
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/args/mapKeysToArgs.js
var require_mapKeysToArgs = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/args/mapKeysToArgs.js"(exports10, module2) {
    var { exists: exists2 } = require_cjs();
    var { getOptionMeta } = require_getOptionMeta();
    var { ensureArg } = require_ensureArgs();
    var mapKeysToArgs = (task, taskKeys, options, mappedParams) => {
      return taskKeys.reduce(async (toResolve, key, index) => {
        const params = await toResolve;
        const meta = getOptionMeta(task, key);
        const val = options[index];
        exists2(val) && (params[key] = val);
        return ensureArg(task, params, key, meta);
      }, Promise.resolve(mappedParams));
    };
    module2.exports = {
      mapKeysToArgs
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/utils/convertNoArgs.js
var require_convertNoArgs = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/utils/convertNoArgs.js"(exports10, module2) {
    var NO_ARG = `--no-`;
    var convertNoArgs = (args) => {
      return args.map((arg) => arg.indexOf(NO_ARG) === 0 ? `${arg.replace(NO_ARG, ``)}=false` : arg);
    };
    module2.exports = {
      convertNoArgs
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/options/addDefaultOptions.js
var require_addDefaultOptions = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/options/addDefaultOptions.js"(exports10, module2) {
    var { getConfig } = require_getConfig();
    var addDefaultOptions = (options = {}) => {
      const { defaultArgs } = getConfig();
      if (!defaultArgs)
        return options;
      return Object.entries(defaultArgs).reduce((updated, [name2, meta]) => {
        if (!updated[name2])
          updated[name2] = meta;
        return updated;
      }, { ...options });
    };
    module2.exports = {
      addDefaultOptions
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/options/optionsHasIdentifiers.js
var require_optionsHasIdentifiers = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/options/optionsHasIdentifiers.js"(exports10, module2) {
    var { hasKeyIdentifier } = require_hasKeyIdentifier();
    var optionsHasIdentifiers = (options = []) => {
      return options.map((option) => hasKeyIdentifier(option)).includes(true);
    };
    module2.exports = {
      optionsHasIdentifiers
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/argsParse.js
var require_argsParse = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/argsParse.js"(exports10, module2) {
    var { findArg } = require_findArg();
    var { getConfig } = require_getConfig();
    var { exists: exists2, isObj } = require_cjs();
    var { parseQuotes } = require_parseQuotes();
    var { mapKeysToArgs } = require_mapKeysToArgs();
    var { convertNoArgs } = require_convertNoArgs();
    var { getOptionMeta } = require_getOptionMeta();
    var { ensureArg, ensureArgs } = require_ensureArgs();
    var { hasKeyIdentifier } = require_hasKeyIdentifier();
    var { addDefaultOptions } = require_addDefaultOptions();
    var { optionsHasIdentifiers } = require_optionsHasIdentifiers();
    var loopTaskKeys = (task, taskKeys, options, mappedParams) => {
      return taskKeys.reduce(async (toResolve, key, index) => {
        const params = await toResolve;
        const meta = getOptionMeta(task, key);
        const value = findArg({
          key,
          meta,
          task,
          index,
          options
        });
        exists2(value) && (params[key] = value);
        return ensureArg(task, params, key, meta);
      }, Promise.resolve(mappedParams));
    };
    var loopTaskOptions = (task, taskKeys, options, params) => {
      return optionsHasIdentifiers(options) ? loopTaskKeys(task, taskKeys, options, params) : mapKeysToArgs(task, taskKeys, options, params);
    };
    var argsParse = async (toParse, config) => {
      const { task, params = {} } = toParse;
      const args = convertNoArgs(
        // Check for any quoted arguments and join them together as a single argument
        parseQuotes(toParse.args)
      );
      const builtConfig = getConfig(config);
      toParse.originalOptions = Array.from(args);
      task.options = addDefaultOptions(task.options);
      if (!args.length)
        return ensureArgs(task, params);
      const taskKeys = isObj(task.options) && Object.keys(task.options);
      const doOptsLoop = args.length !== 1 || hasKeyIdentifier(args[0]);
      const parsedArgs = doOptsLoop ? taskKeys && await loopTaskOptions(task, taskKeys, args, params) : await ensureArgs(task, { ...params, [taskKeys[0]]: args[0] });
      Object.defineProperty(parsedArgs, `$getConfig`, { value: () => builtConfig });
      return parsedArgs;
    };
    module2.exports = {
      ensureArgs,
      argsParse
    };
  }
});

// node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/@keg-hub+args-parse@10.0.1/node_modules/@keg-hub/args-parse/src/index.js"(exports10, module2) {
    module2.exports = require_argsParse();
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/globalConfig/getKegGlobalConfig.js
var require_getKegGlobalConfig = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/globalConfig/getKegGlobalConfig.js"(exports10, module2) {
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var { GLOBAL_CONFIG_FOLDER, GLOBAL_CONFIG_FILE } = require_constants2();
    var getKegGlobalConfig = (throwError = true) => {
      const configPath = path3.join(GLOBAL_CONFIG_FOLDER, GLOBAL_CONFIG_FILE);
      try {
        return require(configPath);
      } catch (err) {
        if (throwError)
          throw new Error(
            `Keg CLI global config could not be loaded from path: ${configPath}!`
          );
        return {};
      }
    };
    module2.exports = {
      getKegGlobalConfig
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/runTask.js
var require_runTask = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/runTask.js"(exports10, module2) {
    var { throwExitError } = require_error2();
    var { findTask } = require_findTask();
    var { showHelp } = require_showHelp();
    var { deepMerge } = require_cjs();
    var { getTaskDefinitions } = require_tasks2();
    var { hasHelpArg } = require_hasHelpArg();
    var { argsParse } = require_src();
    var { getKegGlobalConfig } = require_getKegGlobalConfig();
    var defParams = { env: process.env.NODE_ENV || "local" };
    var runTask = async (customTasks, customDefParams, parseConfig) => {
      const globalConfig = getKegGlobalConfig(false);
      try {
        const args = process.argv.slice(2);
        const Definitions = await getTaskDefinitions(customTasks);
        if (!args[0] || hasHelpArg(args[0]))
          return showHelp({ tasks: Definitions });
        const { task, options } = findTask(Definitions, [...args]);
        if (hasHelpArg(options[options.length - 1]))
          return showHelp({ task, options });
        const params = await argsParse({
          task,
          args: [...options],
          params: deepMerge(defParams, customDefParams)
        }, parseConfig);
        const response = await task.action({
          task,
          params,
          options,
          globalConfig,
          command: args[0],
          tasks: Definitions
        });
        return response;
      } catch (err) {
        throwExitError(err);
      }
    };
    module2.parent ? module2.exports = { runTask } : runTask();
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/globalConfig/configHelpers.js
var require_configHelpers = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/globalConfig/configHelpers.js"(exports10, module2) {
    var { get: get2 } = require_cjs();
    var { getKegGlobalConfig } = require_getKegGlobalConfig();
    var { GLOBAL_CONFIG_FOLDER, GLOBAL_CONFIG_PATHS } = require_constants2();
    var getDefaultEnv = () => {
      return process.env.KEG_DEFAULT_ENV || getKegSetting("defaultEnv");
    };
    var getEditorCmd = (globalConfig) => {
      return get2(globalConfig || getKegGlobalConfig(), GLOBAL_CONFIG_PATHS.EDITOR_CMD);
    };
    var getPathFromConfig = (globalConfig, pathName) => {
      return pathName === "config" ? GLOBAL_CONFIG_FOLDER : get2(globalConfig || getKegGlobalConfig(), `${GLOBAL_CONFIG_PATHS.CLI_PATHS}.${pathName}`);
    };
    var getKegSetting = (setting, globalConfig) => {
      return get2(globalConfig || getKegGlobalConfig(), `cli.settings.${setting}`);
    };
    module2.exports = {
      getEditorCmd,
      getKegSetting,
      getDefaultEnv,
      getPathFromConfig
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/globalConfig/globalOptions.js
var require_globalOptions = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/globalConfig/globalOptions.js"(exports10, module2) {
    var { getDefaultEnv } = require_configHelpers();
    var { ENV_ALIAS, ENV_OPTIONS } = require_constants2();
    var { deepMerge, get: get2, set } = require_cjs();
    var getGlobalOptions = (task, action) => {
      return {
        env: {
          alias: ENV_ALIAS,
          allowed: ENV_OPTIONS,
          description: "Environment to run the task in",
          example: "keg ${ task } ${ action } --env staging",
          default: getDefaultEnv()
        }
      };
    };
    var addGlobalOptions = (namedTask, name2, parent) => {
      set(namedTask, `${name2}.options`, deepMerge(
        get2(namedTask, `${name2}.options`),
        getGlobalOptions(parent, name2)
      ));
      return namedTask;
    };
    module2.exports = {
      addGlobalOptions,
      getGlobalOptions,
      getDefaultEnv
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/globalConfig/index.js
var require_globalConfig = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/globalConfig/index.js"(exports10, module2) {
    module2.exports = {
      ...require_configHelpers(),
      ...require_globalOptions(),
      ...require_getKegGlobalConfig()
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/validateTask.js
var require_validateTask = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/validateTask.js"(exports10, module2) {
    var { isObj, isFunc } = require_cjs();
    var { throwNoAction, throwNoTask } = require_error2();
    var validateTask = (task, taskPath, helpArg) => {
      return !isObj(task) ? throwNoTask(taskPath ? taskPath.replace(/\./g, " ") : task) : !isFunc(task.action) && !helpArg ? throwNoAction(task) : task;
    };
    module2.exports = {
      validateTask
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/runInternalTask.js
var require_runInternalTask = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/runInternalTask.js"(exports10, module2) {
    var { validateTask } = require_validateTask();
    var { ensureArgs } = require_src();
    var { get: get2, isStr, deepClone } = require_cjs();
    var runInternalTask = async (taskPath, args, task) => {
      const {
        tasks,
        globalConfig,
        task: orgTask,
        __internal,
        ...taskArgs
      } = args;
      taskPath = taskPath.indexOf(`tasks.`) === 0 ? taskPath : `tasks.${taskPath}`;
      task = task || get2(args, taskPath);
      task = isStr(task) && get2(args, `tasks.${task}.${taskPath}`) || task;
      const params = await ensureArgs(task, args.params);
      return validateTask(task, taskPath).action({
        task,
        tasks,
        __internal,
        globalConfig,
        command: task.name,
        ...deepClone({
          ...taskArgs,
          params,
          options: [...args.options]
        })
      });
    };
    module2.exports = {
      runInternalTask
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/buildTaskData.js
var require_buildTaskData = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/buildTaskData.js"(exports10, module2) {
    var { addGlobalOptions } = require_globalConfig();
    var { runInternalTask } = require_runInternalTask();
    var {
      get: get2,
      isArr,
      reduceObj,
      set,
      noOpObj,
      deepMerge
    } = require_cjs();
    var addCliTask = (namedTask, task, cliTask, taskPath) => {
      const tapTaskDef = namedTask[task.name];
      return !cliTask ? namedTask : { [task.name]: {
        // Merge the task definitions, so original task properties still exit
        ...cliTask,
        ...tapTaskDef,
        options: task.mergeOptions ? deepMerge(cliTask.options, tapTaskDef.options) : tapTaskDef.options,
        // Add the wrapper for the original cliTask, so it can still be called
        cliTask: (args) => runInternalTask(
          taskPath,
          { ...args, task: cliTask },
          cliTask
        ),
        // Merge the original cli sub-tasks, so they can still be called
        tasks: {
          ...cliTask.tasks,
          ...tapTaskDef.tasks
        }
      } };
    };
    var buildSubTasks = (namedTask, task, cliTasks, taskPath) => {
      const subTasks = get2(namedTask, `${task.name}.tasks`);
      subTasks && set(namedTask, `${task.name}.tasks`, reduceObj(subTasks, (key, value, existingTasks) => ({
        ...existingTasks,
        ...buildTaskData(
          value,
          task.name,
          cliTasks[task.name],
          taskPath
        )
      }), subTasks));
      return namedTask;
    };
    var buildTaskAlias = (namedTask, task) => {
      const alias = get2(task, "alias");
      return !isArr(alias) ? namedTask : alias.reduce((update, al) => {
        update[al] = task.name;
        return update;
      }, namedTask);
    };
    var buildTaskData = (task, parent, cliTasks = noOpObj, taskPath) => {
      if (!task.name)
        throw new Error(
          `Required task name could not be found for task: ${JSON.stringify(task, null, 2)}`
        );
      task.parent = task.parent || parent;
      taskPath = taskPath ? `${taskPath}.tasks.${task.name}` : `${task.parent}.tasks.${task.name}`;
      const namedTask = buildTaskAlias({ [task.name]: task }, task);
      const builtTask = buildSubTasks(namedTask, task, cliTasks, taskPath);
      const withCliTask = cliTasks[task.name] ? addCliTask(builtTask, task, cliTasks[task.name], taskPath) : builtTask;
      return addGlobalOptions(withCliTask, task.name, parent);
    };
    module2.exports = {
      buildTaskData
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/parseTaskArgs.js
var require_parseTaskArgs = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/parseTaskArgs.js"(exports10, module2) {
    var { argsParse } = require_src();
    var { getGlobalOptions } = require_globalOptions();
    var { getKegGlobalConfig } = require_getKegGlobalConfig();
    var parseTaskArgs = (args, globalConfig) => {
      const { command, task, params } = args;
      globalConfig = globalConfig || getKegGlobalConfig();
      const globalOptions = getGlobalOptions(task, command);
      return argsParse(
        { args: args.options, task, params },
        { ...globalConfig.cli, defaultArgs: globalOptions }
      );
    };
    module2.exports = {
      parseTaskArgs
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/executeTask.js
var require_executeTask = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/executeTask.js"(exports10, module2) {
    var { throwNoAction } = require_error2();
    var { isFunc } = require_cjs();
    var { hasHelpArg } = require_hasHelpArg();
    var { showHelp } = require_showHelp();
    var { parseTaskArgs } = require_parseTaskArgs();
    var executeTask = async (args) => {
      const { globalConfig, task, options } = args;
      if (hasHelpArg(options[options.length - 1]))
        return showHelp({ task, options });
      const params = args.params || await parseTaskArgs(args, globalConfig);
      return isFunc(task.action) ? task.action({ ...args, params }) : throwNoAction(task);
    };
    module2.exports = {
      executeTask
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/sharedOptions.js
var require_sharedOptions = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/sharedOptions.js"(exports10, module2) {
    var {
      deepMerge,
      isArr,
      noOpObj,
      noOpArr,
      pickKeys,
      eitherArr
    } = require_cjs();
    var __SHARED_OPTS = {
      all: {},
      groups: {}
    };
    var resetSharedOptions = () => {
      __SHARED_OPTS = {
        all: {},
        groups: {}
      };
    };
    var setSharedOptions = (options = noOpObj, groups, mergeGroups) => {
      if (!groups)
        return Object.assign(__SHARED_OPTS.all, options);
      groups && Object.assign(__SHARED_OPTS.groups, options);
      mergeGroups && Object.values(opts).map((opts2) => Object.assign(__SHARED_OPTS.all, opts2));
    };
    var sharedOptions = (action, taskOps = noOpObj, include = noOpArr, groups) => {
      const groupNames = groups && eitherArr(groups, [groups]);
      const shared = groupNames ? groupNames.reduce((joined, group) => ({
        ...joined,
        ...__SHARED_OPTS.groups[group] || noOpObj
      }), {}) : __SHARED_OPTS.all;
      const addOpts = isArr(include) && include.length ? pickKeys(shared, include) : shared;
      return deepMerge(taskOps, addOpts, taskOps);
    };
    module2.exports = {
      sharedOptions,
      setSharedOptions,
      resetSharedOptions
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/index.js
var require_task = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/task/index.js"(exports10, module2) {
    module2.exports = {
      ...require_buildTaskData(),
      ...require_executeTask(),
      ...require_findTask(),
      ...require_hasHelpArg(),
      ...require_parseTaskArgs(),
      ...require_runInternalTask(),
      ...require_sharedOptions(),
      ...require_validateTask()
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/commands/arguments.js
var require_arguments = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/commands/arguments.js"(exports10, module2) {
    var { isArr, isStr, exists: exists2, isBool } = require_cjs();
    var addToProcess = (addEnvs, overwrite) => {
      Object.entries(addEnvs).map(([key, value]) => {
        exists2(value) && (!exists2(process.env[key]) || isArr(overwrite) && overwrite.includes(key) || isBool(overwrite) && overwrite) && (process.env[key] = value);
      });
    };
    var addParam = (name2, value, ident = `--`) => name2 && exists2(value) ? `${ident}${name2} ${value}` : "";
    var addFlag = (...args) => {
      const name2 = args[0];
      return !name2 || args.length == 2 && !args[1] ? "" : `--${name2}`;
    };
    var addValues = (values) => isArr(values) ? values.join(" ") : isStr(values) ? values.replace(/,/g, " ") : "";
    module2.exports = {
      addFlag,
      addParam,
      addValues,
      addToProcess
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/commands/inDocker.js
var require_inDocker2 = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/commands/inDocker.js"(exports10, module2) {
    var fs2 = (init_fs2(), __toCommonJS(fs_exports));
    var inContainer;
    var tryCatch = (cb) => {
      try {
        return Boolean(cb());
      } catch (_8) {
        return false;
      }
    };
    var dockEnv = () => fs2.statSync("/.dockerenv") || true;
    var docGroup = () => fs2.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
    var inDocker = () => {
      inContainer === void 0 && (inContainer = tryCatch(dockEnv) || tryCatch(docGroup));
      return inContainer;
    };
    module2.exports = {
      inDocker
    };
  }
});

// node_modules/.pnpm/shell-exec@1.0.2/node_modules/shell-exec/index.js
var require_shell_exec = __commonJS({
  "node_modules/.pnpm/shell-exec@1.0.2/node_modules/shell-exec/index.js"(exports10, module2) {
    "use strict";
    var childProcess = (init_child_process2(), __toCommonJS(child_process_exports));
    function shellExec(cmd = "", opts2 = {}) {
      if (Array.isArray(cmd)) {
        cmd = cmd.join(";");
      }
      opts2 = Object.assign({ stdio: "pipe", cwd: process.cwd() }, opts2);
      let child;
      const shell = process.platform === "win32" ? { cmd: "cmd", arg: "/C" } : { cmd: "sh", arg: "-c" };
      try {
        child = childProcess.spawn(shell.cmd, [shell.arg, cmd], opts2);
      } catch (error) {
        return Promise.reject(error);
      }
      return new Promise((resolve4) => {
        let stdout = "";
        let stderr = "";
        if (child.stdout) {
          child.stdout.on("data", (data) => {
            stdout += data;
          });
        }
        if (child.stderr) {
          child.stderr.on("data", (data) => {
            stderr += data;
          });
        }
        child.on("error", (error) => {
          resolve4({ error, stdout, stderr, cmd });
        });
        child.on("close", (code) => {
          resolve4({ stdout, stderr, cmd, code });
        });
      });
    }
    module2.exports = shellExec;
  }
});

// node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/utils/error/show_error.js
var require_show_error = __commonJS({
  "node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/utils/error/show_error.js"(exports10, module2) {
    var { logData } = require_cjs();
    module2.exports = (err, exit) => {
      err.message && logData(err.message, "error");
      err.stack && logData(err.stack, "error");
      exit && process.exit(1);
    };
  }
});

// node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/utils/error/exit_error.js
var require_exit_error = __commonJS({
  "node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/utils/error/exit_error.js"(exports10, module2) {
    var showError = require_show_error();
    module2.exports = (err) => showError(err || {}, true);
  }
});

// node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/utils/error/error_handler.js
var require_error_handler = __commonJS({
  "node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/utils/error/error_handler.js"(exports10, module2) {
    var showError = require_show_error();
    module2.exports = (err) => showError(err || {});
  }
});

// node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/utils/error/index.js
var require_error3 = __commonJS({
  "node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/utils/error/index.js"(exports10, module2) {
    var exitError = require_exit_error();
    var errorHandler = require_error_handler();
    module2.exports = {
      exitError,
      errorHandler
    };
  }
});

// node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/utils/parseQuotes.js
var require_parseQuotes2 = __commonJS({
  "node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/utils/parseQuotes.js"(exports10, module2) {
    var { isArr, isStr } = require_cjs();
    var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
    var DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
    var BARE_WORD = `(\\\\['"|&;()<> \\t]|[^\\s'"|&;()<> \\t])+`;
    var MATCHER = new RegExp(`(${BARE_WORD}|${SINGLE_QUOTE}|${DOUBLE_QUOTE})*`, "g");
    var SQ = "'";
    var DQ = '"';
    var parseQuotes = (args) => {
      const argsStr = Array.isArray(args) ? args.join(" ") : args;
      if (!isStr(argsStr))
        return [];
      const matches = argsStr.match(MATCHER).filter(Boolean);
      return !matches || !isArr(matches) ? args : matches.map((match) => {
        let quote = false;
        let out = "";
        for (let i13 = 0, length = match.length; i13 < length; i13++) {
          let char = match.charAt(i13);
          quote ? char === quote ? quote = false : out += char : char === DQ || char === SQ ? quote = char : out += char;
        }
        return out;
      }).reduce((prev, arg) => arg === void 0 ? prev : prev.concat(arg), []);
    };
    module2.exports = {
      parseQuotes
    };
  }
});

// node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/utils/cmdArgs.js
var require_cmdArgs = __commonJS({
  "node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/utils/cmdArgs.js"(exports10, module2) {
    var { isArr, isStr, isObj, get: get2 } = require_cjs();
    var rootDir = require_app_root_path2().path;
    var { errorHandler } = require_error3();
    var { parseQuotes } = require_parseQuotes2();
    var ensureArgsArray = (args) => {
      return isArr(args) ? args : isStr(args) ? args.split(" ") : errorHandler({ message: "Arguments must be a string or an array of strings!" }) || [];
    };
    var checkExtraArgs = (cmd, args) => {
      const cmdSplit = cmd.split(" ");
      cmd = cmdSplit.shift();
      args = ensureArgsArray(args);
      args = parseQuotes(cmdSplit.concat(args));
      return { cmd, args };
    };
    var getCWD = (config, cwd) => {
      return isStr(cwd) ? cwd : isStr(config) ? config : isObj(config) && get2(config, "cwd", rootDir);
    };
    var getArgs = (cmd, config, cwd) => {
      return {
        cmd,
        config: isObj(config) ? config : {},
        cwd: getCWD(config, cwd)
      };
    };
    module2.exports = {
      checkExtraArgs,
      ensureArgsArray,
      getArgs,
      getCWD
    };
  }
});

// node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/utils/index.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/utils/index.js"(exports10, module2) {
    module2.exports = {
      ...require_cmdArgs(),
      ...require_error3()
    };
  }
});

// node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/asyncCmd.js
var require_asyncCmd = __commonJS({
  "node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/asyncCmd.js"(exports10, module2) {
    var shellExec = require_shell_exec();
    var { errorHandler } = require_utils2();
    var rootDir = require_app_root_path2().path;
    var { getCWD } = require_cmdArgs();
    var { limbo, isStr, get: get2 } = require_cjs();
    var cmdOpts = {
      gid: process.getgid(),
      uid: process.getuid(),
      env: process.env,
      cwd: rootDir
    };
    var asyncCmd = async (command, options = {}, cwd) => {
      if (!isStr(command))
        return errorHandler(new Error(`asyncCmd requires a string as the first argument!`));
      cwd = getCWD(options, cwd);
      const [error, output] = await limbo(shellExec(
        command,
        {
          ...cmdOpts,
          ...options,
          env: { ...cmdOpts.env, ...options.env },
          ...cwd && { cwd }
        }
      ));
      return {
        error: get2(error, "message", get2(output, "stderr")) || get2(output, "stderr"),
        data: get2(output, "stdout"),
        exitCode: get2(output, "code")
      };
    };
    module2.exports = {
      asyncCmd
    };
  }
});

// node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js"(exports10, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = (init_fs2(), __toCommonJS(fs_exports));
    function checkPathExt(path3, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i13 = 0; i13 < pathext.length; i13++) {
        var p13 = pathext[i13].toLowerCase();
        if (p13 && path3.substr(-p13.length).toLowerCase() === p13) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat2, path3, options) {
      if (!stat2.isSymbolicLink() && !stat2.isFile()) {
        return false;
      }
      return checkPathExt(path3, options);
    }
    function isexe(path3, options, cb) {
      fs2.stat(path3, function(er, stat2) {
        cb(er, er ? false : checkStat(stat2, path3, options));
      });
    }
    function sync(path3, options) {
      return checkStat(fs2.statSync(path3), path3, options);
    }
  }
});

// node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js"(exports10, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = (init_fs2(), __toCommonJS(fs_exports));
    function isexe(path3, options, cb) {
      fs2.stat(path3, function(er, stat2) {
        cb(er, er ? false : checkStat(stat2, options));
      });
    }
    function sync(path3, options) {
      return checkStat(fs2.statSync(path3), options);
    }
    function checkStat(stat2, options) {
      return stat2.isFile() && checkMode(stat2, options);
    }
    function checkMode(stat2, options) {
      var mod = stat2.mode;
      var uid = stat2.uid;
      var gid = stat2.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u13 = parseInt("100", 8);
      var g9 = parseInt("010", 8);
      var o14 = parseInt("001", 8);
      var ug = u13 | g9;
      var ret = mod & o14 || mod & g9 && gid === myGid || mod & u13 && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js"(exports10, module2) {
    var fs2 = (init_fs2(), __toCommonJS(fs_exports));
    var core;
    if (process.platform === "win32" || globalThis.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path3, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve4, reject) {
          isexe(path3, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve4(is);
            }
          });
        });
      }
      core(path3, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path3, options) {
      try {
        return core.sync(path3, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/.pnpm/which@2.0.2/node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/.pnpm/which@2.0.2/node_modules/which/which.js"(exports10, module2) {
    var isWindows3 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var COLON = isWindows3 ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows3 && cmd.match(/\\/) ? [""] : [
        // windows always checks the cwd first
        ...isWindows3 ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon)
      ];
      const pathExtExe = isWindows3 ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows3 ? pathExtExe.split(colon) : [""];
      if (isWindows3) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i13) => new Promise((resolve4, reject) => {
        if (i13 === pathEnv.length)
          return opt.all && found.length ? resolve4(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i13];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path3.join(pathPart, cmd);
        const p13 = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve4(subStep(p13, i13, 0));
      });
      const subStep = (p13, i13, ii) => new Promise((resolve4, reject) => {
        if (ii === pathExt.length)
          return resolve4(step(i13 + 1));
        const ext = pathExt[ii];
        isexe(p13 + ext, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p13 + ext);
            else
              return resolve4(p13 + ext);
          }
          return resolve4(subStep(p13, i13, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i13 = 0; i13 < pathEnv.length; i13++) {
        const ppRaw = pathEnv[i13];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path3.join(pathPart, cmd);
        const p13 = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j8 = 0; j8 < pathExt.length; j8++) {
          const cur = p13 + pathExt[j8];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which;
    which.sync = whichSync;
  }
});

// node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js
var require_path_key = __commonJS({
  "node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js"(exports10, module2) {
    "use strict";
    var pathKey = (options = {}) => {
      const environment = options.env || process.env;
      const platform2 = options.platform || process.platform;
      if (platform2 !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    module2.exports = pathKey;
    module2.exports.default = pathKey;
  }
});

// node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports10, module2) {
    "use strict";
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var which = require_which();
    var getPathKey = require_path_key();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const env2 = parsed.options.env || process.env;
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which.sync(parsed.command, {
          path: env2[getPathKey({ env: env2 })],
          pathExt: withoutPathExt ? path3.delimiter : void 0
        });
      } catch (e14) {
      } finally {
        if (shouldSwitchCwd) {
          process.chdir(cwd);
        }
      }
      if (resolved) {
        resolved = path3.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    module2.exports = resolveCommand;
  }
});

// node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js"(exports10, module2) {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      arg = arg.replace(metaCharsRegExp, "^$1");
      return arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      arg = `${arg}`;
      arg = arg.replace(/(\\*)"/g, '$1$1\\"');
      arg = arg.replace(/(\\*)$/, "$1$1");
      arg = `"${arg}"`;
      arg = arg.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, "^$1");
      }
      return arg;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  }
});

// node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({
  "node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js"(exports10, module2) {
    "use strict";
    module2.exports = /^#!(.*)/;
  }
});

// node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({
  "node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js"(exports10, module2) {
    "use strict";
    var shebangRegex = require_shebang_regex();
    module2.exports = (string = "") => {
      const match = string.match(shebangRegex);
      if (!match) {
        return null;
      }
      const [path3, argument] = match[0].replace(/#! ?/, "").split(" ");
      const binary = path3.split("/").pop();
      if (binary === "env") {
        return argument;
      }
      return argument ? `${binary} ${argument}` : binary;
    };
  }
});

// node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js"(exports10, module2) {
    "use strict";
    var fs2 = (init_fs2(), __toCommonJS(fs_exports));
    var shebangCommand = require_shebang_command();
    function readShebang(command) {
      const size = 150;
      const buffer4 = Buffer.alloc(size);
      let fd;
      try {
        fd = fs2.openSync(command, "r");
        fs2.readSync(fd, buffer4, 0, size, 0);
        fs2.closeSync(fd);
      } catch (e14) {
      }
      return shebangCommand(buffer4.toString());
    }
    module2.exports = readShebang;
  }
});

// node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js"(exports10, module2) {
    "use strict";
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var resolveCommand = require_resolveCommand();
    var escape2 = require_escape();
    var readShebang = require_readShebang();
    var isWin = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path3.normalize(parsed.command);
        parsed.command = escape2.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape2.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parse4(command, args, options) {
      if (args && !Array.isArray(args)) {
        options = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options = Object.assign({}, options);
      const parsed = {
        command,
        args,
        options,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options.shell ? parsed : parseNonShell(parsed);
    }
    module2.exports = parse4;
  }
});

// node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js"(exports10, module2) {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp2, parsed) {
      if (!isWin) {
        return;
      }
      const originalEmit = cp2.emit;
      cp2.emit = function(name2, arg1) {
        if (name2 === "exit") {
          const err = verifyENOENT(arg1, parsed, "spawn");
          if (err) {
            return originalEmit.call(cp2, "error", err);
          }
        }
        return originalEmit.apply(cp2, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});

// node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js"(exports10, module2) {
    "use strict";
    var cp2 = (init_child_process2(), __toCommonJS(child_process_exports));
    var parse4 = require_parse();
    var enoent = require_enoent();
    function spawn(command, args, options) {
      const parsed = parse4(command, args, options);
      const spawned = cp2.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command, args, options) {
      const parsed = parse4(command, args, options);
      const result = cp2.spawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    module2.exports = spawn;
    module2.exports.spawn = spawn;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse4;
    module2.exports._enoent = enoent;
  }
});

// node_modules/.pnpm/tree-kill@1.2.2/node_modules/tree-kill/index.js
var require_tree_kill = __commonJS({
  "node_modules/.pnpm/tree-kill@1.2.2/node_modules/tree-kill/index.js"(exports10, module2) {
    "use strict";
    var childProcess = (init_child_process2(), __toCommonJS(child_process_exports));
    var spawn = childProcess.spawn;
    var exec = childProcess.exec;
    module2.exports = function(pid, signal, callback) {
      if (typeof signal === "function" && callback === void 0) {
        callback = signal;
        signal = void 0;
      }
      pid = parseInt(pid);
      if (Number.isNaN(pid)) {
        if (callback) {
          return callback(new Error("pid must be a number"));
        } else {
          throw new Error("pid must be a number");
        }
      }
      var tree = {};
      var pidsToProcess = {};
      tree[pid] = [];
      pidsToProcess[pid] = 1;
      switch (process.platform) {
        case "win32":
          exec("taskkill /pid " + pid + " /T /F", callback);
          break;
        case "darwin":
          buildProcessTree(pid, tree, pidsToProcess, function(parentPid) {
            return spawn("pgrep", ["-P", parentPid]);
          }, function() {
            killAll(tree, signal, callback);
          });
          break;
        default:
          buildProcessTree(pid, tree, pidsToProcess, function(parentPid) {
            return spawn("ps", ["-o", "pid", "--no-headers", "--ppid", parentPid]);
          }, function() {
            killAll(tree, signal, callback);
          });
          break;
      }
    };
    function killAll(tree, signal, callback) {
      var killed = {};
      try {
        Object.keys(tree).forEach(function(pid) {
          tree[pid].forEach(function(pidpid) {
            if (!killed[pidpid]) {
              killPid(pidpid, signal);
              killed[pidpid] = 1;
            }
          });
          if (!killed[pid]) {
            killPid(pid, signal);
            killed[pid] = 1;
          }
        });
      } catch (err) {
        if (callback) {
          return callback(err);
        } else {
          throw err;
        }
      }
      if (callback) {
        return callback();
      }
    }
    function killPid(pid, signal) {
      try {
        process.kill(parseInt(pid, 10), signal);
      } catch (err) {
        if (err.code !== "ESRCH")
          throw err;
      }
    }
    function buildProcessTree(parentPid, tree, pidsToProcess, spawnChildProcessesList, cb) {
      var ps = spawnChildProcessesList(parentPid);
      var allData = "";
      ps.stdout.on("data", function(data) {
        var data = data.toString("ascii");
        allData += data;
      });
      var onClose = function(code) {
        delete pidsToProcess[parentPid];
        if (code != 0) {
          if (Object.keys(pidsToProcess).length == 0) {
            cb();
          }
          return;
        }
        allData.match(/\d+/g).forEach(function(pid) {
          pid = parseInt(pid, 10);
          tree[parentPid].push(pid);
          tree[pid] = [];
          pidsToProcess[pid] = 1;
          buildProcessTree(pid, tree, pidsToProcess, spawnChildProcessesList, cb);
        });
      };
      ps.on("close", onClose);
    }
  }
});

// node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/childProcess.js
var require_childProcess = __commonJS({
  "node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/childProcess.js"(exports10, module2) {
    var spawn = require_cross_spawn();
    var killProc = require_tree_kill();
    var rootDir = require_app_root_path2().path;
    var { errorHandler } = require_utils2();
    var { logData, mapObj: mapObj2, checkCall, deepMerge, isFunc } = require_cjs();
    var processes = {};
    var initExitHandlers = () => {
      Array.from([
        "exit",
        "SIGINT",
        "SIGUSR1",
        "SIGUSR2",
        "uncaughtException",
        "SIGTERM"
      ]).map((event) => process.on(event, async (exitCode) => {
        if (process.__spOnExitCalled)
          return;
        process.__spOnExitCalled = true;
        mapObj2(processes, (procId, childProc) => {
          if (childProc.__spOnExitCalled)
            return;
          childProc.__spOnExitCalled = true;
          logData(`Cleaning up child processes, On event: ${event}`);
          killProc(procId, "SIGKILL");
        });
      }));
    };
    var spawnOpts = {
      gid: process.getgid(),
      uid: process.getuid(),
      env: process.env,
      cwd: rootDir,
      stdio: "inherit"
    };
    var defKillProc = async (_8, procId) => {
      try {
        return await forceKill(procId);
      } catch (e14) {
        console.error(e14.stack);
        return 1;
      }
    };
    var defEvents = {
      onError: { name: "error" },
      onClose: { name: "close" },
      onStdErr: { name: "stderr", childKey: "stderr", sub: "data" },
      onStdOut: { name: "stdout", childKey: "stdout", sub: "data" },
      onExit: { method: defKillProc, name: "exit" }
    };
    var evtWrap = (cb, procId, event) => (data) => checkCall(cb, data, procId);
    var addEvents = (procId, cbEvents, child) => {
      child = child || get2(procId);
      if (!child)
        return logData(`No child process found with ID: ${procId}`);
      mapObj2(defEvents, (key, { name: name2, method, childKey, sub }) => {
        const validChild = childKey ? Boolean(child[childKey]) : true;
        const callback = cbEvents[key] || method;
        if (!validChild || !isFunc(callback))
          return;
        sub ? child[childKey].on(sub, evtWrap(callback, procId, name2)) : child.on(name2, evtWrap(callback, procId, name2));
      });
    };
    var setupProc = (childProc) => {
      const procId = childProc.pid;
      processes[procId] = childProc;
      processes[procId].stdout && processes[procId].stdout.setEncoding("utf-8");
      processes[procId].stderr && processes[procId].stderr.setEncoding("utf-8");
    };
    var get2 = (procId) => {
      return processes[procId];
    };
    var afterKill = (procId, res) => {
      delete processes[procId];
      return checkCall(res, true);
    };
    var kill = (procId, child) => {
      child = child || get2(procId);
      if (!child)
        return logData(`No child process found with ID: ${procId}`);
      if (procId !== child.pid)
        procId = child.pid;
      return new Promise((res, rej) => {
        try {
          return killProc(child.pid, (err) => {
            err ? rej(err) : afterKill(procId, res);
          });
        } catch (err) {
          return rej(err, procId);
        }
      }).catch((e14) => forceKill(procId)).finally((data) => data);
    };
    var forceKill = (procId) => {
      return new Promise((res, rej) => {
        try {
          killProc(procId, "SIGKILL", (err) => err ? rej(err) : afterKill(procId, res));
        } catch (err) {
          errorHandler(err);
          return rej(err, procId);
        }
      });
    };
    var killAll = async () => {
      try {
        await Promise.all(mapObj2(processes, (key, value) => kill(key, value)));
        return true;
      } catch (err) {
        errorHandler(err);
        return false;
      }
    };
    var create = (params) => {
      params.log && logData("Creating child process...");
      const { cmd, args, options } = params;
      const procOpts = deepMerge(spawnOpts, options);
      const childProc = spawn(cmd, args || [], procOpts);
      if (!childProc.pid) {
        logData(`Child process created, but is no longer running!`, `warn`);
        return childProc;
      }
      procOpts.detached && procOpts.stdio !== "inherit" && childProc.unref();
      setupProc(childProc);
      addEvents(childProc.pid, params, childProc);
      initExitHandlers();
      params.log && logData(`Created child process with PID: ${childProc.pid}`);
      return childProc;
    };
    module2.exports = {
      create,
      get: get2,
      kill,
      killAll
    };
  }
});

// node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/spawnCmd.js
var require_spawnCmd = __commonJS({
  "node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/spawnCmd.js"(exports10, module2) {
    var { errorHandler } = require_utils2();
    var { create } = require_childProcess();
    var { get: get2, checkCall, isFunc } = require_cjs();
    var { checkExtraArgs, getArgs } = require_cmdArgs();
    var defEvents = (config, res, rej) => ({
      onStdOut: (data, procId) => {
        const onOut = get2(config, "onStdOut");
        isFunc(onOut) ? onOut(data, procId) : process.stdout.write(data);
      },
      onStdErr: (err, procId) => {
        const onErr = get2(config, "onStdErr");
        isFunc(onErr) ? onErr(err, procId) : process.stderr.write(err);
      },
      onError: (err, procId) => {
        const onErr = get2(config, "onError");
        isFunc(onErr) ? onErr(err, procId) : errorHandler(err);
      },
      onExit: (exitCode, procId) => {
        checkCall(get2(config, "onExit"), exitCode, procId);
        res(exitCode);
      }
    });
    var spawnCmd = (...args) => {
      const { cmd, config, cwd } = getArgs(...args);
      return new Promise((res, rej) => {
        return create({
          ...config,
          ...checkExtraArgs(cmd, get2(config, "args", [])),
          ...defEvents(config, res, rej),
          options: {
            env: process.env,
            ...cwd && { cwd },
            ...get2(config, "options", {})
          }
        });
      });
    };
    module2.exports = {
      spawnCmd
    };
  }
});

// node_modules/.pnpm/ansi-escapes@4.3.2/node_modules/ansi-escapes/index.js
var require_ansi_escapes = __commonJS({
  "node_modules/.pnpm/ansi-escapes@4.3.2/node_modules/ansi-escapes/index.js"(exports10, module2) {
    "use strict";
    var ansiEscapes = module2.exports;
    module2.exports.default = ansiEscapes;
    var ESC = "\x1B[";
    var OSC = "\x1B]";
    var BEL = "\x07";
    var SEP = ";";
    var isTerminalApp = process.env.TERM_PROGRAM === "Apple_Terminal";
    ansiEscapes.cursorTo = (x8, y11) => {
      if (typeof x8 !== "number") {
        throw new TypeError("The `x` argument is required");
      }
      if (typeof y11 !== "number") {
        return ESC + (x8 + 1) + "G";
      }
      return ESC + (y11 + 1) + ";" + (x8 + 1) + "H";
    };
    ansiEscapes.cursorMove = (x8, y11) => {
      if (typeof x8 !== "number") {
        throw new TypeError("The `x` argument is required");
      }
      let ret = "";
      if (x8 < 0) {
        ret += ESC + -x8 + "D";
      } else if (x8 > 0) {
        ret += ESC + x8 + "C";
      }
      if (y11 < 0) {
        ret += ESC + -y11 + "A";
      } else if (y11 > 0) {
        ret += ESC + y11 + "B";
      }
      return ret;
    };
    ansiEscapes.cursorUp = (count = 1) => ESC + count + "A";
    ansiEscapes.cursorDown = (count = 1) => ESC + count + "B";
    ansiEscapes.cursorForward = (count = 1) => ESC + count + "C";
    ansiEscapes.cursorBackward = (count = 1) => ESC + count + "D";
    ansiEscapes.cursorLeft = ESC + "G";
    ansiEscapes.cursorSavePosition = isTerminalApp ? "\x1B7" : ESC + "s";
    ansiEscapes.cursorRestorePosition = isTerminalApp ? "\x1B8" : ESC + "u";
    ansiEscapes.cursorGetPosition = ESC + "6n";
    ansiEscapes.cursorNextLine = ESC + "E";
    ansiEscapes.cursorPrevLine = ESC + "F";
    ansiEscapes.cursorHide = ESC + "?25l";
    ansiEscapes.cursorShow = ESC + "?25h";
    ansiEscapes.eraseLines = (count) => {
      let clear = "";
      for (let i13 = 0; i13 < count; i13++) {
        clear += ansiEscapes.eraseLine + (i13 < count - 1 ? ansiEscapes.cursorUp() : "");
      }
      if (count) {
        clear += ansiEscapes.cursorLeft;
      }
      return clear;
    };
    ansiEscapes.eraseEndLine = ESC + "K";
    ansiEscapes.eraseStartLine = ESC + "1K";
    ansiEscapes.eraseLine = ESC + "2K";
    ansiEscapes.eraseDown = ESC + "J";
    ansiEscapes.eraseUp = ESC + "1J";
    ansiEscapes.eraseScreen = ESC + "2J";
    ansiEscapes.scrollUp = ESC + "S";
    ansiEscapes.scrollDown = ESC + "T";
    ansiEscapes.clearScreen = "\x1Bc";
    ansiEscapes.clearTerminal = process.platform === "win32" ? `${ansiEscapes.eraseScreen}${ESC}0f` : (
      // 1. Erases the screen (Only done in case `2` is not supported)
      // 2. Erases the whole screen including scrollback buffer
      // 3. Moves cursor to the top-left position
      // More info: https://www.real-world-systems.com/docs/ANSIcode.html
      `${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`
    );
    ansiEscapes.beep = BEL;
    ansiEscapes.link = (text, url) => {
      return [
        OSC,
        "8",
        SEP,
        SEP,
        url,
        BEL,
        text,
        OSC,
        "8",
        SEP,
        SEP,
        BEL
      ].join("");
    };
    ansiEscapes.image = (buffer4, options = {}) => {
      let ret = `${OSC}1337;File=inline=1`;
      if (options.width) {
        ret += `;width=${options.width}`;
      }
      if (options.height) {
        ret += `;height=${options.height}`;
      }
      if (options.preserveAspectRatio === false) {
        ret += ";preserveAspectRatio=0";
      }
      return ret + ":" + buffer4.toString("base64") + BEL;
    };
    ansiEscapes.iTerm = {
      setCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,
      annotation: (message, options = {}) => {
        let ret = `${OSC}1337;`;
        const hasX = typeof options.x !== "undefined";
        const hasY = typeof options.y !== "undefined";
        if ((hasX || hasY) && !(hasX && hasY && typeof options.length !== "undefined")) {
          throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
        }
        message = message.replace(/\|/g, "");
        ret += options.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=";
        if (options.length > 0) {
          ret += (hasX ? [message, options.length, options.x, options.y] : [options.length, message]).join("|");
        } else {
          ret += message;
        }
        return ret + BEL;
      }
    };
  }
});

// node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js
var require_mimic_fn = __commonJS({
  "node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js"(exports10, module2) {
    "use strict";
    var mimicFn = (to, from) => {
      for (const prop of Reflect.ownKeys(from)) {
        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
      }
      return to;
    };
    module2.exports = mimicFn;
    module2.exports.default = mimicFn;
  }
});

// node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js
var require_onetime = __commonJS({
  "node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js"(exports10, module2) {
    "use strict";
    var mimicFn = require_mimic_fn();
    var calledFunctions = /* @__PURE__ */ new WeakMap();
    var onetime = (function_, options = {}) => {
      if (typeof function_ !== "function") {
        throw new TypeError("Expected a function");
      }
      let returnValue;
      let callCount = 0;
      const functionName = function_.displayName || function_.name || "<anonymous>";
      const onetime2 = function(...arguments_) {
        calledFunctions.set(onetime2, ++callCount);
        if (callCount === 1) {
          returnValue = function_.apply(this, arguments_);
          function_ = null;
        } else if (options.throw === true) {
          throw new Error(`Function \`${functionName}\` can only be called once`);
        }
        return returnValue;
      };
      mimicFn(onetime2, function_);
      calledFunctions.set(onetime2, callCount);
      return onetime2;
    };
    module2.exports = onetime;
    module2.exports.default = onetime;
    module2.exports.callCount = (function_) => {
      if (!calledFunctions.has(function_)) {
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
      }
      return calledFunctions.get(function_);
    };
  }
});

// node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js
var require_signals = __commonJS({
  "node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js"(exports10, module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push(
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      module2.exports.push(
        "SIGIO",
        "SIGPOLL",
        "SIGPWR",
        "SIGSTKFLT",
        "SIGUNUSED"
      );
    }
  }
});

// node-modules-polyfills:events
function o12() {
  o12.init.call(this);
}
function u11(e26) {
  if ("function" != typeof e26)
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e26);
}
function f11(e26) {
  return void 0 === e26._maxListeners ? o12.defaultMaxListeners : e26._maxListeners;
}
function v9(e26, t26, n26, r26) {
  var i26, o26, s26, v25;
  if (u11(n26), void 0 === (o26 = e26._events) ? (o26 = e26._events = /* @__PURE__ */ Object.create(null), e26._eventsCount = 0) : (void 0 !== o26.newListener && (e26.emit("newListener", t26, n26.listener ? n26.listener : n26), o26 = e26._events), s26 = o26[t26]), void 0 === s26)
    s26 = o26[t26] = n26, ++e26._eventsCount;
  else if ("function" == typeof s26 ? s26 = o26[t26] = r26 ? [n26, s26] : [s26, n26] : r26 ? s26.unshift(n26) : s26.push(n26), (i26 = f11(e26)) > 0 && s26.length > i26 && !s26.warned) {
    s26.warned = true;
    var a26 = new Error("Possible EventEmitter memory leak detected. " + s26.length + " " + String(t26) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a26.name = "MaxListenersExceededWarning", a26.emitter = e26, a26.type = t26, a26.count = s26.length, v25 = a26, console && console.warn && console.warn(v25);
  }
  return e26;
}
function a11() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function l11(e26, t26, n26) {
  var r26 = { fired: false, wrapFn: void 0, target: e26, type: t26, listener: n26 }, i26 = a11.bind(r26);
  return i26.listener = n26, r26.wrapFn = i26, i26;
}
function h11(e26, t26, n26) {
  var r26 = e26._events;
  if (void 0 === r26)
    return [];
  var i26 = r26[t26];
  return void 0 === i26 ? [] : "function" == typeof i26 ? n26 ? [i26.listener || i26] : [i26] : n26 ? function(e35) {
    for (var t35 = new Array(e35.length), n35 = 0; n35 < t35.length; ++n35)
      t35[n35] = e35[n35].listener || e35[n35];
    return t35;
  }(i26) : c11(i26, i26.length);
}
function p11(e26) {
  var t26 = this._events;
  if (void 0 !== t26) {
    var n26 = t26[e26];
    if ("function" == typeof n26)
      return 1;
    if (void 0 !== n26)
      return n26.length;
  }
  return 0;
}
function c11(e26, t26) {
  for (var n26 = new Array(t26), r26 = 0; r26 < t26; ++r26)
    n26[r26] = e26[r26];
  return n26;
}
var e12, t11, n12, r12, i11, s10, y9, EventEmitter3, defaultMaxListeners3, init3, listenerCount3, on3, once3;
var init_events = __esm({
  "node-modules-polyfills:events"() {
    n12 = "object" == typeof Reflect ? Reflect : null;
    r12 = n12 && "function" == typeof n12.apply ? n12.apply : function(e26, t26, n26) {
      return Function.prototype.apply.call(e26, t26, n26);
    };
    t11 = n12 && "function" == typeof n12.ownKeys ? n12.ownKeys : Object.getOwnPropertySymbols ? function(e26) {
      return Object.getOwnPropertyNames(e26).concat(Object.getOwnPropertySymbols(e26));
    } : function(e26) {
      return Object.getOwnPropertyNames(e26);
    };
    i11 = Number.isNaN || function(e26) {
      return e26 != e26;
    };
    e12 = o12, o12.EventEmitter = o12, o12.prototype._events = void 0, o12.prototype._eventsCount = 0, o12.prototype._maxListeners = void 0;
    s10 = 10;
    Object.defineProperty(o12, "defaultMaxListeners", { enumerable: true, get: function() {
      return s10;
    }, set: function(e26) {
      if ("number" != typeof e26 || e26 < 0 || i11(e26))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e26 + ".");
      s10 = e26;
    } }), o12.init = function() {
      void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    }, o12.prototype.setMaxListeners = function(e26) {
      if ("number" != typeof e26 || e26 < 0 || i11(e26))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e26 + ".");
      return this._maxListeners = e26, this;
    }, o12.prototype.getMaxListeners = function() {
      return f11(this);
    }, o12.prototype.emit = function(e26) {
      for (var t26 = [], n26 = 1; n26 < arguments.length; n26++)
        t26.push(arguments[n26]);
      var i26 = "error" === e26, o26 = this._events;
      if (void 0 !== o26)
        i26 = i26 && void 0 === o26.error;
      else if (!i26)
        return false;
      if (i26) {
        var s26;
        if (t26.length > 0 && (s26 = t26[0]), s26 instanceof Error)
          throw s26;
        var u26 = new Error("Unhandled error." + (s26 ? " (" + s26.message + ")" : ""));
        throw u26.context = s26, u26;
      }
      var f26 = o26[e26];
      if (void 0 === f26)
        return false;
      if ("function" == typeof f26)
        r12(f26, this, t26);
      else {
        var v25 = f26.length, a26 = c11(f26, v25);
        for (n26 = 0; n26 < v25; ++n26)
          r12(a26[n26], this, t26);
      }
      return true;
    }, o12.prototype.addListener = function(e26, t26) {
      return v9(this, e26, t26, false);
    }, o12.prototype.on = o12.prototype.addListener, o12.prototype.prependListener = function(e26, t26) {
      return v9(this, e26, t26, true);
    }, o12.prototype.once = function(e26, t26) {
      return u11(t26), this.on(e26, l11(this, e26, t26)), this;
    }, o12.prototype.prependOnceListener = function(e26, t26) {
      return u11(t26), this.prependListener(e26, l11(this, e26, t26)), this;
    }, o12.prototype.removeListener = function(e26, t26) {
      var n26, r26, i26, o26, s26;
      if (u11(t26), void 0 === (r26 = this._events))
        return this;
      if (void 0 === (n26 = r26[e26]))
        return this;
      if (n26 === t26 || n26.listener === t26)
        0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r26[e26], r26.removeListener && this.emit("removeListener", e26, n26.listener || t26));
      else if ("function" != typeof n26) {
        for (i26 = -1, o26 = n26.length - 1; o26 >= 0; o26--)
          if (n26[o26] === t26 || n26[o26].listener === t26) {
            s26 = n26[o26].listener, i26 = o26;
            break;
          }
        if (i26 < 0)
          return this;
        0 === i26 ? n26.shift() : !function(e35, t35) {
          for (; t35 + 1 < e35.length; t35++)
            e35[t35] = e35[t35 + 1];
          e35.pop();
        }(n26, i26), 1 === n26.length && (r26[e26] = n26[0]), void 0 !== r26.removeListener && this.emit("removeListener", e26, s26 || t26);
      }
      return this;
    }, o12.prototype.off = o12.prototype.removeListener, o12.prototype.removeAllListeners = function(e26) {
      var t26, n26, r26;
      if (void 0 === (n26 = this._events))
        return this;
      if (void 0 === n26.removeListener)
        return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n26[e26] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n26[e26]), this;
      if (0 === arguments.length) {
        var i26, o26 = Object.keys(n26);
        for (r26 = 0; r26 < o26.length; ++r26)
          "removeListener" !== (i26 = o26[r26]) && this.removeAllListeners(i26);
        return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
      }
      if ("function" == typeof (t26 = n26[e26]))
        this.removeListener(e26, t26);
      else if (void 0 !== t26)
        for (r26 = t26.length - 1; r26 >= 0; r26--)
          this.removeListener(e26, t26[r26]);
      return this;
    }, o12.prototype.listeners = function(e26) {
      return h11(this, e26, true);
    }, o12.prototype.rawListeners = function(e26) {
      return h11(this, e26, false);
    }, o12.listenerCount = function(e26, t26) {
      return "function" == typeof e26.listenerCount ? e26.listenerCount(t26) : p11.call(e26, t26);
    }, o12.prototype.listenerCount = p11, o12.prototype.eventNames = function() {
      return this._eventsCount > 0 ? t11(this._events) : [];
    };
    y9 = e12;
    y9.EventEmitter;
    y9.defaultMaxListeners;
    y9.init;
    y9.listenerCount;
    y9.EventEmitter;
    y9.defaultMaxListeners;
    y9.init;
    y9.listenerCount;
    y9.once = function(emitter, event) {
      return new Promise((resolve4, reject) => {
        function eventListener(...args) {
          if (errorListener !== void 0) {
            emitter.removeListener("error", errorListener);
          }
          resolve4(args);
        }
        let errorListener;
        if (event !== "error") {
          errorListener = (err) => {
            emitter.removeListener(name, eventListener);
            reject(err);
          };
          emitter.once("error", errorListener);
        }
        emitter.once(event, eventListener);
      });
    };
    y9.on = function(emitter, event) {
      const unconsumedEventValues = [];
      const unconsumedPromises = [];
      let error = null;
      let finished3 = false;
      const iterator = {
        async next() {
          const value = unconsumedEventValues.shift();
          if (value) {
            return createIterResult(value, false);
          }
          if (error) {
            const p26 = Promise.reject(error);
            error = null;
            return p26;
          }
          if (finished3) {
            return createIterResult(void 0, true);
          }
          return new Promise((resolve4, reject) => unconsumedPromises.push({ resolve: resolve4, reject }));
        },
        async return() {
          emitter.removeListener(event, eventHandler);
          emitter.removeListener("error", errorHandler);
          finished3 = true;
          for (const promise of unconsumedPromises) {
            promise.resolve(createIterResult(void 0, true));
          }
          return createIterResult(void 0, true);
        },
        throw(err) {
          error = err;
          emitter.removeListener(event, eventHandler);
          emitter.removeListener("error", errorHandler);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
      emitter.on(event, eventHandler);
      emitter.on("error", errorHandler);
      return iterator;
      function eventHandler(...args) {
        const promise = unconsumedPromises.shift();
        if (promise) {
          promise.resolve(createIterResult(args, false));
        } else {
          unconsumedEventValues.push(args);
        }
      }
      function errorHandler(err) {
        finished3 = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
          toError.reject(err);
        } else {
          error = err;
        }
        iterator.return();
      }
    };
    ({
      EventEmitter: EventEmitter3,
      defaultMaxListeners: defaultMaxListeners3,
      init: init3,
      listenerCount: listenerCount3,
      on: on3,
      once: once3
    } = y9);
  }
});

// node-modules-polyfills-commonjs:events
var events_exports = {};
__export(events_exports, {
  EventEmitter: () => EventEmitter3,
  defaultMaxListeners: () => defaultMaxListeners3,
  init: () => init3,
  listenerCount: () => listenerCount3,
  on: () => on3,
  once: () => once3
});
var init_events2 = __esm({
  "node-modules-polyfills-commonjs:events"() {
    init_events();
  }
});

// node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js"(exports10, module2) {
    var process6 = globalThis.process;
    var processOk = function(process7) {
      return process7 && typeof process7 === "object" && typeof process7.removeListener === "function" && typeof process7.emit === "function" && typeof process7.reallyExit === "function" && typeof process7.listeners === "function" && typeof process7.kill === "function" && typeof process7.pid === "number" && typeof process7.on === "function";
    };
    if (!processOk(process6)) {
      module2.exports = function() {
        return function() {
        };
      };
    } else {
      assert = (init_assert2(), __toCommonJS(assert_exports));
      signals = require_signals();
      isWin = /^win/i.test(process6.platform);
      EE = (init_events2(), __toCommonJS(events_exports));
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process6.__signal_exit_emitter__) {
        emitter = process6.__signal_exit_emitter__;
      } else {
        emitter = process6.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts2) {
        if (!processOk(globalThis.process)) {
          return function() {
          };
        }
        assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load();
        }
        var ev = "exit";
        if (opts2 && opts2.alwaysLast) {
          ev = "afterexit";
        }
        var remove = function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove;
      };
      unload = function unload2() {
        if (!loaded || !processOk(globalThis.process)) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process6.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process6.emit = originalProcessEmit;
        process6.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      module2.exports.unload = unload;
      emit = function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
          if (!processOk(globalThis.process)) {
            return;
          }
          var listeners = process6.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process6.kill(process6.pid, sig);
          }
        };
      });
      module2.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load = function load2() {
        if (loaded || !processOk(globalThis.process)) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process6.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process6.emit = processEmit;
        process6.reallyExit = processReallyExit;
      };
      module2.exports.load = load;
      originalProcessReallyExit = process6.reallyExit;
      processReallyExit = function processReallyExit2(code) {
        if (!processOk(globalThis.process)) {
          return;
        }
        process6.exitCode = code || /* istanbul ignore next */
        0;
        emit("exit", process6.exitCode, null);
        emit("afterexit", process6.exitCode, null);
        originalProcessReallyExit.call(process6, process6.exitCode);
      };
      originalProcessEmit = process6.emit;
      processEmit = function processEmit2(ev, arg) {
        if (ev === "exit" && processOk(globalThis.process)) {
          if (arg !== void 0) {
            process6.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process6.exitCode, null);
          emit("afterexit", process6.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      };
    }
    var assert;
    var signals;
    var isWin;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  }
});

// node_modules/.pnpm/restore-cursor@3.1.0/node_modules/restore-cursor/index.js
var require_restore_cursor = __commonJS({
  "node_modules/.pnpm/restore-cursor@3.1.0/node_modules/restore-cursor/index.js"(exports10, module2) {
    "use strict";
    var onetime = require_onetime();
    var signalExit = require_signal_exit();
    module2.exports = onetime(() => {
      signalExit(() => {
        process.stderr.write("\x1B[?25h");
      }, { alwaysLast: true });
    });
  }
});

// node_modules/.pnpm/cli-cursor@3.1.0/node_modules/cli-cursor/index.js
var require_cli_cursor = __commonJS({
  "node_modules/.pnpm/cli-cursor@3.1.0/node_modules/cli-cursor/index.js"(exports10) {
    "use strict";
    var restoreCursor = require_restore_cursor();
    var isHidden = false;
    exports10.show = (writableStream = process.stderr) => {
      if (!writableStream.isTTY) {
        return;
      }
      isHidden = false;
      writableStream.write("\x1B[?25h");
    };
    exports10.hide = (writableStream = process.stderr) => {
      if (!writableStream.isTTY) {
        return;
      }
      restoreCursor();
      isHidden = true;
      writableStream.write("\x1B[?25l");
    };
    exports10.toggle = (force, writableStream) => {
      if (force !== void 0) {
        isHidden = force;
      }
      if (isHidden) {
        exports10.show(writableStream);
      } else {
        exports10.hide(writableStream);
      }
    };
  }
});

// node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js"(exports10, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js"(exports10, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  }
});

// node_modules/.pnpm/is-fullwidth-code-point@3.0.0/node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS({
  "node_modules/.pnpm/is-fullwidth-code-point@3.0.0/node_modules/is-fullwidth-code-point/index.js"(exports10, module2) {
    "use strict";
    var isFullwidthCodePoint = (codePoint) => {
      if (Number.isNaN(codePoint)) {
        return false;
      }
      if (codePoint >= 4352 && (codePoint <= 4447 || // Hangul Jamo
      codePoint === 9001 || // LEFT-POINTING ANGLE BRACKET
      codePoint === 9002 || // RIGHT-POINTING ANGLE BRACKET
      // CJK Radicals Supplement .. Enclosed CJK Letters and Months
      11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
      12880 <= codePoint && codePoint <= 19903 || // CJK Unified Ideographs .. Yi Radicals
      19968 <= codePoint && codePoint <= 42182 || // Hangul Jamo Extended-A
      43360 <= codePoint && codePoint <= 43388 || // Hangul Syllables
      44032 <= codePoint && codePoint <= 55203 || // CJK Compatibility Ideographs
      63744 <= codePoint && codePoint <= 64255 || // Vertical Forms
      65040 <= codePoint && codePoint <= 65049 || // CJK Compatibility Forms .. Small Form Variants
      65072 <= codePoint && codePoint <= 65131 || // Halfwidth and Fullwidth Forms
      65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || // Kana Supplement
      110592 <= codePoint && codePoint <= 110593 || // Enclosed Ideographic Supplement
      127488 <= codePoint && codePoint <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
      131072 <= codePoint && codePoint <= 262141)) {
        return true;
      }
      return false;
    };
    module2.exports = isFullwidthCodePoint;
    module2.exports.default = isFullwidthCodePoint;
  }
});

// node_modules/.pnpm/emoji-regex@8.0.0/node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  "node_modules/.pnpm/emoji-regex@8.0.0/node_modules/emoji-regex/index.js"(exports10, module2) {
    "use strict";
    module2.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  }
});

// node_modules/.pnpm/string-width@4.2.3/node_modules/string-width/index.js
var require_string_width = __commonJS({
  "node_modules/.pnpm/string-width@4.2.3/node_modules/string-width/index.js"(exports10, module2) {
    "use strict";
    var stripAnsi = require_strip_ansi();
    var isFullwidthCodePoint = require_is_fullwidth_code_point();
    var emojiRegex = require_emoji_regex();
    var stringWidth = (string) => {
      if (typeof string !== "string" || string.length === 0) {
        return 0;
      }
      string = stripAnsi(string);
      if (string.length === 0) {
        return 0;
      }
      string = string.replace(emojiRegex(), "  ");
      let width = 0;
      for (let i13 = 0; i13 < string.length; i13++) {
        const code = string.codePointAt(i13);
        if (code <= 31 || code >= 127 && code <= 159) {
          continue;
        }
        if (code >= 768 && code <= 879) {
          continue;
        }
        if (code > 65535) {
          i13++;
        }
        width += isFullwidthCodePoint(code) ? 2 : 1;
      }
      return width;
    };
    module2.exports = stringWidth;
    module2.exports.default = stringWidth;
  }
});

// node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports10, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js"(exports10, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r14 = rgb[0] / 255;
      const g9 = rgb[1] / 255;
      const b9 = rgb[2] / 255;
      const min = Math.min(r14, g9, b9);
      const max = Math.max(r14, g9, b9);
      const delta = max - min;
      let h13;
      let s12;
      if (max === min) {
        h13 = 0;
      } else if (r14 === max) {
        h13 = (g9 - b9) / delta;
      } else if (g9 === max) {
        h13 = 2 + (b9 - r14) / delta;
      } else if (b9 === max) {
        h13 = 4 + (r14 - g9) / delta;
      }
      h13 = Math.min(h13 * 60, 360);
      if (h13 < 0) {
        h13 += 360;
      }
      const l13 = (min + max) / 2;
      if (max === min) {
        s12 = 0;
      } else if (l13 <= 0.5) {
        s12 = delta / (max + min);
      } else {
        s12 = delta / (2 - max - min);
      }
      return [h13, s12 * 100, l13 * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h13;
      let s12;
      const r14 = rgb[0] / 255;
      const g9 = rgb[1] / 255;
      const b9 = rgb[2] / 255;
      const v11 = Math.max(r14, g9, b9);
      const diff = v11 - Math.min(r14, g9, b9);
      const diffc = function(c13) {
        return (v11 - c13) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h13 = 0;
        s12 = 0;
      } else {
        s12 = diff / v11;
        rdif = diffc(r14);
        gdif = diffc(g9);
        bdif = diffc(b9);
        if (r14 === v11) {
          h13 = bdif - gdif;
        } else if (g9 === v11) {
          h13 = 1 / 3 + rdif - bdif;
        } else if (b9 === v11) {
          h13 = 2 / 3 + gdif - rdif;
        }
        if (h13 < 0) {
          h13 += 1;
        } else if (h13 > 1) {
          h13 -= 1;
        }
      }
      return [
        h13 * 360,
        s12 * 100,
        v11 * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r14 = rgb[0];
      const g9 = rgb[1];
      let b9 = rgb[2];
      const h13 = convert.rgb.hsl(rgb)[0];
      const w8 = 1 / 255 * Math.min(r14, Math.min(g9, b9));
      b9 = 1 - 1 / 255 * Math.max(r14, Math.max(g9, b9));
      return [h13, w8 * 100, b9 * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r14 = rgb[0] / 255;
      const g9 = rgb[1] / 255;
      const b9 = rgb[2] / 255;
      const k8 = Math.min(1 - r14, 1 - g9, 1 - b9);
      const c13 = (1 - r14 - k8) / (1 - k8) || 0;
      const m10 = (1 - g9 - k8) / (1 - k8) || 0;
      const y11 = (1 - b9 - k8) / (1 - k8) || 0;
      return [c13 * 100, m10 * 100, y11 * 100, k8 * 100];
    };
    function comparativeDistance(x8, y11) {
      return (x8[0] - y11[0]) ** 2 + (x8[1] - y11[1]) ** 2 + (x8[2] - y11[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r14 = rgb[0] / 255;
      let g9 = rgb[1] / 255;
      let b9 = rgb[2] / 255;
      r14 = r14 > 0.04045 ? ((r14 + 0.055) / 1.055) ** 2.4 : r14 / 12.92;
      g9 = g9 > 0.04045 ? ((g9 + 0.055) / 1.055) ** 2.4 : g9 / 12.92;
      b9 = b9 > 0.04045 ? ((b9 + 0.055) / 1.055) ** 2.4 : b9 / 12.92;
      const x8 = r14 * 0.4124 + g9 * 0.3576 + b9 * 0.1805;
      const y11 = r14 * 0.2126 + g9 * 0.7152 + b9 * 0.0722;
      const z8 = r14 * 0.0193 + g9 * 0.1192 + b9 * 0.9505;
      return [x8 * 100, y11 * 100, z8 * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x8 = xyz[0];
      let y11 = xyz[1];
      let z8 = xyz[2];
      x8 /= 95.047;
      y11 /= 100;
      z8 /= 108.883;
      x8 = x8 > 8856e-6 ? x8 ** (1 / 3) : 7.787 * x8 + 16 / 116;
      y11 = y11 > 8856e-6 ? y11 ** (1 / 3) : 7.787 * y11 + 16 / 116;
      z8 = z8 > 8856e-6 ? z8 ** (1 / 3) : 7.787 * z8 + 16 / 116;
      const l13 = 116 * y11 - 16;
      const a13 = 500 * (x8 - y11);
      const b9 = 200 * (y11 - z8);
      return [l13, a13, b9];
    };
    convert.hsl.rgb = function(hsl) {
      const h13 = hsl[0] / 360;
      const s12 = hsl[1] / 100;
      const l13 = hsl[2] / 100;
      let t26;
      let t35;
      let val;
      if (s12 === 0) {
        val = l13 * 255;
        return [val, val, val];
      }
      if (l13 < 0.5) {
        t26 = l13 * (1 + s12);
      } else {
        t26 = l13 + s12 - l13 * s12;
      }
      const t1 = 2 * l13 - t26;
      const rgb = [0, 0, 0];
      for (let i13 = 0; i13 < 3; i13++) {
        t35 = h13 + 1 / 3 * -(i13 - 1);
        if (t35 < 0) {
          t35++;
        }
        if (t35 > 1) {
          t35--;
        }
        if (6 * t35 < 1) {
          val = t1 + (t26 - t1) * 6 * t35;
        } else if (2 * t35 < 1) {
          val = t26;
        } else if (3 * t35 < 2) {
          val = t1 + (t26 - t1) * (2 / 3 - t35) * 6;
        } else {
          val = t1;
        }
        rgb[i13] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h13 = hsl[0];
      let s12 = hsl[1] / 100;
      let l13 = hsl[2] / 100;
      let smin = s12;
      const lmin = Math.max(l13, 0.01);
      l13 *= 2;
      s12 *= l13 <= 1 ? l13 : 2 - l13;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v11 = (l13 + s12) / 2;
      const sv = l13 === 0 ? 2 * smin / (lmin + smin) : 2 * s12 / (l13 + s12);
      return [h13, sv * 100, v11 * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h13 = hsv[0] / 60;
      const s12 = hsv[1] / 100;
      let v11 = hsv[2] / 100;
      const hi = Math.floor(h13) % 6;
      const f13 = h13 - Math.floor(h13);
      const p13 = 255 * v11 * (1 - s12);
      const q7 = 255 * v11 * (1 - s12 * f13);
      const t13 = 255 * v11 * (1 - s12 * (1 - f13));
      v11 *= 255;
      switch (hi) {
        case 0:
          return [v11, t13, p13];
        case 1:
          return [q7, v11, p13];
        case 2:
          return [p13, v11, t13];
        case 3:
          return [p13, q7, v11];
        case 4:
          return [t13, p13, v11];
        case 5:
          return [v11, p13, q7];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h13 = hsv[0];
      const s12 = hsv[1] / 100;
      const v11 = hsv[2] / 100;
      const vmin = Math.max(v11, 0.01);
      let sl;
      let l13;
      l13 = (2 - s12) * v11;
      const lmin = (2 - s12) * vmin;
      sl = s12 * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l13 /= 2;
      return [h13, sl * 100, l13 * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h13 = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f13;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i13 = Math.floor(6 * h13);
      const v11 = 1 - bl;
      f13 = 6 * h13 - i13;
      if ((i13 & 1) !== 0) {
        f13 = 1 - f13;
      }
      const n14 = wh + f13 * (v11 - wh);
      let r14;
      let g9;
      let b9;
      switch (i13) {
        default:
        case 6:
        case 0:
          r14 = v11;
          g9 = n14;
          b9 = wh;
          break;
        case 1:
          r14 = n14;
          g9 = v11;
          b9 = wh;
          break;
        case 2:
          r14 = wh;
          g9 = v11;
          b9 = n14;
          break;
        case 3:
          r14 = wh;
          g9 = n14;
          b9 = v11;
          break;
        case 4:
          r14 = n14;
          g9 = wh;
          b9 = v11;
          break;
        case 5:
          r14 = v11;
          g9 = wh;
          b9 = n14;
          break;
      }
      return [r14 * 255, g9 * 255, b9 * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c13 = cmyk[0] / 100;
      const m10 = cmyk[1] / 100;
      const y11 = cmyk[2] / 100;
      const k8 = cmyk[3] / 100;
      const r14 = 1 - Math.min(1, c13 * (1 - k8) + k8);
      const g9 = 1 - Math.min(1, m10 * (1 - k8) + k8);
      const b9 = 1 - Math.min(1, y11 * (1 - k8) + k8);
      return [r14 * 255, g9 * 255, b9 * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x8 = xyz[0] / 100;
      const y11 = xyz[1] / 100;
      const z8 = xyz[2] / 100;
      let r14;
      let g9;
      let b9;
      r14 = x8 * 3.2406 + y11 * -1.5372 + z8 * -0.4986;
      g9 = x8 * -0.9689 + y11 * 1.8758 + z8 * 0.0415;
      b9 = x8 * 0.0557 + y11 * -0.204 + z8 * 1.057;
      r14 = r14 > 31308e-7 ? 1.055 * r14 ** (1 / 2.4) - 0.055 : r14 * 12.92;
      g9 = g9 > 31308e-7 ? 1.055 * g9 ** (1 / 2.4) - 0.055 : g9 * 12.92;
      b9 = b9 > 31308e-7 ? 1.055 * b9 ** (1 / 2.4) - 0.055 : b9 * 12.92;
      r14 = Math.min(Math.max(0, r14), 1);
      g9 = Math.min(Math.max(0, g9), 1);
      b9 = Math.min(Math.max(0, b9), 1);
      return [r14 * 255, g9 * 255, b9 * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x8 = xyz[0];
      let y11 = xyz[1];
      let z8 = xyz[2];
      x8 /= 95.047;
      y11 /= 100;
      z8 /= 108.883;
      x8 = x8 > 8856e-6 ? x8 ** (1 / 3) : 7.787 * x8 + 16 / 116;
      y11 = y11 > 8856e-6 ? y11 ** (1 / 3) : 7.787 * y11 + 16 / 116;
      z8 = z8 > 8856e-6 ? z8 ** (1 / 3) : 7.787 * z8 + 16 / 116;
      const l13 = 116 * y11 - 16;
      const a13 = 500 * (x8 - y11);
      const b9 = 200 * (y11 - z8);
      return [l13, a13, b9];
    };
    convert.lab.xyz = function(lab) {
      const l13 = lab[0];
      const a13 = lab[1];
      const b9 = lab[2];
      let x8;
      let y11;
      let z8;
      y11 = (l13 + 16) / 116;
      x8 = a13 / 500 + y11;
      z8 = y11 - b9 / 200;
      const y25 = y11 ** 3;
      const x25 = x8 ** 3;
      const z25 = z8 ** 3;
      y11 = y25 > 8856e-6 ? y25 : (y11 - 16 / 116) / 7.787;
      x8 = x25 > 8856e-6 ? x25 : (x8 - 16 / 116) / 7.787;
      z8 = z25 > 8856e-6 ? z25 : (z8 - 16 / 116) / 7.787;
      x8 *= 95.047;
      y11 *= 100;
      z8 *= 108.883;
      return [x8, y11, z8];
    };
    convert.lab.lch = function(lab) {
      const l13 = lab[0];
      const a13 = lab[1];
      const b9 = lab[2];
      let h13;
      const hr = Math.atan2(b9, a13);
      h13 = hr * 360 / 2 / Math.PI;
      if (h13 < 0) {
        h13 += 360;
      }
      const c13 = Math.sqrt(a13 * a13 + b9 * b9);
      return [l13, c13, h13];
    };
    convert.lch.lab = function(lch) {
      const l13 = lch[0];
      const c13 = lch[1];
      const h13 = lch[2];
      const hr = h13 / 360 * 2 * Math.PI;
      const a13 = c13 * Math.cos(hr);
      const b9 = c13 * Math.sin(hr);
      return [l13, a13, b9];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r14, g9, b9] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b9 / 255) << 2 | Math.round(g9 / 255) << 1 | Math.round(r14 / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r14 = args[0];
      const g9 = args[1];
      const b9 = args[2];
      if (r14 === g9 && g9 === b9) {
        if (r14 < 8) {
          return 16;
        }
        if (r14 > 248) {
          return 231;
        }
        return Math.round((r14 - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r14 / 255 * 5) + 6 * Math.round(g9 / 255 * 5) + Math.round(b9 / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r14 = (color & 1) * mult * 255;
      const g9 = (color >> 1 & 1) * mult * 255;
      const b9 = (color >> 2 & 1) * mult * 255;
      return [r14, g9, b9];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c13 = (args - 232) * 10 + 8;
        return [c13, c13, c13];
      }
      args -= 16;
      let rem;
      const r14 = Math.floor(args / 36) / 5 * 255;
      const g9 = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b9 = rem % 6 / 5 * 255;
      return [r14, g9, b9];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r14 = integer >> 16 & 255;
      const g9 = integer >> 8 & 255;
      const b9 = integer & 255;
      return [r14, g9, b9];
    };
    convert.rgb.hcg = function(rgb) {
      const r14 = rgb[0] / 255;
      const g9 = rgb[1] / 255;
      const b9 = rgb[2] / 255;
      const max = Math.max(Math.max(r14, g9), b9);
      const min = Math.min(Math.min(r14, g9), b9);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r14) {
        hue = (g9 - b9) / chroma % 6;
      } else if (max === g9) {
        hue = 2 + (b9 - r14) / chroma;
      } else {
        hue = 4 + (r14 - g9) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s12 = hsl[1] / 100;
      const l13 = hsl[2] / 100;
      const c13 = l13 < 0.5 ? 2 * s12 * l13 : 2 * s12 * (1 - l13);
      let f13 = 0;
      if (c13 < 1) {
        f13 = (l13 - 0.5 * c13) / (1 - c13);
      }
      return [hsl[0], c13 * 100, f13 * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s12 = hsv[1] / 100;
      const v11 = hsv[2] / 100;
      const c13 = s12 * v11;
      let f13 = 0;
      if (c13 < 1) {
        f13 = (v11 - c13) / (1 - c13);
      }
      return [hsv[0], c13 * 100, f13 * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h13 = hcg[0] / 360;
      const c13 = hcg[1] / 100;
      const g9 = hcg[2] / 100;
      if (c13 === 0) {
        return [g9 * 255, g9 * 255, g9 * 255];
      }
      const pure = [0, 0, 0];
      const hi = h13 % 1 * 6;
      const v11 = hi % 1;
      const w8 = 1 - v11;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v11;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w8;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v11;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w8;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v11;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w8;
      }
      mg = (1 - c13) * g9;
      return [
        (c13 * pure[0] + mg) * 255,
        (c13 * pure[1] + mg) * 255,
        (c13 * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c13 = hcg[1] / 100;
      const g9 = hcg[2] / 100;
      const v11 = c13 + g9 * (1 - c13);
      let f13 = 0;
      if (v11 > 0) {
        f13 = c13 / v11;
      }
      return [hcg[0], f13 * 100, v11 * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c13 = hcg[1] / 100;
      const g9 = hcg[2] / 100;
      const l13 = g9 * (1 - c13) + 0.5 * c13;
      let s12 = 0;
      if (l13 > 0 && l13 < 0.5) {
        s12 = c13 / (2 * l13);
      } else if (l13 >= 0.5 && l13 < 1) {
        s12 = c13 / (2 * (1 - l13));
      }
      return [hcg[0], s12 * 100, l13 * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c13 = hcg[1] / 100;
      const g9 = hcg[2] / 100;
      const v11 = c13 + g9 * (1 - c13);
      return [hcg[0], (v11 - c13) * 100, (1 - v11) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w8 = hwb[1] / 100;
      const b9 = hwb[2] / 100;
      const v11 = 1 - b9;
      const c13 = v11 - w8;
      let g9 = 0;
      if (c13 < 1) {
        g9 = (v11 - c13) / (1 - c13);
      }
      return [hwb[0], c13 * 100, g9 * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js"(exports10, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i13 = 0; i13 < len; i13++) {
        graph[models[i13]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i13 = 0; i13 < len; i13++) {
          const adjacent = adjacents[i13];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link2(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path3 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path3.unshift(graph[cur].parent);
        fn = link2(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path3;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i13 = 0; i13 < len; i13++) {
        const toModel = models[i13];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js"(exports10, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i13 = 0; i13 < len; i13++) {
            result[i13] = Math.round(result[i13]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js"(exports10, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n14) => n14;
    var rgb2rgb = (r14, g9, b9) => [r14, g9, b9];
    var setLazyProperty = (object, property, get2) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get2();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name2 = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name2] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name2] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/.pnpm/wrap-ansi@6.2.0/node_modules/wrap-ansi/index.js
var require_wrap_ansi = __commonJS({
  "node_modules/.pnpm/wrap-ansi@6.2.0/node_modules/wrap-ansi/index.js"(exports10, module2) {
    "use strict";
    var stringWidth = require_string_width();
    var stripAnsi = require_strip_ansi();
    var ansiStyles = require_ansi_styles();
    var ESCAPES = /* @__PURE__ */ new Set([
      "\x1B",
      "\x9B"
    ]);
    var END_CODE = 39;
    var wrapAnsi = (code) => `${ESCAPES.values().next().value}[${code}m`;
    var wordLengths = (string) => string.split(" ").map((character) => stringWidth(character));
    var wrapWord = (rows, word, columns) => {
      const characters = [...word];
      let isInsideEscape = false;
      let visible = stringWidth(stripAnsi(rows[rows.length - 1]));
      for (const [index, character] of characters.entries()) {
        const characterLength = stringWidth(character);
        if (visible + characterLength <= columns) {
          rows[rows.length - 1] += character;
        } else {
          rows.push(character);
          visible = 0;
        }
        if (ESCAPES.has(character)) {
          isInsideEscape = true;
        } else if (isInsideEscape && character === "m") {
          isInsideEscape = false;
          continue;
        }
        if (isInsideEscape) {
          continue;
        }
        visible += characterLength;
        if (visible === columns && index < characters.length - 1) {
          rows.push("");
          visible = 0;
        }
      }
      if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
        rows[rows.length - 2] += rows.pop();
      }
    };
    var stringVisibleTrimSpacesRight = (str) => {
      const words = str.split(" ");
      let last = words.length;
      while (last > 0) {
        if (stringWidth(words[last - 1]) > 0) {
          break;
        }
        last--;
      }
      if (last === words.length) {
        return str;
      }
      return words.slice(0, last).join(" ") + words.slice(last).join("");
    };
    var exec = (string, columns, options = {}) => {
      if (options.trim !== false && string.trim() === "") {
        return "";
      }
      let pre = "";
      let ret = "";
      let escapeCode;
      const lengths = wordLengths(string);
      let rows = [""];
      for (const [index, word] of string.split(" ").entries()) {
        if (options.trim !== false) {
          rows[rows.length - 1] = rows[rows.length - 1].trimLeft();
        }
        let rowLength = stringWidth(rows[rows.length - 1]);
        if (index !== 0) {
          if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
            rows.push("");
            rowLength = 0;
          }
          if (rowLength > 0 || options.trim === false) {
            rows[rows.length - 1] += " ";
            rowLength++;
          }
        }
        if (options.hard && lengths[index] > columns) {
          const remainingColumns = columns - rowLength;
          const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
          const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
          if (breaksStartingNextLine < breaksStartingThisLine) {
            rows.push("");
          }
          wrapWord(rows, word, columns);
          continue;
        }
        if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
          if (options.wordWrap === false && rowLength < columns) {
            wrapWord(rows, word, columns);
            continue;
          }
          rows.push("");
        }
        if (rowLength + lengths[index] > columns && options.wordWrap === false) {
          wrapWord(rows, word, columns);
          continue;
        }
        rows[rows.length - 1] += word;
      }
      if (options.trim !== false) {
        rows = rows.map(stringVisibleTrimSpacesRight);
      }
      pre = rows.join("\n");
      for (const [index, character] of [...pre].entries()) {
        ret += character;
        if (ESCAPES.has(character)) {
          const code2 = parseFloat(/\d[^m]*/.exec(pre.slice(index, index + 4)));
          escapeCode = code2 === END_CODE ? null : code2;
        }
        const code = ansiStyles.codes.get(Number(escapeCode));
        if (escapeCode && code) {
          if (pre[index + 1] === "\n") {
            ret += wrapAnsi(code);
          } else if (character === "\n") {
            ret += wrapAnsi(escapeCode);
          }
        }
      }
      return ret;
    };
    module2.exports = (string, columns, options) => {
      return String(string).normalize().replace(/\r\n/g, "\n").split("\n").map((line) => exec(line, columns, options)).join("\n");
    };
  }
});

// node_modules/.pnpm/astral-regex@2.0.0/node_modules/astral-regex/index.js
var require_astral_regex = __commonJS({
  "node_modules/.pnpm/astral-regex@2.0.0/node_modules/astral-regex/index.js"(exports10, module2) {
    "use strict";
    var regex = "[\uD800-\uDBFF][\uDC00-\uDFFF]";
    var astralRegex = (options) => options && options.exact ? new RegExp(`^${regex}$`) : new RegExp(regex, "g");
    module2.exports = astralRegex;
  }
});

// node_modules/.pnpm/slice-ansi@4.0.0/node_modules/slice-ansi/index.js
var require_slice_ansi = __commonJS({
  "node_modules/.pnpm/slice-ansi@4.0.0/node_modules/slice-ansi/index.js"(exports10, module2) {
    "use strict";
    var isFullwidthCodePoint = require_is_fullwidth_code_point();
    var astralRegex = require_astral_regex();
    var ansiStyles = require_ansi_styles();
    var ESCAPES = [
      "\x1B",
      "\x9B"
    ];
    var wrapAnsi = (code) => `${ESCAPES[0]}[${code}m`;
    var checkAnsi = (ansiCodes, isEscapes, endAnsiCode) => {
      let output = [];
      ansiCodes = [...ansiCodes];
      for (let ansiCode of ansiCodes) {
        const ansiCodeOrigin = ansiCode;
        if (ansiCode.includes(";")) {
          ansiCode = ansiCode.split(";")[0][0] + "0";
        }
        const item = ansiStyles.codes.get(Number.parseInt(ansiCode, 10));
        if (item) {
          const indexEscape = ansiCodes.indexOf(item.toString());
          if (indexEscape === -1) {
            output.push(wrapAnsi(isEscapes ? item : ansiCodeOrigin));
          } else {
            ansiCodes.splice(indexEscape, 1);
          }
        } else if (isEscapes) {
          output.push(wrapAnsi(0));
          break;
        } else {
          output.push(wrapAnsi(ansiCodeOrigin));
        }
      }
      if (isEscapes) {
        output = output.filter((element, index) => output.indexOf(element) === index);
        if (endAnsiCode !== void 0) {
          const fistEscapeCode = wrapAnsi(ansiStyles.codes.get(Number.parseInt(endAnsiCode, 10)));
          output = output.reduce((current, next) => next === fistEscapeCode ? [next, ...current] : [...current, next], []);
        }
      }
      return output.join("");
    };
    module2.exports = (string, begin, end) => {
      const characters = [...string];
      const ansiCodes = [];
      let stringEnd = typeof end === "number" ? end : characters.length;
      let isInsideEscape = false;
      let ansiCode;
      let visible = 0;
      let output = "";
      for (const [index, character] of characters.entries()) {
        let leftEscape = false;
        if (ESCAPES.includes(character)) {
          const code = /\d[^m]*/.exec(string.slice(index, index + 18));
          ansiCode = code && code.length > 0 ? code[0] : void 0;
          if (visible < stringEnd) {
            isInsideEscape = true;
            if (ansiCode !== void 0) {
              ansiCodes.push(ansiCode);
            }
          }
        } else if (isInsideEscape && character === "m") {
          isInsideEscape = false;
          leftEscape = true;
        }
        if (!isInsideEscape && !leftEscape) {
          visible++;
        }
        if (!astralRegex({ exact: true }).test(character) && isFullwidthCodePoint(character.codePointAt())) {
          visible++;
          if (typeof end !== "number") {
            stringEnd++;
          }
        }
        if (visible > begin && visible <= stringEnd) {
          output += character;
        } else if (visible === begin && !isInsideEscape && ansiCode !== void 0) {
          output = checkAnsi(ansiCodes);
        } else if (visible >= stringEnd) {
          output += checkAnsi(ansiCodes, true, ansiCode);
          break;
        }
      }
      return output;
    };
  }
});

// node_modules/.pnpm/log-update@4.0.0/node_modules/log-update/index.js
var require_log_update = __commonJS({
  "node_modules/.pnpm/log-update@4.0.0/node_modules/log-update/index.js"(exports10, module2) {
    "use strict";
    var ansiEscapes = require_ansi_escapes();
    var cliCursor = require_cli_cursor();
    var wrapAnsi = require_wrap_ansi();
    var sliceAnsi = require_slice_ansi();
    var defaultTerminalHeight = 24;
    var getWidth = (stream) => {
      const { columns } = stream;
      if (!columns) {
        return 80;
      }
      return columns;
    };
    var fitToTerminalHeight = (stream, text) => {
      const terminalHeight = stream.rows || defaultTerminalHeight;
      const lines = text.split("\n");
      const toRemove = lines.length - terminalHeight;
      if (toRemove <= 0) {
        return text;
      }
      return sliceAnsi(
        text,
        lines.slice(0, toRemove).join("\n").length + 1,
        text.length
      );
    };
    var main = (stream, { showCursor = false } = {}) => {
      let previousLineCount = 0;
      let previousWidth = getWidth(stream);
      let previousOutput = "";
      const render = (...args) => {
        if (!showCursor) {
          cliCursor.hide();
        }
        let output = args.join(" ") + "\n";
        output = fitToTerminalHeight(stream, output);
        const width = getWidth(stream);
        if (output === previousOutput && previousWidth === width) {
          return;
        }
        previousOutput = output;
        previousWidth = width;
        output = wrapAnsi(output, width, {
          trim: false,
          hard: true,
          wordWrap: false
        });
        stream.write(ansiEscapes.eraseLines(previousLineCount) + output);
        previousLineCount = output.split("\n").length;
      };
      render.clear = () => {
        stream.write(ansiEscapes.eraseLines(previousLineCount));
        previousOutput = "";
        previousWidth = getWidth(stream);
        previousLineCount = 0;
      };
      render.done = () => {
        previousOutput = "";
        previousWidth = getWidth(stream);
        previousLineCount = 0;
        if (!showCursor) {
          cliCursor.show();
        }
      };
      return render;
    };
    module2.exports = main(process.stdout);
    module2.exports.stderr = main(process.stderr);
    module2.exports.create = main;
  }
});

// node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/eta.js
var require_eta = __commonJS({
  "node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/eta.js"(exports10, module2) {
    var ETA = class {
      constructor(length, initTime, initValue) {
        this.etaBufferLength = length || 100;
        this.valueBuffer = [initValue];
        this.timeBuffer = [initTime];
        this.eta = "0";
      }
      // add new values to calculation buffer
      update(time, value, total) {
        this.valueBuffer.push(value);
        this.timeBuffer.push(time);
        this.calculate(total - value);
      }
      // fetch estimated time
      getTime() {
        return this.eta;
      }
      // eta calculation - request number of remaining events
      calculate(remaining) {
        const currentBufferSize = this.valueBuffer.length;
        const buffer4 = Math.min(this.etaBufferLength, currentBufferSize);
        const v_diff = this.valueBuffer[currentBufferSize - 1] - this.valueBuffer[currentBufferSize - buffer4];
        const t_diff = this.timeBuffer[currentBufferSize - 1] - this.timeBuffer[currentBufferSize - buffer4];
        const vt_rate = v_diff / t_diff;
        this.valueBuffer = this.valueBuffer.slice(-this.etaBufferLength);
        this.timeBuffer = this.timeBuffer.slice(-this.etaBufferLength);
        const eta = Math.ceil(remaining / vt_rate / 1e3);
        if (isNaN(eta)) {
          this.eta = "NULL";
        } else if (!isFinite(eta)) {
          this.eta = "INF";
        } else if (eta > 1e7) {
          this.eta = "INF";
        } else if (eta < 0) {
          this.eta = 0;
        } else {
          this.eta = eta;
        }
      }
    };
    module2.exports = ETA;
  }
});

// node-modules-polyfills:readline
function unimplemented4() {
  throw new Error("Node.js readline module is not supported by JSPM core outside of Node.js");
}
var init_readline = __esm({
  "node-modules-polyfills:readline"() {
  }
});

// node-modules-polyfills-commonjs:readline
var readline_exports = {};
__export(readline_exports, {
  Interface: () => unimplemented4,
  clearLine: () => unimplemented4,
  clearScreenDown: () => unimplemented4,
  createInterface: () => unimplemented4,
  cursorTo: () => unimplemented4,
  emitKeypressEvents: () => unimplemented4,
  moveCursor: () => unimplemented4
});
var init_readline2 = __esm({
  "node-modules-polyfills-commonjs:readline"() {
    init_readline();
  }
});

// node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/terminal.js
var require_terminal = __commonJS({
  "node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/terminal.js"(exports10, module2) {
    var _readline = (init_readline2(), __toCommonJS(readline_exports));
    var Terminal = class {
      constructor(outputStream) {
        this.stream = outputStream;
        this.linewrap = true;
        this.dy = 0;
      }
      // save cursor position + settings
      cursorSave() {
        if (!this.stream.isTTY) {
          return;
        }
        this.stream.write("\x1B7");
      }
      // restore last cursor position + settings
      cursorRestore() {
        if (!this.stream.isTTY) {
          return;
        }
        this.stream.write("\x1B8");
      }
      // show/hide cursor
      cursor(enabled) {
        if (!this.stream.isTTY) {
          return;
        }
        if (enabled) {
          this.stream.write("\x1B[?25h");
        } else {
          this.stream.write("\x1B[?25l");
        }
      }
      // change cursor positionn
      cursorTo(x8 = null, y11 = null) {
        if (!this.stream.isTTY) {
          return;
        }
        _readline.cursorTo(this.stream, x8, y11);
      }
      // change relative cursor position
      cursorRelative(dx = null, dy = null) {
        if (!this.stream.isTTY) {
          return;
        }
        this.dy = this.dy + dy;
        _readline.moveCursor(this.stream, dx, dy);
      }
      // relative reset
      cursorRelativeReset() {
        if (!this.stream.isTTY) {
          return;
        }
        _readline.moveCursor(this.stream, 0, -this.dy);
        _readline.cursorTo(this.stream, 0, null);
        this.dy = 0;
      }
      // clear to the right from cursor
      clearRight() {
        if (!this.stream.isTTY) {
          return;
        }
        _readline.clearLine(this.stream, 1);
      }
      // clear the full line
      clearLine() {
        if (!this.stream.isTTY) {
          return;
        }
        _readline.clearLine(this.stream, 0);
      }
      // clear everyting beyond the current line
      clearBottom() {
        if (!this.stream.isTTY) {
          return;
        }
        _readline.clearScreenDown(this.stream);
      }
      // add new line; increment counter
      newline() {
        this.stream.write("\n");
        this.dy++;
      }
      // write content to output stream
      // @TODO use string-width to strip length
      write(s12) {
        if (this.linewrap === true) {
          this.stream.write(s12.substr(0, this.getWidth()));
        } else {
          this.stream.write(s12);
        }
      }
      // control line wrapping
      lineWrapping(enabled) {
        if (!this.stream.isTTY) {
          return;
        }
        this.linewrap = enabled;
        if (enabled) {
          this.stream.write("\x1B[?7h");
        } else {
          this.stream.write("\x1B[?7l");
        }
      }
      // tty environment ?
      isTTY() {
        return this.stream.isTTY === true;
      }
      // get terminal width
      getWidth() {
        return this.stream.columns || (this.stream.isTTY ? 80 : 200);
      }
    };
    module2.exports = Terminal;
  }
});

// node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/format-value.js
var require_format_value = __commonJS({
  "node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/format-value.js"(exports10, module2) {
    module2.exports = function formatValue(v11, options, type2) {
      if (options.autopadding !== true) {
        return v11;
      }
      function autopadding(value, length) {
        return (options.autopaddingChar + value).slice(-length);
      }
      switch (type2) {
        case "percentage":
          return autopadding(v11, 3);
        default:
          return v11;
      }
    };
  }
});

// node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/format-bar.js
var require_format_bar = __commonJS({
  "node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/format-bar.js"(exports10, module2) {
    module2.exports = function formatBar(progress, options) {
      const completeSize = Math.round(progress * options.barsize);
      const incompleteSize = options.barsize - completeSize;
      return options.barCompleteString.substr(0, completeSize) + options.barGlue + options.barIncompleteString.substr(0, incompleteSize);
    };
  }
});

// node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/format-time.js
var require_format_time = __commonJS({
  "node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/format-time.js"(exports10, module2) {
    module2.exports = function formatTime(t13, options, roundToMultipleOf) {
      function round(input) {
        if (roundToMultipleOf) {
          return roundToMultipleOf * Math.round(input / roundToMultipleOf);
        } else {
          return input;
        }
      }
      function autopadding(v11) {
        return (options.autopaddingChar + v11).slice(-2);
      }
      if (t13 > 3600) {
        return autopadding(Math.floor(t13 / 3600)) + "h" + autopadding(round(t13 % 3600 / 60)) + "m";
      } else if (t13 > 60) {
        return autopadding(Math.floor(t13 / 60)) + "m" + autopadding(round(t13 % 60)) + "s";
      } else if (t13 > 10) {
        return autopadding(round(t13)) + "s";
      } else {
        return autopadding(t13) + "s";
      }
    };
  }
});

// node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/formatter.js
var require_formatter = __commonJS({
  "node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/formatter.js"(exports10, module2) {
    var _stringWidth = require_string_width();
    var _defaultFormatValue = require_format_value();
    var _defaultFormatBar = require_format_bar();
    var _defaultFormatTime = require_format_time();
    module2.exports = function defaultFormatter(options, params, payload) {
      let s12 = options.format;
      const formatTime = options.formatTime || _defaultFormatTime;
      const formatValue = options.formatValue || _defaultFormatValue;
      const formatBar = options.formatBar || _defaultFormatBar;
      const percentage = Math.floor(params.progress * 100) + "";
      const stopTime = params.stopTime || Date.now();
      const elapsedTime = Math.round((stopTime - params.startTime) / 1e3);
      const context = Object.assign({}, payload, {
        bar: formatBar(params.progress, options),
        percentage: formatValue(percentage, options, "percentage"),
        total: formatValue(params.total, options, "total"),
        value: formatValue(params.value, options, "value"),
        eta: formatValue(params.eta, options, "eta"),
        eta_formatted: formatTime(params.eta, options, 5),
        duration: formatValue(elapsedTime, options, "duration"),
        duration_formatted: formatTime(elapsedTime, options, 1)
      });
      s12 = s12.replace(/\{(\w+)\}/g, function(match, key) {
        if (typeof context[key] !== "undefined") {
          return context[key];
        }
        return match;
      });
      const fullMargin = Math.max(0, params.maxWidth - _stringWidth(s12) - 2);
      const halfMargin = Math.floor(fullMargin / 2);
      switch (options.align) {
        case "right":
          s12 = fullMargin > 0 ? " ".repeat(fullMargin) + s12 : s12;
          break;
        case "center":
          s12 = halfMargin > 0 ? " ".repeat(halfMargin) + s12 : s12;
          break;
        case "left":
        default:
          break;
      }
      return s12;
    };
  }
});

// node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/generic-bar.js
var require_generic_bar = __commonJS({
  "node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/generic-bar.js"(exports10, module2) {
    var _ETA = require_eta();
    var _Terminal = require_terminal();
    var _formatter = require_formatter();
    var _EventEmitter = (init_events2(), __toCommonJS(events_exports));
    module2.exports = class GenericBar extends _EventEmitter {
      constructor(options) {
        super();
        this.options = options;
        this.terminal = this.options.terminal ? this.options.terminal : new _Terminal(this.options.stream);
        this.value = 0;
        this.total = 100;
        this.lastDrawnString = null;
        this.startTime = null;
        this.stopTime = null;
        this.lastRedraw = Date.now();
        this.eta = new _ETA(this.options.etaBufferLength, 0, 0);
        this.payload = {};
        this.isActive = false;
        this.formatter = typeof this.options.format === "function" ? this.options.format : _formatter;
      }
      // internal render function
      render() {
        let progress = this.value / this.total;
        if (isNaN(progress)) {
          progress = this.options && this.options.emptyOnZero ? 0 : 1;
        }
        progress = Math.min(Math.max(progress, 0), 1);
        const params = {
          progress,
          eta: this.eta.getTime(),
          startTime: this.startTime,
          stopTime: this.stopTime,
          total: this.total,
          value: this.value,
          maxWidth: this.terminal.getWidth()
        };
        if (this.options.etaAsynchronousUpdate) {
          this.updateETA();
        }
        const s12 = this.formatter(this.options, params, this.payload);
        const forceRedraw = this.options.forceRedraw || this.options.noTTYOutput && !this.terminal.isTTY();
        if (forceRedraw || this.lastDrawnString != s12) {
          this.emit("redraw-pre");
          this.terminal.cursorTo(0, null);
          this.terminal.write(s12);
          this.terminal.clearRight();
          this.lastDrawnString = s12;
          this.lastRedraw = Date.now();
          this.emit("redraw-post");
        }
      }
      // start the progress bar
      start(total, startValue, payload) {
        this.value = startValue || 0;
        this.total = typeof total !== "undefined" && total >= 0 ? total : 100;
        this.payload = payload || {};
        this.startTime = Date.now();
        this.stopTime = null;
        this.lastDrawnString = "";
        this.eta = new _ETA(this.options.etaBufferLength, this.startTime, this.value);
        this.isActive = true;
        this.emit("start", total, startValue);
      }
      // stop the bar
      stop() {
        this.isActive = false;
        this.stopTime = Date.now();
        this.emit("stop", this.total, this.value);
      }
      // update the bar value
      // update(value, payload)
      // update(payload)
      update(arg0, arg1 = {}) {
        if (typeof arg0 === "number") {
          this.value = arg0;
          this.eta.update(Date.now(), arg0, this.total);
        }
        const payloadData = (typeof arg0 === "object" ? arg0 : arg1) || {};
        this.emit("update", this.total, this.value);
        for (const key in payloadData) {
          this.payload[key] = payloadData[key];
        }
        if (this.value >= this.getTotal() && this.options.stopOnComplete) {
          this.stop();
        }
      }
      // update the bar value
      // increment(delta, payload)
      // increment(payload)
      increment(arg0 = 1, arg1 = {}) {
        if (typeof arg0 === "object") {
          this.update(this.value + 1, arg0);
        } else {
          this.update(this.value + arg0, arg1);
        }
      }
      // get the total (limit) value
      getTotal() {
        return this.total;
      }
      // set the total (limit) value
      setTotal(total) {
        if (typeof total !== "undefined" && total >= 0) {
          this.total = total;
        }
      }
      // force eta calculation update (long running processes)
      updateETA() {
        this.eta.update(Date.now(), this.value, this.total);
      }
    };
  }
});

// node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/options.js
var require_options = __commonJS({
  "node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/options.js"(exports10, module2) {
    function mergeOption(v11, defaultValue) {
      if (typeof v11 === "undefined" || v11 === null) {
        return defaultValue;
      } else {
        return v11;
      }
    }
    module2.exports = {
      // set global options
      parse: function parse4(rawOptions, preset) {
        const options = {};
        const opt = Object.assign({}, preset, rawOptions);
        options.throttleTime = 1e3 / mergeOption(opt.fps, 10);
        options.stream = mergeOption(opt.stream, process.stderr);
        options.terminal = mergeOption(opt.terminal, null);
        options.clearOnComplete = mergeOption(opt.clearOnComplete, false);
        options.stopOnComplete = mergeOption(opt.stopOnComplete, false);
        options.barsize = mergeOption(opt.barsize, 40);
        options.align = mergeOption(opt.align, "left");
        options.hideCursor = mergeOption(opt.hideCursor, false);
        options.linewrap = mergeOption(opt.linewrap, false);
        options.barCompleteString = new Array(options.barsize + 1).join(opt.barCompleteChar || "=");
        options.barIncompleteString = new Array(options.barsize + 1).join(opt.barIncompleteChar || "-");
        options.barGlue = mergeOption(opt.barGlue, "");
        options.format = mergeOption(opt.format, "progress [{bar}] {percentage}% | ETA: {eta}s | {value}/{total}");
        options.formatTime = mergeOption(opt.formatTime, null);
        options.formatValue = mergeOption(opt.formatValue, null);
        options.formatBar = mergeOption(opt.formatBar, null);
        options.etaBufferLength = mergeOption(opt.etaBuffer, 10);
        options.etaAsynchronousUpdate = mergeOption(opt.etaAsynchronousUpdate, false);
        options.synchronousUpdate = mergeOption(opt.synchronousUpdate, true);
        options.noTTYOutput = mergeOption(opt.noTTYOutput, false);
        options.notTTYSchedule = mergeOption(opt.notTTYSchedule, 2e3);
        options.emptyOnZero = mergeOption(opt.emptyOnZero, false);
        options.forceRedraw = mergeOption(opt.forceRedraw, false);
        options.autopadding = mergeOption(opt.autopadding, false);
        options.autopaddingChar = options.autopadding ? mergeOption(opt.autopaddingChar, "   ") : "";
        return options;
      }
    };
  }
});

// node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/single-bar.js
var require_single_bar = __commonJS({
  "node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/single-bar.js"(exports10, module2) {
    var _GenericBar = require_generic_bar();
    var _options = require_options();
    module2.exports = class SingleBar extends _GenericBar {
      constructor(options, preset) {
        super(_options.parse(options, preset));
        this.timer = null;
        if (this.options.noTTYOutput && this.terminal.isTTY() === false) {
          this.options.synchronousUpdate = false;
        }
        this.schedulingRate = this.terminal.isTTY() ? this.options.throttleTime : this.options.notTTYSchedule;
      }
      // internal render function
      render() {
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = null;
        }
        super.render();
        if (this.options.noTTYOutput && this.terminal.isTTY() === false) {
          this.terminal.newline();
        }
        this.timer = setTimeout(this.render.bind(this), this.schedulingRate);
      }
      update(current, payload) {
        if (!this.timer) {
          return;
        }
        super.update(current, payload);
        if (this.options.synchronousUpdate && this.lastRedraw + this.options.throttleTime * 2 < Date.now()) {
          this.render();
        }
      }
      // start the progress bar
      start(total, startValue, payload) {
        if (this.options.noTTYOutput === false && this.terminal.isTTY() === false) {
          return;
        }
        this.terminal.cursorSave();
        if (this.options.hideCursor === true) {
          this.terminal.cursor(false);
        }
        if (this.options.linewrap === false) {
          this.terminal.lineWrapping(false);
        }
        super.start(total, startValue, payload);
        this.render();
      }
      // stop the bar
      stop() {
        if (!this.timer) {
          return;
        }
        this.render();
        super.stop();
        clearTimeout(this.timer);
        this.timer = null;
        if (this.options.hideCursor === true) {
          this.terminal.cursor(true);
        }
        if (this.options.linewrap === false) {
          this.terminal.lineWrapping(true);
        }
        this.terminal.cursorRestore();
        if (this.options.clearOnComplete) {
          this.terminal.cursorTo(0, null);
          this.terminal.clearLine();
        } else {
          this.terminal.newline();
        }
      }
    };
  }
});

// node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/multi-bar.js
var require_multi_bar = __commonJS({
  "node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/lib/multi-bar.js"(exports10, module2) {
    var _Terminal = require_terminal();
    var _BarElement = require_generic_bar();
    var _options = require_options();
    var _EventEmitter = (init_events2(), __toCommonJS(events_exports));
    module2.exports = class MultiBar extends _EventEmitter {
      constructor(options, preset) {
        super();
        this.bars = [];
        this.options = _options.parse(options, preset);
        this.options.synchronousUpdate = false;
        this.terminal = this.options.terminal ? this.options.terminal : new _Terminal(this.options.stream);
        this.timer = null;
        this.isActive = false;
        this.schedulingRate = this.terminal.isTTY() ? this.options.throttleTime : this.options.notTTYSchedule;
      }
      // add a new bar to the stack
      create(total, startValue, payload) {
        if (this.options.noTTYOutput === false && this.terminal.isTTY() === false) {
          return;
        }
        const bar = new _BarElement(this.options);
        this.bars.push(bar);
        if (!this.isActive) {
          if (this.options.hideCursor === true) {
            this.terminal.cursor(false);
          }
          if (this.options.linewrap === false) {
            this.terminal.lineWrapping(false);
          }
          this.timer = setTimeout(this.update.bind(this), this.schedulingRate);
        }
        this.isActive = true;
        bar.start(total, startValue, payload);
        this.emit("start");
        return bar;
      }
      // remove a bar from the stack
      remove(bar) {
        const index = this.bars.indexOf(bar);
        if (index < 0) {
          return false;
        }
        this.bars.splice(index, 1);
        this.update();
        this.terminal.newline();
        this.terminal.clearBottom();
        return true;
      }
      // internal update routine
      update() {
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = null;
        }
        this.emit("update-pre");
        this.terminal.cursorRelativeReset();
        this.emit("redraw-pre");
        for (let i13 = 0; i13 < this.bars.length; i13++) {
          if (i13 > 0) {
            this.terminal.newline();
          }
          this.bars[i13].render();
        }
        this.emit("redraw-post");
        if (this.options.noTTYOutput && this.terminal.isTTY() === false) {
          this.terminal.newline();
          this.terminal.newline();
        }
        this.timer = setTimeout(this.update.bind(this), this.schedulingRate);
        this.emit("update-post");
        if (this.options.stopOnComplete && !this.bars.find((bar) => bar.isActive)) {
          this.stop();
        }
      }
      stop() {
        clearTimeout(this.timer);
        this.timer = null;
        this.isActive = false;
        if (this.options.hideCursor === true) {
          this.terminal.cursor(true);
        }
        if (this.options.linewrap === false) {
          this.terminal.lineWrapping(true);
        }
        this.terminal.cursorRelativeReset();
        this.emit("stop-pre-clear");
        if (this.options.clearOnComplete) {
          this.terminal.clearBottom();
        } else {
          for (let i13 = 0; i13 < this.bars.length; i13++) {
            if (i13 > 0) {
              this.terminal.newline();
            }
            this.bars[i13].render();
            this.bars[i13].stop();
          }
          this.terminal.newline();
        }
        this.emit("stop");
      }
    };
  }
});

// node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/presets/legacy.js
var require_legacy = __commonJS({
  "node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/presets/legacy.js"(exports10, module2) {
    module2.exports = {
      format: "progress [{bar}] {percentage}% | ETA: {eta}s | {value}/{total}",
      barCompleteChar: "=",
      barIncompleteChar: "-"
    };
  }
});

// node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/presets/shades-classic.js
var require_shades_classic = __commonJS({
  "node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/presets/shades-classic.js"(exports10, module2) {
    module2.exports = {
      format: " {bar} {percentage}% | ETA: {eta}s | {value}/{total}",
      barCompleteChar: "\u2588",
      barIncompleteChar: "\u2591"
    };
  }
});

// node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/extendStringPrototype.js
var require_extendStringPrototype = __commonJS({
  "node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/extendStringPrototype.js"(exports10, module2) {
    var colors = require_colors2();
    module2["exports"] = function() {
      var addProperty = function(color, func) {
        String.prototype.__defineGetter__(color, func);
      };
      addProperty("strip", function() {
        return colors.strip(this);
      });
      addProperty("stripColors", function() {
        return colors.strip(this);
      });
      addProperty("trap", function() {
        return colors.trap(this);
      });
      addProperty("zalgo", function() {
        return colors.zalgo(this);
      });
      addProperty("zebra", function() {
        return colors.zebra(this);
      });
      addProperty("rainbow", function() {
        return colors.rainbow(this);
      });
      addProperty("random", function() {
        return colors.random(this);
      });
      addProperty("america", function() {
        return colors.america(this);
      });
      var x8 = Object.keys(colors.styles);
      x8.forEach(function(style) {
        addProperty(style, function() {
          return colors.stylize(this, style);
        });
      });
      function applyTheme(theme) {
        var stringPrototypeBlacklist = [
          "__defineGetter__",
          "__defineSetter__",
          "__lookupGetter__",
          "__lookupSetter__",
          "charAt",
          "constructor",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "toLocaleString",
          "toString",
          "valueOf",
          "charCodeAt",
          "indexOf",
          "lastIndexOf",
          "length",
          "localeCompare",
          "match",
          "repeat",
          "replace",
          "search",
          "slice",
          "split",
          "substring",
          "toLocaleLowerCase",
          "toLocaleUpperCase",
          "toLowerCase",
          "toUpperCase",
          "trim",
          "trimLeft",
          "trimRight"
        ];
        Object.keys(theme).forEach(function(prop) {
          if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
            console.log("warn: ".red + ("String.prototype" + prop).magenta + " is probably something you don't want to override.  Ignoring style name");
          } else {
            if (typeof theme[prop] === "string") {
              colors[prop] = colors[theme[prop]];
              addProperty(prop, function() {
                return colors[prop](this);
              });
            } else {
              var themePropApplicator = function(str) {
                var ret = str || this;
                for (var t13 = 0; t13 < theme[prop].length; t13++) {
                  ret = colors[theme[prop][t13]](ret);
                }
                return ret;
              };
              addProperty(prop, themePropApplicator);
              colors[prop] = function(str) {
                return themePropApplicator(str);
              };
            }
          }
        });
      }
      colors.setTheme = function(theme) {
        if (typeof theme === "string") {
          console.log("colors.setTheme now only accepts an object, not a string. If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
          return;
        } else {
          applyTheme(theme);
        }
      };
    };
  }
});

// node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/.pnpm/colors@1.4.0/node_modules/colors/lib/index.js"(exports10, module2) {
    var colors = require_colors2();
    module2["exports"] = colors;
    require_extendStringPrototype()();
  }
});

// node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/presets/shades-grey.js
var require_shades_grey = __commonJS({
  "node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/presets/shades-grey.js"(exports10, module2) {
    var _colors = require_lib2();
    module2.exports = {
      format: _colors.grey(" {bar}") + " {percentage}% | ETA: {eta}s | {value}/{total}",
      barCompleteChar: "\u2588",
      barIncompleteChar: "\u2591"
    };
  }
});

// node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/presets/rect.js
var require_rect = __commonJS({
  "node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/presets/rect.js"(exports10, module2) {
    module2.exports = {
      format: " {bar}\u25A0 {percentage}% | ETA: {eta}s | {value}/{total}",
      barCompleteChar: "\u25A0",
      barIncompleteChar: " "
    };
  }
});

// node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/presets/index.js
var require_presets = __commonJS({
  "node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/presets/index.js"(exports10, module2) {
    var _legacy = require_legacy();
    var _shades_classic = require_shades_classic();
    var _shades_grey = require_shades_grey();
    var _rect = require_rect();
    module2.exports = {
      legacy: _legacy,
      shades_classic: _shades_classic,
      shades_grey: _shades_grey,
      rect: _rect
    };
  }
});

// node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/cli-progress.js
var require_cli_progress = __commonJS({
  "node_modules/.pnpm/cli-progress@3.9.1/node_modules/cli-progress/cli-progress.js"(exports10, module2) {
    var _SingleBar = require_single_bar();
    var _MultiBar = require_multi_bar();
    var _Presets = require_presets();
    var _Formatter = require_formatter();
    var _defaultFormatValue = require_format_value();
    var _defaultFormatBar = require_format_bar();
    var _defaultFormatTime = require_format_time();
    module2.exports = {
      Bar: _SingleBar,
      SingleBar: _SingleBar,
      MultiBar: _MultiBar,
      Presets: _Presets,
      Format: {
        Formatter: _Formatter,
        BarFormat: _defaultFormatBar,
        ValueFormat: _defaultFormatValue,
        TimeFormat: _defaultFormatTime
      }
    };
  }
});

// node_modules/.pnpm/cli-spinners@2.6.1/node_modules/cli-spinners/spinners.json
var require_spinners = __commonJS({
  "node_modules/.pnpm/cli-spinners@2.6.1/node_modules/cli-spinners/spinners.json"(exports10, module2) {
    module2.exports = {
      dots: {
        interval: 80,
        frames: [
          "\u280B",
          "\u2819",
          "\u2839",
          "\u2838",
          "\u283C",
          "\u2834",
          "\u2826",
          "\u2827",
          "\u2807",
          "\u280F"
        ]
      },
      dots2: {
        interval: 80,
        frames: [
          "\u28FE",
          "\u28FD",
          "\u28FB",
          "\u28BF",
          "\u287F",
          "\u28DF",
          "\u28EF",
          "\u28F7"
        ]
      },
      dots3: {
        interval: 80,
        frames: [
          "\u280B",
          "\u2819",
          "\u281A",
          "\u281E",
          "\u2816",
          "\u2826",
          "\u2834",
          "\u2832",
          "\u2833",
          "\u2813"
        ]
      },
      dots4: {
        interval: 80,
        frames: [
          "\u2804",
          "\u2806",
          "\u2807",
          "\u280B",
          "\u2819",
          "\u2838",
          "\u2830",
          "\u2820",
          "\u2830",
          "\u2838",
          "\u2819",
          "\u280B",
          "\u2807",
          "\u2806"
        ]
      },
      dots5: {
        interval: 80,
        frames: [
          "\u280B",
          "\u2819",
          "\u281A",
          "\u2812",
          "\u2802",
          "\u2802",
          "\u2812",
          "\u2832",
          "\u2834",
          "\u2826",
          "\u2816",
          "\u2812",
          "\u2810",
          "\u2810",
          "\u2812",
          "\u2813",
          "\u280B"
        ]
      },
      dots6: {
        interval: 80,
        frames: [
          "\u2801",
          "\u2809",
          "\u2819",
          "\u281A",
          "\u2812",
          "\u2802",
          "\u2802",
          "\u2812",
          "\u2832",
          "\u2834",
          "\u2824",
          "\u2804",
          "\u2804",
          "\u2824",
          "\u2834",
          "\u2832",
          "\u2812",
          "\u2802",
          "\u2802",
          "\u2812",
          "\u281A",
          "\u2819",
          "\u2809",
          "\u2801"
        ]
      },
      dots7: {
        interval: 80,
        frames: [
          "\u2808",
          "\u2809",
          "\u280B",
          "\u2813",
          "\u2812",
          "\u2810",
          "\u2810",
          "\u2812",
          "\u2816",
          "\u2826",
          "\u2824",
          "\u2820",
          "\u2820",
          "\u2824",
          "\u2826",
          "\u2816",
          "\u2812",
          "\u2810",
          "\u2810",
          "\u2812",
          "\u2813",
          "\u280B",
          "\u2809",
          "\u2808"
        ]
      },
      dots8: {
        interval: 80,
        frames: [
          "\u2801",
          "\u2801",
          "\u2809",
          "\u2819",
          "\u281A",
          "\u2812",
          "\u2802",
          "\u2802",
          "\u2812",
          "\u2832",
          "\u2834",
          "\u2824",
          "\u2804",
          "\u2804",
          "\u2824",
          "\u2820",
          "\u2820",
          "\u2824",
          "\u2826",
          "\u2816",
          "\u2812",
          "\u2810",
          "\u2810",
          "\u2812",
          "\u2813",
          "\u280B",
          "\u2809",
          "\u2808",
          "\u2808"
        ]
      },
      dots9: {
        interval: 80,
        frames: [
          "\u28B9",
          "\u28BA",
          "\u28BC",
          "\u28F8",
          "\u28C7",
          "\u2867",
          "\u2857",
          "\u284F"
        ]
      },
      dots10: {
        interval: 80,
        frames: [
          "\u2884",
          "\u2882",
          "\u2881",
          "\u2841",
          "\u2848",
          "\u2850",
          "\u2860"
        ]
      },
      dots11: {
        interval: 100,
        frames: [
          "\u2801",
          "\u2802",
          "\u2804",
          "\u2840",
          "\u2880",
          "\u2820",
          "\u2810",
          "\u2808"
        ]
      },
      dots12: {
        interval: 80,
        frames: [
          "\u2880\u2800",
          "\u2840\u2800",
          "\u2804\u2800",
          "\u2882\u2800",
          "\u2842\u2800",
          "\u2805\u2800",
          "\u2883\u2800",
          "\u2843\u2800",
          "\u280D\u2800",
          "\u288B\u2800",
          "\u284B\u2800",
          "\u280D\u2801",
          "\u288B\u2801",
          "\u284B\u2801",
          "\u280D\u2809",
          "\u280B\u2809",
          "\u280B\u2809",
          "\u2809\u2819",
          "\u2809\u2819",
          "\u2809\u2829",
          "\u2808\u2899",
          "\u2808\u2859",
          "\u2888\u2829",
          "\u2840\u2899",
          "\u2804\u2859",
          "\u2882\u2829",
          "\u2842\u2898",
          "\u2805\u2858",
          "\u2883\u2828",
          "\u2843\u2890",
          "\u280D\u2850",
          "\u288B\u2820",
          "\u284B\u2880",
          "\u280D\u2841",
          "\u288B\u2801",
          "\u284B\u2801",
          "\u280D\u2809",
          "\u280B\u2809",
          "\u280B\u2809",
          "\u2809\u2819",
          "\u2809\u2819",
          "\u2809\u2829",
          "\u2808\u2899",
          "\u2808\u2859",
          "\u2808\u2829",
          "\u2800\u2899",
          "\u2800\u2859",
          "\u2800\u2829",
          "\u2800\u2898",
          "\u2800\u2858",
          "\u2800\u2828",
          "\u2800\u2890",
          "\u2800\u2850",
          "\u2800\u2820",
          "\u2800\u2880",
          "\u2800\u2840"
        ]
      },
      dots8Bit: {
        interval: 80,
        frames: [
          "\u2800",
          "\u2801",
          "\u2802",
          "\u2803",
          "\u2804",
          "\u2805",
          "\u2806",
          "\u2807",
          "\u2840",
          "\u2841",
          "\u2842",
          "\u2843",
          "\u2844",
          "\u2845",
          "\u2846",
          "\u2847",
          "\u2808",
          "\u2809",
          "\u280A",
          "\u280B",
          "\u280C",
          "\u280D",
          "\u280E",
          "\u280F",
          "\u2848",
          "\u2849",
          "\u284A",
          "\u284B",
          "\u284C",
          "\u284D",
          "\u284E",
          "\u284F",
          "\u2810",
          "\u2811",
          "\u2812",
          "\u2813",
          "\u2814",
          "\u2815",
          "\u2816",
          "\u2817",
          "\u2850",
          "\u2851",
          "\u2852",
          "\u2853",
          "\u2854",
          "\u2855",
          "\u2856",
          "\u2857",
          "\u2818",
          "\u2819",
          "\u281A",
          "\u281B",
          "\u281C",
          "\u281D",
          "\u281E",
          "\u281F",
          "\u2858",
          "\u2859",
          "\u285A",
          "\u285B",
          "\u285C",
          "\u285D",
          "\u285E",
          "\u285F",
          "\u2820",
          "\u2821",
          "\u2822",
          "\u2823",
          "\u2824",
          "\u2825",
          "\u2826",
          "\u2827",
          "\u2860",
          "\u2861",
          "\u2862",
          "\u2863",
          "\u2864",
          "\u2865",
          "\u2866",
          "\u2867",
          "\u2828",
          "\u2829",
          "\u282A",
          "\u282B",
          "\u282C",
          "\u282D",
          "\u282E",
          "\u282F",
          "\u2868",
          "\u2869",
          "\u286A",
          "\u286B",
          "\u286C",
          "\u286D",
          "\u286E",
          "\u286F",
          "\u2830",
          "\u2831",
          "\u2832",
          "\u2833",
          "\u2834",
          "\u2835",
          "\u2836",
          "\u2837",
          "\u2870",
          "\u2871",
          "\u2872",
          "\u2873",
          "\u2874",
          "\u2875",
          "\u2876",
          "\u2877",
          "\u2838",
          "\u2839",
          "\u283A",
          "\u283B",
          "\u283C",
          "\u283D",
          "\u283E",
          "\u283F",
          "\u2878",
          "\u2879",
          "\u287A",
          "\u287B",
          "\u287C",
          "\u287D",
          "\u287E",
          "\u287F",
          "\u2880",
          "\u2881",
          "\u2882",
          "\u2883",
          "\u2884",
          "\u2885",
          "\u2886",
          "\u2887",
          "\u28C0",
          "\u28C1",
          "\u28C2",
          "\u28C3",
          "\u28C4",
          "\u28C5",
          "\u28C6",
          "\u28C7",
          "\u2888",
          "\u2889",
          "\u288A",
          "\u288B",
          "\u288C",
          "\u288D",
          "\u288E",
          "\u288F",
          "\u28C8",
          "\u28C9",
          "\u28CA",
          "\u28CB",
          "\u28CC",
          "\u28CD",
          "\u28CE",
          "\u28CF",
          "\u2890",
          "\u2891",
          "\u2892",
          "\u2893",
          "\u2894",
          "\u2895",
          "\u2896",
          "\u2897",
          "\u28D0",
          "\u28D1",
          "\u28D2",
          "\u28D3",
          "\u28D4",
          "\u28D5",
          "\u28D6",
          "\u28D7",
          "\u2898",
          "\u2899",
          "\u289A",
          "\u289B",
          "\u289C",
          "\u289D",
          "\u289E",
          "\u289F",
          "\u28D8",
          "\u28D9",
          "\u28DA",
          "\u28DB",
          "\u28DC",
          "\u28DD",
          "\u28DE",
          "\u28DF",
          "\u28A0",
          "\u28A1",
          "\u28A2",
          "\u28A3",
          "\u28A4",
          "\u28A5",
          "\u28A6",
          "\u28A7",
          "\u28E0",
          "\u28E1",
          "\u28E2",
          "\u28E3",
          "\u28E4",
          "\u28E5",
          "\u28E6",
          "\u28E7",
          "\u28A8",
          "\u28A9",
          "\u28AA",
          "\u28AB",
          "\u28AC",
          "\u28AD",
          "\u28AE",
          "\u28AF",
          "\u28E8",
          "\u28E9",
          "\u28EA",
          "\u28EB",
          "\u28EC",
          "\u28ED",
          "\u28EE",
          "\u28EF",
          "\u28B0",
          "\u28B1",
          "\u28B2",
          "\u28B3",
          "\u28B4",
          "\u28B5",
          "\u28B6",
          "\u28B7",
          "\u28F0",
          "\u28F1",
          "\u28F2",
          "\u28F3",
          "\u28F4",
          "\u28F5",
          "\u28F6",
          "\u28F7",
          "\u28B8",
          "\u28B9",
          "\u28BA",
          "\u28BB",
          "\u28BC",
          "\u28BD",
          "\u28BE",
          "\u28BF",
          "\u28F8",
          "\u28F9",
          "\u28FA",
          "\u28FB",
          "\u28FC",
          "\u28FD",
          "\u28FE",
          "\u28FF"
        ]
      },
      line: {
        interval: 130,
        frames: [
          "-",
          "\\",
          "|",
          "/"
        ]
      },
      line2: {
        interval: 100,
        frames: [
          "\u2802",
          "-",
          "\u2013",
          "\u2014",
          "\u2013",
          "-"
        ]
      },
      pipe: {
        interval: 100,
        frames: [
          "\u2524",
          "\u2518",
          "\u2534",
          "\u2514",
          "\u251C",
          "\u250C",
          "\u252C",
          "\u2510"
        ]
      },
      simpleDots: {
        interval: 400,
        frames: [
          ".  ",
          ".. ",
          "...",
          "   "
        ]
      },
      simpleDotsScrolling: {
        interval: 200,
        frames: [
          ".  ",
          ".. ",
          "...",
          " ..",
          "  .",
          "   "
        ]
      },
      star: {
        interval: 70,
        frames: [
          "\u2736",
          "\u2738",
          "\u2739",
          "\u273A",
          "\u2739",
          "\u2737"
        ]
      },
      star2: {
        interval: 80,
        frames: [
          "+",
          "x",
          "*"
        ]
      },
      flip: {
        interval: 70,
        frames: [
          "_",
          "_",
          "_",
          "-",
          "`",
          "`",
          "'",
          "\xB4",
          "-",
          "_",
          "_",
          "_"
        ]
      },
      hamburger: {
        interval: 100,
        frames: [
          "\u2631",
          "\u2632",
          "\u2634"
        ]
      },
      growVertical: {
        interval: 120,
        frames: [
          "\u2581",
          "\u2583",
          "\u2584",
          "\u2585",
          "\u2586",
          "\u2587",
          "\u2586",
          "\u2585",
          "\u2584",
          "\u2583"
        ]
      },
      growHorizontal: {
        interval: 120,
        frames: [
          "\u258F",
          "\u258E",
          "\u258D",
          "\u258C",
          "\u258B",
          "\u258A",
          "\u2589",
          "\u258A",
          "\u258B",
          "\u258C",
          "\u258D",
          "\u258E"
        ]
      },
      balloon: {
        interval: 140,
        frames: [
          " ",
          ".",
          "o",
          "O",
          "@",
          "*",
          " "
        ]
      },
      balloon2: {
        interval: 120,
        frames: [
          ".",
          "o",
          "O",
          "\xB0",
          "O",
          "o",
          "."
        ]
      },
      noise: {
        interval: 100,
        frames: [
          "\u2593",
          "\u2592",
          "\u2591"
        ]
      },
      bounce: {
        interval: 120,
        frames: [
          "\u2801",
          "\u2802",
          "\u2804",
          "\u2802"
        ]
      },
      boxBounce: {
        interval: 120,
        frames: [
          "\u2596",
          "\u2598",
          "\u259D",
          "\u2597"
        ]
      },
      boxBounce2: {
        interval: 100,
        frames: [
          "\u258C",
          "\u2580",
          "\u2590",
          "\u2584"
        ]
      },
      triangle: {
        interval: 50,
        frames: [
          "\u25E2",
          "\u25E3",
          "\u25E4",
          "\u25E5"
        ]
      },
      arc: {
        interval: 100,
        frames: [
          "\u25DC",
          "\u25E0",
          "\u25DD",
          "\u25DE",
          "\u25E1",
          "\u25DF"
        ]
      },
      circle: {
        interval: 120,
        frames: [
          "\u25E1",
          "\u2299",
          "\u25E0"
        ]
      },
      squareCorners: {
        interval: 180,
        frames: [
          "\u25F0",
          "\u25F3",
          "\u25F2",
          "\u25F1"
        ]
      },
      circleQuarters: {
        interval: 120,
        frames: [
          "\u25F4",
          "\u25F7",
          "\u25F6",
          "\u25F5"
        ]
      },
      circleHalves: {
        interval: 50,
        frames: [
          "\u25D0",
          "\u25D3",
          "\u25D1",
          "\u25D2"
        ]
      },
      squish: {
        interval: 100,
        frames: [
          "\u256B",
          "\u256A"
        ]
      },
      toggle: {
        interval: 250,
        frames: [
          "\u22B6",
          "\u22B7"
        ]
      },
      toggle2: {
        interval: 80,
        frames: [
          "\u25AB",
          "\u25AA"
        ]
      },
      toggle3: {
        interval: 120,
        frames: [
          "\u25A1",
          "\u25A0"
        ]
      },
      toggle4: {
        interval: 100,
        frames: [
          "\u25A0",
          "\u25A1",
          "\u25AA",
          "\u25AB"
        ]
      },
      toggle5: {
        interval: 100,
        frames: [
          "\u25AE",
          "\u25AF"
        ]
      },
      toggle6: {
        interval: 300,
        frames: [
          "\u101D",
          "\u1040"
        ]
      },
      toggle7: {
        interval: 80,
        frames: [
          "\u29BE",
          "\u29BF"
        ]
      },
      toggle8: {
        interval: 100,
        frames: [
          "\u25CD",
          "\u25CC"
        ]
      },
      toggle9: {
        interval: 100,
        frames: [
          "\u25C9",
          "\u25CE"
        ]
      },
      toggle10: {
        interval: 100,
        frames: [
          "\u3282",
          "\u3280",
          "\u3281"
        ]
      },
      toggle11: {
        interval: 50,
        frames: [
          "\u29C7",
          "\u29C6"
        ]
      },
      toggle12: {
        interval: 120,
        frames: [
          "\u2617",
          "\u2616"
        ]
      },
      toggle13: {
        interval: 80,
        frames: [
          "=",
          "*",
          "-"
        ]
      },
      arrow: {
        interval: 100,
        frames: [
          "\u2190",
          "\u2196",
          "\u2191",
          "\u2197",
          "\u2192",
          "\u2198",
          "\u2193",
          "\u2199"
        ]
      },
      arrow2: {
        interval: 80,
        frames: [
          "\u2B06\uFE0F ",
          "\u2197\uFE0F ",
          "\u27A1\uFE0F ",
          "\u2198\uFE0F ",
          "\u2B07\uFE0F ",
          "\u2199\uFE0F ",
          "\u2B05\uFE0F ",
          "\u2196\uFE0F "
        ]
      },
      arrow3: {
        interval: 120,
        frames: [
          "\u25B9\u25B9\u25B9\u25B9\u25B9",
          "\u25B8\u25B9\u25B9\u25B9\u25B9",
          "\u25B9\u25B8\u25B9\u25B9\u25B9",
          "\u25B9\u25B9\u25B8\u25B9\u25B9",
          "\u25B9\u25B9\u25B9\u25B8\u25B9",
          "\u25B9\u25B9\u25B9\u25B9\u25B8"
        ]
      },
      bouncingBar: {
        interval: 80,
        frames: [
          "[    ]",
          "[=   ]",
          "[==  ]",
          "[=== ]",
          "[ ===]",
          "[  ==]",
          "[   =]",
          "[    ]",
          "[   =]",
          "[  ==]",
          "[ ===]",
          "[====]",
          "[=== ]",
          "[==  ]",
          "[=   ]"
        ]
      },
      bouncingBall: {
        interval: 80,
        frames: [
          "( \u25CF    )",
          "(  \u25CF   )",
          "(   \u25CF  )",
          "(    \u25CF )",
          "(     \u25CF)",
          "(    \u25CF )",
          "(   \u25CF  )",
          "(  \u25CF   )",
          "( \u25CF    )",
          "(\u25CF     )"
        ]
      },
      smiley: {
        interval: 200,
        frames: [
          "\u{1F604} ",
          "\u{1F61D} "
        ]
      },
      monkey: {
        interval: 300,
        frames: [
          "\u{1F648} ",
          "\u{1F648} ",
          "\u{1F649} ",
          "\u{1F64A} "
        ]
      },
      hearts: {
        interval: 100,
        frames: [
          "\u{1F49B} ",
          "\u{1F499} ",
          "\u{1F49C} ",
          "\u{1F49A} ",
          "\u2764\uFE0F "
        ]
      },
      clock: {
        interval: 100,
        frames: [
          "\u{1F55B} ",
          "\u{1F550} ",
          "\u{1F551} ",
          "\u{1F552} ",
          "\u{1F553} ",
          "\u{1F554} ",
          "\u{1F555} ",
          "\u{1F556} ",
          "\u{1F557} ",
          "\u{1F558} ",
          "\u{1F559} ",
          "\u{1F55A} "
        ]
      },
      earth: {
        interval: 180,
        frames: [
          "\u{1F30D} ",
          "\u{1F30E} ",
          "\u{1F30F} "
        ]
      },
      material: {
        interval: 17,
        frames: [
          "\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588",
          "\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
          "\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
          "\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
          "\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
          "\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
          "\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581"
        ]
      },
      moon: {
        interval: 80,
        frames: [
          "\u{1F311} ",
          "\u{1F312} ",
          "\u{1F313} ",
          "\u{1F314} ",
          "\u{1F315} ",
          "\u{1F316} ",
          "\u{1F317} ",
          "\u{1F318} "
        ]
      },
      runner: {
        interval: 140,
        frames: [
          "\u{1F6B6} ",
          "\u{1F3C3} "
        ]
      },
      pong: {
        interval: 80,
        frames: [
          "\u2590\u2802       \u258C",
          "\u2590\u2808       \u258C",
          "\u2590 \u2802      \u258C",
          "\u2590 \u2820      \u258C",
          "\u2590  \u2840     \u258C",
          "\u2590  \u2820     \u258C",
          "\u2590   \u2802    \u258C",
          "\u2590   \u2808    \u258C",
          "\u2590    \u2802   \u258C",
          "\u2590    \u2820   \u258C",
          "\u2590     \u2840  \u258C",
          "\u2590     \u2820  \u258C",
          "\u2590      \u2802 \u258C",
          "\u2590      \u2808 \u258C",
          "\u2590       \u2802\u258C",
          "\u2590       \u2820\u258C",
          "\u2590       \u2840\u258C",
          "\u2590      \u2820 \u258C",
          "\u2590      \u2802 \u258C",
          "\u2590     \u2808  \u258C",
          "\u2590     \u2802  \u258C",
          "\u2590    \u2820   \u258C",
          "\u2590    \u2840   \u258C",
          "\u2590   \u2820    \u258C",
          "\u2590   \u2802    \u258C",
          "\u2590  \u2808     \u258C",
          "\u2590  \u2802     \u258C",
          "\u2590 \u2820      \u258C",
          "\u2590 \u2840      \u258C",
          "\u2590\u2820       \u258C"
        ]
      },
      shark: {
        interval: 120,
        frames: [
          "\u2590|\\____________\u258C",
          "\u2590_|\\___________\u258C",
          "\u2590__|\\__________\u258C",
          "\u2590___|\\_________\u258C",
          "\u2590____|\\________\u258C",
          "\u2590_____|\\_______\u258C",
          "\u2590______|\\______\u258C",
          "\u2590_______|\\_____\u258C",
          "\u2590________|\\____\u258C",
          "\u2590_________|\\___\u258C",
          "\u2590__________|\\__\u258C",
          "\u2590___________|\\_\u258C",
          "\u2590____________|\\\u258C",
          "\u2590____________/|\u258C",
          "\u2590___________/|_\u258C",
          "\u2590__________/|__\u258C",
          "\u2590_________/|___\u258C",
          "\u2590________/|____\u258C",
          "\u2590_______/|_____\u258C",
          "\u2590______/|______\u258C",
          "\u2590_____/|_______\u258C",
          "\u2590____/|________\u258C",
          "\u2590___/|_________\u258C",
          "\u2590__/|__________\u258C",
          "\u2590_/|___________\u258C",
          "\u2590/|____________\u258C"
        ]
      },
      dqpb: {
        interval: 100,
        frames: [
          "d",
          "q",
          "p",
          "b"
        ]
      },
      weather: {
        interval: 100,
        frames: [
          "\u2600\uFE0F ",
          "\u2600\uFE0F ",
          "\u2600\uFE0F ",
          "\u{1F324} ",
          "\u26C5\uFE0F ",
          "\u{1F325} ",
          "\u2601\uFE0F ",
          "\u{1F327} ",
          "\u{1F328} ",
          "\u{1F327} ",
          "\u{1F328} ",
          "\u{1F327} ",
          "\u{1F328} ",
          "\u26C8 ",
          "\u{1F328} ",
          "\u{1F327} ",
          "\u{1F328} ",
          "\u2601\uFE0F ",
          "\u{1F325} ",
          "\u26C5\uFE0F ",
          "\u{1F324} ",
          "\u2600\uFE0F ",
          "\u2600\uFE0F "
        ]
      },
      christmas: {
        interval: 400,
        frames: [
          "\u{1F332}",
          "\u{1F384}"
        ]
      },
      grenade: {
        interval: 80,
        frames: [
          "\u060C  ",
          "\u2032  ",
          " \xB4 ",
          " \u203E ",
          "  \u2E0C",
          "  \u2E0A",
          "  |",
          "  \u204E",
          "  \u2055",
          " \u0DF4 ",
          "  \u2053",
          "   ",
          "   ",
          "   "
        ]
      },
      point: {
        interval: 125,
        frames: [
          "\u2219\u2219\u2219",
          "\u25CF\u2219\u2219",
          "\u2219\u25CF\u2219",
          "\u2219\u2219\u25CF",
          "\u2219\u2219\u2219"
        ]
      },
      layer: {
        interval: 150,
        frames: [
          "-",
          "=",
          "\u2261"
        ]
      },
      betaWave: {
        interval: 80,
        frames: [
          "\u03C1\u03B2\u03B2\u03B2\u03B2\u03B2\u03B2",
          "\u03B2\u03C1\u03B2\u03B2\u03B2\u03B2\u03B2",
          "\u03B2\u03B2\u03C1\u03B2\u03B2\u03B2\u03B2",
          "\u03B2\u03B2\u03B2\u03C1\u03B2\u03B2\u03B2",
          "\u03B2\u03B2\u03B2\u03B2\u03C1\u03B2\u03B2",
          "\u03B2\u03B2\u03B2\u03B2\u03B2\u03C1\u03B2",
          "\u03B2\u03B2\u03B2\u03B2\u03B2\u03B2\u03C1"
        ]
      },
      fingerDance: {
        interval: 160,
        frames: [
          "\u{1F918} ",
          "\u{1F91F} ",
          "\u{1F596} ",
          "\u270B ",
          "\u{1F91A} ",
          "\u{1F446} "
        ]
      },
      fistBump: {
        interval: 80,
        frames: [
          "\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ",
          "\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ",
          "\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ",
          "\u3000\u{1F91C}\u3000\u3000\u{1F91B}\u3000 ",
          "\u3000\u3000\u{1F91C}\u{1F91B}\u3000\u3000 ",
          "\u3000\u{1F91C}\u2728\u{1F91B}\u3000\u3000 ",
          "\u{1F91C}\u3000\u2728\u3000\u{1F91B}\u3000 "
        ]
      },
      soccerHeader: {
        interval: 80,
        frames: [
          " \u{1F9D1}\u26BD\uFE0F       \u{1F9D1} ",
          "\u{1F9D1}  \u26BD\uFE0F      \u{1F9D1} ",
          "\u{1F9D1}   \u26BD\uFE0F     \u{1F9D1} ",
          "\u{1F9D1}    \u26BD\uFE0F    \u{1F9D1} ",
          "\u{1F9D1}     \u26BD\uFE0F   \u{1F9D1} ",
          "\u{1F9D1}      \u26BD\uFE0F  \u{1F9D1} ",
          "\u{1F9D1}       \u26BD\uFE0F\u{1F9D1}  ",
          "\u{1F9D1}      \u26BD\uFE0F  \u{1F9D1} ",
          "\u{1F9D1}     \u26BD\uFE0F   \u{1F9D1} ",
          "\u{1F9D1}    \u26BD\uFE0F    \u{1F9D1} ",
          "\u{1F9D1}   \u26BD\uFE0F     \u{1F9D1} ",
          "\u{1F9D1}  \u26BD\uFE0F      \u{1F9D1} "
        ]
      },
      mindblown: {
        interval: 160,
        frames: [
          "\u{1F610} ",
          "\u{1F610} ",
          "\u{1F62E} ",
          "\u{1F62E} ",
          "\u{1F626} ",
          "\u{1F626} ",
          "\u{1F627} ",
          "\u{1F627} ",
          "\u{1F92F} ",
          "\u{1F4A5} ",
          "\u2728 ",
          "\u3000 ",
          "\u3000 ",
          "\u3000 "
        ]
      },
      speaker: {
        interval: 160,
        frames: [
          "\u{1F508} ",
          "\u{1F509} ",
          "\u{1F50A} ",
          "\u{1F509} "
        ]
      },
      orangePulse: {
        interval: 100,
        frames: [
          "\u{1F538} ",
          "\u{1F536} ",
          "\u{1F7E0} ",
          "\u{1F7E0} ",
          "\u{1F536} "
        ]
      },
      bluePulse: {
        interval: 100,
        frames: [
          "\u{1F539} ",
          "\u{1F537} ",
          "\u{1F535} ",
          "\u{1F535} ",
          "\u{1F537} "
        ]
      },
      orangeBluePulse: {
        interval: 100,
        frames: [
          "\u{1F538} ",
          "\u{1F536} ",
          "\u{1F7E0} ",
          "\u{1F7E0} ",
          "\u{1F536} ",
          "\u{1F539} ",
          "\u{1F537} ",
          "\u{1F535} ",
          "\u{1F535} ",
          "\u{1F537} "
        ]
      },
      timeTravel: {
        interval: 100,
        frames: [
          "\u{1F55B} ",
          "\u{1F55A} ",
          "\u{1F559} ",
          "\u{1F558} ",
          "\u{1F557} ",
          "\u{1F556} ",
          "\u{1F555} ",
          "\u{1F554} ",
          "\u{1F553} ",
          "\u{1F552} ",
          "\u{1F551} ",
          "\u{1F550} "
        ]
      },
      aesthetic: {
        interval: 80,
        frames: [
          "\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1\u25B1",
          "\u25B0\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1",
          "\u25B0\u25B0\u25B0\u25B1\u25B1\u25B1\u25B1",
          "\u25B0\u25B0\u25B0\u25B0\u25B1\u25B1\u25B1",
          "\u25B0\u25B0\u25B0\u25B0\u25B0\u25B1\u25B1",
          "\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0\u25B1",
          "\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0",
          "\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1\u25B1"
        ]
      }
    };
  }
});

// node_modules/.pnpm/cli-spinners@2.6.1/node_modules/cli-spinners/index.js
var require_cli_spinners = __commonJS({
  "node_modules/.pnpm/cli-spinners@2.6.1/node_modules/cli-spinners/index.js"(exports10, module2) {
    "use strict";
    var spinners = Object.assign({}, require_spinners());
    var spinnersList = Object.keys(spinners);
    Object.defineProperty(spinners, "random", {
      get() {
        const randomIndex = Math.floor(Math.random() * spinnersList.length);
        const spinnerName = spinnersList[randomIndex];
        return spinners[spinnerName];
      }
    });
    module2.exports = spinners;
  }
});

// node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/utils/loading.js
var require_loading = __commonJS({
  "node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/utils/loading.js"(exports10, module2) {
    var logUpdate = require_log_update();
    var cliProgress = require_cli_progress();
    var cliSpinners = require_cli_spinners();
    var { deepMerge, isFunc, isArr } = require_cjs();
    var createBar = (title, { total = 100, start = 0, preset, ...config }) => {
      console.log("");
      title && console.log(` ${title}`);
      const bar = new cliProgress.SingleBar({
        clearOnComplete: true,
        format: " {bar} | {percentage}%",
        hideCursor: true,
        ...config
      }, preset || cliProgress.Presets.shades_classic);
      bar.start(total, start);
      return bar;
    };
    var createSpinner = ({ spinner }) => {
      return cliSpinners[spinner || "bouncingBall"];
    };
    var startSpinner = (loading) => {
      if (!loading.active || loading.loader.stop)
        return;
      const { frames, interval } = loading.loader;
      console.log("");
      let i13 = 0;
      const timeout = setInterval(() => {
        logUpdate(` ${frames[i13 = ++i13 % frames.length]} ${loading.title}`);
      }, interval);
      loading.loader.stop = () => {
        clearInterval(timeout);
      };
    };
    var defaults = {
      increment: 1,
      config: {
        active: false,
        offMatch: void 0,
        type: "bar"
      },
      options: {
        start: 0,
        total: 100
      }
    };
    var Loading = class {
      constructor(options, loadConf) {
        loadConf.offMatch = isArr(loadConf.offMatch) ? loadConf.offMatch : [loadConf.offMatch];
        const config = deepMerge(defaults.config, loadConf);
        this.options = deepMerge(defaults.options, options);
        this.loader = config.type !== "bar" ? createSpinner(config) : createBar(config.title, this.options);
        Object.assign(this, config);
        return this;
      }
      isBar = () => this.type === "bar";
      /**
      * Helper to add percentage to the loader
      * @param {number} amount - The amount to increase the progress bar by
      *
      * @returns {void}
      */
      add = (amount) => {
        !this.isBar() ? startSpinner(this) : this.loader.increment(amount || defaults.config.increment);
      };
      /**
      * Helper to set the loader to a finished state
      * <br/> Updates the loader to the full amount, then stops it
      *
      * @returns {void}
      */
      finish = () => {
        this.isBar() && this.loader.update(this.options.total);
        isFunc(this.loader.stop) && this.loader.stop();
        const loading = this;
        setTimeout(() => {
          loading.finishMessage && console.log(loading.finishMessage);
        }, 1e3);
      };
      /**
      * Updates the progress bar instance to the passed in amount
      * @param {number} amount - The amount to increase the progress bar by
      *
      * @returns {void}
      */
      update = (amount) => amount && this.isBar() && this.loader.update(amount);
      /**
      * Updates the progress bar instance by the increment amount, or stopping
      * @param {number} amount - The amount to increase the progress bar by
      * @param {string|boolean} data - Toggle to turn the loader off
      *
      * @returns {void}
      */
      progress = (amount, data) => {
        amount && this.add(amount);
        this.checkActive(data);
        !this.active && this.finish();
      };
      /**
      * Checks if loading is active, and if it should be turned off
      * <br/> Checks the passed in data, to see if it should turn off loading
      * @param {string|boolean} data - Toggle to turn the loader off
      *
      * @returns {boolean} - True if loading is active / False if loading is not
      */
      checkActive = (data) => {
        const check = data.trim();
        this.offMatch.map((match) => {
          this.active && (check === match || isFunc(check.includes) && check.includes(match)) && (this.active = false);
        });
        return this.active;
      };
    };
    module2.exports = {
      Loading
    };
  }
});

// node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/pipeCmd.js
var require_pipeCmd = __commonJS({
  "node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/pipeCmd.js"(exports10, module2) {
    var { spawnCmd } = require_spawnCmd();
    var { Loading } = require_loading();
    var {
      get: get2,
      isFunc,
      noOpObj,
      checkCall
    } = require_cjs();
    var filterAllowedLogs = (filters, data) => {
      const isFiltered = filters.reduce((inFilter, filter) => {
        return inFilter || data.trim().indexOf(filter) === 0;
      }, false);
      return isFiltered;
    };
    var handleLog = (eventCb, type2, loading = noOpObj, logs = noOpObj, data, procId) => {
      try {
        const activeLoading = loading && loading.active;
        const allowLog = logs.allow && filterAllowedLogs(logs.allow, data);
        const shouldFilter = activeLoading || !allowLog;
        activeLoading && loading.progress(shouldFilter && 1, data);
        isFunc(eventCb) && eventCb(data, procId);
        (!loading || !loading.active) && !shouldFilter && process[type2] && process[type2].write(data);
      } catch (err) {
        console.error(err.message);
      }
    };
    var handleExit = (config, loading) => {
      return (...args) => {
        loading && isFunc(loading.loader.stop) && loading.loader.stop();
        return checkCall(config.onExit, ...args);
      };
    };
    var buildEvents = (config = noOpObj, logs = noOpObj, loading) => {
      const allow = get2(logs, "allow");
      const onStdOut = get2(config, "onStdOut");
      const onStdErr = get2(config, "onStdErr");
      if (allow !== true && (!onStdOut && !onStdErr))
        return noOpObj;
      const loadingConf = loading && new Loading({}, loading);
      return {
        onStdOut: (...args) => handleLog(onStdOut, "stdout", loadingConf, logs, ...args),
        onStdErr: (...args) => handleLog(onStdErr, "stderr", loadingConf, logs, ...args),
        onExit: handleExit(config, loadingConf)
      };
    };
    var pipeCmd = (cmd, options = {}, location2 = process.cwd()) => {
      const { logs = noOpObj, loading, ...cmdOpts } = options;
      const spawnOpts = {
        ...cmdOpts,
        // Build the event listeners to allow log filtering
        ...buildEvents(options, logs, loading),
        // Set the location where the command should be run
        cwd: options.cwd || location2,
        // Ensure the stdio gets set to pipe
        options: { ...cmdOpts.options, stdio: "pipe" }
      };
      return spawnCmd(cmd, spawnOpts);
    };
    module2.exports = {
      pipeCmd
    };
  }
});

// node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/index.js
var require_src2 = __commonJS({
  "node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/src/index.js"(exports10, module2) {
    module2.exports = {
      ...require_asyncCmd(),
      ...require_childProcess(),
      ...require_pipeCmd(),
      ...require_spawnCmd()
    };
  }
});

// node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/index.js
var require_spawn_cmd = __commonJS({
  "node_modules/.pnpm/@keg-hub+spawn-cmd@0.3.2/node_modules/@keg-hub/spawn-cmd/index.js"(exports10, module2) {
    module2.exports = require_src2();
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/commands/commands.js
var require_commands = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/commands/commands.js"(exports10, module2) {
    var { inDocker } = require_inDocker2();
    var { getAppRoot } = require_appRoot();
    var { Logger: Logger3 } = require_logger();
    var { isArr, noOpObj, noPropArr, camelCase, isStr, exists: exists2 } = require_cjs();
    var { spawnCmd, asyncCmd: execCmd } = require_spawn_cmd();
    var ensureArray = (data = noPropArr) => !exists2(data) ? noPropArr : isArr(data) ? data : isStr(data) ? data.split(" ") : Logger3.error(
      `The runCmd method requires arguments be an Array or string.
`,
      `Instead got ${typeof data}: ${data}
`,
      `Args will be ignored!
`
    ) || noPropArr;
    var normalizeEnv = (options) => {
      const { envs = noOpObj, env: env2 = noOpObj } = options;
      return { ...envs, ...env2 };
    };
    var runCmd = async (cmd, args = noPropArr, options = noOpObj, cwd, asExec) => {
      const {
        exec,
        onStdOut,
        onStdErr,
        onError,
        onExit,
        env: env2,
        envs,
        ...opts2
      } = options;
      const cmdOpts = {
        ...opts2,
        // Normalize the env(s) options
        env: { ...process.env, ...normalizeEnv(options) }
      };
      return exec || asExec ? await execCmd(
        `${cmd} ${ensureArray(args).join(" ")}`,
        cmdOpts,
        cwd || getAppRoot()
      ) : await spawnCmd(cmd, {
        onStdOut,
        onStdErr,
        onError,
        onExit,
        args: ensureArray(args),
        options: cmdOpts,
        cwd: cwd || getAppRoot()
      });
    };
    var shortcutCmds = Array.from([
      "npm",
      "npx",
      "node",
      "yarn",
      "docker",
      "docker-compose"
    ]).reduce((cmds, cmd) => {
      cmds[camelCase(cmd)] = (args, ...opts2) => runCmd(cmd, args, ...opts2);
      return cmds;
    }, {});
    var envToStr = (envs) => Object.keys(envs).reduce((acc, key) => {
      acc.push(`--env`);
      acc.push(`${key}=${envs[key]}`);
      return acc;
    }, []);
    var dockerExec = (containerName, args, opts2 = noOpObj, ...extra) => {
      const cmdEnvs = normalizeEnv(opts2);
      const cmdArgs = [
        "exec",
        "-it",
        ...envToStr(cmdEnvs),
        containerName,
        ...ensureArray(args)
      ];
      return runCmd("docker", cmdArgs, { ...opts2, env: cmdEnvs }, ...extra);
    };
    var containerExec = (_8, args, opts2 = noOpObj, ...extra) => {
      const argsArr = [...ensureArray(args)];
      const cmd = argsArr.shift();
      return runCmd(
        cmd,
        argsArr,
        { ...opts2, env: normalizeEnv(opts2) },
        ...extra
      );
    };
    var dockerCmd = (...args) => inDocker() ? containerExec(...args) : dockerExec(...args);
    module2.exports = {
      execCmd,
      runCmd,
      spawnCmd,
      dockerCmd,
      dockerExec,
      /**
       * Creates a helper to call the **npx** executable within a child process
       * @function
       * @param {Array|string} args - Arguments to pass to the **npx** command
       * @param {Object} [options] - Options forwarded to the child process
       * @param {Object} options.env - Environment variables to set in the child process
       * @param {boolean} options.exec - Execute the command instead of calling child spawn process
       * @param {string} options.cwd - Directory to execute the command from
       * @example
       * await npx(`http-server ./public -p 3000 --cors`)
       * await npx([`http-server`, `./public`, `-p`, `3000`, `--cors`], { env: { MY_ENV: 'some-value' } })
       * @returns {Object|undefined} - Object if exec is true, undefined if false
       */
      npx: shortcutCmds.npx,
      /**
       * Creates a helper to call the **npm** executable within a child process
       * @function
       * @param {Array|string} args - Arguments to pass to the **npm** command
       * @param {Object} [options] - Options forwarded to the child process
       * @param {Object} options.env - Environment variables to set in the child process
       * @param {boolean} options.exec - Execute the command instead of calling child spawn process
       * @param {string} options.cwd - Directory to execute the command from
       * @example
       * await npm(`start`)
       * await npm([`start`], { env: { NODE_ENV: 'staging' } })
       * @returns {Object|undefined} - Object if exec is true, undefined if false
       */
      npm: shortcutCmds.npm,
      /**
       * Creates a helper to call the **node** executable within a child process
       * @function
       * @param {Array|string} args - Arguments to pass to the **node** command
       * @param {Object} [options] - Options forwarded to the child process
       * @param {Object} options.env - Environment variables to set in the child process
       * @param {boolean} options.exec - Execute the command instead of calling child spawn process
       * @param {string} options.cwd - Directory to execute the command from
       * @example
       * await node(`./index.js`)
       * await node([`./index.js`], { cwd: process.env.HOME, env: { KEY: 'VALUE' } })
       * @returns {Object|undefined} - Object if exec is true, undefined if false
       */
      node: shortcutCmds.node,
      /**
       * Creates a helper to call the **yarn** executable within a child process
       * @function
       * @param {Array|string} args - Arguments to pass to the **yarn** command
       * @param {Object} [options] - Options forwarded to the child process
       * @param {Object} options.env - Environment variables to set in the child process
       * @param {boolean} options.exec - Execute the command instead of calling child spawn process
       * @param {string} options.cwd - Directory to execute the command from
       * @example
       * await yarn(`start`)
       * await yarn([`start`])
       * @returns {Object|undefined} - Object if exec is true, undefined if false
       */
      yarn: shortcutCmds.yarn,
      /**
       * Creates a helper to call the **docker** executable within a child process
       * @function
       * @param {Array|string} args - Arguments to pass to the **docker** command
       * @param {Object} [options] - Options forwarded to the child process
       * @param {Object} options.env - Environment variables to set in the child process
       * @param {boolean} options.exec - Execute the command instead of calling child spawn process
       * @param {string} options.cwd - Directory to execute the command from
       * @example
       * await docker(`exec my-container /bin/bash`)
       * await docker([`exec`, `my-container`, `/bin/bash`], { env: {PORT: 1000}, exec: true })
       * @returns {Object|undefined} - Object if exec is true, undefined if false
       */
      docker: shortcutCmds.docker,
      /**
       * Creates a helper to call the **docker-compose** executable within a child process
       * @function
       * @param {Array|string} args - Arguments to pass to the **docker-compose** command
       * @param {Object} [options] - Options forwarded to the child process
       * @param {Object} options.env - Environment variables to set in the child process
       * @param {boolean} options.exec - Execute the command instead of calling child spawn process
       * @param {string} options.cwd - Directory to execute the command from
       * @example
       * await dockerCompose(`up`)
       * await dockerCompose([`up`, `-f`, `./path/to/docker-compose.yml`])
       * @returns {Object|undefined} - Object if exec is true, undefined if false
       */
      dockerCompose: shortcutCmds.dockerCompose
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/commands/which.js
var require_which2 = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/commands/which.js"(exports10, module2) {
    var { runCmd } = require_commands();
    var { limbo } = require_cjs();
    var which = async (cmd, throwErr = true) => {
      const [err, res] = await limbo(runCmd(`which`, [cmd], { exec: true }));
      const { error, data, exitCode } = res;
      if (exitCode || error || err) {
        if (throwErr)
          throw new Error(err || error || `${cmd} not found`);
        return false;
      }
      return data;
    };
    module2.exports = {
      which
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/commands/index.js
var require_commands2 = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/commands/index.js"(exports10, module2) {
    module2.exports = {
      ...require_arguments(),
      ...require_commands(),
      ...require_inDocker2(),
      ...require_which2()
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/logger/index.js
var require_logger2 = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/logger/index.js"(exports10, module2) {
    module2.exports = {
      ...require_showHelp(),
      ...require_logger()
    };
  }
});

// node-modules-polyfills:net
function unimplemented5() {
  throw new Error("Node.js net module is not supported by JSPM core outside of Node.js");
}
var init_net = __esm({
  "node-modules-polyfills:net"() {
  }
});

// node-modules-polyfills-commonjs:net
var net_exports = {};
__export(net_exports, {
  Server: () => unimplemented5,
  Socket: () => unimplemented5,
  Stream: () => unimplemented5,
  _createServerHandle: () => unimplemented5,
  _normalizeArgs: () => unimplemented5,
  _setSimultaneousAccepts: () => unimplemented5,
  connect: () => unimplemented5,
  createConnection: () => unimplemented5,
  createServer: () => unimplemented5,
  isIP: () => unimplemented5,
  isIPv4: () => unimplemented5,
  isIPv6: () => unimplemented5
});
var init_net2 = __esm({
  "node-modules-polyfills-commonjs:net"() {
    init_net();
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/network/ipIsInRange.js
var require_ipIsInRange = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/network/ipIsInRange.js"(exports10, module2) {
    var { validate } = require_cjs();
    var { isIP } = (init_net2(), __toCommonJS(net_exports));
    var parseParts = (ip) => ip.split(".").map((part) => parseInt(part));
    var ipIsInRange = (ip, start, end) => {
      const [valid] = validate({ ip, start, end }, { $default: isIP });
      if (!valid)
        return false;
      const parts = parseParts(ip);
      const startParts = parseParts(start);
      const endParts = parseParts(end);
      if (parts.length !== 4)
        return false;
      for (let i13 = 0; i13 < 4; i13++) {
        if (parts[i13] < startParts[i13] || parts[i13] > endParts[i13])
          return false;
      }
      return true;
    };
    module2.exports = { ipIsInRange };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/network/isPrivateIP.js
var require_isPrivateIP = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/network/isPrivateIP.js"(exports10, module2) {
    var { ipIsInRange } = require_ipIsInRange();
    var { PRIVATE_IPV4_CLASSES } = require_constants();
    var isPrivateIP = (ip) => {
      return Object.values(PRIVATE_IPV4_CLASSES).some((range) => ipIsInRange(ip, range[0], range[1]));
    };
    module2.exports = { isPrivateIP };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/network/getAddresses.js
var require_getAddresses = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/network/getAddresses.js"(exports10, module2) {
    var { networkInterfaces: networkInterfaces2 } = (init_os2(), __toCommonJS(os_exports));
    var { isPrivateIP } = require_isPrivateIP();
    var getIPVersion = (familyStr) => familyStr && parseInt(
      familyStr.charAt(familyStr.length - 1)
    );
    var getAddresses = ({ iface = "en0", isPrivate, isPublic, version: version2 }) => {
      const interfaces = networkInterfaces2();
      if (!interfaces[iface])
        throw new Error(`Could not find interface ${iface} in network`);
      return interfaces[iface].filter((addr) => {
        const ipVersion = getIPVersion(addr.family);
        const ipIsPrivate = isPrivateIP(addr.address);
        return (!version2 || ipVersion === version2) && (!isPrivate || ipIsPrivate) && (!isPublic || !ipIsPrivate);
      });
    };
    module2.exports = { getAddresses };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/network/getPrivateIPs.js
var require_getPrivateIPs = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/network/getPrivateIPs.js"(exports10, module2) {
    var { getAddresses } = require_getAddresses();
    var getPrivateIPs = (iface = "en0") => getAddresses({ iface, isPrivate: true }).map((addrInfo) => addrInfo.address);
    module2.exports = { getPrivateIPs };
  }
});

// node-modules-polyfills:http
function o13() {
  o13.init.call(this);
}
function u12(e82) {
  if ("function" != typeof e82)
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e82);
}
function f12(e82) {
  return void 0 === e82._maxListeners ? o13.defaultMaxListeners : e82._maxListeners;
}
function v10(e82, t72, n82, r82) {
  var i72, o82, s62, v52;
  if (u12(n82), void 0 === (o82 = e82._events) ? (o82 = e82._events = /* @__PURE__ */ Object.create(null), e82._eventsCount = 0) : (void 0 !== o82.newListener && (e82.emit("newListener", t72, n82.listener ? n82.listener : n82), o82 = e82._events), s62 = o82[t72]), void 0 === s62)
    s62 = o82[t72] = n82, ++e82._eventsCount;
  else if ("function" == typeof s62 ? s62 = o82[t72] = r82 ? [n82, s62] : [s62, n82] : r82 ? s62.unshift(n82) : s62.push(n82), (i72 = f12(e82)) > 0 && s62.length > i72 && !s62.warned) {
    s62.warned = true;
    var a72 = new Error("Possible EventEmitter memory leak detected. " + s62.length + " " + String(t72) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a72.name = "MaxListenersExceededWarning", a72.emitter = e82, a72.type = t72, a72.count = s62.length, v52 = a72, console && console.warn && console.warn(v52);
  }
  return e82;
}
function a12() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function l12(e82, t72, n82) {
  var r82 = { fired: false, wrapFn: void 0, target: e82, type: t72, listener: n82 }, i72 = a12.bind(r82);
  return i72.listener = n82, r82.wrapFn = i72, i72;
}
function h12(e82, t72, n82) {
  var r82 = e82._events;
  if (void 0 === r82)
    return [];
  var i72 = r82[t72];
  return void 0 === i72 ? [] : "function" == typeof i72 ? n82 ? [i72.listener || i72] : [i72] : n82 ? function(e92) {
    for (var t82 = new Array(e92.length), n92 = 0; n92 < t82.length; ++n92)
      t82[n92] = e92[n92].listener || e92[n92];
    return t82;
  }(i72) : c12(i72, i72.length);
}
function p12(e82) {
  var t72 = this._events;
  if (void 0 !== t72) {
    var n82 = t72[e82];
    if ("function" == typeof n82)
      return 1;
    if (void 0 !== n82)
      return n82.length;
  }
  return 0;
}
function c12(e82, t72) {
  for (var n82 = new Array(t72), r82 = 0; r82 < t72; ++r82)
    n82[r82] = e82[r82];
  return n82;
}
function i25() {
  throw new Error("setTimeout has not been defined");
}
function u25() {
  throw new Error("clearTimeout has not been defined");
}
function c25(e82) {
  if (t25 === setTimeout)
    return setTimeout(e82, 0);
  if ((t25 === i25 || !t25) && setTimeout)
    return t25 = setTimeout, setTimeout(e82, 0);
  try {
    return t25(e82, 0);
  } catch (n82) {
    try {
      return t25.call(null, e82, 0);
    } catch (n92) {
      return t25.call(this || r25, e82, 0);
    }
  }
}
function h25() {
  f25 && l25 && (f25 = false, l25.length ? s25 = l25.concat(s25) : a25 = -1, s25.length && d9());
}
function d9() {
  if (!f25) {
    var e82 = c25(h25);
    f25 = true;
    for (var t72 = s25.length; t72; ) {
      for (l25 = s25, s25 = []; ++a25 < t72; )
        l25 && l25[a25].run();
      a25 = -1, t72 = s25.length;
    }
    l25 = null, f25 = false, function(e92) {
      if (n25 === clearTimeout)
        return clearTimeout(e92);
      if ((n25 === u25 || !n25) && clearTimeout)
        return n25 = clearTimeout, clearTimeout(e92);
      try {
        n25(e92);
      } catch (t82) {
        try {
          return n25.call(null, e92);
        } catch (t92) {
          return n25.call(this || r25, e92);
        }
      }
    }(e82);
  }
}
function m9(e82, t72) {
  (this || r25).fun = e82, (this || r25).array = t72;
}
function p25() {
}
function c$17(e82) {
  return e82.call.bind(e82);
}
function O8(e82, t72) {
  if ("object" != typeof e82)
    return false;
  try {
    return t72(e82), true;
  } catch (e92) {
    return false;
  }
}
function S7(e82) {
  return l$17 && y24 ? void 0 !== b8(e82) : B7(e82) || k7(e82) || E7(e82) || D7(e82) || U7(e82) || P7(e82) || x7(e82) || I7(e82) || M7(e82) || z7(e82) || F7(e82);
}
function B7(e82) {
  return l$17 && y24 ? "Uint8Array" === b8(e82) : "[object Uint8Array]" === m25(e82) || u$17(e82) && void 0 !== e82.buffer;
}
function k7(e82) {
  return l$17 && y24 ? "Uint8ClampedArray" === b8(e82) : "[object Uint8ClampedArray]" === m25(e82);
}
function E7(e82) {
  return l$17 && y24 ? "Uint16Array" === b8(e82) : "[object Uint16Array]" === m25(e82);
}
function D7(e82) {
  return l$17 && y24 ? "Uint32Array" === b8(e82) : "[object Uint32Array]" === m25(e82);
}
function U7(e82) {
  return l$17 && y24 ? "Int8Array" === b8(e82) : "[object Int8Array]" === m25(e82);
}
function P7(e82) {
  return l$17 && y24 ? "Int16Array" === b8(e82) : "[object Int16Array]" === m25(e82);
}
function x7(e82) {
  return l$17 && y24 ? "Int32Array" === b8(e82) : "[object Int32Array]" === m25(e82);
}
function I7(e82) {
  return l$17 && y24 ? "Float32Array" === b8(e82) : "[object Float32Array]" === m25(e82);
}
function M7(e82) {
  return l$17 && y24 ? "Float64Array" === b8(e82) : "[object Float64Array]" === m25(e82);
}
function z7(e82) {
  return l$17 && y24 ? "BigInt64Array" === b8(e82) : "[object BigInt64Array]" === m25(e82);
}
function F7(e82) {
  return l$17 && y24 ? "BigUint64Array" === b8(e82) : "[object BigUint64Array]" === m25(e82);
}
function T25(e82) {
  return "[object Map]" === m25(e82);
}
function N7(e82) {
  return "[object Set]" === m25(e82);
}
function W6(e82) {
  return "[object WeakMap]" === m25(e82);
}
function $6(e82) {
  return "[object WeakSet]" === m25(e82);
}
function C7(e82) {
  return "[object ArrayBuffer]" === m25(e82);
}
function V6(e82) {
  return "undefined" != typeof ArrayBuffer && (C7.working ? C7(e82) : e82 instanceof ArrayBuffer);
}
function G6(e82) {
  return "[object DataView]" === m25(e82);
}
function R7(e82) {
  return "undefined" != typeof DataView && (G6.working ? G6(e82) : e82 instanceof DataView);
}
function J6(e82) {
  return "[object SharedArrayBuffer]" === m25(e82);
}
function _7(e82) {
  return "undefined" != typeof SharedArrayBuffer && (J6.working ? J6(e82) : e82 instanceof SharedArrayBuffer);
}
function H6(e82) {
  return O8(e82, h34);
}
function Z6(e82) {
  return O8(e82, j7);
}
function q6(e82) {
  return O8(e82, A7);
}
function K6(e82) {
  return s34 && O8(e82, w7);
}
function L7(e82) {
  return p34 && O8(e82, v24);
}
function oe5(e82, t72) {
  var r82 = { seen: [], stylize: fe5 };
  return arguments.length >= 3 && (r82.depth = arguments[2]), arguments.length >= 4 && (r82.colors = arguments[3]), ye5(t72) ? r82.showHidden = t72 : t72 && X6._extend(r82, t72), be5(r82.showHidden) && (r82.showHidden = false), be5(r82.depth) && (r82.depth = 2), be5(r82.colors) && (r82.colors = false), be5(r82.customInspect) && (r82.customInspect = true), r82.colors && (r82.stylize = ue5), ae5(r82, e82, r82.depth);
}
function ue5(e82, t72) {
  var r82 = oe5.styles[t72];
  return r82 ? "\x1B[" + oe5.colors[r82][0] + "m" + e82 + "\x1B[" + oe5.colors[r82][1] + "m" : e82;
}
function fe5(e82, t72) {
  return e82;
}
function ae5(e82, t72, r82) {
  if (e82.customInspect && t72 && we5(t72.inspect) && t72.inspect !== X6.inspect && (!t72.constructor || t72.constructor.prototype !== t72)) {
    var n82 = t72.inspect(r82, e82);
    return ge5(n82) || (n82 = ae5(e82, n82, r82)), n82;
  }
  var i72 = function(e92, t82) {
    if (be5(t82))
      return e92.stylize("undefined", "undefined");
    if (ge5(t82)) {
      var r92 = "'" + JSON.stringify(t82).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return e92.stylize(r92, "string");
    }
    if (de5(t82))
      return e92.stylize("" + t82, "number");
    if (ye5(t82))
      return e92.stylize("" + t82, "boolean");
    if (le5(t82))
      return e92.stylize("null", "null");
  }(e82, t72);
  if (i72)
    return i72;
  var o82 = Object.keys(t72), u72 = function(e92) {
    var t82 = {};
    return e92.forEach(function(e102, r92) {
      t82[e102] = true;
    }), t82;
  }(o82);
  if (e82.showHidden && (o82 = Object.getOwnPropertyNames(t72)), Ae5(t72) && (o82.indexOf("message") >= 0 || o82.indexOf("description") >= 0))
    return ce5(t72);
  if (0 === o82.length) {
    if (we5(t72)) {
      var f72 = t72.name ? ": " + t72.name : "";
      return e82.stylize("[Function" + f72 + "]", "special");
    }
    if (me5(t72))
      return e82.stylize(RegExp.prototype.toString.call(t72), "regexp");
    if (je5(t72))
      return e82.stylize(Date.prototype.toString.call(t72), "date");
    if (Ae5(t72))
      return ce5(t72);
  }
  var a72, c72 = "", s62 = false, p72 = ["{", "}"];
  (pe5(t72) && (s62 = true, p72 = ["[", "]"]), we5(t72)) && (c72 = " [Function" + (t72.name ? ": " + t72.name : "") + "]");
  return me5(t72) && (c72 = " " + RegExp.prototype.toString.call(t72)), je5(t72) && (c72 = " " + Date.prototype.toUTCString.call(t72)), Ae5(t72) && (c72 = " " + ce5(t72)), 0 !== o82.length || s62 && 0 != t72.length ? r82 < 0 ? me5(t72) ? e82.stylize(RegExp.prototype.toString.call(t72), "regexp") : e82.stylize("[Object]", "special") : (e82.seen.push(t72), a72 = s62 ? function(e92, t82, r92, n92, i82) {
    for (var o92 = [], u82 = 0, f82 = t82.length; u82 < f82; ++u82)
      ke5(t82, String(u82)) ? o92.push(se5(e92, t82, r92, n92, String(u82), true)) : o92.push("");
    return i82.forEach(function(i92) {
      i92.match(/^\d+$/) || o92.push(se5(e92, t82, r92, n92, i92, true));
    }), o92;
  }(e82, t72, r82, u72, o82) : o82.map(function(n92) {
    return se5(e82, t72, r82, u72, n92, s62);
  }), e82.seen.pop(), function(e92, t82, r92) {
    var n92 = 0;
    if (e92.reduce(function(e102, t92) {
      return n92++, t92.indexOf("\n") >= 0 && n92++, e102 + t92.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0) > 60)
      return r92[0] + ("" === t82 ? "" : t82 + "\n ") + " " + e92.join(",\n  ") + " " + r92[1];
    return r92[0] + t82 + " " + e92.join(", ") + " " + r92[1];
  }(a72, c72, p72)) : p72[0] + c72 + p72[1];
}
function ce5(e82) {
  return "[" + Error.prototype.toString.call(e82) + "]";
}
function se5(e82, t72, r82, n82, i72, o82) {
  var u72, f72, a72;
  if ((a72 = Object.getOwnPropertyDescriptor(t72, i72) || { value: t72[i72] }).get ? f72 = a72.set ? e82.stylize("[Getter/Setter]", "special") : e82.stylize("[Getter]", "special") : a72.set && (f72 = e82.stylize("[Setter]", "special")), ke5(n82, i72) || (u72 = "[" + i72 + "]"), f72 || (e82.seen.indexOf(a72.value) < 0 ? (f72 = le5(r82) ? ae5(e82, a72.value, null) : ae5(e82, a72.value, r82 - 1)).indexOf("\n") > -1 && (f72 = o82 ? f72.split("\n").map(function(e92) {
    return "  " + e92;
  }).join("\n").substr(2) : "\n" + f72.split("\n").map(function(e92) {
    return "   " + e92;
  }).join("\n")) : f72 = e82.stylize("[Circular]", "special")), be5(u72)) {
    if (o82 && i72.match(/^\d+$/))
      return f72;
    (u72 = JSON.stringify("" + i72)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u72 = u72.substr(1, u72.length - 2), u72 = e82.stylize(u72, "name")) : (u72 = u72.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u72 = e82.stylize(u72, "string"));
  }
  return u72 + ": " + f72;
}
function pe5(e82) {
  return Array.isArray(e82);
}
function ye5(e82) {
  return "boolean" == typeof e82;
}
function le5(e82) {
  return null === e82;
}
function de5(e82) {
  return "number" == typeof e82;
}
function ge5(e82) {
  return "string" == typeof e82;
}
function be5(e82) {
  return void 0 === e82;
}
function me5(e82) {
  return he5(e82) && "[object RegExp]" === ve5(e82);
}
function he5(e82) {
  return "object" == typeof e82 && null !== e82;
}
function je5(e82) {
  return he5(e82) && "[object Date]" === ve5(e82);
}
function Ae5(e82) {
  return he5(e82) && ("[object Error]" === ve5(e82) || e82 instanceof Error);
}
function we5(e82) {
  return "function" == typeof e82;
}
function ve5(e82) {
  return Object.prototype.toString.call(e82);
}
function Oe5(e82) {
  return e82 < 10 ? "0" + e82.toString(10) : e82.toString(10);
}
function Be5() {
  var e82 = /* @__PURE__ */ new Date(), t72 = [Oe5(e82.getHours()), Oe5(e82.getMinutes()), Oe5(e82.getSeconds())].join(":");
  return [e82.getDate(), Se5[e82.getMonth()], t72].join(" ");
}
function ke5(e82, t72) {
  return Object.prototype.hasOwnProperty.call(e82, t72);
}
function De5(e82, t72) {
  if (!e82) {
    var r82 = new Error("Promise was rejected with a falsy value");
    r82.reason = e82, e82 = r82;
  }
  return t72(e82);
}
function dew9() {
  if (_dewExec9)
    return exports9;
  _dewExec9 = true;
  var process22 = exports9 = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e82) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e82) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e82) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e92) {
        return cachedSetTimeout.call(this || _global6, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e82) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e92) {
        return cachedClearTimeout.call(this || _global6, marker);
      }
    }
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  process22.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i72 = 1; i72 < arguments.length; i72++) {
        args[i72 - 1] = arguments[i72];
      }
    }
    queue.push(new Item2(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  };
  function Item2(fun, array) {
    (this || _global6).fun = fun;
    (this || _global6).array = array;
  }
  Item2.prototype.run = function() {
    (this || _global6).fun.apply(null, (this || _global6).array);
  };
  process22.title = "browser";
  process22.browser = true;
  process22.env = {};
  process22.argv = [];
  process22.version = "";
  process22.versions = {};
  function noop() {
  }
  process22.on = noop;
  process22.addListener = noop;
  process22.once = noop;
  process22.off = noop;
  process22.removeListener = noop;
  process22.removeAllListeners = noop;
  process22.emit = noop;
  process22.prependListener = noop;
  process22.prependOnceListener = noop;
  process22.listeners = function(name2) {
    return [];
  };
  process22.binding = function(name2) {
    throw new Error("process.binding is not supported");
  };
  process22.cwd = function() {
    return "/";
  };
  process22.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process22.umask = function() {
    return 0;
  };
  return exports9;
}
function u$25(r82) {
  var t72 = r82.length;
  if (t72 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var e82 = r82.indexOf("=");
  return -1 === e82 && (e82 = t72), [e82, e82 === t72 ? 0 : 4 - e82 % 4];
}
function c$124(r82, e82, n82) {
  for (var o82, a72, h72 = [], u72 = e82; u72 < n82; u72 += 3)
    o82 = (r82[u72] << 16 & 16711680) + (r82[u72 + 1] << 8 & 65280) + (255 & r82[u72 + 2]), h72.push(t$124[(a72 = o82) >> 18 & 63] + t$124[a72 >> 12 & 63] + t$124[a72 >> 6 & 63] + t$124[63 & a72]);
  return h72.join("");
}
function f$25(t72) {
  if (t72 > 2147483647)
    throw new RangeError('The value "' + t72 + '" is invalid for option "size"');
  var r82 = new Uint8Array(t72);
  return Object.setPrototypeOf(r82, u$1$13.prototype), r82;
}
function u$1$13(t72, r82, e82) {
  if ("number" == typeof t72) {
    if ("string" == typeof r82)
      throw new TypeError('The "string" argument must be of type string. Received type number');
    return a$25(t72);
  }
  return s$15(t72, r82, e82);
}
function s$15(t72, r82, e82) {
  if ("string" == typeof t72)
    return function(t82, r92) {
      "string" == typeof r92 && "" !== r92 || (r92 = "utf8");
      if (!u$1$13.isEncoding(r92))
        throw new TypeError("Unknown encoding: " + r92);
      var e92 = 0 | y33(t82, r92), n92 = f$25(e92), i82 = n92.write(t82, r92);
      i82 !== e92 && (n92 = n92.slice(0, i82));
      return n92;
    }(t72, r82);
  if (ArrayBuffer.isView(t72))
    return p43(t72);
  if (null == t72)
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t72);
  if (F24(t72, ArrayBuffer) || t72 && F24(t72.buffer, ArrayBuffer))
    return c$1$13(t72, r82, e82);
  if ("undefined" != typeof SharedArrayBuffer && (F24(t72, SharedArrayBuffer) || t72 && F24(t72.buffer, SharedArrayBuffer)))
    return c$1$13(t72, r82, e82);
  if ("number" == typeof t72)
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  var n82 = t72.valueOf && t72.valueOf();
  if (null != n82 && n82 !== t72)
    return u$1$13.from(n82, r82, e82);
  var i72 = function(t82) {
    if (u$1$13.isBuffer(t82)) {
      var r92 = 0 | l$124(t82.length), e92 = f$25(r92);
      return 0 === e92.length || t82.copy(e92, 0, 0, r92), e92;
    }
    if (void 0 !== t82.length)
      return "number" != typeof t82.length || N24(t82.length) ? f$25(0) : p43(t82);
    if ("Buffer" === t82.type && Array.isArray(t82.data))
      return p43(t82.data);
  }(t72);
  if (i72)
    return i72;
  if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t72[Symbol.toPrimitive])
    return u$1$13.from(t72[Symbol.toPrimitive]("string"), r82, e82);
  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t72);
}
function h$1$13(t72) {
  if ("number" != typeof t72)
    throw new TypeError('"size" argument must be of type number');
  if (t72 < 0)
    throw new RangeError('The value "' + t72 + '" is invalid for option "size"');
}
function a$25(t72) {
  return h$1$13(t72), f$25(t72 < 0 ? 0 : 0 | l$124(t72));
}
function p43(t72) {
  for (var r82 = t72.length < 0 ? 0 : 0 | l$124(t72.length), e82 = f$25(r82), n82 = 0; n82 < r82; n82 += 1)
    e82[n82] = 255 & t72[n82];
  return e82;
}
function c$1$13(t72, r82, e82) {
  if (r82 < 0 || t72.byteLength < r82)
    throw new RangeError('"offset" is outside of buffer bounds');
  if (t72.byteLength < r82 + (e82 || 0))
    throw new RangeError('"length" is outside of buffer bounds');
  var n82;
  return n82 = void 0 === r82 && void 0 === e82 ? new Uint8Array(t72) : void 0 === e82 ? new Uint8Array(t72, r82) : new Uint8Array(t72, r82, e82), Object.setPrototypeOf(n82, u$1$13.prototype), n82;
}
function l$124(t72) {
  if (t72 >= 2147483647)
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
  return 0 | t72;
}
function y33(t72, r82) {
  if (u$1$13.isBuffer(t72))
    return t72.length;
  if (ArrayBuffer.isView(t72) || F24(t72, ArrayBuffer))
    return t72.byteLength;
  if ("string" != typeof t72)
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t72);
  var e82 = t72.length, n82 = arguments.length > 2 && true === arguments[2];
  if (!n82 && 0 === e82)
    return 0;
  for (var i72 = false; ; )
    switch (r82) {
      case "ascii":
      case "latin1":
      case "binary":
        return e82;
      case "utf8":
      case "utf-8":
        return _24(t72).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * e82;
      case "hex":
        return e82 >>> 1;
      case "base64":
        return z24(t72).length;
      default:
        if (i72)
          return n82 ? -1 : _24(t72).length;
        r82 = ("" + r82).toLowerCase(), i72 = true;
    }
}
function g24(t72, r82, e82) {
  var n82 = false;
  if ((void 0 === r82 || r82 < 0) && (r82 = 0), r82 > this.length)
    return "";
  if ((void 0 === e82 || e82 > this.length) && (e82 = this.length), e82 <= 0)
    return "";
  if ((e82 >>>= 0) <= (r82 >>>= 0))
    return "";
  for (t72 || (t72 = "utf8"); ; )
    switch (t72) {
      case "hex":
        return O24(this, r82, e82);
      case "utf8":
      case "utf-8":
        return I24(this, r82, e82);
      case "ascii":
        return S24(this, r82, e82);
      case "latin1":
      case "binary":
        return R24(this, r82, e82);
      case "base64":
        return T34(this, r82, e82);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return L24(this, r82, e82);
      default:
        if (n82)
          throw new TypeError("Unknown encoding: " + t72);
        t72 = (t72 + "").toLowerCase(), n82 = true;
    }
}
function w24(t72, r82, e82) {
  var n82 = t72[r82];
  t72[r82] = t72[e82], t72[e82] = n82;
}
function d34(t72, r82, e82, n82, i72) {
  if (0 === t72.length)
    return -1;
  if ("string" == typeof e82 ? (n82 = e82, e82 = 0) : e82 > 2147483647 ? e82 = 2147483647 : e82 < -2147483648 && (e82 = -2147483648), N24(e82 = +e82) && (e82 = i72 ? 0 : t72.length - 1), e82 < 0 && (e82 = t72.length + e82), e82 >= t72.length) {
    if (i72)
      return -1;
    e82 = t72.length - 1;
  } else if (e82 < 0) {
    if (!i72)
      return -1;
    e82 = 0;
  }
  if ("string" == typeof r82 && (r82 = u$1$13.from(r82, n82)), u$1$13.isBuffer(r82))
    return 0 === r82.length ? -1 : v33(t72, r82, e82, n82, i72);
  if ("number" == typeof r82)
    return r82 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i72 ? Uint8Array.prototype.indexOf.call(t72, r82, e82) : Uint8Array.prototype.lastIndexOf.call(t72, r82, e82) : v33(t72, [r82], e82, n82, i72);
  throw new TypeError("val must be string, number or Buffer");
}
function v33(t72, r82, e82, n82, i72) {
  var o82, f72 = 1, u72 = t72.length, s62 = r82.length;
  if (void 0 !== n82 && ("ucs2" === (n82 = String(n82).toLowerCase()) || "ucs-2" === n82 || "utf16le" === n82 || "utf-16le" === n82)) {
    if (t72.length < 2 || r82.length < 2)
      return -1;
    f72 = 2, u72 /= 2, s62 /= 2, e82 /= 2;
  }
  function h72(t82, r92) {
    return 1 === f72 ? t82[r92] : t82.readUInt16BE(r92 * f72);
  }
  if (i72) {
    var a72 = -1;
    for (o82 = e82; o82 < u72; o82++)
      if (h72(t72, o82) === h72(r82, -1 === a72 ? 0 : o82 - a72)) {
        if (-1 === a72 && (a72 = o82), o82 - a72 + 1 === s62)
          return a72 * f72;
      } else
        -1 !== a72 && (o82 -= o82 - a72), a72 = -1;
  } else
    for (e82 + s62 > u72 && (e82 = u72 - s62), o82 = e82; o82 >= 0; o82--) {
      for (var p72 = true, c72 = 0; c72 < s62; c72++)
        if (h72(t72, o82 + c72) !== h72(r82, c72)) {
          p72 = false;
          break;
        }
      if (p72)
        return o82;
    }
  return -1;
}
function b24(t72, r82, e82, n82) {
  e82 = Number(e82) || 0;
  var i72 = t72.length - e82;
  n82 ? (n82 = Number(n82)) > i72 && (n82 = i72) : n82 = i72;
  var o82 = r82.length;
  n82 > o82 / 2 && (n82 = o82 / 2);
  for (var f72 = 0; f72 < n82; ++f72) {
    var u72 = parseInt(r82.substr(2 * f72, 2), 16);
    if (N24(u72))
      return f72;
    t72[e82 + f72] = u72;
  }
  return f72;
}
function m34(t72, r82, e82, n82) {
  return D24(_24(r82, t72.length - e82), t72, e82, n82);
}
function E24(t72, r82, e82, n82) {
  return D24(function(t82) {
    for (var r92 = [], e92 = 0; e92 < t82.length; ++e92)
      r92.push(255 & t82.charCodeAt(e92));
    return r92;
  }(r82), t72, e82, n82);
}
function B24(t72, r82, e82, n82) {
  return E24(t72, r82, e82, n82);
}
function A24(t72, r82, e82, n82) {
  return D24(z24(r82), t72, e82, n82);
}
function U24(t72, r82, e82, n82) {
  return D24(function(t82, r92) {
    for (var e92, n92, i72, o82 = [], f72 = 0; f72 < t82.length && !((r92 -= 2) < 0); ++f72)
      e92 = t82.charCodeAt(f72), n92 = e92 >> 8, i72 = e92 % 256, o82.push(i72), o82.push(n92);
    return o82;
  }(r82, t72.length - e82), t72, e82, n82);
}
function T34(t72, r82, e82) {
  return 0 === r82 && e82 === t72.length ? n$1$13.fromByteArray(t72) : n$1$13.fromByteArray(t72.slice(r82, e82));
}
function I24(t72, r82, e82) {
  e82 = Math.min(t72.length, e82);
  for (var n82 = [], i72 = r82; i72 < e82; ) {
    var o82, f72, u72, s62, h72 = t72[i72], a72 = null, p72 = h72 > 239 ? 4 : h72 > 223 ? 3 : h72 > 191 ? 2 : 1;
    if (i72 + p72 <= e82)
      switch (p72) {
        case 1:
          h72 < 128 && (a72 = h72);
          break;
        case 2:
          128 == (192 & (o82 = t72[i72 + 1])) && (s62 = (31 & h72) << 6 | 63 & o82) > 127 && (a72 = s62);
          break;
        case 3:
          o82 = t72[i72 + 1], f72 = t72[i72 + 2], 128 == (192 & o82) && 128 == (192 & f72) && (s62 = (15 & h72) << 12 | (63 & o82) << 6 | 63 & f72) > 2047 && (s62 < 55296 || s62 > 57343) && (a72 = s62);
          break;
        case 4:
          o82 = t72[i72 + 1], f72 = t72[i72 + 2], u72 = t72[i72 + 3], 128 == (192 & o82) && 128 == (192 & f72) && 128 == (192 & u72) && (s62 = (15 & h72) << 18 | (63 & o82) << 12 | (63 & f72) << 6 | 63 & u72) > 65535 && s62 < 1114112 && (a72 = s62);
      }
    null === a72 ? (a72 = 65533, p72 = 1) : a72 > 65535 && (a72 -= 65536, n82.push(a72 >>> 10 & 1023 | 55296), a72 = 56320 | 1023 & a72), n82.push(a72), i72 += p72;
  }
  return function(t82) {
    var r92 = t82.length;
    if (r92 <= 4096)
      return String.fromCharCode.apply(String, t82);
    var e92 = "", n92 = 0;
    for (; n92 < r92; )
      e92 += String.fromCharCode.apply(String, t82.slice(n92, n92 += 4096));
    return e92;
  }(n82);
}
function S24(t72, r82, e82) {
  var n82 = "";
  e82 = Math.min(t72.length, e82);
  for (var i72 = r82; i72 < e82; ++i72)
    n82 += String.fromCharCode(127 & t72[i72]);
  return n82;
}
function R24(t72, r82, e82) {
  var n82 = "";
  e82 = Math.min(t72.length, e82);
  for (var i72 = r82; i72 < e82; ++i72)
    n82 += String.fromCharCode(t72[i72]);
  return n82;
}
function O24(t72, r82, e82) {
  var n82 = t72.length;
  (!r82 || r82 < 0) && (r82 = 0), (!e82 || e82 < 0 || e82 > n82) && (e82 = n82);
  for (var i72 = "", o82 = r82; o82 < e82; ++o82)
    i72 += Y24[t72[o82]];
  return i72;
}
function L24(t72, r82, e82) {
  for (var n82 = t72.slice(r82, e82), i72 = "", o82 = 0; o82 < n82.length; o82 += 2)
    i72 += String.fromCharCode(n82[o82] + 256 * n82[o82 + 1]);
  return i72;
}
function x24(t72, r82, e82) {
  if (t72 % 1 != 0 || t72 < 0)
    throw new RangeError("offset is not uint");
  if (t72 + r82 > e82)
    throw new RangeError("Trying to access beyond buffer length");
}
function C24(t72, r82, e82, n82, i72, o82) {
  if (!u$1$13.isBuffer(t72))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (r82 > i72 || r82 < o82)
    throw new RangeError('"value" argument is out of bounds');
  if (e82 + n82 > t72.length)
    throw new RangeError("Index out of range");
}
function P24(t72, r82, e82, n82, i72, o82) {
  if (e82 + n82 > t72.length)
    throw new RangeError("Index out of range");
  if (e82 < 0)
    throw new RangeError("Index out of range");
}
function k24(t72, r82, e82, n82, o82) {
  return r82 = +r82, e82 >>>= 0, o82 || P24(t72, 0, e82, 4), i$124.write(t72, r82, e82, n82, 23, 4), e82 + 4;
}
function M24(t72, r82, e82, n82, o82) {
  return r82 = +r82, e82 >>>= 0, o82 || P24(t72, 0, e82, 8), i$124.write(t72, r82, e82, n82, 52, 8), e82 + 8;
}
function _24(t72, r82) {
  var e82;
  r82 = r82 || 1 / 0;
  for (var n82 = t72.length, i72 = null, o82 = [], f72 = 0; f72 < n82; ++f72) {
    if ((e82 = t72.charCodeAt(f72)) > 55295 && e82 < 57344) {
      if (!i72) {
        if (e82 > 56319) {
          (r82 -= 3) > -1 && o82.push(239, 191, 189);
          continue;
        }
        if (f72 + 1 === n82) {
          (r82 -= 3) > -1 && o82.push(239, 191, 189);
          continue;
        }
        i72 = e82;
        continue;
      }
      if (e82 < 56320) {
        (r82 -= 3) > -1 && o82.push(239, 191, 189), i72 = e82;
        continue;
      }
      e82 = 65536 + (i72 - 55296 << 10 | e82 - 56320);
    } else
      i72 && (r82 -= 3) > -1 && o82.push(239, 191, 189);
    if (i72 = null, e82 < 128) {
      if ((r82 -= 1) < 0)
        break;
      o82.push(e82);
    } else if (e82 < 2048) {
      if ((r82 -= 2) < 0)
        break;
      o82.push(e82 >> 6 | 192, 63 & e82 | 128);
    } else if (e82 < 65536) {
      if ((r82 -= 3) < 0)
        break;
      o82.push(e82 >> 12 | 224, e82 >> 6 & 63 | 128, 63 & e82 | 128);
    } else {
      if (!(e82 < 1114112))
        throw new Error("Invalid code point");
      if ((r82 -= 4) < 0)
        break;
      o82.push(e82 >> 18 | 240, e82 >> 12 & 63 | 128, e82 >> 6 & 63 | 128, 63 & e82 | 128);
    }
  }
  return o82;
}
function z24(t72) {
  return n$1$13.toByteArray(function(t82) {
    if ((t82 = (t82 = t82.split("=")[0]).trim().replace(j24, "")).length < 2)
      return "";
    for (; t82.length % 4 != 0; )
      t82 += "=";
    return t82;
  }(t72));
}
function D24(t72, r82, e82, n82) {
  for (var i72 = 0; i72 < n82 && !(i72 + e82 >= r82.length || i72 >= t72.length); ++i72)
    r82[i72 + e82] = t72[i72];
  return i72;
}
function F24(t72, r82) {
  return t72 instanceof r82 || null != t72 && null != t72.constructor && null != t72.constructor.name && t72.constructor.name === r82.name;
}
function N24(t72) {
  return t72 != t72;
}
function t43(r82, e82) {
  for (var n82 in r82)
    e82[n82] = r82[n82];
}
function f43(r82, e82, n82) {
  return o43(r82, e82, n82);
}
function a43(t72) {
  var e82;
  switch (this.encoding = function(t82) {
    var e92 = function(t92) {
      if (!t92)
        return "utf8";
      for (var e102; ; )
        switch (t92) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return t92;
          default:
            if (e102)
              return;
            t92 = ("" + t92).toLowerCase(), e102 = true;
        }
    }(t82);
    if ("string" != typeof e92 && (s43.isEncoding === i43 || !i43(t82)))
      throw new Error("Unknown encoding: " + t82);
    return e92 || t82;
  }(t72), this.encoding) {
    case "utf16le":
      this.text = h43, this.end = l43, e82 = 4;
      break;
    case "utf8":
      this.fillLast = n$124, e82 = 4;
      break;
    case "base64":
      this.text = u$124, this.end = o$124, e82 = 3;
      break;
    default:
      return this.write = f$15, this.end = c43, void 0;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = s43.allocUnsafe(e82);
}
function r43(t72) {
  return t72 <= 127 ? 0 : t72 >> 5 == 6 ? 2 : t72 >> 4 == 14 ? 3 : t72 >> 3 == 30 ? 4 : t72 >> 6 == 2 ? -1 : -2;
}
function n$124(t72) {
  var e82 = this.lastTotal - this.lastNeed, s62 = function(t82, e92, s72) {
    if (128 != (192 & e92[0]))
      return t82.lastNeed = 0, "\uFFFD";
    if (t82.lastNeed > 1 && e92.length > 1) {
      if (128 != (192 & e92[1]))
        return t82.lastNeed = 1, "\uFFFD";
      if (t82.lastNeed > 2 && e92.length > 2 && 128 != (192 & e92[2]))
        return t82.lastNeed = 2, "\uFFFD";
    }
  }(this, t72);
  return void 0 !== s62 ? s62 : this.lastNeed <= t72.length ? (t72.copy(this.lastChar, e82, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t72.copy(this.lastChar, e82, 0, t72.length), this.lastNeed -= t72.length, void 0);
}
function h43(t72, e82) {
  if ((t72.length - e82) % 2 == 0) {
    var s62 = t72.toString("utf16le", e82);
    if (s62) {
      var i72 = s62.charCodeAt(s62.length - 1);
      if (i72 >= 55296 && i72 <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t72[t72.length - 2], this.lastChar[1] = t72[t72.length - 1], s62.slice(0, -1);
    }
    return s62;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t72[t72.length - 1], t72.toString("utf16le", e82, t72.length - 1);
}
function l43(t72) {
  var e82 = t72 && t72.length ? this.write(t72) : "";
  if (this.lastNeed) {
    var s62 = this.lastTotal - this.lastNeed;
    return e82 + this.lastChar.toString("utf16le", 0, s62);
  }
  return e82;
}
function u$124(t72, e82) {
  var s62 = (t72.length - e82) % 3;
  return 0 === s62 ? t72.toString("base64", e82) : (this.lastNeed = 3 - s62, this.lastTotal = 3, 1 === s62 ? this.lastChar[0] = t72[t72.length - 1] : (this.lastChar[0] = t72[t72.length - 2], this.lastChar[1] = t72[t72.length - 1]), t72.toString("base64", e82, t72.length - s62));
}
function o$124(t72) {
  var e82 = t72 && t72.length ? this.write(t72) : "";
  return this.lastNeed ? e82 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e82;
}
function f$15(t72) {
  return t72.toString(this.encoding);
}
function c43(t72) {
  return t72 && t72.length ? this.write(t72) : "";
}
function dew$2$13() {
  if (_dewExec$2$13)
    return exports$2$13;
  _dewExec$2$13 = true;
  exports$2$13.byteLength = byteLength;
  exports$2$13.toByteArray = toByteArray;
  exports$2$13.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i72 = 0, len = code.length; i72 < len; ++i72) {
    lookup[i72] = code[i72];
    revLookup[code.charCodeAt(i72)] = i72;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i82;
    for (i82 = 0; i82 < len2; i82 += 4) {
      tmp = revLookup[b64.charCodeAt(i82)] << 18 | revLookup[b64.charCodeAt(i82 + 1)] << 12 | revLookup[b64.charCodeAt(i82 + 2)] << 6 | revLookup[b64.charCodeAt(i82 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i82)] << 2 | revLookup[b64.charCodeAt(i82 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i82)] << 10 | revLookup[b64.charCodeAt(i82 + 1)] << 4 | revLookup[b64.charCodeAt(i82 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i82 = start; i82 < end; i82 += 3) {
      tmp = (uint8[i82] << 16 & 16711680) + (uint8[i82 + 1] << 8 & 65280) + (uint8[i82 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i82 = 0, len22 = len2 - extraBytes; i82 < len22; i82 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i82, i82 + maxChunkLength > len22 ? len22 : i82 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  return exports$2$13;
}
function dew$1$13() {
  if (_dewExec$1$13)
    return exports$1$13;
  _dewExec$1$13 = true;
  exports$1$13.read = function(buffer22, offset, isLE, mLen, nBytes) {
    var e82, m52;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i72 = isLE ? nBytes - 1 : 0;
    var d52 = isLE ? -1 : 1;
    var s62 = buffer22[offset + i72];
    i72 += d52;
    e82 = s62 & (1 << -nBits) - 1;
    s62 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e82 = e82 * 256 + buffer22[offset + i72], i72 += d52, nBits -= 8) {
    }
    m52 = e82 & (1 << -nBits) - 1;
    e82 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m52 = m52 * 256 + buffer22[offset + i72], i72 += d52, nBits -= 8) {
    }
    if (e82 === 0) {
      e82 = 1 - eBias;
    } else if (e82 === eMax) {
      return m52 ? NaN : (s62 ? -1 : 1) * Infinity;
    } else {
      m52 = m52 + Math.pow(2, mLen);
      e82 = e82 - eBias;
    }
    return (s62 ? -1 : 1) * m52 * Math.pow(2, e82 - mLen);
  };
  exports$1$13.write = function(buffer22, value, offset, isLE, mLen, nBytes) {
    var e82, m52, c72;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i72 = isLE ? 0 : nBytes - 1;
    var d52 = isLE ? 1 : -1;
    var s62 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m52 = isNaN(value) ? 1 : 0;
      e82 = eMax;
    } else {
      e82 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c72 = Math.pow(2, -e82)) < 1) {
        e82--;
        c72 *= 2;
      }
      if (e82 + eBias >= 1) {
        value += rt / c72;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c72 >= 2) {
        e82++;
        c72 /= 2;
      }
      if (e82 + eBias >= eMax) {
        m52 = 0;
        e82 = eMax;
      } else if (e82 + eBias >= 1) {
        m52 = (value * c72 - 1) * Math.pow(2, mLen);
        e82 = e82 + eBias;
      } else {
        m52 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e82 = 0;
      }
    }
    for (; mLen >= 8; buffer22[offset + i72] = m52 & 255, i72 += d52, m52 /= 256, mLen -= 8) {
    }
    e82 = e82 << mLen | m52;
    eLen += mLen;
    for (; eLen > 0; buffer22[offset + i72] = e82 & 255, i72 += d52, e82 /= 256, eLen -= 8) {
    }
    buffer22[offset + i72 - d52] |= s62 * 128;
  };
  return exports$1$13;
}
function dew$g3() {
  if (_dewExec$g3)
    return exports$g4;
  _dewExec$g3 = true;
  const base64 = dew$2$13();
  const ieee754 = dew$1$13();
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$g4.Buffer = Buffer3;
  exports$g4.SlowBuffer = SlowBuffer;
  exports$g4.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$g4.kMaxLength = K_MAX_LENGTH;
  Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e82) {
      return false;
    }
  }
  Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function Buffer3(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer3.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer3.from(valueOf, encodingOrOffset, length);
    }
    const b42 = fromObject(value);
    if (b42)
      return b42;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer3.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer3, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer3.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer3.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer3.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i72 = 0; i72 < length; i72 += 1) {
      buf[i72] = array[i72] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer3.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer3.alloc(+length);
  }
  Buffer3.isBuffer = function isBuffer24(b42) {
    return b42 != null && b42._isBuffer === true && b42 !== Buffer3.prototype;
  };
  Buffer3.compare = function compare(a72, b42) {
    if (isInstance(a72, Uint8Array))
      a72 = Buffer3.from(a72, a72.offset, a72.byteLength);
    if (isInstance(b42, Uint8Array))
      b42 = Buffer3.from(b42, b42.offset, b42.byteLength);
    if (!Buffer3.isBuffer(a72) || !Buffer3.isBuffer(b42)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a72 === b42)
      return 0;
    let x32 = a72.length;
    let y52 = b42.length;
    for (let i72 = 0, len = Math.min(x32, y52); i72 < len; ++i72) {
      if (a72[i72] !== b42[i72]) {
        x32 = a72[i72];
        y52 = b42[i72];
        break;
      }
    }
    if (x32 < y52)
      return -1;
    if (y52 < x32)
      return 1;
    return 0;
  };
  Buffer3.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer3.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer3.alloc(0);
    }
    let i72;
    if (length === void 0) {
      length = 0;
      for (i72 = 0; i72 < list.length; ++i72) {
        length += list[i72].length;
      }
    }
    const buffer22 = Buffer3.allocUnsafe(length);
    let pos = 0;
    for (i72 = 0; i72 < list.length; ++i72) {
      let buf = list[i72];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer22.length) {
          if (!Buffer3.isBuffer(buf))
            buf = Buffer3.from(buf);
          buf.copy(buffer22, pos);
        } else {
          Uint8Array.prototype.set.call(buffer22, buf, pos);
        }
      } else if (!Buffer3.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer22, pos);
      }
      pos += buf.length;
    }
    return buffer22;
  };
  function byteLength(string, encoding) {
    if (Buffer3.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.prototype._isBuffer = true;
  function swap(b42, n82, m52) {
    const i72 = b42[n82];
    b42[n82] = b42[m52];
    b42[m52] = i72;
  }
  Buffer3.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i72 = 0; i72 < len; i72 += 2) {
      swap(this, i72, i72 + 1);
    }
    return this;
  };
  Buffer3.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i72 = 0; i72 < len; i72 += 4) {
      swap(this, i72, i72 + 3);
      swap(this, i72 + 1, i72 + 2);
    }
    return this;
  };
  Buffer3.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i72 = 0; i72 < len; i72 += 8) {
      swap(this, i72, i72 + 7);
      swap(this, i72 + 1, i72 + 6);
      swap(this, i72 + 2, i72 + 5);
      swap(this, i72 + 3, i72 + 4);
    }
    return this;
  };
  Buffer3.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
  Buffer3.prototype.equals = function equals(b42) {
    if (!Buffer3.isBuffer(b42))
      throw new TypeError("Argument must be a Buffer");
    if (this === b42)
      return true;
    return Buffer3.compare(this, b42) === 0;
  };
  Buffer3.prototype.inspect = function inspect24() {
    let str = "";
    const max = exports$g4.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
  }
  Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x32 = thisEnd - thisStart;
    let y52 = end - start;
    const len = Math.min(x32, y52);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i72 = 0; i72 < len; ++i72) {
      if (thisCopy[i72] !== targetCopy[i72]) {
        x32 = thisCopy[i72];
        y52 = targetCopy[i72];
        break;
      }
    }
    if (x32 < y52)
      return -1;
    if (y52 < x32)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer22, val, byteOffset, encoding, dir) {
    if (buffer22.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer22.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer22.length + byteOffset;
    if (byteOffset >= buffer22.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer22.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (Buffer3.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer22, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer22, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer22, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer22, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i82) {
      if (indexSize === 1) {
        return buf[i82];
      } else {
        return buf.readUInt16BE(i82 * indexSize);
      }
    }
    let i72;
    if (dir) {
      let foundIndex = -1;
      for (i72 = byteOffset; i72 < arrLength; i72++) {
        if (read2(arr, i72) === read2(val, foundIndex === -1 ? 0 : i72 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i72;
          if (i72 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i72 -= i72 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i72 = byteOffset; i72 >= 0; i72--) {
        let found = true;
        for (let j32 = 0; j32 < valLength; j32++) {
          if (read2(arr, i72 + j32) !== read2(val, j32)) {
            found = false;
            break;
          }
        }
        if (found)
          return i72;
      }
    }
    return -1;
  }
  Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i72;
    for (i72 = 0; i72 < length; ++i72) {
      const parsed = parseInt(string.substr(i72 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i72;
      buf[offset + i72] = parsed;
    }
    return i72;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer3.prototype.write = function write2(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer3.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i72 = start;
    while (i72 < end) {
      const firstByte = buf[i72];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i72 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i72 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i72 + 1];
            thirdByte = buf[i72 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i72 + 1];
            thirdByte = buf[i72 + 2];
            fourthByte = buf[i72 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i72 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i72 = 0;
    while (i72 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i72, i72 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i72 = start; i72 < end; ++i72) {
      ret += String.fromCharCode(buf[i72] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i72 = start; i72 < end; ++i72) {
      ret += String.fromCharCode(buf[i72]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i72 = start; i72 < end; ++i72) {
      out += hexSliceLookupTable[buf[i72]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i72 = 0; i72 < bytes.length - 1; i72 += 2) {
      res += String.fromCharCode(bytes[i72] + bytes[i72 + 1] * 256);
    }
    return res;
  }
  Buffer3.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i72 = 0;
    while (++i72 < byteLength2 && (mul *= 256)) {
      val += this[offset + i72] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    let val = this[offset + --byteLength2];
    let mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i72 = 0;
    while (++i72 < byteLength2 && (mul *= 256)) {
      val += this[offset + i72] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let i72 = byteLength2;
    let mul = 1;
    let val = this[offset + --i72];
    while (i72 > 0 && (mul *= 256)) {
      val += this[offset + --i72] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer3.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1;
    let i72 = 0;
    this[offset] = value & 255;
    while (++i72 < byteLength2 && (mul *= 256)) {
      this[offset + i72] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i72 = byteLength2 - 1;
    let mul = 1;
    this[offset + i72] = value & 255;
    while (--i72 >= 0 && (mul *= 256)) {
      this[offset + i72] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i72 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i72 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i72 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i72] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i72 = byteLength2 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i72] = value & 255;
    while (--i72 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i72 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i72] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer3.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer3.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code = val.charCodeAt(0);
        if (encoding === "utf8" && code < 128 || encoding === "latin1") {
          val = code;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i72;
    if (typeof val === "number") {
      for (i72 = start; i72 < end; ++i72) {
        this[i72] = val;
      }
    } else {
      const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i72 = 0; i72 < end - start; ++i72) {
        this[i72 + start] = bytes[i72 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E32(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E32("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
    if (name2) {
      return `${name2} is outside of buffer bounds`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E32("ERR_INVALID_ARG_TYPE", function(name2, actual) {
    return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  E32("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i72 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i72 >= start + 4; i72 -= 3) {
      res = `_${val.slice(i72 - 3, i72)}${res}`;
    }
    return `${val.slice(0, i72)}${res}`;
  }
  function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
      boundsError(offset, buf.length - (byteLength2 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
      const n82 = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength2 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n82} and < 2${n82} ** ${(byteLength2 + 1) * 8}${n82}`;
        } else {
          range = `>= -(2${n82} ** ${(byteLength2 + 1) * 8 - 1}${n82}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n82}`;
        }
      } else {
        range = `>= ${min}${n82} and <= ${max}${n82}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", `>= ${type2 ? 1 : 0} and <= ${length}`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i72 = 0; i72 < length; ++i72) {
      codePoint = string.charCodeAt(i72);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i72 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i72 = 0; i72 < str.length; ++i72) {
      byteArray.push(str.charCodeAt(i72) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c72, hi, lo;
    const byteArray = [];
    for (let i72 = 0; i72 < str.length; ++i72) {
      if ((units -= 2) < 0)
        break;
      c72 = str.charCodeAt(i72);
      hi = c72 >> 8;
      lo = c72 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i72;
    for (i72 = 0; i72 < length; ++i72) {
      if (i72 + offset >= dst.length || i72 >= src.length)
        break;
      dst[i72 + offset] = src[i72];
    }
    return i72;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i72 = 0; i72 < 16; ++i72) {
      const i16 = i72 * 16;
      for (let j32 = 0; j32 < 16; ++j32) {
        table[i16 + j32] = alphabet[i72] + alphabet[j32];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
  return exports$g4;
}
function dew$f4() {
  if (_dewExec$f4)
    return exports$f4;
  _dewExec$f4 = true;
  if (typeof Object.create === "function") {
    exports$f4 = function inherits24(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    exports$f4 = function inherits24(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return exports$f4;
}
function dew$e4() {
  if (_dewExec$e4)
    return exports$e4;
  _dewExec$e4 = true;
  exports$e4 = y10.EventEmitter;
  return exports$e4;
}
function dew$d4() {
  if (_dewExec$d4)
    return exports$d4;
  _dewExec$d4 = true;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i72 = 1; i72 < arguments.length; i72++) {
      var source = arguments[i72] != null ? arguments[i72] : {};
      if (i72 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i72 = 0; i72 < props.length; i72++) {
      var descriptor = props[i72];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var _require = buffer3, Buffer3 = _require.Buffer;
  var _require2 = X6, inspect24 = _require2.inspect;
  var custom = inspect24 && inspect24.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer3.prototype.copy.call(src, target, offset);
  }
  exports$d4 = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v52) {
        var entry = {
          data: v52,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v52) {
        var entry = {
          data: v52,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join3(s62) {
        if (this.length === 0)
          return "";
        var p72 = this.head;
        var ret = "" + p72.data;
        while (p72 = p72.next) {
          ret += s62 + p72.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n82) {
        if (this.length === 0)
          return Buffer3.alloc(0);
        var ret = Buffer3.allocUnsafe(n82 >>> 0);
        var p72 = this.head;
        var i72 = 0;
        while (p72) {
          copyBuffer(p72.data, ret, i72);
          i72 += p72.data.length;
          p72 = p72.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n82, hasStrings) {
        var ret;
        if (n82 < this.head.data.length) {
          ret = this.head.data.slice(0, n82);
          this.head.data = this.head.data.slice(n82);
        } else if (n82 === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n82) : this._getBuffer(n82);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n82) {
        var p72 = this.head;
        var c72 = 1;
        var ret = p72.data;
        n82 -= ret.length;
        while (p72 = p72.next) {
          var str = p72.data;
          var nb = n82 > str.length ? str.length : n82;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n82);
          n82 -= nb;
          if (n82 === 0) {
            if (nb === str.length) {
              ++c72;
              if (p72.next)
                this.head = p72.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p72;
              p72.data = str.slice(nb);
            }
            break;
          }
          ++c72;
        }
        this.length -= c72;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n82) {
        var ret = Buffer3.allocUnsafe(n82);
        var p72 = this.head;
        var c72 = 1;
        p72.data.copy(ret);
        n82 -= p72.data.length;
        while (p72 = p72.next) {
          var buf = p72.data;
          var nb = n82 > buf.length ? buf.length : n82;
          buf.copy(ret, ret.length - n82, 0, nb);
          n82 -= nb;
          if (n82 === 0) {
            if (nb === buf.length) {
              ++c72;
              if (p72.next)
                this.head = p72.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p72;
              p72.data = buf.slice(nb);
            }
            break;
          }
          ++c72;
        }
        this.length -= c72;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_32, options) {
        return inspect24(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
  return exports$d4;
}
function dew$c4() {
  if (_dewExec$c4)
    return exports$c4;
  _dewExec$c4 = true;
  var process$1 = process5;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process$1.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process$1.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream.destroy(err);
    else
      stream.emit("error", err);
  }
  exports$c4 = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return exports$c4;
}
function dew$b4() {
  if (_dewExec$b4)
    return exports$b4;
  _dewExec$b4 = true;
  const codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i72) => String(i72));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
    return 'The value "' + value + '" is invalid for option "' + name2 + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name2, " argument")) {
      msg = `The ${name2} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type2 = includes(name2, ".") ? "property" : "argument";
      msg = `The "${name2}" ${type2} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
    return "The " + name2 + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name2) {
    return "Cannot call " + name2 + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  exports$b4.codes = codes;
  return exports$b4;
}
function dew$a4() {
  if (_dewExec$a4)
    return exports$a4;
  _dewExec$a4 = true;
  var ERR_INVALID_OPT_VALUE = dew$b4().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name2 = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name2, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  }
  exports$a4 = {
    getHighWaterMark
  };
  return exports$a4;
}
function dew$94() {
  if (_dewExec$94)
    return exports$94;
  _dewExec$94 = true;
  exports$94 = deprecate24;
  function deprecate24(fn, msg) {
    if (config("noDeprecation")) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config("throwDeprecation")) {
          throw new Error(msg);
        } else if (config("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this || _global$24, arguments);
    }
    return deprecated;
  }
  function config(name2) {
    try {
      if (!_global$24.localStorage)
        return false;
    } catch (_32) {
      return false;
    }
    var val = _global$24.localStorage[name2];
    if (null == val)
      return false;
    return String(val).toLowerCase() === "true";
  }
  return exports$94;
}
function dew$84() {
  if (_dewExec$84)
    return exports$84;
  _dewExec$84 = true;
  var process$1 = process5;
  exports$84 = Writable3;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var Duplex3;
  Writable3.WritableState = WritableState;
  var internalUtil = {
    deprecate: dew$94()
  };
  var Stream3 = dew$e4();
  var Buffer3 = buffer3.Buffer;
  var OurUint8Array = _global$14.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer3.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = dew$c4();
  var _require = dew$a4(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = dew$b4().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  dew$f4()(Writable3, Stream3);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex3 = Duplex3 || dew$74();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex3;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_32) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable3, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable3)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable3(options) {
    Duplex3 = Duplex3 || dew$74();
    var isDuplex = this instanceof Duplex3;
    if (!isDuplex && !realHasInstance.call(Writable3, this))
      return new Writable3(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream3.call(this);
  }
  Writable3.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process$1.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable3.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer3.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable3.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable3.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable3.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable3.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer3.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable3.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev2, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev2)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      process$1.nextTick(cb, er);
      process$1.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished3 = needFinish(state) || stream.destroyed;
      if (!finished3 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        process$1.nextTick(afterWrite, stream, state, finished3, cb);
      } else {
        afterWrite(stream, state, finished3, cb);
      }
    }
  }
  function afterWrite(stream, state, finished3, cb) {
    if (!finished3)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l72 = state.bufferedRequestCount;
      var buffer22 = new Array(l72);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer22[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer22.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer22, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable3.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable3.prototype._writev = null;
  Writable3.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable3.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process$1.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
        if (state.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        process$1.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable3.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable3.prototype.destroy = destroyImpl.destroy;
  Writable3.prototype._undestroy = destroyImpl.undestroy;
  Writable3.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return exports$84;
}
function dew$74() {
  if (_dewExec$74)
    return exports$74;
  _dewExec$74 = true;
  var process$1 = process5;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  exports$74 = Duplex3;
  var Readable3 = dew$34();
  var Writable3 = dew$84();
  dew$f4()(Duplex3, Readable3);
  {
    var keys = objectKeys(Writable3.prototype);
    for (var v52 = 0; v52 < keys.length; v52++) {
      var method = keys[v52];
      if (!Duplex3.prototype[method])
        Duplex3.prototype[method] = Writable3.prototype[method];
    }
  }
  function Duplex3(options) {
    if (!(this instanceof Duplex3))
      return new Duplex3(options);
    Readable3.call(this, options);
    Writable3.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex3.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex3.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex3.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process$1.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex3.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return exports$74;
}
function dew$64() {
  if (_dewExec$64)
    return exports$64;
  _dewExec$64 = true;
  var ERR_STREAM_PREMATURE_CLOSE = dew$b4().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once4(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts2, callback) {
    if (typeof opts2 === "function")
      return eos(stream, null, opts2);
    if (!opts2)
      opts2 = {};
    callback = once4(callback || noop);
    var readable = opts2.readable || opts2.readable !== false && stream.readable;
    var writable = opts2.writable || opts2.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable)
        onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts2.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  exports$64 = eos;
  return exports$64;
}
function dew$54() {
  if (_dewExec$54)
    return exports$54;
  _dewExec$54 = true;
  var process$1 = process5;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var finished3 = dew$64();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult2(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve23 = iter[kLastResolve];
    if (resolve23 !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve23(createIterResult2(data, false));
      }
    }
  }
  function onReadable(iter) {
    process$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve23, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve23(createIterResult2(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve23, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult2(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve23, reject) {
          process$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve23(createIterResult2(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult2(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve23, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve23(createIterResult2(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve23, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve23(createIterResult2(data, false));
        } else {
          iterator[kLastResolve] = resolve23;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished3(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve23 = iterator[kLastResolve];
      if (resolve23 !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve23(createIterResult2(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  exports$54 = createReadableStreamAsyncIterator;
  return exports$54;
}
function dew$44() {
  if (_dewExec$44)
    return exports$44;
  _dewExec$44 = true;
  exports$44 = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return exports$44;
}
function dew$34() {
  if (_dewExec$34)
    return exports$35;
  _dewExec$34 = true;
  var process$1 = process5;
  exports$35 = Readable3;
  var Duplex3;
  Readable3.ReadableState = ReadableState;
  y10.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream3 = dew$e4();
  var Buffer3 = buffer3.Buffer;
  var OurUint8Array = _global24.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer3.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = X6;
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList = dew$d4();
  var destroyImpl = dew$c4();
  var _require = dew$a4(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = dew$b4().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  dew$f4()(Readable3, Stream3);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex3 = Duplex3 || dew$74();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex3;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = e$124.StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable3(options) {
    Duplex3 = Duplex3 || dew$74();
    if (!(this instanceof Readable3))
      return new Readable3(options);
    var isDuplex = this instanceof Duplex3;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream3.call(this);
  }
  Object.defineProperty(Readable3.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable3.prototype.destroy = destroyImpl.destroy;
  Readable3.prototype._undestroy = destroyImpl.undestroy;
  Readable3.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable3.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer3.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable3.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable3.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable3.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = e$124.StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p72 = this._readableState.buffer.head;
    var content = "";
    while (p72 !== null) {
      content += decoder.write(p72.data);
      p72 = p72.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n82) {
    if (n82 >= MAX_HWM) {
      n82 = MAX_HWM;
    } else {
      n82--;
      n82 |= n82 >>> 1;
      n82 |= n82 >>> 2;
      n82 |= n82 >>> 4;
      n82 |= n82 >>> 8;
      n82 |= n82 >>> 16;
      n82++;
    }
    return n82;
  }
  function howMuchToRead(n82, state) {
    if (n82 <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n82 !== n82) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n82 > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n82);
    if (n82 <= state.length)
      return n82;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable3.prototype.read = function(n82) {
    debug("read", n82);
    n82 = parseInt(n82, 10);
    var state = this._readableState;
    var nOrig = n82;
    if (n82 !== 0)
      state.emittedReadable = false;
    if (n82 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n82 = howMuchToRead(n82, state);
    if (n82 === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n82 < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n82 = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n82 > 0)
      ret = fromList(n82, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n82 = 0;
    } else {
      state.length -= n82;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n82 && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process$1.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process$1.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable3.prototype._read = function(n82) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable3.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process$1.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable3.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i72 = 0; i72 < len; i72++) {
        dests[i72].emit("unpipe", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable3.prototype.on = function(ev, fn) {
    var res = Stream3.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process$1.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable3.prototype.addListener = Readable3.prototype.on;
  Readable3.prototype.removeListener = function(ev, fn) {
    var res = Stream3.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable3.prototype.removeAllListeners = function(ev) {
    var res = Stream3.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable3.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process$1.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable3.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
  }
  Readable3.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i72 in stream) {
      if (this[i72] === void 0 && typeof stream[i72] === "function") {
        this[i72] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i72);
      }
    }
    for (var n82 = 0; n82 < kProxyEvents.length; n82++) {
      stream.on(kProxyEvents[n82], this.emit.bind(this, kProxyEvents[n82]));
    }
    this._read = function(n92) {
      debug("wrapped _read", n92);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable3.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = dew$54();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable3.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable3.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable3.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable3._fromList = fromList;
  Object.defineProperty(Readable3.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.length;
    }
  });
  function fromList(n82, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n82 || n82 >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n82, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process$1.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable3.from = function(iterable, opts2) {
      if (from === void 0) {
        from = dew$44();
      }
      return from(Readable3, iterable, opts2);
    };
  }
  function indexOf(xs, x32) {
    for (var i72 = 0, l72 = xs.length; i72 < l72; i72++) {
      if (xs[i72] === x32)
        return i72;
    }
    return -1;
  }
  return exports$35;
}
function dew$25() {
  if (_dewExec$25)
    return exports$25;
  _dewExec$25 = true;
  exports$25 = Transform3;
  var _require$codes = dew$b4().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex3 = dew$74();
  dew$f4()(Transform3, Duplex3);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform3(options) {
    if (!(this instanceof Transform3))
      return new Transform3(options);
    Duplex3.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform3.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex3.prototype.push.call(this, chunk, encoding);
  };
  Transform3.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform3.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform3.prototype._read = function(n82) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform3.prototype._destroy = function(err, cb) {
    Duplex3.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
  return exports$25;
}
function dew$15() {
  if (_dewExec$15)
    return exports$17;
  _dewExec$15 = true;
  exports$17 = PassThrough3;
  var Transform3 = dew$25();
  dew$f4()(PassThrough3, Transform3);
  function PassThrough3(options) {
    if (!(this instanceof PassThrough3))
      return new PassThrough3(options);
    Transform3.call(this, options);
  }
  PassThrough3.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return exports$17;
}
function dew24() {
  if (_dewExec24)
    return exports24;
  _dewExec24 = true;
  var eos;
  function once4(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = dew$b4().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop(err) {
    if (err)
      throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once4(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0)
      eos = dew$64();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream))
        return stream.abort();
      if (typeof stream.destroy === "function")
        return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length)
      return noop;
    if (typeof streams[streams.length - 1] !== "function")
      return noop;
    return streams.pop();
  }
  function pipeline3() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i72) {
      var reading = i72 < streams.length - 1;
      var writing = i72 > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  exports24 = pipeline3;
  return exports24;
}
function dew34() {
  if (_dewExec34)
    return exports34;
  _dewExec34 = true;
  exports34 = exports34 = dew$34();
  exports34.Stream = exports34;
  exports34.Readable = exports34;
  exports34.Writable = dew$84();
  exports34.Duplex = dew$74();
  exports34.Transform = dew$25();
  exports34.PassThrough = dew$15();
  exports34.finished = dew$64();
  exports34.pipeline = dew24();
  return exports34;
}
function i52(t72) {
  throw new RangeError(r52[t72]);
}
function f52(t72, o82) {
  const n82 = t72.split("@");
  let r82 = "";
  n82.length > 1 && (r82 = n82[0] + "@", t72 = n82[1]);
  const c72 = function(t82, o92) {
    const n92 = [];
    let e82 = t82.length;
    for (; e82--; )
      n92[e82] = o92(t82[e82]);
    return n92;
  }((t72 = t72.replace(e52, ".")).split("."), o82).join(".");
  return r82 + c72;
}
function l52(t72) {
  const o82 = [];
  let n82 = 0;
  const e82 = t72.length;
  for (; n82 < e82; ) {
    const r82 = t72.charCodeAt(n82++);
    if (r82 >= 55296 && r82 <= 56319 && n82 < e82) {
      const e92 = t72.charCodeAt(n82++);
      56320 == (64512 & e92) ? o82.push(((1023 & r82) << 10) + (1023 & e92) + 65536) : (o82.push(r82), n82--);
    } else
      o82.push(r82);
  }
  return o82;
}
function e62(e82, n82) {
  return Object.prototype.hasOwnProperty.call(e82, n82);
}
function dew43() {
  if (_dewExec43)
    return exports$124;
  _dewExec43 = true;
  var process$1 = process5;
  function assertPath(path22) {
    if (typeof path22 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path22));
    }
  }
  function normalizeStringPosix(path22, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i72 = 0; i72 <= path22.length; ++i72) {
      if (i72 < path22.length)
        code = path22.charCodeAt(i72);
      else if (code === 47)
        break;
      else
        code = 47;
      if (code === 47) {
        if (lastSlash === i72 - 1 || dots === 1)
          ;
        else if (lastSlash !== i72 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i72;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i72;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += "/..";
            else
              res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path22.slice(lastSlash + 1, i72);
          else
            res = path22.slice(lastSlash + 1, i72);
          lastSegmentLength = i72 - lastSlash - 1;
        }
        lastSlash = i72;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep3, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep3 + base;
  }
  var posix3 = {
    // path.resolve([from ...], to)
    resolve: function resolve23() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd;
      for (var i72 = arguments.length - 1; i72 >= -1 && !resolvedAbsolute; i72--) {
        var path22;
        if (i72 >= 0)
          path22 = arguments[i72];
        else {
          if (cwd === void 0)
            cwd = process$1.cwd();
          path22 = cwd;
        }
        assertPath(path22);
        if (path22.length === 0) {
          continue;
        }
        resolvedPath = path22 + "/" + resolvedPath;
        resolvedAbsolute = path22.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return "/" + resolvedPath;
        else
          return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize3(path22) {
      assertPath(path22);
      if (path22.length === 0)
        return ".";
      var isAbsolute3 = path22.charCodeAt(0) === 47;
      var trailingSeparator = path22.charCodeAt(path22.length - 1) === 47;
      path22 = normalizeStringPosix(path22, !isAbsolute3);
      if (path22.length === 0 && !isAbsolute3)
        path22 = ".";
      if (path22.length > 0 && trailingSeparator)
        path22 += "/";
      if (isAbsolute3)
        return "/" + path22;
      return path22;
    },
    isAbsolute: function isAbsolute3(path22) {
      assertPath(path22);
      return path22.length > 0 && path22.charCodeAt(0) === 47;
    },
    join: function join3() {
      if (arguments.length === 0)
        return ".";
      var joined;
      for (var i72 = 0; i72 < arguments.length; ++i72) {
        var arg = arguments[i72];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += "/" + arg;
        }
      }
      if (joined === void 0)
        return ".";
      return posix3.normalize(joined);
    },
    relative: function relative3(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to)
        return "";
      from = posix3.resolve(from);
      to = posix3.resolve(to);
      if (from === to)
        return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i72 = 0;
      for (; i72 <= length; ++i72) {
        if (i72 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i72) === 47) {
              return to.slice(toStart + i72 + 1);
            } else if (i72 === 0) {
              return to.slice(toStart + i72);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i72) === 47) {
              lastCommonSep = i72;
            } else if (i72 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i72);
        var toCode = to.charCodeAt(toStart + i72);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i72;
      }
      var out = "";
      for (i72 = fromStart + lastCommonSep + 1; i72 <= fromEnd; ++i72) {
        if (i72 === fromEnd || from.charCodeAt(i72) === 47) {
          if (out.length === 0)
            out += "..";
          else
            out += "/..";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong3(path22) {
      return path22;
    },
    dirname: function dirname3(path22) {
      assertPath(path22);
      if (path22.length === 0)
        return ".";
      var code = path22.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i72 = path22.length - 1; i72 >= 1; --i72) {
        code = path22.charCodeAt(i72);
        if (code === 47) {
          if (!matchedSlash) {
            end = i72;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : ".";
      if (hasRoot && end === 1)
        return "//";
      return path22.slice(0, end);
    },
    basename: function basename3(path22, ext) {
      if (ext !== void 0 && typeof ext !== "string")
        throw new TypeError('"ext" argument must be a string');
      assertPath(path22);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i72;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path22.length) {
        if (ext.length === path22.length && ext === path22)
          return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i72 = path22.length - 1; i72 >= 0; --i72) {
          var code = path22.charCodeAt(i72);
          if (code === 47) {
            if (!matchedSlash) {
              start = i72 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i72 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i72;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path22.length;
        return path22.slice(start, end);
      } else {
        for (i72 = path22.length - 1; i72 >= 0; --i72) {
          if (path22.charCodeAt(i72) === 47) {
            if (!matchedSlash) {
              start = i72 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i72 + 1;
          }
        }
        if (end === -1)
          return "";
        return path22.slice(start, end);
      }
    },
    extname: function extname3(path22) {
      assertPath(path22);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i72 = path22.length - 1; i72 >= 0; --i72) {
        var code = path22.charCodeAt(i72);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i72 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i72 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i72;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path22.slice(startDot, end);
    },
    format: function format32(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse23(path22) {
      assertPath(path22);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path22.length === 0)
        return ret;
      var code = path22.charCodeAt(0);
      var isAbsolute3 = code === 47;
      var start;
      if (isAbsolute3) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i72 = path22.length - 1;
      var preDotState = 0;
      for (; i72 >= start; --i72) {
        code = path22.charCodeAt(i72);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i72 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i72 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i72;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute3)
            ret.base = ret.name = path22.slice(1, end);
          else
            ret.base = ret.name = path22.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute3) {
          ret.name = path22.slice(1, startDot);
          ret.base = path22.slice(1, end);
        } else {
          ret.name = path22.slice(startPart, startDot);
          ret.base = path22.slice(startPart, end);
        }
        ret.ext = path22.slice(startDot, end);
      }
      if (startPart > 0)
        ret.dir = path22.slice(0, startPart - 1);
      else if (isAbsolute3)
        ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix3.posix = posix3;
  exports$124 = posix3;
  return exports$124;
}
function r72() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
function O32(t72, s62, h72) {
  if (t72 && a62.isObject(t72) && t72 instanceof r72)
    return t72;
  var e82 = new r72();
  return e82.parse(t72, s62, h72), e82;
}
function dew52() {
  if (_dewExec52)
    return exports52;
  _dewExec52 = true;
  var process22 = T8;
  function assertPath(path22) {
    if (typeof path22 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path22));
    }
  }
  function normalizeStringPosix(path22, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i72 = 0; i72 <= path22.length; ++i72) {
      if (i72 < path22.length)
        code = path22.charCodeAt(i72);
      else if (code === 47)
        break;
      else
        code = 47;
      if (code === 47) {
        if (lastSlash === i72 - 1 || dots === 1)
          ;
        else if (lastSlash !== i72 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i72;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i72;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += "/..";
            else
              res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path22.slice(lastSlash + 1, i72);
          else
            res = path22.slice(lastSlash + 1, i72);
          lastSegmentLength = i72 - lastSlash - 1;
        }
        lastSlash = i72;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep3, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep3 + base;
  }
  var posix3 = {
    // path.resolve([from ...], to)
    resolve: function resolve23() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd;
      for (var i72 = arguments.length - 1; i72 >= -1 && !resolvedAbsolute; i72--) {
        var path22;
        if (i72 >= 0)
          path22 = arguments[i72];
        else {
          if (cwd === void 0)
            cwd = process22.cwd();
          path22 = cwd;
        }
        assertPath(path22);
        if (path22.length === 0) {
          continue;
        }
        resolvedPath = path22 + "/" + resolvedPath;
        resolvedAbsolute = path22.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return "/" + resolvedPath;
        else
          return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize3(path22) {
      assertPath(path22);
      if (path22.length === 0)
        return ".";
      var isAbsolute3 = path22.charCodeAt(0) === 47;
      var trailingSeparator = path22.charCodeAt(path22.length - 1) === 47;
      path22 = normalizeStringPosix(path22, !isAbsolute3);
      if (path22.length === 0 && !isAbsolute3)
        path22 = ".";
      if (path22.length > 0 && trailingSeparator)
        path22 += "/";
      if (isAbsolute3)
        return "/" + path22;
      return path22;
    },
    isAbsolute: function isAbsolute3(path22) {
      assertPath(path22);
      return path22.length > 0 && path22.charCodeAt(0) === 47;
    },
    join: function join3() {
      if (arguments.length === 0)
        return ".";
      var joined;
      for (var i72 = 0; i72 < arguments.length; ++i72) {
        var arg = arguments[i72];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += "/" + arg;
        }
      }
      if (joined === void 0)
        return ".";
      return posix3.normalize(joined);
    },
    relative: function relative3(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to)
        return "";
      from = posix3.resolve(from);
      to = posix3.resolve(to);
      if (from === to)
        return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i72 = 0;
      for (; i72 <= length; ++i72) {
        if (i72 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i72) === 47) {
              return to.slice(toStart + i72 + 1);
            } else if (i72 === 0) {
              return to.slice(toStart + i72);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i72) === 47) {
              lastCommonSep = i72;
            } else if (i72 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i72);
        var toCode = to.charCodeAt(toStart + i72);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i72;
      }
      var out = "";
      for (i72 = fromStart + lastCommonSep + 1; i72 <= fromEnd; ++i72) {
        if (i72 === fromEnd || from.charCodeAt(i72) === 47) {
          if (out.length === 0)
            out += "..";
          else
            out += "/..";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong3(path22) {
      return path22;
    },
    dirname: function dirname3(path22) {
      assertPath(path22);
      if (path22.length === 0)
        return ".";
      var code = path22.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i72 = path22.length - 1; i72 >= 1; --i72) {
        code = path22.charCodeAt(i72);
        if (code === 47) {
          if (!matchedSlash) {
            end = i72;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : ".";
      if (hasRoot && end === 1)
        return "//";
      return path22.slice(0, end);
    },
    basename: function basename3(path22, ext) {
      if (ext !== void 0 && typeof ext !== "string")
        throw new TypeError('"ext" argument must be a string');
      assertPath(path22);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i72;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path22.length) {
        if (ext.length === path22.length && ext === path22)
          return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i72 = path22.length - 1; i72 >= 0; --i72) {
          var code = path22.charCodeAt(i72);
          if (code === 47) {
            if (!matchedSlash) {
              start = i72 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i72 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i72;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path22.length;
        return path22.slice(start, end);
      } else {
        for (i72 = path22.length - 1; i72 >= 0; --i72) {
          if (path22.charCodeAt(i72) === 47) {
            if (!matchedSlash) {
              start = i72 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i72 + 1;
          }
        }
        if (end === -1)
          return "";
        return path22.slice(start, end);
      }
    },
    extname: function extname3(path22) {
      assertPath(path22);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i72 = path22.length - 1; i72 >= 0; --i72) {
        var code = path22.charCodeAt(i72);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i72 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i72 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i72;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path22.slice(startDot, end);
    },
    format: function format32(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse23(path22) {
      assertPath(path22);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path22.length === 0)
        return ret;
      var code = path22.charCodeAt(0);
      var isAbsolute3 = code === 47;
      var start;
      if (isAbsolute3) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i72 = path22.length - 1;
      var preDotState = 0;
      for (; i72 >= start; --i72) {
        code = path22.charCodeAt(i72);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i72 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i72 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i72;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute3)
            ret.base = ret.name = path22.slice(1, end);
          else
            ret.base = ret.name = path22.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute3) {
          ret.name = path22.slice(1, startDot);
          ret.base = path22.slice(1, end);
        } else {
          ret.name = path22.slice(startPart, startDot);
          ret.base = path22.slice(startPart, end);
        }
        ret.ext = path22.slice(startDot, end);
      }
      if (startPart > 0)
        ret.dir = path22.slice(0, startPart - 1);
      else if (isAbsolute3)
        ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix3.posix = posix3;
  exports52 = posix3;
  return exports52;
}
function fileURLToPath$12(path22) {
  if (typeof path22 === "string")
    path22 = new URL(path22);
  else if (!(path22 instanceof URL)) {
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path22.protocol !== "file:") {
    throw new Deno.errors.InvalidData("invalid url scheme");
  }
  return isWindows$12 ? getPathFromURLWin$12(path22) : getPathFromURLPosix$12(path22);
}
function getPathFromURLWin$12(url) {
  const hostname2 = url.hostname;
  let pathname = url.pathname;
  for (let n82 = 0; n82 < pathname.length; n82++) {
    if (pathname[n82] === "%") {
      const third = pathname.codePointAt(n82 + 2) || 32;
      if (pathname[n82 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n82 + 1] === "5" && third === 99) {
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx$12, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname2 !== "") {
    return `\\\\${hostname2}${pathname}`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep3 = pathname[2];
    if (letter < CHAR_LOWERCASE_A$12 || letter > CHAR_LOWERCASE_Z$12 || // a..z A..Z
    sep3 !== ":") {
      throw new Deno.errors.InvalidData("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix$12(url) {
  if (url.hostname !== "") {
    throw new Deno.errors.InvalidData("invalid file url hostname");
  }
  const pathname = url.pathname;
  for (let n82 = 0; n82 < pathname.length; n82++) {
    if (pathname[n82] === "%") {
      const third = pathname.codePointAt(n82 + 2) || 32;
      if (pathname[n82 + 1] === "2" && third === 102) {
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL$12(filepath) {
  let resolved = path2.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH$12 || isWindows$12 && filePathLast === CHAR_BACKWARD_SLASH$12) && resolved[resolved.length - 1] !== path2.sep) {
    resolved += "/";
  }
  const outURL = new URL("file://");
  if (resolved.includes("%"))
    resolved = resolved.replace(percentRegEx$12, "%25");
  if (!isWindows$12 && resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx$12, "%5C");
  }
  if (resolved.includes("\n"))
    resolved = resolved.replace(newlineRegEx$12, "%0A");
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx$12, "%0D");
  }
  if (resolved.includes("	"))
    resolved = resolved.replace(tabRegEx$12, "%09");
  outURL.pathname = resolved;
  return outURL;
}
function fileURLToPath2(path22) {
  if (typeof path22 === "string")
    path22 = new URL(path22);
  else if (!(path22 instanceof URL)) {
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path22.protocol !== "file:") {
    throw new Deno.errors.InvalidData("invalid url scheme");
  }
  return isWindows2 ? getPathFromURLWin2(path22) : getPathFromURLPosix2(path22);
}
function getPathFromURLWin2(url) {
  const hostname2 = url.hostname;
  let pathname = url.pathname;
  for (let n82 = 0; n82 < pathname.length; n82++) {
    if (pathname[n82] === "%") {
      const third = pathname.codePointAt(n82 + 2) || 32;
      if (pathname[n82 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n82 + 1] === "5" && third === 99) {
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx2, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname2 !== "") {
    return `\\\\${hostname2}${pathname}`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep3 = pathname[2];
    if (letter < CHAR_LOWERCASE_A2 || letter > CHAR_LOWERCASE_Z2 || // a..z A..Z
    sep3 !== ":") {
      throw new Deno.errors.InvalidData("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix2(url) {
  if (url.hostname !== "") {
    throw new Deno.errors.InvalidData("invalid file url hostname");
  }
  const pathname = url.pathname;
  for (let n82 = 0; n82 < pathname.length; n82++) {
    if (pathname[n82] === "%") {
      const third = pathname.codePointAt(n82 + 2) || 32;
      if (pathname[n82 + 1] === "2" && third === 102) {
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL2(filepath) {
  let resolved = exports43.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH2 || isWindows2 && filePathLast === CHAR_BACKWARD_SLASH2) && resolved[resolved.length - 1] !== exports43.sep) {
    resolved += "/";
  }
  const outURL = new URL("file://");
  if (resolved.includes("%"))
    resolved = resolved.replace(percentRegEx2, "%25");
  if (!isWindows2 && resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx2, "%5C");
  }
  if (resolved.includes("\n"))
    resolved = resolved.replace(newlineRegEx2, "%0A");
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx2, "%0D");
  }
  if (resolved.includes("	"))
    resolved = resolved.replace(tabRegEx2, "%09");
  outURL.pathname = resolved;
  return outURL;
}
function dew$522() {
  if (_dewExec$522)
    return exports$622;
  _dewExec$522 = true;
  exports$622.fetch = isFunction24(_global$32.fetch) && isFunction24(_global$32.ReadableStream);
  exports$622.writableStream = isFunction24(_global$32.WritableStream);
  exports$622.abortController = isFunction24(_global$32.AbortController);
  var xhr;
  function getXHR() {
    if (xhr !== void 0)
      return xhr;
    if (_global$32.XMLHttpRequest) {
      xhr = new _global$32.XMLHttpRequest();
      try {
        xhr.open("GET", _global$32.XDomainRequest ? "/" : "https://example.com");
      } catch (e82) {
        xhr = null;
      }
    } else {
      xhr = null;
    }
    return xhr;
  }
  function checkTypeSupport(type2) {
    var xhr2 = getXHR();
    if (!xhr2)
      return false;
    try {
      xhr2.responseType = type2;
      return xhr2.responseType === type2;
    } catch (e82) {
    }
    return false;
  }
  exports$622.arraybuffer = exports$622.fetch || checkTypeSupport("arraybuffer");
  exports$622.msstream = !exports$622.fetch && checkTypeSupport("ms-stream");
  exports$622.mozchunkedarraybuffer = !exports$622.fetch && checkTypeSupport("moz-chunked-arraybuffer");
  exports$622.overrideMimeType = exports$622.fetch || (getXHR() ? isFunction24(getXHR().overrideMimeType) : false);
  function isFunction24(value) {
    return typeof value === "function";
  }
  xhr = null;
  return exports$622;
}
function dew$422() {
  if (_dewExec$422)
    return exports$522;
  _dewExec$422 = true;
  var Buffer3 = buffer3.Buffer;
  var process$1 = process5;
  var capability = dew$522();
  var inherits24 = dew$f4();
  var stream = dew34();
  var rStates = exports$522.readyStates = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
  };
  var IncomingMessage2 = exports$522.IncomingMessage = function(xhr, response, mode, resetTimers) {
    var self2 = this || _global$222;
    stream.Readable.call(self2);
    self2._mode = mode;
    self2.headers = {};
    self2.rawHeaders = [];
    self2.trailers = {};
    self2.rawTrailers = [];
    self2.on("end", function() {
      process$1.nextTick(function() {
        self2.emit("close");
      });
    });
    if (mode === "fetch") {
      let read2 = function() {
        reader.read().then(function(result) {
          if (self2._destroyed)
            return;
          resetTimers(result.done);
          if (result.done) {
            self2.push(null);
            return;
          }
          self2.push(Buffer3.from(result.value));
          read2();
        }).catch(function(err) {
          resetTimers(true);
          if (!self2._destroyed)
            self2.emit("error", err);
        });
      };
      self2._fetchResponse = response;
      self2.url = response.url;
      self2.statusCode = response.status;
      self2.statusMessage = response.statusText;
      response.headers.forEach(function(header, key) {
        self2.headers[key.toLowerCase()] = header;
        self2.rawHeaders.push(key, header);
      });
      if (capability.writableStream) {
        var writable = new WritableStream({
          write: function(chunk) {
            resetTimers(false);
            return new Promise(function(resolve23, reject) {
              if (self2._destroyed) {
                reject();
              } else if (self2.push(Buffer3.from(chunk))) {
                resolve23();
              } else {
                self2._resumeFetch = resolve23;
              }
            });
          },
          close: function() {
            resetTimers(true);
            if (!self2._destroyed)
              self2.push(null);
          },
          abort: function(err) {
            resetTimers(true);
            if (!self2._destroyed)
              self2.emit("error", err);
          }
        });
        try {
          response.body.pipeTo(writable).catch(function(err) {
            resetTimers(true);
            if (!self2._destroyed)
              self2.emit("error", err);
          });
          return;
        } catch (e82) {
        }
      }
      var reader = response.body.getReader();
      read2();
    } else {
      self2._xhr = xhr;
      self2._pos = 0;
      self2.url = xhr.responseURL;
      self2.statusCode = xhr.status;
      self2.statusMessage = xhr.statusText;
      var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
      headers.forEach(function(header) {
        var matches = header.match(/^([^:]+):\s*(.*)/);
        if (matches) {
          var key = matches[1].toLowerCase();
          if (key === "set-cookie") {
            if (self2.headers[key] === void 0) {
              self2.headers[key] = [];
            }
            self2.headers[key].push(matches[2]);
          } else if (self2.headers[key] !== void 0) {
            self2.headers[key] += ", " + matches[2];
          } else {
            self2.headers[key] = matches[2];
          }
          self2.rawHeaders.push(matches[1], matches[2]);
        }
      });
      self2._charset = "x-user-defined";
      if (!capability.overrideMimeType) {
        var mimeType = self2.rawHeaders["mime-type"];
        if (mimeType) {
          var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
          if (charsetMatch) {
            self2._charset = charsetMatch[1].toLowerCase();
          }
        }
        if (!self2._charset)
          self2._charset = "utf-8";
      }
    }
  };
  inherits24(IncomingMessage2, stream.Readable);
  IncomingMessage2.prototype._read = function() {
    var self2 = this || _global$222;
    var resolve23 = self2._resumeFetch;
    if (resolve23) {
      self2._resumeFetch = null;
      resolve23();
    }
  };
  IncomingMessage2.prototype._onXHRProgress = function(resetTimers) {
    var self2 = this || _global$222;
    var xhr = self2._xhr;
    var response = null;
    switch (self2._mode) {
      case "text":
        response = xhr.responseText;
        if (response.length > self2._pos) {
          var newData = response.substr(self2._pos);
          if (self2._charset === "x-user-defined") {
            var buffer22 = Buffer3.alloc(newData.length);
            for (var i72 = 0; i72 < newData.length; i72++)
              buffer22[i72] = newData.charCodeAt(i72) & 255;
            self2.push(buffer22);
          } else {
            self2.push(newData, self2._charset);
          }
          self2._pos = response.length;
        }
        break;
      case "arraybuffer":
        if (xhr.readyState !== rStates.DONE || !xhr.response)
          break;
        response = xhr.response;
        self2.push(Buffer3.from(new Uint8Array(response)));
        break;
      case "moz-chunked-arraybuffer":
        response = xhr.response;
        if (xhr.readyState !== rStates.LOADING || !response)
          break;
        self2.push(Buffer3.from(new Uint8Array(response)));
        break;
      case "ms-stream":
        response = xhr.response;
        if (xhr.readyState !== rStates.LOADING)
          break;
        var reader = new _global$222.MSStreamReader();
        reader.onprogress = function() {
          if (reader.result.byteLength > self2._pos) {
            self2.push(Buffer3.from(new Uint8Array(reader.result.slice(self2._pos))));
            self2._pos = reader.result.byteLength;
          }
        };
        reader.onload = function() {
          resetTimers(true);
          self2.push(null);
        };
        reader.readAsArrayBuffer(response);
        break;
    }
    if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
      resetTimers(true);
      self2.push(null);
    }
  };
  return exports$522;
}
function dew$322() {
  if (_dewExec$322)
    return exports$422;
  _dewExec$322 = true;
  var Buffer3 = buffer3.Buffer;
  var process$1 = process5;
  var capability = dew$522();
  var inherits24 = dew$f4();
  var response = dew$422();
  var stream = dew34();
  var IncomingMessage2 = response.IncomingMessage;
  var rStates = response.readyStates;
  function decideMode(preferBinary, useFetch) {
    if (capability.fetch && useFetch) {
      return "fetch";
    } else if (capability.mozchunkedarraybuffer) {
      return "moz-chunked-arraybuffer";
    } else if (capability.msstream) {
      return "ms-stream";
    } else if (capability.arraybuffer && preferBinary) {
      return "arraybuffer";
    } else {
      return "text";
    }
  }
  var ClientRequest2 = exports$422 = function(opts2) {
    var self2 = this || _global$122;
    stream.Writable.call(self2);
    self2._opts = opts2;
    self2._body = [];
    self2._headers = {};
    if (opts2.auth)
      self2.setHeader("Authorization", "Basic " + Buffer3.from(opts2.auth).toString("base64"));
    Object.keys(opts2.headers).forEach(function(name2) {
      self2.setHeader(name2, opts2.headers[name2]);
    });
    var preferBinary;
    var useFetch = true;
    if (opts2.mode === "disable-fetch" || "requestTimeout" in opts2 && !capability.abortController) {
      useFetch = false;
      preferBinary = true;
    } else if (opts2.mode === "prefer-streaming") {
      preferBinary = false;
    } else if (opts2.mode === "allow-wrong-content-type") {
      preferBinary = !capability.overrideMimeType;
    } else if (!opts2.mode || opts2.mode === "default" || opts2.mode === "prefer-fast") {
      preferBinary = true;
    } else {
      throw new Error("Invalid value for opts.mode");
    }
    self2._mode = decideMode(preferBinary, useFetch);
    self2._fetchTimer = null;
    self2._socketTimeout = null;
    self2._socketTimer = null;
    self2.on("finish", function() {
      self2._onFinish();
    });
  };
  inherits24(ClientRequest2, stream.Writable);
  ClientRequest2.prototype.setHeader = function(name2, value) {
    var self2 = this || _global$122;
    var lowerName = name2.toLowerCase();
    if (unsafeHeaders.indexOf(lowerName) !== -1)
      return;
    self2._headers[lowerName] = {
      name: name2,
      value
    };
  };
  ClientRequest2.prototype.getHeader = function(name2) {
    var header = (this || _global$122)._headers[name2.toLowerCase()];
    if (header)
      return header.value;
    return null;
  };
  ClientRequest2.prototype.removeHeader = function(name2) {
    var self2 = this || _global$122;
    delete self2._headers[name2.toLowerCase()];
  };
  ClientRequest2.prototype._onFinish = function() {
    var self2 = this || _global$122;
    if (self2._destroyed)
      return;
    var opts2 = self2._opts;
    if ("timeout" in opts2 && opts2.timeout !== 0) {
      self2.setTimeout(opts2.timeout);
    }
    var headersObj = self2._headers;
    var body = null;
    if (opts2.method !== "GET" && opts2.method !== "HEAD") {
      body = new Blob(self2._body, {
        type: (headersObj["content-type"] || {}).value || ""
      });
    }
    var headersList = [];
    Object.keys(headersObj).forEach(function(keyName) {
      var name2 = headersObj[keyName].name;
      var value = headersObj[keyName].value;
      if (Array.isArray(value)) {
        value.forEach(function(v52) {
          headersList.push([name2, v52]);
        });
      } else {
        headersList.push([name2, value]);
      }
    });
    if (self2._mode === "fetch") {
      var signal = null;
      if (capability.abortController) {
        var controller = new AbortController();
        signal = controller.signal;
        self2._fetchAbortController = controller;
        if ("requestTimeout" in opts2 && opts2.requestTimeout !== 0) {
          self2._fetchTimer = _global$122.setTimeout(function() {
            self2.emit("requestTimeout");
            if (self2._fetchAbortController)
              self2._fetchAbortController.abort();
          }, opts2.requestTimeout);
        }
      }
      _global$122.fetch(self2._opts.url, {
        method: self2._opts.method,
        headers: headersList,
        body: body || void 0,
        mode: "cors",
        credentials: opts2.withCredentials ? "include" : "same-origin",
        signal
      }).then(function(response2) {
        self2._fetchResponse = response2;
        self2._resetTimers(false);
        self2._connect();
      }, function(reason) {
        self2._resetTimers(true);
        if (!self2._destroyed)
          self2.emit("error", reason);
      });
    } else {
      var xhr = self2._xhr = new _global$122.XMLHttpRequest();
      try {
        xhr.open(self2._opts.method, self2._opts.url, true);
      } catch (err) {
        process$1.nextTick(function() {
          self2.emit("error", err);
        });
        return;
      }
      if ("responseType" in xhr)
        xhr.responseType = self2._mode;
      if ("withCredentials" in xhr)
        xhr.withCredentials = !!opts2.withCredentials;
      if (self2._mode === "text" && "overrideMimeType" in xhr)
        xhr.overrideMimeType("text/plain; charset=x-user-defined");
      if ("requestTimeout" in opts2) {
        xhr.timeout = opts2.requestTimeout;
        xhr.ontimeout = function() {
          self2.emit("requestTimeout");
        };
      }
      headersList.forEach(function(header) {
        xhr.setRequestHeader(header[0], header[1]);
      });
      self2._response = null;
      xhr.onreadystatechange = function() {
        switch (xhr.readyState) {
          case rStates.LOADING:
          case rStates.DONE:
            self2._onXHRProgress();
            break;
        }
      };
      if (self2._mode === "moz-chunked-arraybuffer") {
        xhr.onprogress = function() {
          self2._onXHRProgress();
        };
      }
      xhr.onerror = function() {
        if (self2._destroyed)
          return;
        self2._resetTimers(true);
        self2.emit("error", new Error("XHR error"));
      };
      try {
        xhr.send(body);
      } catch (err) {
        process$1.nextTick(function() {
          self2.emit("error", err);
        });
        return;
      }
    }
  };
  function statusValid(xhr) {
    try {
      var status = xhr.status;
      return status !== null && status !== 0;
    } catch (e82) {
      return false;
    }
  }
  ClientRequest2.prototype._onXHRProgress = function() {
    var self2 = this || _global$122;
    self2._resetTimers(false);
    if (!statusValid(self2._xhr) || self2._destroyed)
      return;
    if (!self2._response)
      self2._connect();
    self2._response._onXHRProgress(self2._resetTimers.bind(self2));
  };
  ClientRequest2.prototype._connect = function() {
    var self2 = this || _global$122;
    if (self2._destroyed)
      return;
    self2._response = new IncomingMessage2(self2._xhr, self2._fetchResponse, self2._mode, self2._resetTimers.bind(self2));
    self2._response.on("error", function(err) {
      self2.emit("error", err);
    });
    self2.emit("response", self2._response);
  };
  ClientRequest2.prototype._write = function(chunk, encoding, cb) {
    var self2 = this || _global$122;
    self2._body.push(chunk);
    cb();
  };
  ClientRequest2.prototype._resetTimers = function(done) {
    var self2 = this || _global$122;
    _global$122.clearTimeout(self2._socketTimer);
    self2._socketTimer = null;
    if (done) {
      _global$122.clearTimeout(self2._fetchTimer);
      self2._fetchTimer = null;
    } else if (self2._socketTimeout) {
      self2._socketTimer = _global$122.setTimeout(function() {
        self2.emit("timeout");
      }, self2._socketTimeout);
    }
  };
  ClientRequest2.prototype.abort = ClientRequest2.prototype.destroy = function(err) {
    var self2 = this || _global$122;
    self2._destroyed = true;
    self2._resetTimers(true);
    if (self2._response)
      self2._response._destroyed = true;
    if (self2._xhr)
      self2._xhr.abort();
    else if (self2._fetchAbortController)
      self2._fetchAbortController.abort();
    if (err)
      self2.emit("error", err);
  };
  ClientRequest2.prototype.end = function(data, encoding, cb) {
    var self2 = this || _global$122;
    if (typeof data === "function") {
      cb = data;
      data = void 0;
    }
    stream.Writable.prototype.end.call(self2, data, encoding, cb);
  };
  ClientRequest2.prototype.setTimeout = function(timeout, cb) {
    var self2 = this || _global$122;
    if (cb)
      self2.once("timeout", cb);
    self2._socketTimeout = timeout;
    self2._resetTimers(false);
  };
  ClientRequest2.prototype.flushHeaders = function() {
  };
  ClientRequest2.prototype.setNoDelay = function() {
  };
  ClientRequest2.prototype.setSocketKeepAlive = function() {
  };
  var unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
  return exports$422;
}
function dew$222() {
  if (_dewExec$222)
    return exports$322;
  _dewExec$222 = true;
  exports$322 = extend;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function extend() {
    var target = {};
    for (var i72 = 0; i72 < arguments.length; i72++) {
      var source = arguments[i72];
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
  return exports$322;
}
function dew$122() {
  if (_dewExec$122)
    return exports$222;
  _dewExec$122 = true;
  exports$222 = {
    "100": "Continue",
    "101": "Switching Protocols",
    "102": "Processing",
    "200": "OK",
    "201": "Created",
    "202": "Accepted",
    "203": "Non-Authoritative Information",
    "204": "No Content",
    "205": "Reset Content",
    "206": "Partial Content",
    "207": "Multi-Status",
    "208": "Already Reported",
    "226": "IM Used",
    "300": "Multiple Choices",
    "301": "Moved Permanently",
    "302": "Found",
    "303": "See Other",
    "304": "Not Modified",
    "305": "Use Proxy",
    "307": "Temporary Redirect",
    "308": "Permanent Redirect",
    "400": "Bad Request",
    "401": "Unauthorized",
    "402": "Payment Required",
    "403": "Forbidden",
    "404": "Not Found",
    "405": "Method Not Allowed",
    "406": "Not Acceptable",
    "407": "Proxy Authentication Required",
    "408": "Request Timeout",
    "409": "Conflict",
    "410": "Gone",
    "411": "Length Required",
    "412": "Precondition Failed",
    "413": "Payload Too Large",
    "414": "URI Too Long",
    "415": "Unsupported Media Type",
    "416": "Range Not Satisfiable",
    "417": "Expectation Failed",
    "418": "I'm a teapot",
    "421": "Misdirected Request",
    "422": "Unprocessable Entity",
    "423": "Locked",
    "424": "Failed Dependency",
    "425": "Unordered Collection",
    "426": "Upgrade Required",
    "428": "Precondition Required",
    "429": "Too Many Requests",
    "431": "Request Header Fields Too Large",
    "451": "Unavailable For Legal Reasons",
    "500": "Internal Server Error",
    "501": "Not Implemented",
    "502": "Bad Gateway",
    "503": "Service Unavailable",
    "504": "Gateway Timeout",
    "505": "HTTP Version Not Supported",
    "506": "Variant Also Negotiates",
    "507": "Insufficient Storage",
    "508": "Loop Detected",
    "509": "Bandwidth Limit Exceeded",
    "510": "Not Extended",
    "511": "Network Authentication Required"
  };
  return exports$222;
}
function dew62() {
  if (_dewExec62)
    return exports$133;
  _dewExec62 = true;
  var ClientRequest2 = dew$322();
  var response = dew$422();
  var extend = dew$222();
  var statusCodes = dew$122();
  var url = h62;
  var http = exports$133;
  http.request = function(opts2, cb) {
    if (typeof opts2 === "string")
      opts2 = url.parse(opts2);
    else
      opts2 = extend(opts2);
    var defaultProtocol = _global33.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
    var protocol = opts2.protocol || defaultProtocol;
    var host = opts2.hostname || opts2.host;
    var port = opts2.port;
    var path22 = opts2.path || "/";
    if (host && host.indexOf(":") !== -1)
      host = "[" + host + "]";
    opts2.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path22;
    opts2.method = (opts2.method || "GET").toUpperCase();
    opts2.headers = opts2.headers || {};
    var req = new ClientRequest2(opts2);
    if (cb)
      req.on("response", cb);
    return req;
  };
  http.get = function get2(opts2, cb) {
    var req = http.request(opts2, cb);
    req.end();
    return req;
  };
  http.ClientRequest = ClientRequest2;
  http.IncomingMessage = response.IncomingMessage;
  http.Agent = function() {
  };
  http.Agent.defaultMaxSockets = 4;
  http.globalAgent = new http.Agent();
  http.STATUS_CODES = statusCodes;
  http.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
  return exports$133;
}
var e13, t12, n13, r13, i12, s11, y10, e25, t25, n25, r25, o25, l25, s25, f25, a25, T8, t34, e34, o34, n34, r34, l34, t$17, o$17, n$17, e$17, r$17, c34, u34, i34, t$26, i$17, o$27, u$17, f34, a34, s34, p34, y24, l$17, d25, m25, h34, j7, A7, Q6, X6, Y7, ee5, te5, re5, ne5, ie5, Se5, Ee5, _extend5, callbackify5, debuglog5, deprecate5, format7, inherits5, inspect5, isArray5, isBoolean5, isBuffer5, isDate5, isError5, isFunction5, isNull5, isNullOrUndefined5, isNumber5, isObject5, isPrimitive5, isRegExp5, isString5, isSymbol5, isUndefined5, log5, promisify5, types5, TextEncoder5, TextDecoder6, exports9, _dewExec9, _global6, process5, r$124, t$124, e$25, n$25, o$224, a$15, h$15, a$1$13, e$1$13, n$1$13, i$124, o$1$13, j24, Y24, e43, n43, o43, u43, e$124, s43, i43, exports$2$13, _dewExec$2$13, exports$1$13, _dewExec$1$13, exports$g4, _dewExec$g3, buffer3, exports$f4, _dewExec$f4, exports$e4, _dewExec$e4, exports$d4, _dewExec$d4, exports$c4, _dewExec$c4, exports$b4, _dewExec$b4, exports$a4, _dewExec$a4, exports$94, _dewExec$94, _global$24, exports$84, _dewExec$84, _global$14, exports$74, _dewExec$74, exports$64, _dewExec$64, exports$54, _dewExec$54, exports$44, _dewExec$44, exports$35, _dewExec$34, _global24, exports$25, _dewExec$25, exports$17, _dewExec$15, exports24, _dewExec24, exports34, _dewExec34, t52, o52, n52, e52, r52, c52, s52, u52, a52, d42, h52, p52, n62, r62, t62, o62, exports$124, _dewExec43, exports43, h62, e72, a62, o72, n72, i62, l62, p62, c62, u62, f62, m42, v42, g32, y42, b32, exports52, _dewExec52, path2, processPlatform$12, CHAR_BACKWARD_SLASH$12, CHAR_FORWARD_SLASH$12, CHAR_LOWERCASE_A$12, CHAR_LOWERCASE_Z$12, isWindows$12, forwardSlashRegEx$12, percentRegEx$12, backslashRegEx$12, newlineRegEx$12, carriageReturnRegEx$12, tabRegEx$12, processPlatform2, Url2, format25, resolve3, resolveObject2, parse3, _URL2, CHAR_BACKWARD_SLASH2, CHAR_FORWARD_SLASH2, CHAR_LOWERCASE_A2, CHAR_LOWERCASE_Z2, isWindows2, forwardSlashRegEx2, percentRegEx2, backslashRegEx2, newlineRegEx2, carriageReturnRegEx2, tabRegEx2, exports$622, _dewExec$522, _global$32, exports$522, _dewExec$422, _global$222, exports$422, _dewExec$322, _global$122, exports$322, _dewExec$222, exports$222, _dewExec$122, exports$133, _dewExec62, _global33, exports62, Agent, ClientRequest, IncomingMessage, METHODS, STATUS_CODES, get, globalAgent, request;
var init_http = __esm({
  "node-modules-polyfills:http"() {
    n13 = "object" == typeof Reflect ? Reflect : null;
    r13 = n13 && "function" == typeof n13.apply ? n13.apply : function(e82, t72, n82) {
      return Function.prototype.apply.call(e82, t72, n82);
    };
    t12 = n13 && "function" == typeof n13.ownKeys ? n13.ownKeys : Object.getOwnPropertySymbols ? function(e82) {
      return Object.getOwnPropertyNames(e82).concat(Object.getOwnPropertySymbols(e82));
    } : function(e82) {
      return Object.getOwnPropertyNames(e82);
    };
    i12 = Number.isNaN || function(e82) {
      return e82 != e82;
    };
    e13 = o13, o13.EventEmitter = o13, o13.prototype._events = void 0, o13.prototype._eventsCount = 0, o13.prototype._maxListeners = void 0;
    s11 = 10;
    Object.defineProperty(o13, "defaultMaxListeners", { enumerable: true, get: function() {
      return s11;
    }, set: function(e82) {
      if ("number" != typeof e82 || e82 < 0 || i12(e82))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e82 + ".");
      s11 = e82;
    } }), o13.init = function() {
      void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    }, o13.prototype.setMaxListeners = function(e82) {
      if ("number" != typeof e82 || e82 < 0 || i12(e82))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e82 + ".");
      return this._maxListeners = e82, this;
    }, o13.prototype.getMaxListeners = function() {
      return f12(this);
    }, o13.prototype.emit = function(e82) {
      for (var t72 = [], n82 = 1; n82 < arguments.length; n82++)
        t72.push(arguments[n82]);
      var i72 = "error" === e82, o82 = this._events;
      if (void 0 !== o82)
        i72 = i72 && void 0 === o82.error;
      else if (!i72)
        return false;
      if (i72) {
        var s62;
        if (t72.length > 0 && (s62 = t72[0]), s62 instanceof Error)
          throw s62;
        var u72 = new Error("Unhandled error." + (s62 ? " (" + s62.message + ")" : ""));
        throw u72.context = s62, u72;
      }
      var f72 = o82[e82];
      if (void 0 === f72)
        return false;
      if ("function" == typeof f72)
        r13(f72, this, t72);
      else {
        var v52 = f72.length, a72 = c12(f72, v52);
        for (n82 = 0; n82 < v52; ++n82)
          r13(a72[n82], this, t72);
      }
      return true;
    }, o13.prototype.addListener = function(e82, t72) {
      return v10(this, e82, t72, false);
    }, o13.prototype.on = o13.prototype.addListener, o13.prototype.prependListener = function(e82, t72) {
      return v10(this, e82, t72, true);
    }, o13.prototype.once = function(e82, t72) {
      return u12(t72), this.on(e82, l12(this, e82, t72)), this;
    }, o13.prototype.prependOnceListener = function(e82, t72) {
      return u12(t72), this.prependListener(e82, l12(this, e82, t72)), this;
    }, o13.prototype.removeListener = function(e82, t72) {
      var n82, r82, i72, o82, s62;
      if (u12(t72), void 0 === (r82 = this._events))
        return this;
      if (void 0 === (n82 = r82[e82]))
        return this;
      if (n82 === t72 || n82.listener === t72)
        0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r82[e82], r82.removeListener && this.emit("removeListener", e82, n82.listener || t72));
      else if ("function" != typeof n82) {
        for (i72 = -1, o82 = n82.length - 1; o82 >= 0; o82--)
          if (n82[o82] === t72 || n82[o82].listener === t72) {
            s62 = n82[o82].listener, i72 = o82;
            break;
          }
        if (i72 < 0)
          return this;
        0 === i72 ? n82.shift() : !function(e92, t82) {
          for (; t82 + 1 < e92.length; t82++)
            e92[t82] = e92[t82 + 1];
          e92.pop();
        }(n82, i72), 1 === n82.length && (r82[e82] = n82[0]), void 0 !== r82.removeListener && this.emit("removeListener", e82, s62 || t72);
      }
      return this;
    }, o13.prototype.off = o13.prototype.removeListener, o13.prototype.removeAllListeners = function(e82) {
      var t72, n82, r82;
      if (void 0 === (n82 = this._events))
        return this;
      if (void 0 === n82.removeListener)
        return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n82[e82] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n82[e82]), this;
      if (0 === arguments.length) {
        var i72, o82 = Object.keys(n82);
        for (r82 = 0; r82 < o82.length; ++r82)
          "removeListener" !== (i72 = o82[r82]) && this.removeAllListeners(i72);
        return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
      }
      if ("function" == typeof (t72 = n82[e82]))
        this.removeListener(e82, t72);
      else if (void 0 !== t72)
        for (r82 = t72.length - 1; r82 >= 0; r82--)
          this.removeListener(e82, t72[r82]);
      return this;
    }, o13.prototype.listeners = function(e82) {
      return h12(this, e82, true);
    }, o13.prototype.rawListeners = function(e82) {
      return h12(this, e82, false);
    }, o13.listenerCount = function(e82, t72) {
      return "function" == typeof e82.listenerCount ? e82.listenerCount(t72) : p12.call(e82, t72);
    }, o13.prototype.listenerCount = p12, o13.prototype.eventNames = function() {
      return this._eventsCount > 0 ? t12(this._events) : [];
    };
    y10 = e13;
    y10.EventEmitter;
    y10.defaultMaxListeners;
    y10.init;
    y10.listenerCount;
    y10.EventEmitter;
    y10.defaultMaxListeners;
    y10.init;
    y10.listenerCount;
    r25 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis;
    o25 = e25 = {};
    !function() {
      try {
        t25 = "function" == typeof setTimeout ? setTimeout : i25;
      } catch (e82) {
        t25 = i25;
      }
      try {
        n25 = "function" == typeof clearTimeout ? clearTimeout : u25;
      } catch (e82) {
        n25 = u25;
      }
    }();
    s25 = [];
    f25 = false;
    a25 = -1;
    o25.nextTick = function(e82) {
      var t72 = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var n82 = 1; n82 < arguments.length; n82++)
          t72[n82 - 1] = arguments[n82];
      s25.push(new m9(e82, t72)), 1 !== s25.length || f25 || c25(d9);
    }, m9.prototype.run = function() {
      (this || r25).fun.apply(null, (this || r25).array);
    }, o25.title = "browser", o25.browser = true, o25.env = {}, o25.argv = [], o25.version = "", o25.versions = {}, o25.on = p25, o25.addListener = p25, o25.once = p25, o25.off = p25, o25.removeListener = p25, o25.removeAllListeners = p25, o25.emit = p25, o25.prependListener = p25, o25.prependOnceListener = p25, o25.listeners = function(e82) {
      return [];
    }, o25.binding = function(e82) {
      throw new Error("process.binding is not supported");
    }, o25.cwd = function() {
      return "/";
    }, o25.chdir = function(e82) {
      throw new Error("process.chdir is not supported");
    }, o25.umask = function() {
      return 0;
    };
    T8 = e25;
    T8.addListener;
    T8.argv;
    T8.binding;
    T8.browser;
    T8.chdir;
    T8.cwd;
    T8.emit;
    T8.env;
    T8.listeners;
    T8.nextTick;
    T8.off;
    T8.on;
    T8.once;
    T8.prependListener;
    T8.prependOnceListener;
    T8.removeAllListeners;
    T8.removeListener;
    T8.title;
    T8.umask;
    T8.version;
    T8.versions;
    t34 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
    e34 = Object.prototype.toString;
    o34 = function(o82) {
      return !(t34 && o82 && "object" == typeof o82 && Symbol.toStringTag in o82) && "[object Arguments]" === e34.call(o82);
    };
    n34 = function(t72) {
      return !!o34(t72) || null !== t72 && "object" == typeof t72 && "number" == typeof t72.length && t72.length >= 0 && "[object Array]" !== e34.call(t72) && "[object Function]" === e34.call(t72.callee);
    };
    r34 = function() {
      return o34(arguments);
    }();
    o34.isLegacyArguments = n34;
    l34 = r34 ? o34 : n34;
    t$17 = Object.prototype.toString;
    o$17 = Function.prototype.toString;
    n$17 = /^\s*(?:function)?\*/;
    e$17 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
    r$17 = Object.getPrototypeOf;
    c34 = function() {
      if (!e$17)
        return false;
      try {
        return Function("return function*() {}")();
      } catch (t72) {
      }
    }();
    u34 = c34 ? r$17(c34) : {};
    i34 = function(c72) {
      return "function" == typeof c72 && (!!n$17.test(o$17.call(c72)) || (e$17 ? r$17(c72) === u34 : "[object GeneratorFunction]" === t$17.call(c72)));
    };
    t$26 = "function" == typeof Object.create ? function(t72, e82) {
      e82 && (t72.super_ = e82, t72.prototype = Object.create(e82.prototype, { constructor: { value: t72, enumerable: false, writable: true, configurable: true } }));
    } : function(t72, e82) {
      if (e82) {
        t72.super_ = e82;
        var o82 = function() {
        };
        o82.prototype = e82.prototype, t72.prototype = new o82(), t72.prototype.constructor = t72;
      }
    };
    i$17 = function(e82) {
      return e82 && "object" == typeof e82 && "function" == typeof e82.copy && "function" == typeof e82.fill && "function" == typeof e82.readUInt8;
    };
    o$27 = {};
    u$17 = i$17;
    f34 = l34;
    a34 = i34;
    s34 = "undefined" != typeof BigInt;
    p34 = "undefined" != typeof Symbol;
    y24 = p34 && void 0 !== Symbol.toStringTag;
    l$17 = "undefined" != typeof Uint8Array;
    d25 = "undefined" != typeof ArrayBuffer;
    if (l$17 && y24)
      var g8 = Object.getPrototypeOf(Uint8Array.prototype), b8 = c$17(Object.getOwnPropertyDescriptor(g8, Symbol.toStringTag).get);
    m25 = c$17(Object.prototype.toString);
    h34 = c$17(Number.prototype.valueOf);
    j7 = c$17(String.prototype.valueOf);
    A7 = c$17(Boolean.prototype.valueOf);
    if (s34)
      var w7 = c$17(BigInt.prototype.valueOf);
    if (p34)
      var v24 = c$17(Symbol.prototype.valueOf);
    o$27.isArgumentsObject = f34, o$27.isGeneratorFunction = a34, o$27.isPromise = function(e82) {
      return "undefined" != typeof Promise && e82 instanceof Promise || null !== e82 && "object" == typeof e82 && "function" == typeof e82.then && "function" == typeof e82.catch;
    }, o$27.isArrayBufferView = function(e82) {
      return d25 && ArrayBuffer.isView ? ArrayBuffer.isView(e82) : S7(e82) || R7(e82);
    }, o$27.isTypedArray = S7, o$27.isUint8Array = B7, o$27.isUint8ClampedArray = k7, o$27.isUint16Array = E7, o$27.isUint32Array = D7, o$27.isInt8Array = U7, o$27.isInt16Array = P7, o$27.isInt32Array = x7, o$27.isFloat32Array = I7, o$27.isFloat64Array = M7, o$27.isBigInt64Array = z7, o$27.isBigUint64Array = F7, T25.working = "undefined" != typeof Map && T25(/* @__PURE__ */ new Map()), o$27.isMap = function(e82) {
      return "undefined" != typeof Map && (T25.working ? T25(e82) : e82 instanceof Map);
    }, N7.working = "undefined" != typeof Set && N7(/* @__PURE__ */ new Set()), o$27.isSet = function(e82) {
      return "undefined" != typeof Set && (N7.working ? N7(e82) : e82 instanceof Set);
    }, W6.working = "undefined" != typeof WeakMap && W6(/* @__PURE__ */ new WeakMap()), o$27.isWeakMap = function(e82) {
      return "undefined" != typeof WeakMap && (W6.working ? W6(e82) : e82 instanceof WeakMap);
    }, $6.working = "undefined" != typeof WeakSet && $6(/* @__PURE__ */ new WeakSet()), o$27.isWeakSet = function(e82) {
      return $6(e82);
    }, C7.working = "undefined" != typeof ArrayBuffer && C7(new ArrayBuffer()), o$27.isArrayBuffer = V6, G6.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && G6(new DataView(new ArrayBuffer(1), 0, 1)), o$27.isDataView = R7, J6.working = "undefined" != typeof SharedArrayBuffer && J6(new SharedArrayBuffer()), o$27.isSharedArrayBuffer = _7, o$27.isAsyncFunction = function(e82) {
      return "[object AsyncFunction]" === m25(e82);
    }, o$27.isMapIterator = function(e82) {
      return "[object Map Iterator]" === m25(e82);
    }, o$27.isSetIterator = function(e82) {
      return "[object Set Iterator]" === m25(e82);
    }, o$27.isGeneratorObject = function(e82) {
      return "[object Generator]" === m25(e82);
    }, o$27.isWebAssemblyCompiledModule = function(e82) {
      return "[object WebAssembly.Module]" === m25(e82);
    }, o$27.isNumberObject = H6, o$27.isStringObject = Z6, o$27.isBooleanObject = q6, o$27.isBigIntObject = K6, o$27.isSymbolObject = L7, o$27.isBoxedPrimitive = function(e82) {
      return H6(e82) || Z6(e82) || q6(e82) || K6(e82) || L7(e82);
    }, o$27.isAnyArrayBuffer = function(e82) {
      return l$17 && (V6(e82) || _7(e82));
    }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e82) {
      Object.defineProperty(o$27, e82, { enumerable: false, value: function() {
        throw new Error(e82 + " is not supported in userland");
      } });
    });
    Q6 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis;
    X6 = {};
    Y7 = T8;
    ee5 = Object.getOwnPropertyDescriptors || function(e82) {
      for (var t72 = Object.keys(e82), r82 = {}, n82 = 0; n82 < t72.length; n82++)
        r82[t72[n82]] = Object.getOwnPropertyDescriptor(e82, t72[n82]);
      return r82;
    };
    te5 = /%[sdj%]/g;
    X6.format = function(e82) {
      if (!ge5(e82)) {
        for (var t72 = [], r82 = 0; r82 < arguments.length; r82++)
          t72.push(oe5(arguments[r82]));
        return t72.join(" ");
      }
      r82 = 1;
      for (var n82 = arguments, i72 = n82.length, o82 = String(e82).replace(te5, function(e92) {
        if ("%%" === e92)
          return "%";
        if (r82 >= i72)
          return e92;
        switch (e92) {
          case "%s":
            return String(n82[r82++]);
          case "%d":
            return Number(n82[r82++]);
          case "%j":
            try {
              return JSON.stringify(n82[r82++]);
            } catch (e102) {
              return "[Circular]";
            }
          default:
            return e92;
        }
      }), u72 = n82[r82]; r82 < i72; u72 = n82[++r82])
        le5(u72) || !he5(u72) ? o82 += " " + u72 : o82 += " " + oe5(u72);
      return o82;
    }, X6.deprecate = function(e82, t72) {
      if (void 0 !== Y7 && true === Y7.noDeprecation)
        return e82;
      if (void 0 === Y7)
        return function() {
          return X6.deprecate(e82, t72).apply(this || Q6, arguments);
        };
      var r82 = false;
      return function() {
        if (!r82) {
          if (Y7.throwDeprecation)
            throw new Error(t72);
          Y7.traceDeprecation ? console.trace(t72) : console.error(t72), r82 = true;
        }
        return e82.apply(this || Q6, arguments);
      };
    };
    re5 = {};
    ne5 = /^$/;
    if (Y7.env.NODE_DEBUG) {
      ie5 = Y7.env.NODE_DEBUG;
      ie5 = ie5.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne5 = new RegExp("^" + ie5 + "$", "i");
    }
    X6.debuglog = function(e82) {
      if (e82 = e82.toUpperCase(), !re5[e82])
        if (ne5.test(e82)) {
          var t72 = Y7.pid;
          re5[e82] = function() {
            var r82 = X6.format.apply(X6, arguments);
            console.error("%s %d: %s", e82, t72, r82);
          };
        } else
          re5[e82] = function() {
          };
      return re5[e82];
    }, X6.inspect = oe5, oe5.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe5.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X6.types = o$27, X6.isArray = pe5, X6.isBoolean = ye5, X6.isNull = le5, X6.isNullOrUndefined = function(e82) {
      return null == e82;
    }, X6.isNumber = de5, X6.isString = ge5, X6.isSymbol = function(e82) {
      return "symbol" == typeof e82;
    }, X6.isUndefined = be5, X6.isRegExp = me5, X6.types.isRegExp = me5, X6.isObject = he5, X6.isDate = je5, X6.types.isDate = je5, X6.isError = Ae5, X6.types.isNativeError = Ae5, X6.isFunction = we5, X6.isPrimitive = function(e82) {
      return null === e82 || "boolean" == typeof e82 || "number" == typeof e82 || "string" == typeof e82 || "symbol" == typeof e82 || void 0 === e82;
    }, X6.isBuffer = i$17;
    Se5 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    X6.log = function() {
      console.log("%s - %s", Be5(), X6.format.apply(X6, arguments));
    }, X6.inherits = t$26, X6._extend = function(e82, t72) {
      if (!t72 || !he5(t72))
        return e82;
      for (var r82 = Object.keys(t72), n82 = r82.length; n82--; )
        e82[r82[n82]] = t72[r82[n82]];
      return e82;
    };
    Ee5 = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
    X6.promisify = function(e82) {
      if ("function" != typeof e82)
        throw new TypeError('The "original" argument must be of type Function');
      if (Ee5 && e82[Ee5]) {
        var t72;
        if ("function" != typeof (t72 = e82[Ee5]))
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(t72, Ee5, { value: t72, enumerable: false, writable: false, configurable: true }), t72;
      }
      function t72() {
        for (var t82, r82, n82 = new Promise(function(e92, n92) {
          t82 = e92, r82 = n92;
        }), i72 = [], o82 = 0; o82 < arguments.length; o82++)
          i72.push(arguments[o82]);
        i72.push(function(e92, n92) {
          e92 ? r82(e92) : t82(n92);
        });
        try {
          e82.apply(this || Q6, i72);
        } catch (e92) {
          r82(e92);
        }
        return n82;
      }
      return Object.setPrototypeOf(t72, Object.getPrototypeOf(e82)), Ee5 && Object.defineProperty(t72, Ee5, { value: t72, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t72, ee5(e82));
    }, X6.promisify.custom = Ee5, X6.callbackify = function(e82) {
      if ("function" != typeof e82)
        throw new TypeError('The "original" argument must be of type Function');
      function t72() {
        for (var t82 = [], r82 = 0; r82 < arguments.length; r82++)
          t82.push(arguments[r82]);
        var n82 = t82.pop();
        if ("function" != typeof n82)
          throw new TypeError("The last argument must be of type Function");
        var i72 = this || Q6, o82 = function() {
          return n82.apply(i72, arguments);
        };
        e82.apply(this || Q6, t82).then(function(e92) {
          Y7.nextTick(o82.bind(null, null, e92));
        }, function(e92) {
          Y7.nextTick(De5.bind(null, e92, o82));
        });
      }
      return Object.setPrototypeOf(t72, Object.getPrototypeOf(e82)), Object.defineProperties(t72, ee5(e82)), t72;
    };
    X6._extend;
    X6.callbackify;
    X6.debuglog;
    X6.deprecate;
    X6.format;
    X6.inherits;
    X6.inspect;
    X6.isArray;
    X6.isBoolean;
    X6.isBuffer;
    X6.isDate;
    X6.isError;
    X6.isFunction;
    X6.isNull;
    X6.isNullOrUndefined;
    X6.isNumber;
    X6.isObject;
    X6.isPrimitive;
    X6.isRegExp;
    X6.isString;
    X6.isSymbol;
    X6.isUndefined;
    X6.log;
    X6.promisify;
    _extend5 = X6._extend;
    callbackify5 = X6.callbackify;
    debuglog5 = X6.debuglog;
    deprecate5 = X6.deprecate;
    format7 = X6.format;
    inherits5 = X6.inherits;
    inspect5 = X6.inspect;
    isArray5 = X6.isArray;
    isBoolean5 = X6.isBoolean;
    isBuffer5 = X6.isBuffer;
    isDate5 = X6.isDate;
    isError5 = X6.isError;
    isFunction5 = X6.isFunction;
    isNull5 = X6.isNull;
    isNullOrUndefined5 = X6.isNullOrUndefined;
    isNumber5 = X6.isNumber;
    isObject5 = X6.isObject;
    isPrimitive5 = X6.isPrimitive;
    isRegExp5 = X6.isRegExp;
    isString5 = X6.isString;
    isSymbol5 = X6.isSymbol;
    isUndefined5 = X6.isUndefined;
    log5 = X6.log;
    promisify5 = X6.promisify;
    types5 = X6.types;
    TextEncoder5 = self.TextEncoder;
    TextDecoder6 = self.TextDecoder;
    exports9 = {};
    _dewExec9 = false;
    _global6 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    process5 = dew9();
    process5.platform = "browser";
    process5.addListener;
    process5.argv;
    process5.binding;
    process5.browser;
    process5.chdir;
    process5.cwd;
    process5.emit;
    process5.env;
    process5.listeners;
    process5.nextTick;
    process5.off;
    process5.on;
    process5.once;
    process5.prependListener;
    process5.prependOnceListener;
    process5.removeAllListeners;
    process5.removeListener;
    process5.title;
    process5.umask;
    process5.version;
    process5.versions;
    for (r$124 = { byteLength: function(r82) {
      var t72 = u$25(r82), e82 = t72[0], n82 = t72[1];
      return 3 * (e82 + n82) / 4 - n82;
    }, toByteArray: function(r82) {
      var t72, o82, a72 = u$25(r82), h72 = a72[0], c72 = a72[1], d52 = new n$25(function(r92, t82, e82) {
        return 3 * (t82 + e82) / 4 - e82;
      }(0, h72, c72)), f72 = 0, A32 = c72 > 0 ? h72 - 4 : h72;
      for (o82 = 0; o82 < A32; o82 += 4)
        t72 = e$25[r82.charCodeAt(o82)] << 18 | e$25[r82.charCodeAt(o82 + 1)] << 12 | e$25[r82.charCodeAt(o82 + 2)] << 6 | e$25[r82.charCodeAt(o82 + 3)], d52[f72++] = t72 >> 16 & 255, d52[f72++] = t72 >> 8 & 255, d52[f72++] = 255 & t72;
      2 === c72 && (t72 = e$25[r82.charCodeAt(o82)] << 2 | e$25[r82.charCodeAt(o82 + 1)] >> 4, d52[f72++] = 255 & t72);
      1 === c72 && (t72 = e$25[r82.charCodeAt(o82)] << 10 | e$25[r82.charCodeAt(o82 + 1)] << 4 | e$25[r82.charCodeAt(o82 + 2)] >> 2, d52[f72++] = t72 >> 8 & 255, d52[f72++] = 255 & t72);
      return d52;
    }, fromByteArray: function(r82) {
      for (var e82, n82 = r82.length, o82 = n82 % 3, a72 = [], h72 = 0, u72 = n82 - o82; h72 < u72; h72 += 16383)
        a72.push(c$124(r82, h72, h72 + 16383 > u72 ? u72 : h72 + 16383));
      1 === o82 ? (e82 = r82[n82 - 1], a72.push(t$124[e82 >> 2] + t$124[e82 << 4 & 63] + "==")) : 2 === o82 && (e82 = (r82[n82 - 2] << 8) + r82[n82 - 1], a72.push(t$124[e82 >> 10] + t$124[e82 >> 4 & 63] + t$124[e82 << 2 & 63] + "="));
      return a72.join("");
    } }, t$124 = [], e$25 = [], n$25 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o$224 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a$15 = 0, h$15 = o$224.length; a$15 < h$15; ++a$15)
      t$124[a$15] = o$224[a$15], e$25[o$224.charCodeAt(a$15)] = a$15;
    e$25["-".charCodeAt(0)] = 62, e$25["_".charCodeAt(0)] = 63;
    a$1$13 = { read: function(a72, t72, o82, r82, h72) {
      var M32, f72, p72 = 8 * h72 - r82 - 1, w32 = (1 << p72) - 1, e82 = w32 >> 1, i72 = -7, N32 = o82 ? h72 - 1 : 0, n82 = o82 ? -1 : 1, u72 = a72[t72 + N32];
      for (N32 += n82, M32 = u72 & (1 << -i72) - 1, u72 >>= -i72, i72 += p72; i72 > 0; M32 = 256 * M32 + a72[t72 + N32], N32 += n82, i72 -= 8)
        ;
      for (f72 = M32 & (1 << -i72) - 1, M32 >>= -i72, i72 += r82; i72 > 0; f72 = 256 * f72 + a72[t72 + N32], N32 += n82, i72 -= 8)
        ;
      if (0 === M32)
        M32 = 1 - e82;
      else {
        if (M32 === w32)
          return f72 ? NaN : 1 / 0 * (u72 ? -1 : 1);
        f72 += Math.pow(2, r82), M32 -= e82;
      }
      return (u72 ? -1 : 1) * f72 * Math.pow(2, M32 - r82);
    }, write: function(a72, t72, o82, r82, h72, M32) {
      var f72, p72, w32, e82 = 8 * M32 - h72 - 1, i72 = (1 << e82) - 1, N32 = i72 >> 1, n82 = 23 === h72 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, u72 = r82 ? 0 : M32 - 1, l72 = r82 ? 1 : -1, s62 = t72 < 0 || 0 === t72 && 1 / t72 < 0 ? 1 : 0;
      for (t72 = Math.abs(t72), isNaN(t72) || t72 === 1 / 0 ? (p72 = isNaN(t72) ? 1 : 0, f72 = i72) : (f72 = Math.floor(Math.log(t72) / Math.LN2), t72 * (w32 = Math.pow(2, -f72)) < 1 && (f72--, w32 *= 2), (t72 += f72 + N32 >= 1 ? n82 / w32 : n82 * Math.pow(2, 1 - N32)) * w32 >= 2 && (f72++, w32 /= 2), f72 + N32 >= i72 ? (p72 = 0, f72 = i72) : f72 + N32 >= 1 ? (p72 = (t72 * w32 - 1) * Math.pow(2, h72), f72 += N32) : (p72 = t72 * Math.pow(2, N32 - 1) * Math.pow(2, h72), f72 = 0)); h72 >= 8; a72[o82 + u72] = 255 & p72, u72 += l72, p72 /= 256, h72 -= 8)
        ;
      for (f72 = f72 << h72 | p72, e82 += h72; e82 > 0; a72[o82 + u72] = 255 & f72, u72 += l72, f72 /= 256, e82 -= 8)
        ;
      a72[o82 + u72 - l72] |= 128 * s62;
    } };
    e$1$13 = {};
    n$1$13 = r$124;
    i$124 = a$1$13;
    o$1$13 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
    e$1$13.Buffer = u$1$13, e$1$13.SlowBuffer = function(t72) {
      +t72 != t72 && (t72 = 0);
      return u$1$13.alloc(+t72);
    }, e$1$13.INSPECT_MAX_BYTES = 50;
    e$1$13.kMaxLength = 2147483647, u$1$13.TYPED_ARRAY_SUPPORT = function() {
      try {
        var t72 = new Uint8Array(1), r82 = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(r82, Uint8Array.prototype), Object.setPrototypeOf(t72, r82), 42 === t72.foo();
      } catch (t82) {
        return false;
      }
    }(), u$1$13.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u$1$13.prototype, "parent", { enumerable: true, get: function() {
      if (u$1$13.isBuffer(this))
        return this.buffer;
    } }), Object.defineProperty(u$1$13.prototype, "offset", { enumerable: true, get: function() {
      if (u$1$13.isBuffer(this))
        return this.byteOffset;
    } }), u$1$13.poolSize = 8192, u$1$13.from = function(t72, r82, e82) {
      return s$15(t72, r82, e82);
    }, Object.setPrototypeOf(u$1$13.prototype, Uint8Array.prototype), Object.setPrototypeOf(u$1$13, Uint8Array), u$1$13.alloc = function(t72, r82, e82) {
      return function(t82, r92, e92) {
        return h$1$13(t82), t82 <= 0 ? f$25(t82) : void 0 !== r92 ? "string" == typeof e92 ? f$25(t82).fill(r92, e92) : f$25(t82).fill(r92) : f$25(t82);
      }(t72, r82, e82);
    }, u$1$13.allocUnsafe = function(t72) {
      return a$25(t72);
    }, u$1$13.allocUnsafeSlow = function(t72) {
      return a$25(t72);
    }, u$1$13.isBuffer = function(t72) {
      return null != t72 && true === t72._isBuffer && t72 !== u$1$13.prototype;
    }, u$1$13.compare = function(t72, r82) {
      if (F24(t72, Uint8Array) && (t72 = u$1$13.from(t72, t72.offset, t72.byteLength)), F24(r82, Uint8Array) && (r82 = u$1$13.from(r82, r82.offset, r82.byteLength)), !u$1$13.isBuffer(t72) || !u$1$13.isBuffer(r82))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t72 === r82)
        return 0;
      for (var e82 = t72.length, n82 = r82.length, i72 = 0, o82 = Math.min(e82, n82); i72 < o82; ++i72)
        if (t72[i72] !== r82[i72]) {
          e82 = t72[i72], n82 = r82[i72];
          break;
        }
      return e82 < n82 ? -1 : n82 < e82 ? 1 : 0;
    }, u$1$13.isEncoding = function(t72) {
      switch (String(t72).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, u$1$13.concat = function(t72, r82) {
      if (!Array.isArray(t72))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (0 === t72.length)
        return u$1$13.alloc(0);
      var e82;
      if (void 0 === r82)
        for (r82 = 0, e82 = 0; e82 < t72.length; ++e82)
          r82 += t72[e82].length;
      var n82 = u$1$13.allocUnsafe(r82), i72 = 0;
      for (e82 = 0; e82 < t72.length; ++e82) {
        var o82 = t72[e82];
        if (F24(o82, Uint8Array) && (o82 = u$1$13.from(o82)), !u$1$13.isBuffer(o82))
          throw new TypeError('"list" argument must be an Array of Buffers');
        o82.copy(n82, i72), i72 += o82.length;
      }
      return n82;
    }, u$1$13.byteLength = y33, u$1$13.prototype._isBuffer = true, u$1$13.prototype.swap16 = function() {
      var t72 = this.length;
      if (t72 % 2 != 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var r82 = 0; r82 < t72; r82 += 2)
        w24(this, r82, r82 + 1);
      return this;
    }, u$1$13.prototype.swap32 = function() {
      var t72 = this.length;
      if (t72 % 4 != 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var r82 = 0; r82 < t72; r82 += 4)
        w24(this, r82, r82 + 3), w24(this, r82 + 1, r82 + 2);
      return this;
    }, u$1$13.prototype.swap64 = function() {
      var t72 = this.length;
      if (t72 % 8 != 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var r82 = 0; r82 < t72; r82 += 8)
        w24(this, r82, r82 + 7), w24(this, r82 + 1, r82 + 6), w24(this, r82 + 2, r82 + 5), w24(this, r82 + 3, r82 + 4);
      return this;
    }, u$1$13.prototype.toString = function() {
      var t72 = this.length;
      return 0 === t72 ? "" : 0 === arguments.length ? I24(this, 0, t72) : g24.apply(this, arguments);
    }, u$1$13.prototype.toLocaleString = u$1$13.prototype.toString, u$1$13.prototype.equals = function(t72) {
      if (!u$1$13.isBuffer(t72))
        throw new TypeError("Argument must be a Buffer");
      return this === t72 || 0 === u$1$13.compare(this, t72);
    }, u$1$13.prototype.inspect = function() {
      var t72 = "", r82 = e$1$13.INSPECT_MAX_BYTES;
      return t72 = this.toString("hex", 0, r82).replace(/(.{2})/g, "$1 ").trim(), this.length > r82 && (t72 += " ... "), "<Buffer " + t72 + ">";
    }, o$1$13 && (u$1$13.prototype[o$1$13] = u$1$13.prototype.inspect), u$1$13.prototype.compare = function(t72, r82, e82, n82, i72) {
      if (F24(t72, Uint8Array) && (t72 = u$1$13.from(t72, t72.offset, t72.byteLength)), !u$1$13.isBuffer(t72))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t72);
      if (void 0 === r82 && (r82 = 0), void 0 === e82 && (e82 = t72 ? t72.length : 0), void 0 === n82 && (n82 = 0), void 0 === i72 && (i72 = this.length), r82 < 0 || e82 > t72.length || n82 < 0 || i72 > this.length)
        throw new RangeError("out of range index");
      if (n82 >= i72 && r82 >= e82)
        return 0;
      if (n82 >= i72)
        return -1;
      if (r82 >= e82)
        return 1;
      if (this === t72)
        return 0;
      for (var o82 = (i72 >>>= 0) - (n82 >>>= 0), f72 = (e82 >>>= 0) - (r82 >>>= 0), s62 = Math.min(o82, f72), h72 = this.slice(n82, i72), a72 = t72.slice(r82, e82), p72 = 0; p72 < s62; ++p72)
        if (h72[p72] !== a72[p72]) {
          o82 = h72[p72], f72 = a72[p72];
          break;
        }
      return o82 < f72 ? -1 : f72 < o82 ? 1 : 0;
    }, u$1$13.prototype.includes = function(t72, r82, e82) {
      return -1 !== this.indexOf(t72, r82, e82);
    }, u$1$13.prototype.indexOf = function(t72, r82, e82) {
      return d34(this, t72, r82, e82, true);
    }, u$1$13.prototype.lastIndexOf = function(t72, r82, e82) {
      return d34(this, t72, r82, e82, false);
    }, u$1$13.prototype.write = function(t72, r82, e82, n82) {
      if (void 0 === r82)
        n82 = "utf8", e82 = this.length, r82 = 0;
      else if (void 0 === e82 && "string" == typeof r82)
        n82 = r82, e82 = this.length, r82 = 0;
      else {
        if (!isFinite(r82))
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        r82 >>>= 0, isFinite(e82) ? (e82 >>>= 0, void 0 === n82 && (n82 = "utf8")) : (n82 = e82, e82 = void 0);
      }
      var i72 = this.length - r82;
      if ((void 0 === e82 || e82 > i72) && (e82 = i72), t72.length > 0 && (e82 < 0 || r82 < 0) || r82 > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      n82 || (n82 = "utf8");
      for (var o82 = false; ; )
        switch (n82) {
          case "hex":
            return b24(this, t72, r82, e82);
          case "utf8":
          case "utf-8":
            return m34(this, t72, r82, e82);
          case "ascii":
            return E24(this, t72, r82, e82);
          case "latin1":
          case "binary":
            return B24(this, t72, r82, e82);
          case "base64":
            return A24(this, t72, r82, e82);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return U24(this, t72, r82, e82);
          default:
            if (o82)
              throw new TypeError("Unknown encoding: " + n82);
            n82 = ("" + n82).toLowerCase(), o82 = true;
        }
    }, u$1$13.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    u$1$13.prototype.slice = function(t72, r82) {
      var e82 = this.length;
      (t72 = ~~t72) < 0 ? (t72 += e82) < 0 && (t72 = 0) : t72 > e82 && (t72 = e82), (r82 = void 0 === r82 ? e82 : ~~r82) < 0 ? (r82 += e82) < 0 && (r82 = 0) : r82 > e82 && (r82 = e82), r82 < t72 && (r82 = t72);
      var n82 = this.subarray(t72, r82);
      return Object.setPrototypeOf(n82, u$1$13.prototype), n82;
    }, u$1$13.prototype.readUIntLE = function(t72, r82, e82) {
      t72 >>>= 0, r82 >>>= 0, e82 || x24(t72, r82, this.length);
      for (var n82 = this[t72], i72 = 1, o82 = 0; ++o82 < r82 && (i72 *= 256); )
        n82 += this[t72 + o82] * i72;
      return n82;
    }, u$1$13.prototype.readUIntBE = function(t72, r82, e82) {
      t72 >>>= 0, r82 >>>= 0, e82 || x24(t72, r82, this.length);
      for (var n82 = this[t72 + --r82], i72 = 1; r82 > 0 && (i72 *= 256); )
        n82 += this[t72 + --r82] * i72;
      return n82;
    }, u$1$13.prototype.readUInt8 = function(t72, r82) {
      return t72 >>>= 0, r82 || x24(t72, 1, this.length), this[t72];
    }, u$1$13.prototype.readUInt16LE = function(t72, r82) {
      return t72 >>>= 0, r82 || x24(t72, 2, this.length), this[t72] | this[t72 + 1] << 8;
    }, u$1$13.prototype.readUInt16BE = function(t72, r82) {
      return t72 >>>= 0, r82 || x24(t72, 2, this.length), this[t72] << 8 | this[t72 + 1];
    }, u$1$13.prototype.readUInt32LE = function(t72, r82) {
      return t72 >>>= 0, r82 || x24(t72, 4, this.length), (this[t72] | this[t72 + 1] << 8 | this[t72 + 2] << 16) + 16777216 * this[t72 + 3];
    }, u$1$13.prototype.readUInt32BE = function(t72, r82) {
      return t72 >>>= 0, r82 || x24(t72, 4, this.length), 16777216 * this[t72] + (this[t72 + 1] << 16 | this[t72 + 2] << 8 | this[t72 + 3]);
    }, u$1$13.prototype.readIntLE = function(t72, r82, e82) {
      t72 >>>= 0, r82 >>>= 0, e82 || x24(t72, r82, this.length);
      for (var n82 = this[t72], i72 = 1, o82 = 0; ++o82 < r82 && (i72 *= 256); )
        n82 += this[t72 + o82] * i72;
      return n82 >= (i72 *= 128) && (n82 -= Math.pow(2, 8 * r82)), n82;
    }, u$1$13.prototype.readIntBE = function(t72, r82, e82) {
      t72 >>>= 0, r82 >>>= 0, e82 || x24(t72, r82, this.length);
      for (var n82 = r82, i72 = 1, o82 = this[t72 + --n82]; n82 > 0 && (i72 *= 256); )
        o82 += this[t72 + --n82] * i72;
      return o82 >= (i72 *= 128) && (o82 -= Math.pow(2, 8 * r82)), o82;
    }, u$1$13.prototype.readInt8 = function(t72, r82) {
      return t72 >>>= 0, r82 || x24(t72, 1, this.length), 128 & this[t72] ? -1 * (255 - this[t72] + 1) : this[t72];
    }, u$1$13.prototype.readInt16LE = function(t72, r82) {
      t72 >>>= 0, r82 || x24(t72, 2, this.length);
      var e82 = this[t72] | this[t72 + 1] << 8;
      return 32768 & e82 ? 4294901760 | e82 : e82;
    }, u$1$13.prototype.readInt16BE = function(t72, r82) {
      t72 >>>= 0, r82 || x24(t72, 2, this.length);
      var e82 = this[t72 + 1] | this[t72] << 8;
      return 32768 & e82 ? 4294901760 | e82 : e82;
    }, u$1$13.prototype.readInt32LE = function(t72, r82) {
      return t72 >>>= 0, r82 || x24(t72, 4, this.length), this[t72] | this[t72 + 1] << 8 | this[t72 + 2] << 16 | this[t72 + 3] << 24;
    }, u$1$13.prototype.readInt32BE = function(t72, r82) {
      return t72 >>>= 0, r82 || x24(t72, 4, this.length), this[t72] << 24 | this[t72 + 1] << 16 | this[t72 + 2] << 8 | this[t72 + 3];
    }, u$1$13.prototype.readFloatLE = function(t72, r82) {
      return t72 >>>= 0, r82 || x24(t72, 4, this.length), i$124.read(this, t72, true, 23, 4);
    }, u$1$13.prototype.readFloatBE = function(t72, r82) {
      return t72 >>>= 0, r82 || x24(t72, 4, this.length), i$124.read(this, t72, false, 23, 4);
    }, u$1$13.prototype.readDoubleLE = function(t72, r82) {
      return t72 >>>= 0, r82 || x24(t72, 8, this.length), i$124.read(this, t72, true, 52, 8);
    }, u$1$13.prototype.readDoubleBE = function(t72, r82) {
      return t72 >>>= 0, r82 || x24(t72, 8, this.length), i$124.read(this, t72, false, 52, 8);
    }, u$1$13.prototype.writeUIntLE = function(t72, r82, e82, n82) {
      (t72 = +t72, r82 >>>= 0, e82 >>>= 0, n82) || C24(this, t72, r82, e82, Math.pow(2, 8 * e82) - 1, 0);
      var i72 = 1, o82 = 0;
      for (this[r82] = 255 & t72; ++o82 < e82 && (i72 *= 256); )
        this[r82 + o82] = t72 / i72 & 255;
      return r82 + e82;
    }, u$1$13.prototype.writeUIntBE = function(t72, r82, e82, n82) {
      (t72 = +t72, r82 >>>= 0, e82 >>>= 0, n82) || C24(this, t72, r82, e82, Math.pow(2, 8 * e82) - 1, 0);
      var i72 = e82 - 1, o82 = 1;
      for (this[r82 + i72] = 255 & t72; --i72 >= 0 && (o82 *= 256); )
        this[r82 + i72] = t72 / o82 & 255;
      return r82 + e82;
    }, u$1$13.prototype.writeUInt8 = function(t72, r82, e82) {
      return t72 = +t72, r82 >>>= 0, e82 || C24(this, t72, r82, 1, 255, 0), this[r82] = 255 & t72, r82 + 1;
    }, u$1$13.prototype.writeUInt16LE = function(t72, r82, e82) {
      return t72 = +t72, r82 >>>= 0, e82 || C24(this, t72, r82, 2, 65535, 0), this[r82] = 255 & t72, this[r82 + 1] = t72 >>> 8, r82 + 2;
    }, u$1$13.prototype.writeUInt16BE = function(t72, r82, e82) {
      return t72 = +t72, r82 >>>= 0, e82 || C24(this, t72, r82, 2, 65535, 0), this[r82] = t72 >>> 8, this[r82 + 1] = 255 & t72, r82 + 2;
    }, u$1$13.prototype.writeUInt32LE = function(t72, r82, e82) {
      return t72 = +t72, r82 >>>= 0, e82 || C24(this, t72, r82, 4, 4294967295, 0), this[r82 + 3] = t72 >>> 24, this[r82 + 2] = t72 >>> 16, this[r82 + 1] = t72 >>> 8, this[r82] = 255 & t72, r82 + 4;
    }, u$1$13.prototype.writeUInt32BE = function(t72, r82, e82) {
      return t72 = +t72, r82 >>>= 0, e82 || C24(this, t72, r82, 4, 4294967295, 0), this[r82] = t72 >>> 24, this[r82 + 1] = t72 >>> 16, this[r82 + 2] = t72 >>> 8, this[r82 + 3] = 255 & t72, r82 + 4;
    }, u$1$13.prototype.writeIntLE = function(t72, r82, e82, n82) {
      if (t72 = +t72, r82 >>>= 0, !n82) {
        var i72 = Math.pow(2, 8 * e82 - 1);
        C24(this, t72, r82, e82, i72 - 1, -i72);
      }
      var o82 = 0, f72 = 1, u72 = 0;
      for (this[r82] = 255 & t72; ++o82 < e82 && (f72 *= 256); )
        t72 < 0 && 0 === u72 && 0 !== this[r82 + o82 - 1] && (u72 = 1), this[r82 + o82] = (t72 / f72 >> 0) - u72 & 255;
      return r82 + e82;
    }, u$1$13.prototype.writeIntBE = function(t72, r82, e82, n82) {
      if (t72 = +t72, r82 >>>= 0, !n82) {
        var i72 = Math.pow(2, 8 * e82 - 1);
        C24(this, t72, r82, e82, i72 - 1, -i72);
      }
      var o82 = e82 - 1, f72 = 1, u72 = 0;
      for (this[r82 + o82] = 255 & t72; --o82 >= 0 && (f72 *= 256); )
        t72 < 0 && 0 === u72 && 0 !== this[r82 + o82 + 1] && (u72 = 1), this[r82 + o82] = (t72 / f72 >> 0) - u72 & 255;
      return r82 + e82;
    }, u$1$13.prototype.writeInt8 = function(t72, r82, e82) {
      return t72 = +t72, r82 >>>= 0, e82 || C24(this, t72, r82, 1, 127, -128), t72 < 0 && (t72 = 255 + t72 + 1), this[r82] = 255 & t72, r82 + 1;
    }, u$1$13.prototype.writeInt16LE = function(t72, r82, e82) {
      return t72 = +t72, r82 >>>= 0, e82 || C24(this, t72, r82, 2, 32767, -32768), this[r82] = 255 & t72, this[r82 + 1] = t72 >>> 8, r82 + 2;
    }, u$1$13.prototype.writeInt16BE = function(t72, r82, e82) {
      return t72 = +t72, r82 >>>= 0, e82 || C24(this, t72, r82, 2, 32767, -32768), this[r82] = t72 >>> 8, this[r82 + 1] = 255 & t72, r82 + 2;
    }, u$1$13.prototype.writeInt32LE = function(t72, r82, e82) {
      return t72 = +t72, r82 >>>= 0, e82 || C24(this, t72, r82, 4, 2147483647, -2147483648), this[r82] = 255 & t72, this[r82 + 1] = t72 >>> 8, this[r82 + 2] = t72 >>> 16, this[r82 + 3] = t72 >>> 24, r82 + 4;
    }, u$1$13.prototype.writeInt32BE = function(t72, r82, e82) {
      return t72 = +t72, r82 >>>= 0, e82 || C24(this, t72, r82, 4, 2147483647, -2147483648), t72 < 0 && (t72 = 4294967295 + t72 + 1), this[r82] = t72 >>> 24, this[r82 + 1] = t72 >>> 16, this[r82 + 2] = t72 >>> 8, this[r82 + 3] = 255 & t72, r82 + 4;
    }, u$1$13.prototype.writeFloatLE = function(t72, r82, e82) {
      return k24(this, t72, r82, true, e82);
    }, u$1$13.prototype.writeFloatBE = function(t72, r82, e82) {
      return k24(this, t72, r82, false, e82);
    }, u$1$13.prototype.writeDoubleLE = function(t72, r82, e82) {
      return M24(this, t72, r82, true, e82);
    }, u$1$13.prototype.writeDoubleBE = function(t72, r82, e82) {
      return M24(this, t72, r82, false, e82);
    }, u$1$13.prototype.copy = function(t72, r82, e82, n82) {
      if (!u$1$13.isBuffer(t72))
        throw new TypeError("argument should be a Buffer");
      if (e82 || (e82 = 0), n82 || 0 === n82 || (n82 = this.length), r82 >= t72.length && (r82 = t72.length), r82 || (r82 = 0), n82 > 0 && n82 < e82 && (n82 = e82), n82 === e82)
        return 0;
      if (0 === t72.length || 0 === this.length)
        return 0;
      if (r82 < 0)
        throw new RangeError("targetStart out of bounds");
      if (e82 < 0 || e82 >= this.length)
        throw new RangeError("Index out of range");
      if (n82 < 0)
        throw new RangeError("sourceEnd out of bounds");
      n82 > this.length && (n82 = this.length), t72.length - r82 < n82 - e82 && (n82 = t72.length - r82 + e82);
      var i72 = n82 - e82;
      if (this === t72 && "function" == typeof Uint8Array.prototype.copyWithin)
        this.copyWithin(r82, e82, n82);
      else if (this === t72 && e82 < r82 && r82 < n82)
        for (var o82 = i72 - 1; o82 >= 0; --o82)
          t72[o82 + r82] = this[o82 + e82];
      else
        Uint8Array.prototype.set.call(t72, this.subarray(e82, n82), r82);
      return i72;
    }, u$1$13.prototype.fill = function(t72, r82, e82, n82) {
      if ("string" == typeof t72) {
        if ("string" == typeof r82 ? (n82 = r82, r82 = 0, e82 = this.length) : "string" == typeof e82 && (n82 = e82, e82 = this.length), void 0 !== n82 && "string" != typeof n82)
          throw new TypeError("encoding must be a string");
        if ("string" == typeof n82 && !u$1$13.isEncoding(n82))
          throw new TypeError("Unknown encoding: " + n82);
        if (1 === t72.length) {
          var i72 = t72.charCodeAt(0);
          ("utf8" === n82 && i72 < 128 || "latin1" === n82) && (t72 = i72);
        }
      } else
        "number" == typeof t72 ? t72 &= 255 : "boolean" == typeof t72 && (t72 = Number(t72));
      if (r82 < 0 || this.length < r82 || this.length < e82)
        throw new RangeError("Out of range index");
      if (e82 <= r82)
        return this;
      var o82;
      if (r82 >>>= 0, e82 = void 0 === e82 ? this.length : e82 >>> 0, t72 || (t72 = 0), "number" == typeof t72)
        for (o82 = r82; o82 < e82; ++o82)
          this[o82] = t72;
      else {
        var f72 = u$1$13.isBuffer(t72) ? t72 : u$1$13.from(t72, n82), s62 = f72.length;
        if (0 === s62)
          throw new TypeError('The value "' + t72 + '" is invalid for argument "value"');
        for (o82 = 0; o82 < e82 - r82; ++o82)
          this[o82 + r82] = f72[o82 % s62];
      }
      return this;
    };
    j24 = /[^+/0-9A-Za-z-_]/g;
    Y24 = function() {
      for (var t72 = new Array(256), r82 = 0; r82 < 16; ++r82)
        for (var e82 = 16 * r82, n82 = 0; n82 < 16; ++n82)
          t72[e82 + n82] = "0123456789abcdef"[r82] + "0123456789abcdef"[n82];
      return t72;
    }();
    e$1$13.Buffer;
    e$1$13.INSPECT_MAX_BYTES;
    e$1$13.kMaxLength;
    e43 = {};
    n43 = e$1$13;
    o43 = n43.Buffer;
    o43.from && o43.alloc && o43.allocUnsafe && o43.allocUnsafeSlow ? e43 = n43 : (t43(n43, e43), e43.Buffer = f43), f43.prototype = Object.create(o43.prototype), t43(o43, f43), f43.from = function(r82, e82, n82) {
      if ("number" == typeof r82)
        throw new TypeError("Argument must not be a number");
      return o43(r82, e82, n82);
    }, f43.alloc = function(r82, e82, n82) {
      if ("number" != typeof r82)
        throw new TypeError("Argument must be a number");
      var t72 = o43(r82);
      return void 0 !== e82 ? "string" == typeof n82 ? t72.fill(e82, n82) : t72.fill(e82) : t72.fill(0), t72;
    }, f43.allocUnsafe = function(r82) {
      if ("number" != typeof r82)
        throw new TypeError("Argument must be a number");
      return o43(r82);
    }, f43.allocUnsafeSlow = function(r82) {
      if ("number" != typeof r82)
        throw new TypeError("Argument must be a number");
      return n43.SlowBuffer(r82);
    };
    u43 = e43;
    e$124 = {};
    s43 = u43.Buffer;
    i43 = s43.isEncoding || function(t72) {
      switch ((t72 = "" + t72) && t72.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    e$124.StringDecoder = a43, a43.prototype.write = function(t72) {
      if (0 === t72.length)
        return "";
      var e82, s62;
      if (this.lastNeed) {
        if (void 0 === (e82 = this.fillLast(t72)))
          return "";
        s62 = this.lastNeed, this.lastNeed = 0;
      } else
        s62 = 0;
      return s62 < t72.length ? e82 ? e82 + this.text(t72, s62) : this.text(t72, s62) : e82 || "";
    }, a43.prototype.end = function(t72) {
      var e82 = t72 && t72.length ? this.write(t72) : "";
      return this.lastNeed ? e82 + "\uFFFD" : e82;
    }, a43.prototype.text = function(t72, e82) {
      var s62 = function(t82, e92, s72) {
        var i82 = e92.length - 1;
        if (i82 < s72)
          return 0;
        var a72 = r43(e92[i82]);
        if (a72 >= 0)
          return a72 > 0 && (t82.lastNeed = a72 - 1), a72;
        if (--i82 < s72 || -2 === a72)
          return 0;
        if ((a72 = r43(e92[i82])) >= 0)
          return a72 > 0 && (t82.lastNeed = a72 - 2), a72;
        if (--i82 < s72 || -2 === a72)
          return 0;
        if ((a72 = r43(e92[i82])) >= 0)
          return a72 > 0 && (2 === a72 ? a72 = 0 : t82.lastNeed = a72 - 3), a72;
        return 0;
      }(this, t72, e82);
      if (!this.lastNeed)
        return t72.toString("utf8", e82);
      this.lastTotal = s62;
      var i72 = t72.length - (s62 - this.lastNeed);
      return t72.copy(this.lastChar, 0, i72), t72.toString("utf8", e82, i72);
    }, a43.prototype.fillLast = function(t72) {
      if (this.lastNeed <= t72.length)
        return t72.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t72.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t72.length), this.lastNeed -= t72.length;
    };
    e$124.StringDecoder;
    e$124.StringDecoder;
    exports$2$13 = {};
    _dewExec$2$13 = false;
    exports$1$13 = {};
    _dewExec$1$13 = false;
    exports$g4 = {};
    _dewExec$g3 = false;
    buffer3 = dew$g3();
    buffer3.Buffer;
    buffer3.INSPECT_MAX_BYTES;
    buffer3.kMaxLength;
    exports$f4 = {};
    _dewExec$f4 = false;
    exports$e4 = {};
    _dewExec$e4 = false;
    exports$d4 = {};
    _dewExec$d4 = false;
    exports$c4 = {};
    _dewExec$c4 = false;
    exports$b4 = {};
    _dewExec$b4 = false;
    exports$a4 = {};
    _dewExec$a4 = false;
    exports$94 = {};
    _dewExec$94 = false;
    _global$24 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$84 = {};
    _dewExec$84 = false;
    _global$14 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$74 = {};
    _dewExec$74 = false;
    exports$64 = {};
    _dewExec$64 = false;
    exports$54 = {};
    _dewExec$54 = false;
    exports$44 = {};
    _dewExec$44 = false;
    exports$35 = {};
    _dewExec$34 = false;
    _global24 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$25 = {};
    _dewExec$25 = false;
    exports$17 = {};
    _dewExec$15 = false;
    exports24 = {};
    _dewExec24 = false;
    exports34 = {};
    _dewExec34 = false;
    t52 = 2147483647;
    o52 = /^xn--/;
    n52 = /[^\0-\x7E]/;
    e52 = /[\x2E\u3002\uFF0E\uFF61]/g;
    r52 = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" };
    c52 = Math.floor;
    s52 = String.fromCharCode;
    u52 = function(t72, o82) {
      return t72 + 22 + 75 * (t72 < 26) - ((0 != o82) << 5);
    };
    a52 = function(t72, o82, n82) {
      let e82 = 0;
      for (t72 = n82 ? c52(t72 / 700) : t72 >> 1, t72 += c52(t72 / o82); t72 > 455; e82 += 36)
        t72 = c52(t72 / 35);
      return c52(e82 + 36 * t72 / (t72 + 38));
    };
    d42 = function(o82) {
      const n82 = [], e82 = o82.length;
      let r82 = 0, s62 = 128, f72 = 72, l72 = o82.lastIndexOf("-");
      l72 < 0 && (l72 = 0);
      for (let t72 = 0; t72 < l72; ++t72)
        o82.charCodeAt(t72) >= 128 && i52("not-basic"), n82.push(o82.charCodeAt(t72));
      for (let d52 = l72 > 0 ? l72 + 1 : 0; d52 < e82; ) {
        let l82 = r82;
        for (let n92 = 1, s72 = 36; ; s72 += 36) {
          d52 >= e82 && i52("invalid-input");
          const l92 = (u72 = o82.charCodeAt(d52++)) - 48 < 10 ? u72 - 22 : u72 - 65 < 26 ? u72 - 65 : u72 - 97 < 26 ? u72 - 97 : 36;
          (l92 >= 36 || l92 > c52((t52 - r82) / n92)) && i52("overflow"), r82 += l92 * n92;
          const a72 = s72 <= f72 ? 1 : s72 >= f72 + 26 ? 26 : s72 - f72;
          if (l92 < a72)
            break;
          const h82 = 36 - a72;
          n92 > c52(t52 / h82) && i52("overflow"), n92 *= h82;
        }
        const h72 = n82.length + 1;
        f72 = a52(r82 - l82, h72, 0 == l82), c52(r82 / h72) > t52 - s62 && i52("overflow"), s62 += c52(r82 / h72), r82 %= h72, n82.splice(r82++, 0, s62);
      }
      var u72;
      return String.fromCodePoint(...n82);
    };
    h52 = function(o82) {
      const n82 = [];
      let e82 = (o82 = l52(o82)).length, r82 = 128, f72 = 0, d52 = 72;
      for (const t72 of o82)
        t72 < 128 && n82.push(s52(t72));
      let h72 = n82.length, p72 = h72;
      for (h72 && n82.push("-"); p72 < e82; ) {
        let e92 = t52;
        for (const t72 of o82)
          t72 >= r82 && t72 < e92 && (e92 = t72);
        const l72 = p72 + 1;
        e92 - r82 > c52((t52 - f72) / l72) && i52("overflow"), f72 += (e92 - r82) * l72, r82 = e92;
        for (const e102 of o82)
          if (e102 < r82 && ++f72 > t52 && i52("overflow"), e102 == r82) {
            let t72 = f72;
            for (let o92 = 36; ; o92 += 36) {
              const e112 = o92 <= d52 ? 1 : o92 >= d52 + 26 ? 26 : o92 - d52;
              if (t72 < e112)
                break;
              const r92 = t72 - e112, i72 = 36 - e112;
              n82.push(s52(u52(e112 + r92 % i72, 0))), t72 = c52(r92 / i72);
            }
            n82.push(s52(u52(t72, 0))), d52 = a52(f72, l72, p72 == h72), f72 = 0, ++p72;
          }
        ++f72, ++r82;
      }
      return n82.join("");
    };
    p52 = { version: "2.1.0", ucs2: { decode: l52, encode: (t72) => String.fromCodePoint(...t72) }, decode: d42, encode: h52, toASCII: function(t72) {
      return f52(t72, function(t82) {
        return n52.test(t82) ? "xn--" + h52(t82) : t82;
      });
    }, toUnicode: function(t72) {
      return f52(t72, function(t82) {
        return o52.test(t82) ? d42(t82.slice(4).toLowerCase()) : t82;
      });
    } };
    p52.decode;
    p52.encode;
    p52.toASCII;
    p52.toUnicode;
    p52.ucs2;
    p52.version;
    n62 = function(n82, r82, t72, o82) {
      r82 = r82 || "&", t72 = t72 || "=";
      var a72 = {};
      if ("string" != typeof n82 || 0 === n82.length)
        return a72;
      var u72 = /\+/g;
      n82 = n82.split(r82);
      var c72 = 1e3;
      o82 && "number" == typeof o82.maxKeys && (c72 = o82.maxKeys);
      var i72 = n82.length;
      c72 > 0 && i72 > c72 && (i72 = c72);
      for (var s62 = 0; s62 < i72; ++s62) {
        var p72, f72, d52, y52, m52 = n82[s62].replace(u72, "%20"), l72 = m52.indexOf(t72);
        l72 >= 0 ? (p72 = m52.substr(0, l72), f72 = m52.substr(l72 + 1)) : (p72 = m52, f72 = ""), d52 = decodeURIComponent(p72), y52 = decodeURIComponent(f72), e62(a72, d52) ? Array.isArray(a72[d52]) ? a72[d52].push(y52) : a72[d52] = [a72[d52], y52] : a72[d52] = y52;
      }
      return a72;
    };
    r62 = function(e82) {
      switch (typeof e82) {
        case "string":
          return e82;
        case "boolean":
          return e82 ? "true" : "false";
        case "number":
          return isFinite(e82) ? e82 : "";
        default:
          return "";
      }
    };
    t62 = function(e82, n82, t72, o82) {
      return n82 = n82 || "&", t72 = t72 || "=", null === e82 && (e82 = void 0), "object" == typeof e82 ? Object.keys(e82).map(function(o92) {
        var a72 = encodeURIComponent(r62(o92)) + t72;
        return Array.isArray(e82[o92]) ? e82[o92].map(function(e92) {
          return a72 + encodeURIComponent(r62(e92));
        }).join(n82) : a72 + encodeURIComponent(r62(e82[o92]));
      }).join(n82) : o82 ? encodeURIComponent(r62(o82)) + t72 + encodeURIComponent(r62(e82)) : "";
    };
    o62 = {};
    o62.decode = o62.parse = n62, o62.encode = o62.stringify = t62;
    o62.decode;
    o62.encode;
    o62.parse;
    o62.stringify;
    exports$124 = {};
    _dewExec43 = false;
    exports43 = dew43();
    h62 = {};
    e72 = p52;
    a62 = { isString: function(t72) {
      return "string" == typeof t72;
    }, isObject: function(t72) {
      return "object" == typeof t72 && null !== t72;
    }, isNull: function(t72) {
      return null === t72;
    }, isNullOrUndefined: function(t72) {
      return null == t72;
    } };
    h62.parse = O32, h62.resolve = function(t72, s62) {
      return O32(t72, false, true).resolve(s62);
    }, h62.resolveObject = function(t72, s62) {
      return t72 ? O32(t72, false, true).resolveObject(s62) : s62;
    }, h62.format = function(t72) {
      a62.isString(t72) && (t72 = O32(t72));
      return t72 instanceof r72 ? t72.format() : r72.prototype.format.call(t72);
    }, h62.Url = r72;
    o72 = /^([a-z0-9.+-]+:)/i;
    n72 = /:[0-9]*$/;
    i62 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    l62 = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]);
    p62 = ["'"].concat(l62);
    c62 = ["%", "/", "?", ";", "#"].concat(p62);
    u62 = ["/", "?", "#"];
    f62 = /^[+a-z0-9A-Z_-]{0,63}$/;
    m42 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    v42 = { javascript: true, "javascript:": true };
    g32 = { javascript: true, "javascript:": true };
    y42 = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
    b32 = o62;
    r72.prototype.parse = function(t72, s62, h72) {
      if (!a62.isString(t72))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof t72);
      var r82 = t72.indexOf("?"), n82 = -1 !== r82 && r82 < t72.indexOf("#") ? "?" : "#", l72 = t72.split(n82);
      l72[0] = l72[0].replace(/\\/g, "/");
      var O42 = t72 = l72.join(n82);
      if (O42 = O42.trim(), !h72 && 1 === t72.split("#").length) {
        var d52 = i62.exec(O42);
        if (d52)
          return this.path = O42, this.href = O42, this.pathname = d52[1], d52[2] ? (this.search = d52[2], this.query = s62 ? b32.parse(this.search.substr(1)) : this.search.substr(1)) : s62 && (this.search = "", this.query = {}), this;
      }
      var j32 = o72.exec(O42);
      if (j32) {
        var q23 = (j32 = j32[0]).toLowerCase();
        this.protocol = q23, O42 = O42.substr(j32.length);
      }
      if (h72 || j32 || O42.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var x32 = "//" === O42.substr(0, 2);
        !x32 || j32 && g32[j32] || (O42 = O42.substr(2), this.slashes = true);
      }
      if (!g32[j32] && (x32 || j32 && !y42[j32])) {
        for (var A32, C32, I32 = -1, w32 = 0; w32 < u62.length; w32++) {
          -1 !== (N32 = O42.indexOf(u62[w32])) && (-1 === I32 || N32 < I32) && (I32 = N32);
        }
        -1 !== (C32 = -1 === I32 ? O42.lastIndexOf("@") : O42.lastIndexOf("@", I32)) && (A32 = O42.slice(0, C32), O42 = O42.slice(C32 + 1), this.auth = decodeURIComponent(A32)), I32 = -1;
        for (w32 = 0; w32 < c62.length; w32++) {
          var N32;
          -1 !== (N32 = O42.indexOf(c62[w32])) && (-1 === I32 || N32 < I32) && (I32 = N32);
        }
        -1 === I32 && (I32 = O42.length), this.host = O42.slice(0, I32), O42 = O42.slice(I32), this.parseHost(), this.hostname = this.hostname || "";
        var U32 = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
        if (!U32)
          for (var k32 = this.hostname.split(/\./), S32 = (w32 = 0, k32.length); w32 < S32; w32++) {
            var R32 = k32[w32];
            if (R32 && !R32.match(f62)) {
              for (var $23 = "", z32 = 0, H23 = R32.length; z32 < H23; z32++)
                R32.charCodeAt(z32) > 127 ? $23 += "x" : $23 += R32[z32];
              if (!$23.match(f62)) {
                var L32 = k32.slice(0, w32), Z23 = k32.slice(w32 + 1), _32 = R32.match(m42);
                _32 && (L32.push(_32[1]), Z23.unshift(_32[2])), Z23.length && (O42 = "/" + Z23.join(".") + O42), this.hostname = L32.join(".");
                break;
              }
            }
          }
        this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), U32 || (this.hostname = e72.toASCII(this.hostname));
        var E32 = this.port ? ":" + this.port : "", P32 = this.hostname || "";
        this.host = P32 + E32, this.href += this.host, U32 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== O42[0] && (O42 = "/" + O42));
      }
      if (!v42[q23])
        for (w32 = 0, S32 = p62.length; w32 < S32; w32++) {
          var T42 = p62[w32];
          if (-1 !== O42.indexOf(T42)) {
            var B32 = encodeURIComponent(T42);
            B32 === T42 && (B32 = escape(T42)), O42 = O42.split(T42).join(B32);
          }
        }
      var D32 = O42.indexOf("#");
      -1 !== D32 && (this.hash = O42.substr(D32), O42 = O42.slice(0, D32));
      var F32 = O42.indexOf("?");
      if (-1 !== F32 ? (this.search = O42.substr(F32), this.query = O42.substr(F32 + 1), s62 && (this.query = b32.parse(this.query)), O42 = O42.slice(0, F32)) : s62 && (this.search = "", this.query = {}), O42 && (this.pathname = O42), y42[q23] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        E32 = this.pathname || "";
        var G23 = this.search || "";
        this.path = E32 + G23;
      }
      return this.href = this.format(), this;
    }, r72.prototype.format = function() {
      var t72 = this.auth || "";
      t72 && (t72 = (t72 = encodeURIComponent(t72)).replace(/%3A/i, ":"), t72 += "@");
      var s62 = this.protocol || "", h72 = this.pathname || "", e82 = this.hash || "", r82 = false, o82 = "";
      this.host ? r82 = t72 + this.host : this.hostname && (r82 = t72 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (r82 += ":" + this.port)), this.query && a62.isObject(this.query) && Object.keys(this.query).length && (o82 = b32.stringify(this.query));
      var n82 = this.search || o82 && "?" + o82 || "";
      return s62 && ":" !== s62.substr(-1) && (s62 += ":"), this.slashes || (!s62 || y42[s62]) && false !== r82 ? (r82 = "//" + (r82 || ""), h72 && "/" !== h72.charAt(0) && (h72 = "/" + h72)) : r82 || (r82 = ""), e82 && "#" !== e82.charAt(0) && (e82 = "#" + e82), n82 && "?" !== n82.charAt(0) && (n82 = "?" + n82), s62 + r82 + (h72 = h72.replace(/[?#]/g, function(t82) {
        return encodeURIComponent(t82);
      })) + (n82 = n82.replace("#", "%23")) + e82;
    }, r72.prototype.resolve = function(t72) {
      return this.resolveObject(O32(t72, false, true)).format();
    }, r72.prototype.resolveObject = function(t72) {
      if (a62.isString(t72)) {
        var s62 = new r72();
        s62.parse(t72, false, true), t72 = s62;
      }
      for (var h72 = new r72(), e82 = Object.keys(this), o82 = 0; o82 < e82.length; o82++) {
        var n82 = e82[o82];
        h72[n82] = this[n82];
      }
      if (h72.hash = t72.hash, "" === t72.href)
        return h72.href = h72.format(), h72;
      if (t72.slashes && !t72.protocol) {
        for (var i72 = Object.keys(t72), l72 = 0; l72 < i72.length; l72++) {
          var p72 = i72[l72];
          "protocol" !== p72 && (h72[p72] = t72[p72]);
        }
        return y42[h72.protocol] && h72.hostname && !h72.pathname && (h72.path = h72.pathname = "/"), h72.href = h72.format(), h72;
      }
      if (t72.protocol && t72.protocol !== h72.protocol) {
        if (!y42[t72.protocol]) {
          for (var c72 = Object.keys(t72), u72 = 0; u72 < c72.length; u72++) {
            var f72 = c72[u72];
            h72[f72] = t72[f72];
          }
          return h72.href = h72.format(), h72;
        }
        if (h72.protocol = t72.protocol, t72.host || g32[t72.protocol])
          h72.pathname = t72.pathname;
        else {
          for (var m52 = (t72.pathname || "").split("/"); m52.length && !(t72.host = m52.shift()); )
            ;
          t72.host || (t72.host = ""), t72.hostname || (t72.hostname = ""), "" !== m52[0] && m52.unshift(""), m52.length < 2 && m52.unshift(""), h72.pathname = m52.join("/");
        }
        if (h72.search = t72.search, h72.query = t72.query, h72.host = t72.host || "", h72.auth = t72.auth, h72.hostname = t72.hostname || t72.host, h72.port = t72.port, h72.pathname || h72.search) {
          var v52 = h72.pathname || "", b42 = h72.search || "";
          h72.path = v52 + b42;
        }
        return h72.slashes = h72.slashes || t72.slashes, h72.href = h72.format(), h72;
      }
      var O42 = h72.pathname && "/" === h72.pathname.charAt(0), d52 = t72.host || t72.pathname && "/" === t72.pathname.charAt(0), j32 = d52 || O42 || h72.host && t72.pathname, q23 = j32, x32 = h72.pathname && h72.pathname.split("/") || [], A32 = (m52 = t72.pathname && t72.pathname.split("/") || [], h72.protocol && !y42[h72.protocol]);
      if (A32 && (h72.hostname = "", h72.port = null, h72.host && ("" === x32[0] ? x32[0] = h72.host : x32.unshift(h72.host)), h72.host = "", t72.protocol && (t72.hostname = null, t72.port = null, t72.host && ("" === m52[0] ? m52[0] = t72.host : m52.unshift(t72.host)), t72.host = null), j32 = j32 && ("" === m52[0] || "" === x32[0])), d52)
        h72.host = t72.host || "" === t72.host ? t72.host : h72.host, h72.hostname = t72.hostname || "" === t72.hostname ? t72.hostname : h72.hostname, h72.search = t72.search, h72.query = t72.query, x32 = m52;
      else if (m52.length)
        x32 || (x32 = []), x32.pop(), x32 = x32.concat(m52), h72.search = t72.search, h72.query = t72.query;
      else if (!a62.isNullOrUndefined(t72.search)) {
        if (A32)
          h72.hostname = h72.host = x32.shift(), (U32 = !!(h72.host && h72.host.indexOf("@") > 0) && h72.host.split("@")) && (h72.auth = U32.shift(), h72.host = h72.hostname = U32.shift());
        return h72.search = t72.search, h72.query = t72.query, a62.isNull(h72.pathname) && a62.isNull(h72.search) || (h72.path = (h72.pathname ? h72.pathname : "") + (h72.search ? h72.search : "")), h72.href = h72.format(), h72;
      }
      if (!x32.length)
        return h72.pathname = null, h72.search ? h72.path = "/" + h72.search : h72.path = null, h72.href = h72.format(), h72;
      for (var C32 = x32.slice(-1)[0], I32 = (h72.host || t72.host || x32.length > 1) && ("." === C32 || ".." === C32) || "" === C32, w32 = 0, N32 = x32.length; N32 >= 0; N32--)
        "." === (C32 = x32[N32]) ? x32.splice(N32, 1) : ".." === C32 ? (x32.splice(N32, 1), w32++) : w32 && (x32.splice(N32, 1), w32--);
      if (!j32 && !q23)
        for (; w32--; w32)
          x32.unshift("..");
      !j32 || "" === x32[0] || x32[0] && "/" === x32[0].charAt(0) || x32.unshift(""), I32 && "/" !== x32.join("/").substr(-1) && x32.push("");
      var U32, k32 = "" === x32[0] || x32[0] && "/" === x32[0].charAt(0);
      A32 && (h72.hostname = h72.host = k32 ? "" : x32.length ? x32.shift() : "", (U32 = !!(h72.host && h72.host.indexOf("@") > 0) && h72.host.split("@")) && (h72.auth = U32.shift(), h72.host = h72.hostname = U32.shift()));
      return (j32 = j32 || h72.host && x32.length) && !k32 && x32.unshift(""), x32.length ? h72.pathname = x32.join("/") : (h72.pathname = null, h72.path = null), a62.isNull(h72.pathname) && a62.isNull(h72.search) || (h72.path = (h72.pathname ? h72.pathname : "") + (h72.search ? h72.search : "")), h72.auth = t72.auth || h72.auth, h72.slashes = h72.slashes || t72.slashes, h72.href = h72.format(), h72;
    }, r72.prototype.parseHost = function() {
      var t72 = this.host, s62 = n72.exec(t72);
      s62 && (":" !== (s62 = s62[0]) && (this.port = s62.substr(1)), t72 = t72.substr(0, t72.length - s62.length)), t72 && (this.hostname = t72);
    };
    h62.Url;
    h62.format;
    h62.resolve;
    h62.resolveObject;
    exports52 = {};
    _dewExec52 = false;
    path2 = dew52();
    processPlatform$12 = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
    h62.URL = typeof URL !== "undefined" ? URL : null;
    h62.pathToFileURL = pathToFileURL$12;
    h62.fileURLToPath = fileURLToPath$12;
    h62.Url;
    h62.format;
    h62.resolve;
    h62.resolveObject;
    h62.URL;
    CHAR_BACKWARD_SLASH$12 = 92;
    CHAR_FORWARD_SLASH$12 = 47;
    CHAR_LOWERCASE_A$12 = 97;
    CHAR_LOWERCASE_Z$12 = 122;
    isWindows$12 = processPlatform$12 === "win32";
    forwardSlashRegEx$12 = /\//g;
    percentRegEx$12 = /%/g;
    backslashRegEx$12 = /\\/g;
    newlineRegEx$12 = /\n/g;
    carriageReturnRegEx$12 = /\r/g;
    tabRegEx$12 = /\t/g;
    processPlatform2 = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
    h62.URL = typeof URL !== "undefined" ? URL : null;
    h62.pathToFileURL = pathToFileURL2;
    h62.fileURLToPath = fileURLToPath2;
    Url2 = h62.Url;
    format25 = h62.format;
    resolve3 = h62.resolve;
    resolveObject2 = h62.resolveObject;
    parse3 = h62.parse;
    _URL2 = h62.URL;
    CHAR_BACKWARD_SLASH2 = 92;
    CHAR_FORWARD_SLASH2 = 47;
    CHAR_LOWERCASE_A2 = 97;
    CHAR_LOWERCASE_Z2 = 122;
    isWindows2 = processPlatform2 === "win32";
    forwardSlashRegEx2 = /\//g;
    percentRegEx2 = /%/g;
    backslashRegEx2 = /\\/g;
    newlineRegEx2 = /\n/g;
    carriageReturnRegEx2 = /\r/g;
    tabRegEx2 = /\t/g;
    exports$622 = {};
    _dewExec$522 = false;
    _global$32 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$522 = {};
    _dewExec$422 = false;
    _global$222 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$422 = {};
    _dewExec$322 = false;
    _global$122 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$322 = {};
    _dewExec$222 = false;
    exports$222 = {};
    _dewExec$122 = false;
    exports$133 = {};
    _dewExec62 = false;
    _global33 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports62 = dew62();
    Agent = exports62.Agent;
    ClientRequest = exports62.ClientRequest;
    IncomingMessage = exports62.IncomingMessage;
    METHODS = exports62.METHODS;
    STATUS_CODES = exports62.STATUS_CODES;
    get = exports62.get;
    globalAgent = exports62.globalAgent;
    request = exports62.request;
  }
});

// node-modules-polyfills-commonjs:http
var http_exports = {};
__export(http_exports, {
  Agent: () => Agent,
  ClientRequest: () => ClientRequest,
  IncomingMessage: () => IncomingMessage,
  METHODS: () => METHODS,
  STATUS_CODES: () => STATUS_CODES,
  get: () => get,
  globalAgent: () => globalAgent,
  request: () => request
});
var init_http2 = __esm({
  "node-modules-polyfills-commonjs:http"() {
    init_http();
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/network/getPublicIP.js
var require_getPublicIP = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/network/getPublicIP.js"(exports10, module2) {
    var http = (init_http2(), __toCommonJS(http_exports));
    var getPublicIP = async () => {
      return new Promise((res, rej) => {
        http.get({ "host": "api.ipify.org", "port": 80, "path": "/" }, (resp) => {
          resp.on("data", (ip) => res(ip));
          resp.on("error", (error) => {
            console.error(error);
            rej(null);
          });
        });
      });
    };
    module2.exports = { getPublicIP };
  }
});

// node-modules-polyfills:dns
function unimplemented6() {
  throw new Error("Node.js dns is not supported by JSPM core outside of Node.js");
}
var promises4, ADDRCONFIG, V4MAPPED, NODATA, FORMERR, SERVFAIL, NOTFOUND, NOTIMP, REFUSED, BADQUERY, BADNAME, BADFAMILY, BADRESP, CONNREFUSED, TIMEOUT, EOF, FILE, NOMEM, DESTRUCTION, BADSTR, BADFLAGS, NONAME, BADHINTS, NOTINITIALIZED, LOADIPHLPAPI, ADDRGETNETWORKPARAMS, CANCELLED;
var init_dns = __esm({
  "node-modules-polyfills:dns"() {
    promises4 = {
      lookup: unimplemented6,
      lookupService: unimplemented6,
      Resolver: unimplemented6,
      getServers: unimplemented6,
      resolve: unimplemented6,
      resolve4: unimplemented6,
      resolve6: unimplemented6,
      resolveAny: unimplemented6,
      resolveCname: unimplemented6,
      resolveMx: unimplemented6,
      resolveNaptr: unimplemented6,
      resolveNs: unimplemented6,
      resolvePtr: unimplemented6,
      resolveSoa: unimplemented6,
      resolveSrv: unimplemented6,
      resolveTxt: unimplemented6,
      reverse: unimplemented6,
      setServers: unimplemented6
    };
    ADDRCONFIG = null;
    V4MAPPED = null;
    NODATA = null;
    FORMERR = null;
    SERVFAIL = null;
    NOTFOUND = null;
    NOTIMP = null;
    REFUSED = null;
    BADQUERY = null;
    BADNAME = null;
    BADFAMILY = null;
    BADRESP = null;
    CONNREFUSED = null;
    TIMEOUT = null;
    EOF = null;
    FILE = null;
    NOMEM = null;
    DESTRUCTION = null;
    BADSTR = null;
    BADFLAGS = null;
    NONAME = null;
    BADHINTS = null;
    NOTINITIALIZED = null;
    LOADIPHLPAPI = null;
    ADDRGETNETWORKPARAMS = null;
    CANCELLED = null;
  }
});

// node-modules-polyfills-commonjs:dns
var dns_exports = {};
__export(dns_exports, {
  ADDRCONFIG: () => ADDRCONFIG,
  ADDRGETNETWORKPARAMS: () => ADDRGETNETWORKPARAMS,
  BADFAMILY: () => BADFAMILY,
  BADFLAGS: () => BADFLAGS,
  BADHINTS: () => BADHINTS,
  BADNAME: () => BADNAME,
  BADQUERY: () => BADQUERY,
  BADRESP: () => BADRESP,
  BADSTR: () => BADSTR,
  CANCELLED: () => CANCELLED,
  CONNREFUSED: () => CONNREFUSED,
  DESTRUCTION: () => DESTRUCTION,
  EOF: () => EOF,
  FILE: () => FILE,
  FORMERR: () => FORMERR,
  LOADIPHLPAPI: () => LOADIPHLPAPI,
  NODATA: () => NODATA,
  NOMEM: () => NOMEM,
  NONAME: () => NONAME,
  NOTFOUND: () => NOTFOUND,
  NOTIMP: () => NOTIMP,
  NOTINITIALIZED: () => NOTINITIALIZED,
  REFUSED: () => REFUSED,
  Resolver: () => unimplemented6,
  SERVFAIL: () => SERVFAIL,
  TIMEOUT: () => TIMEOUT,
  V4MAPPED: () => V4MAPPED,
  getServers: () => unimplemented6,
  lookup: () => unimplemented6,
  lookupService: () => unimplemented6,
  promises: () => promises4,
  resolve: () => unimplemented6,
  resolve4: () => unimplemented6,
  resolve6: () => unimplemented6,
  resolveAny: () => unimplemented6,
  resolveCname: () => unimplemented6,
  resolveMx: () => unimplemented6,
  resolveNaptr: () => unimplemented6,
  resolveNs: () => unimplemented6,
  resolvePtr: () => unimplemented6,
  resolveSoa: () => unimplemented6,
  resolveSrv: () => unimplemented6,
  resolveTxt: () => unimplemented6,
  reverse: () => unimplemented6,
  setServers: () => unimplemented6
});
var init_dns2 = __esm({
  "node-modules-polyfills-commonjs:dns"() {
    init_dns();
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/network/getPublicIPsForUrl.js
var require_getPublicIPsForUrl = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/network/getPublicIPsForUrl.js"(exports10, module2) {
    var dns = (init_dns2(), __toCommonJS(dns_exports));
    var getPublicIPsForUrl = (url) => {
      return new Promise((res, rej) => {
        dns.resolve4(url, (err, addresses) => {
          err ? rej(err) : res(addresses);
        });
      });
    };
    module2.exports = { getPublicIPsForUrl };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/network/getHostIP.js
var require_getHostIP = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/network/getHostIP.js"(exports10, module2) {
    var os = (init_os2(), __toCommonJS(os_exports));
    var { mapFind } = require_cjs();
    var getHostIP = () => {
      const ifaces = os.networkInterfaces();
      return mapFind(
        ifaces,
        (iface) => mapFind(iface, (addrInfo) => {
          const { family, internal, address } = addrInfo;
          const isDNSResolverMatch = address.indexOf("169.254") === 0;
          return family !== "IPv4" || internal || address === "127.0.0.1" || isDNSResolverMatch ? void 0 : address;
        })
      );
    };
    module2.exports = {
      getHostIP
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/network/index.js
var require_network = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/network/index.js"(exports10, module2) {
    module2.exports = {
      ...require_getAddresses(),
      ...require_ipIsInRange(),
      ...require_isPrivateIP(),
      ...require_getPrivateIPs(),
      ...require_getPublicIP(),
      ...require_getPublicIPsForUrl(),
      ...require_getHostIP()
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/path/getPackageRoot.js
var require_getPackageRoot = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/path/getPackageRoot.js"(exports10, module2) {
    var { tryRequireSync } = require_node();
    var path3 = (init_path2(), __toCommonJS(path_exports));
    var getPackageRoot = (location2) => {
      if (location2 === "/")
        return null;
      const nextPath = path3.resolve(location2, "package.json");
      if (tryRequireSync(nextPath))
        return location2;
      const parentPath = path3.resolve(location2, "..");
      return getPackageRoot(parentPath);
    };
    module2.exports = { getPackageRoot };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/path/index.js
var require_path = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/path/index.js"(exports10, module2) {
    module2.exports = {
      ...require_getPackageRoot()
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/process/addToProcess.js
var require_addToProcess = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/process/addToProcess.js"(exports10, module2) {
    var { exists: exists2, emptyObj: emptyObj2, emptyArr } = require_cjs();
    var addToProcess = (addEnvs, opts2 = emptyObj2) => {
      const { force, ignore = emptyArr } = opts2;
      Object.entries(addEnvs).map(([key, value]) => {
        exists2(value) && !ignore.includes(key) && (!exists2(process.env[key]) || force) && (process.env[key] = value);
      });
    };
    module2.exports = {
      addToProcess
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/process/processExit.js
var require_processExit = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/process/processExit.js"(exports10, module2) {
    var { Logger: Logger3 } = require_logger();
    var { exists: exists2, isNum, noOpObj } = require_cjs();
    var eventExitStatus = noOpObj;
    var getEventExitCode = () => {
      return eventExitStatus;
    };
    var onProcessExit = (tag, exitCode, message) => {
      tag && message && Logger3.error(`
[ ${tag} ] - ${message}
`);
      process.exit(exitCode);
    };
    var addExitEvents = () => {
      Array.from([
        "exit",
        "SIGINT",
        "SIGUSR1",
        "SIGUSR2",
        "uncaughtException",
        "SIGTERM"
      ]).map((event) => process.on(event, (type2, exitCode) => {
        !exists2(eventExitStatus.code) && (eventExitStatus = {
          code: isNum(type2) ? type2 : exitCode,
          message: `Process exit from event: ${event}`
        });
      }));
    };
    module2.exports = {
      addExitEvents,
      onProcessExit,
      getEventExitCode
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/process/index.js
var require_process = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/process/index.js"(exports10, module2) {
    module2.exports = {
      ...require_addToProcess(),
      ...require_processExit()
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/tap/getTapPath.js
var require_getTapPath = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/tap/getTapPath.js"(exports10, module2) {
    var { get: get2, validate, isObj, isStr } = require_cjs();
    var { GLOBAL_CONFIG_PATHS } = require_constants();
    var getTapPath = (globalConfig, tapName) => {
      validate(
        { globalConfig, tapName },
        { globalConfig: isObj, tapName: isStr },
        { throws: true }
      );
      return get2(globalConfig, `${GLOBAL_CONFIG_PATHS.TAP_LINKS}.${tapName}.path`);
    };
    module2.exports = {
      getTapPath
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/tap/getTapConfig.js
var require_getTapConfig = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/tap/getTapConfig.js"(exports10, module2) {
    var nodePath = (init_path2(), __toCommonJS(path_exports));
    var { getTapPath } = require_getTapPath();
    var { isObj } = require_cjs();
    var { TAP_CONFIG_NAMES } = require_constants2();
    var { tryRequireSync } = require_node();
    var { getKegGlobalConfig } = require_getKegGlobalConfig();
    var getTapConfig = ({ path: path3, name: name2, configNames = TAP_CONFIG_NAMES } = {}) => {
      if (!path3 && !name2)
        throw new Error("Either path or name parameters for tap must be defined.");
      const tapPath = path3 || getTapPath(getKegGlobalConfig(), name2);
      for (let i13 = 0; i13 < configNames.length; i13++) {
        const possiblePath = nodePath.join(tapPath, configNames[i13]);
        const config = tryRequireSync(possiblePath);
        if (isObj(config))
          return [config, possiblePath];
      }
      return [null, null];
    };
    var getTapPackage = (options) => getTapConfig({ ...options, configNames: ["package.json"] });
    module2.exports = { getTapConfig, getTapPackage };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/tap/getTapRoot.js
var require_getTapRoot = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/tap/getTapRoot.js"(exports10, module2) {
    var { getTapPath } = require_getTapPath();
    var { getPackageRoot } = require_getPackageRoot();
    var { getKegGlobalConfig } = require_getKegGlobalConfig();
    var getTapRoot = ({ tap, location: location2 } = {}) => {
      if (!tap && !location2)
        throw new Error("Cannot resolve tap root without a tap alias or location string!", { tap, location: location2 });
      return location2 ? getPackageRoot(location2) : getTapPath(getKegGlobalConfig(), tap);
    };
    module2.exports = { getTapRoot };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/tap/index.js
var require_tap = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/tap/index.js"(exports10, module2) {
    module2.exports = {
      ...require_getTapConfig(),
      ...require_getTapPath(),
      ...require_getTapRoot()
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/index.js
var require_src3 = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/src/index.js"(exports10, module2) {
    var error = require_error2();
    var fileSys = require_fileSys2();
    var constants4 = require_constants2();
    var { runTask } = require_runTask();
    var { registerTasks } = require_tasks();
    var { getAppRoot, setAppRoot } = require_appRoot();
    var {
      buildTaskData,
      executeTask,
      findTask,
      hasHelpArg,
      parseTaskArgs,
      sharedOptions,
      runInternalTask,
      setSharedOptions,
      validateTask
    } = require_task();
    module2.exports = {
      ...require_commands2(),
      ...require_logger2(),
      ...require_network(),
      ...require_path(),
      ...require_process(),
      ...require_tap(),
      ...require_globalConfig(),
      constants: constants4,
      buildTaskData,
      executeTask,
      findTask,
      fileSys,
      error,
      hasHelpArg,
      registerTasks,
      runTask,
      parseTaskArgs,
      sharedOptions,
      setSharedOptions,
      getAppRoot,
      setAppRoot,
      runInternalTask,
      validateTask
    };
  }
});

// node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/index.js
var require_cli_utils = __commonJS({
  "node_modules/.pnpm/@keg-hub+cli-utils@0.8.0/node_modules/@keg-hub/cli-utils/index.js"(exports10, module2) {
    module2.exports = require_src3();
  }
});

// src/bin/reporters/index.ts
var reporters_exports = {};
__export(reporters_exports, {
  CLIReporter: () => CLIReporter
});
module.exports = __toCommonJS(reporters_exports);

// src/bin/reporters/cli/cli.ts
var import_cli_utils2 = __toESM(require_cli_utils());
var import_jsutils = __toESM(require_cjs());

// src/bin/reporters/cli/formatters.ts
var import_cli_utils = __toESM(require_cli_utils());
var Clrs = import_cli_utils.Logger.colors;
var FailTag = `${Clrs.colorMap.red}\u2718`;
var PassTag = `${Clrs.colorMap.green}\u2714`;
var WarnTag = `${Clrs.colorMap.yellow}\u25CB`;
var FPassTag = `\x1B[42m\x1B[30m PASS \x1B[0m`;
var FFailTag = `\x1B[41m\x1B[30m FAIL \x1B[0m`;
var FWarnTag = `\x1B[43m\x1B[30m WARN \x1B[0m`;
var Tags = {
  root: {
    fail: FFailTag,
    pass: FPassTag,
    warn: FWarnTag
  },
  child: {
    fail: FailTag,
    pass: PassTag,
    warn: WarnTag
  }
};
var DimText = (text) => `${Clrs.colorMap.dim}${text}`;
var ColorMap = {
  Feature: {
    text: Clrs.colorMap.gray,
    type: Clrs.colorMap.yellow
  },
  Rule: {
    text: Clrs.colorMap.gray,
    type: Clrs.colorMap.blue
  },
  Parent: {
    text: Clrs.colorMap.gray,
    type: Clrs.colorMap.magenta
  },
  Step: {
    text: Clrs.colorMap.gray,
    type: Clrs.colorMap.cyan
  },
  Error: {
    text: Clrs.colorMap.white,
    type: Clrs.colorMap.red
  }
};
var FormatLine = (args) => {
  const {
    type: type2,
    text,
    failed,
    isParent,
    isFailed,
    isFeature
  } = args;
  const sep3 = isParent ? ` ${Clrs.colorMap.white}> ` : ` `;
  const [PTag, FTag, WTag] = isFeature ? [FPassTag, FFailTag, FWarnTag] : [PassTag, FailTag, WarnTag];
  const tag = !failed ? PTag : isFailed ? FTag : WTag;
  const colorType = ColorMap[type2];
  const colors = failed && isFailed ? ColorMap.Error : colorType ? colorType : isParent ? ColorMap.Parent : ColorMap.Step;
  const line = `${tag} ${colors.type}${type2}${sep3}${colors.text}${text}${Clrs.colorMap.reset}`;
  return isFailed || !failed ? line : DimText(line);
};
var FormatParent = (text, failed, isFailed) => {
  var _a, _b;
  const [first, description] = text.split(`>`);
  const type2 = first.trim();
  const isFeature = type2.startsWith(`Feature`);
  const line = FormatLine({
    type: type2,
    failed,
    isFailed,
    isParent: true,
    isFeature: type2.startsWith(`Feature`),
    text: (_b = (_a = description || ``) == null ? void 0 : _a.trim) == null ? void 0 : _b.call(_a)
  });
  return isFeature ? `
${line}
` : `  ${line}
`;
};
var FormatChild = (text, failed, isFailed) => {
  var _a, _b;
  const [type2, ...rest] = text.split(` `);
  const line = FormatLine({
    failed,
    isFailed,
    isParent: false,
    type: type2.trim(),
    text: (_b = (_a = rest.join(` `) || ``) == null ? void 0 : _a.trim) == null ? void 0 : _b.call(_a)
  });
  return `    ${line}
`;
};
var FormatError = (failed) => {
  const output = [];
  const space = `      `;
  const { fullName, description, error } = failed;
  const message = error ? error.stack : `${fullName}
${description}`;
  const [first, ...lines] = message.split(`
`);
  output.push(`
${space}${Clrs.red(first)}
`);
  output.push(Clrs.white(lines.map((line) => `${space}${line}`).join(`
`)));
  output.push(`

`);
  return output.join(``);
};
var FormatErrors = (failedExps) => {
  return failedExps.map((failed) => FormatError(failed)).join(``);
};
var Format = (text, failed, isFailed) => {
  return text.includes(`>`) ? FormatParent(text, failed, isFailed) : FormatChild(text, failed, isFailed);
};

// src/bin/reporters/cli/cli.ts
var FailText = (text) => `${import_cli_utils2.Logger.colors.red(`\u2718`)} ${import_cli_utils2.Logger.colors.gray(`-`)} ${text}`;
var PassText = (text) => `${import_cli_utils2.Logger.colors.green(`\u2714`)} ${import_cli_utils2.Logger.colors.gray(`-`)} ${text}`;
var printResult = (results, opts2 = import_jsutils.emptyObj) => {
  const {
    errorOnly,
    failedOnly,
    steps = true,
    features = true,
    stepParents = true,
    exitWithError,
    throwOnFailed
  } = opts2;
  let hasFailed;
  const output = [];
  results.forEach((result) => {
    if (!result.describes)
      return;
    if ((failedOnly || errorOnly) && result.passed)
      return;
    if (!hasFailed && result.failed)
      hasFailed = result.failed;
    if (features && (!errorOnly || !result.passed))
      output.push(FormatParent(result.fullName, result.failed, result.failed));
    result.describes.forEach((describe) => {
      if ((failedOnly || errorOnly) && describe.passed)
        return;
      if (stepParents && (!errorOnly || !describe.passed))
        output.push(FormatParent(describe.description, result.failed, describe.failed));
      describe.tests.forEach((test) => {
        if ((failedOnly || errorOnly) && test.passed)
          return;
        if (steps || !test.passed)
          output.push(FormatChild(test.description, result.failed, test.failed));
        test.failed && output.push(FormatErrors(test.failedExpectations));
      });
    });
  });
  if (!hasFailed) {
    if (!exitWithError)
      return output.length && import_cli_utils2.Logger.log(output.join(``));
    output.length && import_cli_utils2.Logger.log(output.join(``));
    import_cli_utils2.Logger.empty();
    import_cli_utils2.Logger.log(PassText(`All features ${import_cli_utils2.Logger.colors.green(`passed`)}
`));
    process.exit(0);
  }
  if (exitWithError) {
    output.length && import_cli_utils2.Logger.log(output.join(``));
    import_cli_utils2.Logger.empty();
    import_cli_utils2.Logger.log(FailText(`One or more Features ${import_cli_utils2.Logger.colors.red(`failed`)}
`));
    import_cli_utils2.Logger.empty();
    process.exit(1);
  }
  output.length && import_cli_utils2.Logger.log(output.join(``));
  if (throwOnFailed)
    throw new Error(`One or more Features failed`);
};
var CLIReporter = {
  tags: Tags,
  fail: FailText,
  pass: PassText,
  results: printResult,
  format: {
    format: Format,
    line: FormatLine,
    error: FormatError,
    child: FormatChild,
    parent: FormatParent,
    errors: FormatErrors
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CLIReporter
});
/*! Bundled license information:

@jspm/core/nodelibs/browser/chunk-44e51b61.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@jspm/core/nodelibs/browser/assert.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

@jspm/core/nodelibs/browser/buffer.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
/*! Bundled license information:

@jspm/core/nodelibs/browser/chunk-44e51b61.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
/*! Bundled license information:

@jspm/core/nodelibs/browser/assert.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=index.js.map
