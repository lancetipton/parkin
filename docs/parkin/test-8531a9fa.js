System.register(["./wait-26c5e7c6-2112d3c7.js"],(function(t){"use strict";var e,s,i,a,r,o,n,c,h,d,l;return{setters:[function(t){e=t.i,s=t.a,i=t.n,a=t.b,r=t.c,o=t._,n=t.g,c=t.h,h=t.j,d=t.f,l=t.d}],execute:function(){const keyMap=(t,i)=>e(t)&&t.reduce(((t,e)=>{if(!s(e))return t;const a=i&&e.toUpperCase()||e;return t[a]=a,t}),{})||{},p=keyMap(["beforeAll","beforeEach","afterAll","afterEach"]),u={...t("g",{...keyMap(["test","it","xtest","xit","describe"]),...p}),...keyMap(["root"])},throwError=t=>{throw new Error(t)},createItem=(t,e=i,r=!0)=>{const{description:o,action:n}=e;return r&&((t,e,i)=>{!s(t)&&throwError("Test item type is required as a string"),!a(i)&&throwError(`The ${t} method requires a "function" as the second argument`),!s(e)&&throwError(`The ${t} method requires a "string" as the first argument`)})(t,o,n),{...e,type:t}},runResult=(t,{id:e,fullName:s,action:i,failed:a,passed:o,testPath:n})=>{const c={id:e,action:i,testPath:n,fullName:s,type:t.type,failedExpectations:[],passedExpectations:[],failed:Boolean(a),passed:Boolean(o),description:t.description,timestamp:(new Date).getTime()};return r(a)&&c.failedExpectations.push(a),r(o)&&c.passedExpectations.push(o),(o||a)&&(c.status=o?"passed":"failed"),c},loopHooks=async t=>{const{type:e,test:s,specId:i,suiteId:a,describe:r,root:o}=t;let n;const c=o||r,h=o?o.description:s?`${null==r?void 0:r.description} > ${null==s?void 0:s.description} > ${e}`:`${null==r?void 0:r.description} > ${e}`;try{c[e].length&&await Promise.all(c[e].map(((t,e)=>(n=e,t()))))}catch(t){return runResult(c,{fullName:h,action:e,status:"failed",id:s?i:a,failed:{name:t.name,message:t.message},testPath:s?`/${a}/${i}/${e}${n}`:`/${a}/${e}${n}`})}},loopTests=async t=>{const{suiteId:e,describe:s,testOnly:i,specDone:a,specStarted:r}=t;let o=!1;const n=[];for(let t=0;t<s.tests.length;t++){const c=s.tests[t],h=`spec${t}`,d=`/${e}/${h}`,l=`${s.description} > ${c.description}`;let p=runResult(c,{fullName:l,testPath:d,id:h,action:"start"});if(i&&!c.only||c.skip){r({...p,skipped:!0,action:"skipped",status:"skipped"});continue}r(p);const b=await loopHooks({test:c,specId:h,suiteId:e,describe:s,type:u.beforeEach});if(b){o=!0,n.push(b),a(b);break}try{const t=await c.action();p=runResult(c,{fullName:l,id:h,testPath:d,action:u.test,passed:t||!0})}catch(t){p=runResult(c,{fullName:l,id:h,action:u.test,testPath:d,failed:{name:t.name,message:t.message}}),o=!0}const f=await loopHooks({test:c,specId:h,suiteId:e,describe:s,type:u.afterEach});if(f){o=!0,n.push(f),a(f);break}n.push(p),a({...p,action:"end"})}return{tests:n,failed:o}},callBeforeHooks=async({root:t,suiteId:e,describe:s})=>{const i=await loopHooks({root:t,suiteId:u.root,type:u.beforeEach}),a=!i&&await loopHooks({suiteId:e,describe:s,type:u.beforeAll});return i||a},callAfterHooks=async({root:t,suiteId:e,describe:s})=>{const i=await loopHooks({root:t,suiteId:u.root,type:u.afterEach}),a=!i&&await loopHooks({suiteId:e,describe:s,type:u.afterAll});return i||a},loopDescribes=async t=>{const{root:e,testOnly:s,specDone:i,suiteDone:a,specStarted:r,parentIdx:o="",suiteStarted:n,describeOnly:c}=t;let h=!1;const d=[];for(let l=0;l<e.describes.length;l++){const p=e.describes[l],u=`suite-${o}${l}`;let b=runResult(p,{id:u,action:"start",testPath:`/${u}`,fullName:p.description});if(p.skip||c&&!p.only&&!p.onlyChild||s&&!p.onlyChild){n({...b,skipped:!0,action:"skipped",status:"skipped"});continue}n(b);const f=await callBeforeHooks({root:e,suiteId:u,describe:p});if(f){h=!0,b={...b,...f},a(b),d.push(b);continue}const w=await loopTests({suiteId:u,describe:p,testOnly:s,specDone:i,specStarted:r}),y=p.describes&&p.describes.length&&await loopDescribes({...t,root:p,parentIdx:`${l}-`});b={...b,...y,action:"end",tests:w.tests},w.failed||y.failed?(h=!0,b.failed=!0):b.passed=!0;const m=await callAfterHooks({root:e,suiteId:u,describe:p});m?(h=!0,b={...b,...m},a(b),d.push(b)):(a(b),d.push(b))}return{describes:d,failed:h}},run=async t=>{var e;(e=t.root).type!==u.root&&throwError(`Invalid root type "${e.type}" set for root object`),!e.describes||!e.describes.length&&throwError("No tests have been registered to this ParkinTest instance");const s=await loopHooks({root:t.root,suiteId:u.root,type:u.beforeAll});if(s)return[s];const{describes:i}=await loopDescribes(t),a=await loopHooks({root:t.root,suiteId:u.root,type:u.afterAll});return a&&i.push(a),i};var b=new WeakMap,f=new WeakMap,w=new WeakMap,y=new WeakMap,m=new WeakMap,k=new WeakMap,$=new WeakMap,g=new WeakMap,v=new WeakMap,I=new WeakMap,M=new WeakMap,O=new WeakMap,W=new WeakMap;t("P",class ParkinTest{constructor(t=i){o(this,"timeout",6e3),n(this,b,{writable:!0,value:d}),n(this,f,{writable:!0,value:d}),n(this,w,{writable:!0,value:d}),n(this,y,{writable:!0,value:d}),n(this,m,{writable:!0,value:void 0}),n(this,k,{writable:!0,value:!1}),n(this,$,{writable:!0,value:!1}),n(this,g,{writable:!0,value:createItem(u.root,{describes:[]},!1)}),o(this,"getActiveParent",(()=>c(this,m))),n(this,v,{writable:!0,value:({timeout:t,specDone:e,suiteDone:s,specStarted:i,suiteStarted:a})=>{t&&(this.timeout=t),e&&h(this,b,e),s&&h(this,f,s),i&&h(this,w,i),a&&h(this,y,a)}}),n(this,I,{writable:!0,value:()=>{this.describe.only=(...t)=>{this.describe(...t);c(this,m).describes[c(this,m).describes.length-1].only=!0,h(this,$,!0),l(c(this,m).hasOnlyChild)},this.test.only=(...t)=>{this.test(...t);c(this,m).tests[c(this,m).tests.length-1].only=!0,h(this,k,!0),l(c(this,m).hasOnlyChild)}}}),n(this,M,{writable:!0,value:()=>{this.describe.skip=(...t)=>{this.describe(...t);c(this,m).describes[c(this,m).describes.length-1].skip=!0},this.test.skip=(...t)=>{this.test(...t);c(this,m).tests[c(this,m).tests.length-1].skip=!0}}}),n(this,O,{writable:!0,value:()=>{}}),n(this,W,{writable:!0,value:()=>{Object.values(p).map((t=>{this[t]=e=>{((t,e,s)=>{!a(e)&&throwError(`The ${t} method requires a "function" as the first argument`)(!s||s.type===u.root)&&throwError(`The ${t} method must be called within a ${u.describe} method`)})(t,e,c(this,m)),c(this,m)[t].push(e)}}))}}),o(this,"describe",((t,e)=>{const s=createItem(u.describe,{action:e,tests:[],description:t,describes:[]});s.disabled=()=>s.skip=!0,Object.values(p).map((t=>s[t]=[])),c(this,m).describes.push(s);const i=c(this,m);s.hasOnlyChild=()=>{s.onlyChild=!0,l(i.hasOnlyChild)},h(this,m,s),e(),h(this,m,i)})),o(this,"test",((t,e,s)=>{c(this,m)&&c(this,m).type!==u.root||throwError(`All ${u.test} method calls must be called within a ${u.describe} method`);const i=createItem(u.test,{action:e,timeout:s,description:t});i.disabled=()=>i.skip=!0,c(this,m).tests.push(i)})),o(this,"xtest",(t=>{c(this,m)&&c(this,m).type!==u.root||throwError(`All ${u.test} method calls must be called within a ${u.describe} method`),!s(t)&&throwError(`The ${u.test} method requires a "string" as the first argument`);const e=createItem(u.test,{description:t,skip:!0},!1);e.disabled=()=>e.skip=!0,c(this,m).tests.push(e)})),c(this,g).description=t.description||"root",Object.values(p).map((t=>c(this,g)[t]=[])),c(this,I).call(this),c(this,M).call(this),c(this,W).call(this),this.it=this.test,this.xit=this.xtest,h(this,m,c(this,g)),c(this,v).call(this,t),this.run=(t=i)=>(c(this,g).description=t.description||c(this,g).description,c(this,v).call(this,t),run({root:c(this,g),testOnly:c(this,k),specDone:c(this,b),suiteDone:c(this,f),specStarted:c(this,w),describeOnly:c(this,$),suiteStarted:c(this,y)}))}})}}}));
