{"version":3,"file":"index.js","sources":["../../../../repos/jsutils/build/esm/isArr-a4420764.js","../../../../repos/jsutils/build/esm/isObj-2a71d1af.js","../../../../repos/jsutils/build/esm/isFunc-40ceeef8.js","../../../../repos/jsutils/build/esm/deepFreeze-0437aacd.js","../../../../repos/jsutils/build/esm/match-39e2fa8f.js","../../../../repos/jsutils/build/esm/exists-bf542cb8.js","../../../../repos/jsutils/build/esm/isStr-481ce69b.js","../../../../repos/jsutils/build/esm/isNum-cc6ad9ca.js","../../../../repos/jsutils/build/esm/toStr-0e5fe94c.js","../../../../repos/jsutils/build/esm/parseErrorMessage-475a1f22.js","../../../../repos/jsutils/build/esm/joinRegex-8ea25337.js","../../src/matcher/patterns.js","../../src/errors.js","../../src/matcher/paramTypes.js","../../src/matcher/regex.js","../../src/constants.js","../../src/globalObj.js","../../src/matcher/expression.js","../../src/matcher/matcher.js","../../src/steps.js","../../src/hooks.js","../../src/parse/parseFeature.js","../../src/parse/parseDefinition.js","../../src/testMethods.js","../../src/runner.js","../../src/assemble/feature.js","../../src/assemble/assemble.js","../../src/parkin.js"],"sourcesContent":["const isArr = value => Array.isArray(value);\n\nexport { isArr as i };\n//# sourceMappingURL=isArr-a4420764.js.map\n","const isObj = obj => typeof obj === 'object' && !Array.isArray(obj) && obj !== null;\n\nexport { isObj as i };\n//# sourceMappingURL=isObj-2a71d1af.js.map\n","const isFunc = func => typeof func === 'function';\n\nexport { isFunc as i };\n//# sourceMappingURL=isFunc-40ceeef8.js.map\n","import { i as isFunc } from './isFunc-40ceeef8.js';\n\nconst deepFreeze = obj => {\n  Object.freeze(obj);\n  Object.getOwnPropertyNames(obj).map(prop => {\n    obj.hasOwnProperty(prop) && obj[prop] !== null && (typeof obj[prop] === 'object' || isFunc(obj[prop])) && !Object.isFrozen(obj[prop]) && deepFreeze(obj[prop]);\n  });\n  return obj;\n};\n\nexport { deepFreeze as d };\n//# sourceMappingURL=deepFreeze-0437aacd.js.map\n","import { d as deepFreeze } from './deepFreeze-0437aacd.js';\nimport { i as isArr } from './isArr-a4420764.js';\nimport { t as typeOf } from './typeOf-8c86a991.js';\nimport { i as isFunc } from './isFunc-40ceeef8.js';\n\nconst noOp = () => {};\nconst noOpObj = Object.freeze({});\nconst noPropObj = deepFreeze({\n  content: {}\n});\nconst noPropArr = deepFreeze([]);\n\nconst match = (matchArg, ...args) => {\n  if (!args.length) return null;\n  for (let entry of args) {\n    if (!isArr(entry)) {\n      console.error(`Matching case must be an entry (a 2-element array). Found: ${typeOf(entry)}`, entry);\n      break;\n    }\n    const [caseValueOrPredicate, valueOnMatch] = entry;\n    if (isFunc(caseValueOrPredicate) && caseValueOrPredicate(matchArg)) return valueOnMatch;\n    if (caseValueOrPredicate === matchArg) return valueOnMatch;\n  }\n  return null;\n};\nmatch.default = () => true;\n\nexport { noOpObj as a, noPropObj as b, noPropArr as c, match as m, noOp as n };\n//# sourceMappingURL=match-39e2fa8f.js.map\n","const exists = value => value === value && value !== undefined && value !== null;\n\nexport { exists as e };\n//# sourceMappingURL=exists-bf542cb8.js.map\n","const isStr = str => typeof str === 'string';\n\nexport { isStr as i };\n//# sourceMappingURL=isStr-481ce69b.js.map\n","const equalsNaN = val => typeof val === 'number' && val != val;\n\nconst isNum = val => typeof val === 'number' && !equalsNaN(val);\n\nexport { equalsNaN as e, isNum as i };\n//# sourceMappingURL=isNum-cc6ad9ca.js.map\n","import { i as isStr } from './isStr-481ce69b.js';\n\nconst toStr = val => val === null || val === undefined ? '' : isStr(val) ? val : JSON.stringify(val);\n\nexport { toStr as t };\n//# sourceMappingURL=toStr-0e5fe94c.js.map\n","import { i as isFunc } from './isFunc-40ceeef8.js';\nimport { v as validate } from './validate-0eec5ac6.js';\nimport { i as isNum } from './isNum-cc6ad9ca.js';\nimport { h as hasOwn } from './hasOwn-deb5bbb8.js';\nimport { i as isArr } from './isArr-a4420764.js';\nimport { d as deepClone } from './deepClone-bbe59305.js';\nimport { i as isStr } from './isStr-481ce69b.js';\nimport { i as isObj } from './isObj-2a71d1af.js';\nimport { i as isEmpty } from './isEmpty-36c950c4.js';\n\nconst checkCall = (method, ...params) => {\n  return isFunc(method) ? method(...params) : undefined;\n};\n\nconst complement = predicate => {\n  const [valid] = validate({\n    predicate\n  }, {\n    predicate: isFunc\n  });\n  return valid ? (...args) => !predicate(...args) : null;\n};\n\nconst eitherFunc = (func1, func2) => isFunc(func1) && func1 || func2;\n\nconst debounce = (func, wait = 250, immediate = false) => {\n  let timeout;\n  function wrapFunc(...args) {\n    if (!isFunc(func)) return null;\n    const context = this;\n    const later = () => {\n      timeout = null;\n      !immediate && func.apply(context, args);\n    };\n    const callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) return isFunc(func) && func.apply(context, args);\n  }\n  return wrapFunc;\n};\n\nconst doIt = (...args) => {\n  const params = args.slice();\n  const num = params.shift();\n  const bindTo = params.shift();\n  const cb = params.pop();\n  if (!isNum(num) || !isFunc(cb)) return [];\n  const doItAmount = new Array(num);\n  const responses = [];\n  for (let i = 0; i < doItAmount.length; i++) {\n    const data = cb.call(bindTo, i, ...params);\n    if (data === false) break;\n    responses.push(data);\n  }\n  return responses;\n};\n\nconst hasDomAccess = () => {\n  try {\n    return !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n  } catch (error) {\n    return false;\n  }\n};\n\nconst memorize = (func, getCacheKey, limit = 1) => {\n  if (!isFunc(func) || getCacheKey && !isFunc(getCacheKey)) return console.error('Error: Expected a function', func, getCacheKey);\n  let memorized = function () {\n    const cache = memorized.cache;\n    const key = getCacheKey ? getCacheKey.apply(this, arguments) : arguments[0];\n    if (hasOwn(cache, key)) return cache[key];\n    const result = func.apply(this, arguments);\n    isNum(limit) && Object.keys(cache).length < limit ? cache[key] = result : memorized.cache = {\n      [key]: result\n    };\n    return result;\n  };\n  memorized.cache = {};\n  memorized.destroy = () => {\n    getCacheKey = undefined;\n    memorized.cache = undefined;\n    memorized.destroy = undefined;\n    memorized = undefined;\n  };\n  return memorized;\n};\n\nconst runSeq = async (asyncFns = [], options = {}) => {\n  const [valid] = validate({\n    asyncFns\n  }, {\n    asyncFns: isArr\n  });\n  if (!valid) return [];\n  const {\n    cloneResults = false,\n    returnOriginal = true\n  } = options;\n  const results = [];\n  for (const fn of asyncFns) {\n    const result = isFunc(fn) ? await fn(results.length, cloneResults ? deepClone(results) : results) : returnOriginal ? fn : undefined;\n    results.push(result);\n  }\n  return results;\n};\n\nconst timedRun = async (fn, ...args) => {\n  const [valid] = validate({\n    fn\n  }, {\n    fn: isFunc\n  });\n  if (!valid) return [undefined, -1];\n  const startTime = new Date();\n  const result = await fn(...args);\n  return [result, new Date() - startTime];\n};\n\nconst throttle = (func, wait = 100) => {\n  let waiting = false;\n  return function (...args) {\n    if (waiting) return;\n    waiting = true;\n    func.apply(this, args);\n    return setTimeout(() => {\n      waiting = false;\n    }, wait);\n  };\n};\n\nconst throttleLast = (func, cb, wait = 100) => {\n  let throttleTimeout;\n  return function (...args) {\n    if (throttleTimeout) clearTimeout(throttleTimeout);\n    throttleTimeout = setTimeout(() => {\n      func.apply(this, args);\n      clearTimeout(throttleTimeout);\n    }, wait);\n    typeof cb === 'function' && cb();\n  };\n};\n\nconst limbo = promise => {\n  return !promise || !isFunc(promise.then) ? [new Error(`A promise or thenable is required as the first argument!`), null] : promise.then(data => [null, data]).catch(err => [err, undefined]);\n};\n\nconst uuid = a => a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid);\n\nconst parseErrorMessage = exception => {\n  return isStr(exception) && !isEmpty(exception) ? exception : isObj(exception) ? exception.message : null;\n};\n\nexport { complement as a, doIt as b, checkCall as c, debounce as d, eitherFunc as e, throttle as f, throttleLast as g, hasDomAccess as h, limbo as l, memorize as m, parseErrorMessage as p, runSeq as r, timedRun as t, uuid as u };\n//# sourceMappingURL=parseErrorMessage-475a1f22.js.map\n","import { i as isStr } from './isStr-481ce69b.js';\nimport { i as isArr } from './isArr-a4420764.js';\nimport './validate-0eec5ac6.js';\nimport './match-39e2fa8f.js';\n\nconst isRegex = val => Boolean(val && val instanceof RegExp);\n\nconst getRegexSource = maybeRx => isRegex(maybeRx) ? maybeRx.source : isStr(maybeRx) ? maybeRx : null;\n\nconst parseArgs = args => {\n  if (isArr(args[0])) return [args[0], args[1]];\n  const last = args[args.length - 1];\n  const options = isStr(last) ? last : undefined;\n  const expressions = options ? args.splice(0, args.length - 1) : args;\n  return [expressions, options];\n};\nconst joinRegex = (...args) => {\n  const [expressions, options] = parseArgs(args);\n  const source = expressions.reduce((joined, next) => {\n    const nextSource = getRegexSource(next);\n    return !nextSource ? joined : joined === '' ? nextSource : `${joined}|${nextSource}`;\n  }, '');\n  return new RegExp(`(${source})`, options);\n};\n\nexport { getRegexSource as g, isRegex as i, joinRegex as j };\n//# sourceMappingURL=joinRegex-8ea25337.js.map\n","import { joinRegex } from '@keg-hub/jsutils'\n\nexport const RX_OPTIONAL = /\\w*\\([^)]*?\\)/\n\nexport const RX_ALT = /\\s*\\S*\\/\\S*\\s*/\n\nexport const RX_PARAMETER = /\\s*{(.*?)}\\s*/\n\nexport const RX_EXPRESSION = joinRegex(RX_PARAMETER, RX_OPTIONAL, 'g')\n\nexport const RX_ANY = /(.*)/\n\nexport const RX_MATCH_REPLACE = /{|}/g\n\nexport const RX_DOUBLE_QUOTED = /\"[^\"]+\"/\n\nexport const RX_SINGLE_QUOTED = /'[^']+'/\n\nexport const RX_FLOAT = /-?[0-9]+[.][0-9]+/\n\nexport const RX_INT = /-?[0-9]+/\n","/*\n * Helper method to use the a test method can not be found on the global scope\n * @function\n * @public\n * @export\n * @param {string} type - Name of test method to get from the global scope\n *\n * @returns {function} - Test method\n */\nexport const testMethodFill = type => {\n  /*\n   * Internal method that throws an error when a test method does not exist on the global scope\n   * @function\n   * @private\n   * @inner\n   *\n   * @returns {void}\n   */\n  return () => {\n    throw new Error(\n      `` +\n        `Test method ${type} does not exist on the global scope.\\n` +\n        `Please ensure ${type} exists before calling the run method!\\n`\n    )\n  }\n}\n\n/**\n * Throws an error when a Steps class instance is not passed to the runner class constructor\n * @function\n * @public\n * @export\n *\n * @returns {void}\n */\nexport const throwMissingSteps = () => {\n  throw new Error(\n    `Runner class constructor requires an instance of the Steps class`\n  )\n}\n\n/**\n * Throws an error when a Hooks class instance is not passed to the runner class constructor\n * @function\n * @public\n * @export\n *\n * @returns {void}\n */\nexport const throwMissingHooks = found => {\n  throw new Error(\n    `Runner class constructor requires an instance of the Hooks class. Found: ${found}`\n  )\n}\n\n/**\n * Throws an error when a feature text is not passed to the Runner class instance\n * @function\n * @public\n * @export\n *\n * @returns {void}\n */\nexport const throwMissingFeatureText = () => {\n  throw new Error(\n    `Runner class requires feature text when calling the run method`\n  )\n}\n\n/**\n * Throws an error when a feature step does not match a step definition\n * @function\n * @public\n * @export\n * @param {string} text - Text that does not match a registered step definition\n *\n * @returns {void}\n */\nexport const throwNoMatchingStep = text => {\n  throw new ReferenceError(text)\n}\n\n/**\n * Throws an error when a registering a param type that already exists\n * @function\n * @public\n * @export\n * @param {string} name - Name of the param type that is being registered\n *\n * @returns {void}\n */\nexport const throwParamTypeExists = () => {\n  throw new Error(`Cannot register param type \"${name}\". It already exists!`)\n}\n\n/**\n * Throws an error when a assembling a parsed feature, and no parsed feature object exists\n * @function\n * @public\n * @export\n * @param {*} feature - Argument that was passed instead of the parsed feature object\n *\n * @returns {void}\n */\nexport const throwFeatureNotAnObj = feature => {\n  throw new Error(\n    `Assemble feature requires an object matching the feature model spec!`,\n    feature\n  )\n}\n","import {\n  noOpObj,\n  toStr,\n  exists,\n  isQuoted,\n  checkCall,\n  equalsNaN,\n  joinRegex,\n} from '@keg-hub/jsutils'\n\nimport {\n  RX_ANY,\n  RX_FLOAT,\n  RX_INT,\n  RX_DOUBLE_QUOTED,\n  RX_SINGLE_QUOTED,\n} from './patterns'\n\nimport { throwParamTypeExists } from '../errors'\n\n/**\n * Default param type model used when registering param types\n * @type {Object}\n */\nconst typeModel = {\n  name: '',\n  regexp: '',\n  type: 'string',\n  useForSnippets: true,\n  transformer: arg => arg,\n  preferForRegexpMatch: false,\n}\n\n/**\n * Maps param types to function, for type conversion\n * Follows the default conversions for cucumber expressions\n * See https://cucumber.io/docs/cucumber/cucumber-expressions/\n * @type {Object}\n */\nconst __paramTypes = {\n  any: {\n    ...typeModel,\n    name: 'any',\n    regex: RX_ANY,\n  },\n  word: {\n    ...typeModel,\n    name: 'word',\n    regex: RX_ANY,\n    transformer: arg => (!isQuoted(arg) ? toStr(arg) : undefined),\n  },\n  float: {\n    ...typeModel,\n    name: 'float',\n    type: 'number',\n    regex: RX_FLOAT,\n    transformer: arg => {\n      const result = parseFloat(arg)\n      return equalsNaN(result) ? undefined : result\n    },\n  },\n  int: {\n    ...typeModel,\n    name: 'int',\n    type: 'number',\n    regex: RX_INT,\n    transformer: arg => {\n      const result = parseInt(arg)\n      return arg.includes('.') || equalsNaN(result) ? undefined : result\n    },\n  },\n  string: {\n    ...typeModel,\n    name: 'string',\n    regex: joinRegex(RX_DOUBLE_QUOTED, RX_SINGLE_QUOTED),\n    transformer: arg => {\n      return isQuoted(arg)\n        ? arg\n            .trim()\n            .replace(/^(\"|')/, '')\n            .replace(/(\"|')$/, '')\n        : undefined\n    },\n  },\n}\n\n/**\n * Get the registered __paramTypes\n * @function\n * @public\n * @export\n *\n * @return {Object} Registered param types\n */\nexport const getParamTypes = () => __paramTypes\n\n/**\n * Register custom types following the typeModel object\n * See https://cucumber.io/docs/cucumber/cucumber-expressions/ for more info\n * @function\n * @public\n * @export\n *\n * @return {Object} Registered param types\n */\nexport const registerParamType = (model = noOpObj, key = model.name) => {\n  __paramTypes[key]\n    ? throwParamTypeExists(key)\n    : (__paramTypes[key] = { ...typeModel, ...model })\n}\n\n/**\n * Converts the found matching values into the correct types\n * Using transformer methods of the matched paramType names\n * @function\n * @public\n * @export\n * @param {Array<string>} matches - All found dynamic arguments\n * @param {Array<function>} transformers - Matching paramTypes by index\n *\n * @returns {Array<*>} Matches converted into the correct type\n */\nexport const convertTypes = (matches, transformers) => {\n  return matches\n    .map((item, i) => {\n      const paramType = transformers[i]\n      if (!paramType) return item\n      const asType = checkCall(paramType.transformer, item)\n      return typeof asType === paramType.type ? asType : null\n    })\n    .filter(exists)\n}\n","import { noOpObj, getWordEndingAt } from '@keg-hub/jsutils'\nimport { getParamTypes } from './paramTypes'\n\nimport { RX_OPTIONAL, RX_ALT, RX_PARAMETER, RX_MATCH_REPLACE } from './patterns'\n\n/**\n * Finds a matching definition from passed in regex\n * Then extracts the variables from the text to pass to the definitions method\n * @function\n * @public\n * @export\n * @param {Object} definition - Registered definition model\n * @param {string} text - Feature step text to compare with definition match text\n *\n * @returns {Object} Found matching definition and matched arguments\n */\nexport const matchRegex = (definition, text) => {\n  const match = text.match(new RegExp(definition.match))\n\n  // Which is the original string\n  return match\n    ? { definition, match: match.slice(1, match.length).filter(Boolean) }\n    : noOpObj\n}\n\n/**\n * Converts an optional expression into regex\n * @param {string} optional\n * @return {string} regex for an optional cucumber-expression\n * @example\n * toAlternateRegex('test(s)')\n * result: '(test|tests)'\n */\nexport const toAlternateRegex = optional => {\n  const split = optional.split(/(\\(|\\))/)\n\n  const [ start, , middle, , end ] = split\n\n  // no words outside of optional boundary\n  if (start === '' && end === '') return optional + '?'\n  else if (start === '') return `(${middle}|${middle}${end})`\n  else if (end === '') return `(${start}|${start}${middle})`\n  else return `(${start}${end}|${start}${middle}${end})`\n}\n\n/**\n * Gets the full text around an optional\n * @param {Array<string>} match result of optional regex match\n */\nconst getFullOptionalText = match => {\n  const text = match.input\n  const precedingWord = getWordEndingAt(text, match.index)\n  return precedingWord + match[0]\n}\n\n/**\n * Helper for `getParamRegex` to get the optional types regex\n * @param {Array<string>} match result of optional regex match\n *\n * @return {string} - The correct regex source text for a definition optional part\n *                    This regex will be used for matching values in the feature step text\n */\nconst getOptionalRegex = match => {\n  const optionalText = getFullOptionalText(match)\n  return toAlternateRegex(optionalText)\n}\n\n/**\n * Returns regex source for a given parameter type\n * @param {string} type - cucumber-expression parameter type: float, int, word, or string\n * @return {string} regex source text\n */\nexport const getParamRegex = type => {\n  const params = getParamTypes()\n  const spec = params[type] || params.any\n  return spec.regex.source\n}\n\n/**\n * Gets the right regex for an alternate part\n * @param {string} value the regex match's text\n * @return {string} regex source for an alternate part\n */\nexport const getAlternateRegex = value => {\n  return `(${value.trim().replace(/\\//g, '|')})`\n}\n\n/**\n * Helper for `parseMatch` that gets the right regex for a step's dynamic content\n * @param {string} type - optional, alternate, or parameter\n * @param {string} match = regex match results\n * \n * @returns {Object|null} - RegEx object if the type matches\n */\nconst getMatchRegex = (type, match) => {\n  const [ val, paramType ] = match\n\n  switch (type) {\n  case 'parameter':\n    return new RegExp(getParamRegex(paramType))\n  case 'optional':\n    return new RegExp(getOptionalRegex(match))\n  case 'alternate':\n    return new RegExp(getAlternateRegex(val))\n  default:\n    return null\n  }\n}\n\n/**\n * Formats the regex match result into an object,\n * with some computed values\n * @param {Array} matchArr\n * @param {string} type\n *\n * @returns {Object} - Formatted dynamic step parameter as a metadata object \n */\nconst parseMatch = (matchArr, type = 'other') => {\n  const val = matchArr[0]\n\n  return {\n    text: val.trim(),\n    index: matchArr.index,\n    input: matchArr.input,\n    regex: getMatchRegex(type, matchArr),\n    type,\n    ...(type === 'parameter' && {\n      paramType: val.trim().replace(RX_MATCH_REPLACE, ''),\n    }),\n  }\n}\n\n/**\n * Extracts all the dynamic parts to a  definition's match text\n * @param {string} defMatcher - Registered definition match text\n * @return {Array<Object>} array of matches. See `parseMatch` for the structure.\n * @example\n * const parts = getRegexParts('I eat {int} apple(s)')\n * result:\n * [\n *  { type: 'parameter', text: '{int}', regex: /-?[0-9]+/, paramType: 'int', ... } ,\n *  { type: 'optional', text: 'apple(s)', regex: /(apple|apples)/, ... } ,\n * ]\n *\n * @returns {Array} - Sorted found dynamic content match the order from a features step text\n */\nexport const getRegexParts = defMatcher => {\n  const parameters = [\n    ...defMatcher.matchAll(new RegExp(RX_PARAMETER, 'gi')),\n  ].map(match => parseMatch(match, 'parameter'))\n\n  const optionals = [\n    ...defMatcher.matchAll(new RegExp(RX_OPTIONAL, 'gi')),\n  ].map(match => parseMatch(match, 'optional'))\n\n  const alts = [...defMatcher.matchAll(new RegExp(RX_ALT, 'gi'))].map(match =>\n    parseMatch(match, 'alternate')\n  )\n\n  // sort matched expressions by their index in the text\n  const sortedExpressions = [ ...parameters, ...optionals, ...alts ].sort(\n    (matchA, matchB) => matchA.index - matchB.index\n  )\n\n  return sortedExpressions\n}\n","import { deepFreeze } from '@keg-hub/jsutils'\n\nexport const constants = deepFreeze({\n  REGEX_VARIANT: 'regex',\n  EXPRESSION_VARIANT: 'expression',\n  STEP_TYPES: [ 'given', 'when', 'then', 'and', 'but' ],\n  HOOK_TYPES: [ 'beforeAll', 'afterAll', 'beforeEach', 'afterEach' ],\n  FEATURE_META: [ 'feature', 'perspective', 'desire', 'reason', 'comments' ],\n})\n","import { checkCall, noOpObj } from '@keg-hub/jsutils' \n\n/**\n * Helpers to ensure the right code is run in the right environments\n * @function\n * @export\n * @public\n *\n * @returns {Boolean} True if a global object exists\n */\nexport const hasWindow = Boolean(typeof window !== 'undefined')\nexport const hasGlobal = Boolean(typeof global !== 'undefined')\nexport const hasJasmine = Boolean(\n  typeof global !== 'undefined' && typeof global.jasmine !== 'undefined'\n)\n\n/**\n * Resolve the global object based on if the window or global objects exit\n * @function\n * @export\n * @public\n *\n * @returns {Object} Resolved global object (window||global|noOpObj)\n */\nexport const resolveGlobalObj = () => {\n  try {\n    return hasWindow\n      ? checkCall(() => (window))\n      : hasGlobal\n        ? checkCall(() => (global))\n        : noOpObj\n  }\n  catch(err){\n    return noOpObj\n  }\n}","import {\n  matchRegex,\n  getRegexParts,\n  getParamRegex,\n  toAlternateRegex,\n  getAlternateRegex,\n} from './regex'\n\nimport {\n  RX_OPTIONAL,\n  RX_ALT,\n  RX_EXPRESSION,\n  RX_MATCH_REPLACE,\n  RX_PARAMETER,\n} from './patterns'\n\nimport { hasWindow } from '../globalObj'\nimport { noOpObj, isFunc } from '@keg-hub/jsutils'\nimport { getParamTypes, convertTypes } from './paramTypes'\n\n/**\n * Escapes a string so it can be converted into a regular expression\n * @function\n * @private\n * @param {string} str - Step match text to be escaped\n *\n * @return {string} Escaped string to allow converting into a regular expression\n */\nconst escapeStr = str => {\n  return hasWindow\n    ? str.replace(/[|\\\\[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d')\n    : str\n}\n\n/**\n * Replace the passed in matcher string with the passed in replaceWith data based on the testRx\n * @function\n * @private\n * @param {string} match - Step match text from feature scenario\n * @param {string} testRx - Regular expression to find matching text within the matcher text\n * @param {string|function} replaceWith - Data to replace the matched data with\n *                                        Automatically called when it's function\n *\n * @return {string} match string with matched content replaced with regex\n */\nconst runRegexCheck = (matcher, testRx, replaceWith) => {\n  if (!testRx.test(matcher)) return matcher\n\n  // Set the default regex match\n  let regexStr = matcher\n  // Replace any expressions with regex, and convert the param types\n  matcher.replace(testRx, (...args) => {\n    const match = args[0].trim()\n    const [ start, ...end ] = regexStr.split(match)\n    const replace = isFunc(replaceWith) ? replaceWith(...args) : replaceWith\n    regexStr = `${start}${replace}${end.join(match)}`\n  })\n\n  return regexStr\n}\n\n/**\n * Find all expressions in the match string, and convert them into into regex\n * @function\n * @private\n * @param {string} match - Step match text from feature scenario\n *\n * @return {Object} { regex: match string with expression replaced, transformers: Array of transformer objects }\n */\nconst convertToRegex = match => {\n  const paramTypes = getParamTypes()\n  const transformers = []\n  const regex = runRegexCheck(match, RX_EXPRESSION, (val, ...args) => {\n    // Get the expression type\n    const type = val.trim().replace(RX_MATCH_REPLACE, '')\n    const isParameter = val.match(RX_PARAMETER)\n    const isOptional = val.match(RX_OPTIONAL)\n\n    // Add the transformer for the type to the transformers array\n    isParameter && transformers.push(paramTypes[type] || paramTypes.any)\n\n    // Return the regex\n    return isParameter\n      ? getParamRegex(type)\n      : isOptional\n        ? toAlternateRegex(val)\n        : val\n  })\n\n  return { regex, transformers }\n}\n\n/**\n * Find all alternate syntax in the match string, and convert them into into regex\n * @function\n * @private\n * @param {string} match - Step match text from feature scenario\n *\n * @return {string} match string with alternate syntax replaced\n */\nconst checkAlternative = match => {\n  const altIndexes = []\n  const regex = runRegexCheck(\n    match,\n    new RegExp(RX_ALT, 'g'),\n    // Use a non-capture group to allow matching, but don't include in the results (?:)\n    getAlternateRegex\n  )\n\n  return { regex, altIndexes }\n}\n\n/**\n * Adds regex anchors to the ends of the regex string, if it needs them\n * @param {string} str\n * @return {string} with anchors\n */\nconst checkAnchors = str => {\n  let final = str\n  if (!str.startsWith('^')) {\n    final = '^' + final\n  }\n  if (!str.endsWith('$')) {\n    final += '$'\n  }\n\n  return { regex: final }\n}\n\n/**\n * Extracts the dynamic cucumber-expression parameters from the text,\n * given the step matcher template and the fullMatchResults\n * @param {string} text\n * @param {RegExp} stepMatcher\n * @param {Array} wordMatches - matches for the {word} params\n */\nconst extractParameters = (text, stepMatcher, wordMatches) => {\n  // Gets an array of each dynamic element of the step match text,\n  // including: params (e.g. {float}), optionals (e.g. test(s))\n  // and alternate text (e.g. required/optional)\n  const parts = getRegexParts(stepMatcher)\n\n  const expectedParamLength = parts.filter(part => part.type === 'parameter')\n    .length\n\n  // extract the params from the text, using the parts array\n  const result = parts.reduce(\n    (state, part) => {\n      const { params, textIndex, wordMatchIndex } = state\n\n      // look at the section of the text we haven't already evaluated\n      const substring = text.substring(textIndex)\n\n      const isWord = part.paramType === 'word'\n      const partMatch = substring.match(part.regex)\n      const wordMatch = {\n        0: wordMatches[wordMatchIndex],\n        index: substring.indexOf(wordMatches[wordMatchIndex]),\n      }\n\n      // if matching a param {word}, then use the wordMatch, because\n      // it contains all the {word} matches properly\n      const match = isWord ? wordMatch : partMatch\n      if (!match) return state\n\n      // add the matched parameter if the current part is a param and a match exists\n      part.type === 'parameter' && match && params.push(match[0])\n\n      return {\n        params,\n\n        // increment text index so that we don't reevaluate the same text in future iterations\n        textIndex: textIndex + (match && match.index + match[0].length),\n\n        // increment match index so we don't repeat a word in future iterations\n        wordMatchIndex: wordMatchIndex + (isWord && 1),\n      }\n    },\n    { params: [], textIndex: 0, wordMatchIndex: 0 }\n  )\n\n  return expectedParamLength === result.params.length ? result.params : null\n}\n\n/**\n * Finds a matching definition from the passed in expression text\n * Then extracts the variables from the text to pass to the definitions method\n * Converts expression strings into regex then calls the matchRegex method\n * @function\n * @public\n * @export\n * @param {Object} definition - Registered definition\n * @param {string} text - Feature step text to compare with definition text\n *\n * @returns {Object} Found matching definition and matched arguments\n *  - form: { definition, match: Array of Arguments to pass to definitions function }\n */\nexport const matchExpression = (definition, text) => {\n  const escaped = escapeStr(definition.match)\n  const { regex: regexAlts } = checkAlternative(escaped)\n  const { regex: convertedRegex, transformers } = convertToRegex(regexAlts)\n  const { regex: match } = checkAnchors(convertedRegex)\n\n  // Then call the regex matcher to get the content\n  const found = matchRegex({ ...definition, match }, text)\n\n  // If no found definition or match, return an empty object\n  if (!found || !found.definition || !found.match) return noOpObj\n\n  // get all the parameters, without any type coercion\n  const params = extractParameters(text, definition.match, found.match)\n  if (!params) return noOpObj\n\n  // Convert the found variables into their type based on the mapped transformers\n  const converted = convertTypes(params, transformers)\n\n  // If the conversion fails, and no variable or not enough variables are returned,\n  // Then assume the type does not match, so the step does not match.\n  // Otherwise return the matched definition, and the converted variables\n  return converted.length !== params.length\n    ? noOpObj\n    : { definition, match: converted }\n}\n","import { matchRegex } from './regex'\nimport { constants } from '../constants'\nimport { noOpObj } from '@keg-hub/jsutils'\nimport { matchExpression } from './expression'\n\nconst { REGEX_VARIANT } = constants\n\n/**\n * Finds a matching registered definition from the passed in definitions and text\n * Treats all non-regex step variants as expressions\n * @function\n * @public\n * @export\n * @param {Array<Object>} definitions - All Registered definitions\n * @param {string} text - Feature step text to compare with definition text\n *\n * @returns {Object} Found matching definition and matched arguments\n */\nexport const matcher = (definitions, text) => {\n  return definitions.reduce((found, definition) => {\n    return found.match || !definition.match\n      ? found\n      : definition.variant !== REGEX_VARIANT\n        ? matchExpression(definition, text)\n        : matchRegex(definition, text)\n  }, noOpObj)\n}\n","import { matcher } from './matcher'\nimport { constants } from './constants'\nimport { resolveGlobalObj } from './globalObj'\nimport { throwNoMatchingStep } from './errors'\nimport { capitalize, eitherArr, isStr, isFunc } from '@keg-hub/jsutils'\nconst { REGEX_VARIANT, EXPRESSION_VARIANT, STEP_TYPES } = constants\nconst globalObj = resolveGlobalObj()\n\n/**\n * Sanitize the step definition text to be used as the name\n * @function\n * @private\n * @param {Object} step - Parsed step definition object\n *\n * @returns {string} Sanitized string version of the step definition text\n */\nconst sanitize = step => {\n  let name = step.match.toString()\n  if (name[0] === '^') name = name.substr(1)\n  if (name.charAt(name.length - 1) === '$') name = name.slice(0, -1)\n\n  return name.replace(/\\(\\?:([^\\|]+)+\\|+([^\\)]+)?\\)/, '$1')\n}\n\n/**\n * Builds the text content of a step definition call\n * @function\n * @private\n * @param {Object} step - Parsed step definition object\n * @param {string} step.type - Type of step definition this step belongs to\n * @param {string} step.match - Text used to match with a features step\n * @param {function} step.method - Called when a features step matches match property\n * @param {string} step.variant - Syntax used in the match property\n *\n * @returns {string} - Built text content of the step definition\n */\nconst getContent = step => {\n  const match =\n    step.variant === REGEX_VARIANT ? step.match.toString() : `\"${step.match}\"`\n\n  return `${capitalize(step.type)}(${match}, ${step.method.toString()})`\n}\n\n/**\n * Registers a step definition by type\n * @function\n * @private\n * @param {string} internalType - Internal references to the step definition type\n * @param {string} type - Type of step definition to search when matching\n * @param {string} match - Text used to match with a features step\n * @param {function} method - Called when a features step matches match property\n *\n * @returns {void}\n */\nconst registerFromCall = function (internalType, type, match, method) {\n  const step = {\n    type,\n    match,\n    method,\n    // TODO: add token parsing\n    tokens: [],\n    variant:\n      match.toString().indexOf('/') === 0 ? REGEX_VARIANT : EXPRESSION_VARIANT,\n  }\n\n  step.name = sanitize(step)\n  // The name should always be unique, so we can use that as a consistent uuid\n  step.uuid = step.name\n  step.content = getContent(step)\n\n  this[internalType].push(step)\n\n  return step\n}\n\n\n/**\n * Helper method to wrap the default register method of a step definition\n * Allows capturing the definition when it's registered\n * Contains only newly registered definitions, NOT all definitions\n * @function\n * @private\n * @param {Object} parent - Parent class to register the definitions to (Step class instance)\n * @param {string} type - Type of step definition to register\n * @param {Object} container - Holds the newly registered definitions\n *\n * @returns {function} - Method to register step definitions by type\n */\nconst tempRegister = (parent, type, container) => {\n  /**\n   * Captures a registered step definition and adds it the the container object\n   * @function\n   * @internal\n   * @param {string} match - Text used to matched with a features step\n   * @param {function} method - Called when a features step matches the text param\n   * @param {Object} meta - Object describing the functionality of the step definition\n   *\n   * @returns {Object} newly registered definition model\n   */\n  return (...args) => {\n    const definition = parent[type](...args)\n    container[type].push(definition)\n\n    return definition\n  }\n}\n\n/**\n * Registers a parsed step definition object\n * @function\n * @private\n * @param {Array|string} definitions - Array of strings or single string\n *                                     of the text content form a definition file\n *\n * @returns {void}\n */\nconst registerFromParse = function (definitions) {\n\n  // Ensures a consistent index due to being an array\n  const DEF_TYPES = this.types.map(type => capitalize(type))\n\n  // Build a container for holding the newly added definitions\n  // Looks like the object below\n  // { Given: [], When: [], Then: [], But: [], And: [] }\n  const container = DEF_TYPES.reduce((built, type) => {\n    built[type] = []\n    return built\n  }, {})\n\n  // Loop over the passed in definitions\n  eitherArr(definitions, [definitions])\n    .map(definition => {\n      // Create a dynamic function calling the definition\n      // The definition should be a call to a global Given, When, Then methods\n      // Which is comes from the tempRegister method for each type\n      const response = Function(`return (global, ${DEF_TYPES.join(',')}) => {\n          return (function(global) { ${definition} }).call(global, global)\n        }`)()(\n          // Pass in the global object so we can bind the dynamic function to it\n          // Allows referencing values on the global scope directly\n          // For example myGlobalFunction() instead of window.myGlobalFunction()\n          globalObj,\n          // Call the tempRegister for each type,\n          // Then spread the response as arguments to the dynamic function\n          ...DEF_TYPES.map(type => tempRegister(this, type, container)),\n        )\n    })\n\n  // Return the container which should now hold all newly registered definitions ONLY \n  return container\n}\n\n/**\n * Join all step types together into a single array\n * @function\n * @private\n * @param {Object} instance - Steps calls instance\n *\n * @returns {Array} - Joined steps\n */\nconst joinAllSteps = instance => {\n  return instance.types.reduce(\n    (stepDefs, type) => stepDefs.concat(instance[`_${type}`]),\n    []\n  )\n}\n\n/**\n * Allows registering step definition matchs and functions\n * Which are used to map to steps of a parsed feature file\n * @class\n * @public\n * @param {Object} world - Holds configuration for the running test environment\n *\n * @returns {Object} Instance of the Steps class\n */\nexport class Steps {\n  /**\n   * Allowed step definition types\n   * @memberof Steps\n   * @type {Array}\n   * @private\n   */\n  types = STEP_TYPES\n\n  constructor(world) {\n    this._world = world || {}\n    const self = this\n    /**\n     * Creates helpers for registering step definitions by type\n     * @memberof Steps\n     * @function\n     * @public\n     * @param {string} match - Text used to matched with a features step\n     * @param {function} method - Function called when a features step text matches the text param\n     * @example\n     * const steps = new Steps({})\n     * steps.Given(`text`, ()=> {})\n     *\n     * @returns {void}\n     */\n    this.types.map(type => {\n      const internalType = `_${type}`\n      this[internalType] = []\n      this[capitalize(type)] = (match, method) => {\n        return self.register(internalType, type, match, method)\n      }\n    })\n  }\n\n  /**\n   * Gets a list of all step definitions registered with the parkin instance\n   * @memberof Steps\n   * @function\n   * @public\n   *\n   * @returns {Array} - List of all registered step definitions\n   */\n  list = () => {\n    return joinAllSteps(this)\n  }\n\n  /**\n   * Gets a list of all step definitions registered with the parkin instance\n   * @memberof Steps\n   * @function\n   * @public\n   *\n   * @returns {Array} - List of all registered step definitions\n   */\n  typeList = () => {\n    return this.types.reduce((stepDefs, type) => {\n      const internalType = `_${type}`\n      stepDefs[internalType] = [...this[internalType]]\n      return stepDefs\n    }, {})\n  }\n\n  /**\n   * Finds a matching step definition from the passed in text\n   * Steps must be registered with this instance to be found\n   * @memberof Steps\n   * @function\n   * @public\n   * @param {string} text - Feature step text to compare with definition match text\n   *\n   * @returns {Object} - Contains a match property as an array of arguments\n   *                     And the definition property as the found registered definition \n   */\n  match = text => {\n    // Join all step types together when finding a match\n    // Cucumber treats all step definition types as the same when matching to step text\n    const list = this.list()\n\n    // Call the matcher to find a matching step definition\n    const found = matcher(list, text)\n\n    // If no matching step definition exists, then return false\n    if (!found.match || !found.definition) return false\n\n    // Add the Step instance's world to the match arguments\n    // Always added as the last argument\n    found.match.push(this._world)\n\n    return found\n  }\n\n  /**\n   * Finds a matching step definition from the passed in list and text can calls it\n   * This is the method the actually calls a step definition function\n   * @memberof Steps\n   * @function\n   * @public\n   * @param {Array<Object>} list - Group of registered step definition\n   * @param {string} text - Feature step text to compare with step definition text\n   *\n   * @returns {*} - Response from the step definition function\n   */\n  resolve = text => {\n    // Try to find a step definition match to the passed in text\n    const found = this.match(text)\n\n    // If found, call the step function passing the match array as arguments\n    // Otherwise throw a no match error\n    return found\n      ? found.definition.method(...found.match)\n      : throwNoMatchingStep(text)\n  }\n\n  /**\n   * Registers a step definition by type based on passed in args\n   * @memberof Steps\n   * @function\n   * @public\n   * @param {Array} args - All arguments passed to the method\n   * @param {string|Array|Object} args.0 - Type of step definition to search when matching\n   *                                        Or an array of parsed definition objects\n   *                                        Or a single parsed definition object\n   * @param {string} args.1 - Text used to matched with a features step\n   * @param {function} args.2 - Function called when a features step text matches the text param\n   *\n   * @returns {void}\n   */\n  register = (...args) => {\n    return isStr(args[0])\n      ? registerFromCall.apply(this, args)\n      : registerFromParse.apply(this, args)\n  }\n\n  /**\n   * Clears out all registered step definitions for all types\n   * @memberof Steps\n   * @function\n   * @public\n   *\n   * @returns {void}\n   */\n  clear = () => {\n    this.types.map(type => (this[`_${type}`] = []))\n  }\n}\n","import { isFunc, noOp } from '@keg-hub/jsutils'\nimport { constants } from './constants'\n\nconst { HOOK_TYPES } = constants\n\n/**\n * Allows registering hook functions, which are then called when\n * the runner runs a feature\n * @class\n * @public\n * @returns {Object} Instance of the Hooks class\n */\nexport class Hooks {\n  /**\n   * Allowed hook types\n   * @memberof Hooks\n   * @type {Array}\n   * @private\n   */\n  types = HOOK_TYPES\n\n  constructor() {\n    this._registeredHooks = {}\n\n    /**\n     * Creates helpers for registering hooks\n     * @memberof Hooks\n     * @function\n     * @public\n     * @param {function} method - Function to be registered to the hook. They will be called when the runner runs a feature\n     * @example\n     * const hooks = new Hooks()\n     * hooks.beforeAll(() => setupEnvironment())\n     *\n     * @returns {void}\n     */\n    this.types.map(type => {\n      this[type] = clientHookFn => {\n        if (!isFunc(clientHookFn)) return\n        this._registeredHooks[type] = clientHookFn\n      }\n    })\n  }\n\n  /**\n   * @param {string} type\n   * @return {Function} the function registered to the hook type, or a noOp function by default\n   */\n  getRegistered = type => {\n    if (!this.types.includes(type))\n      throw new Error(\n        `Expected client hook type to be one of ', ${HOOK_TYPES.join(', ')}.\n         Found: ${type}`\n      )\n\n    return this._registeredHooks[type] || noOp\n  }\n}\n","/**\n * Regular expressions for matching feature file keywords\n * @type {object}\n */\nconst RX_NEWLINE = /\\r?\\n/g\nconst RX_TAG = /^\\s*@(.*)$/\nconst RX_COMMENT = /^\\s*#(.*)$/\nconst RX_FEATURE = /^\\s*Feature:(.*)$/\nconst RX_AS = /^\\s*As (.*)$/\nconst RX_I_WANT = /^\\s*I want (.*)$/\nconst RX_SO_THAT = /^\\s*So that (.*)$/\nconst RX_IN_ORDER = /^\\s*In order (.*)$/\nconst RX_SCENARIO = /^\\s*Scenario:(.*)$/\nconst RX_EXAMPLE = /^\\s*Example:(.*)$/\nconst RX_BACKGROUND = /^\\s*Background:(.*)$/\nconst RX_GIVEN = /^\\s*Given (.*)$/\nconst RX_WHEN = /^\\s*When(.*)$/\nconst RX_THEN = /^\\s*Then (.*)$/\nconst RX_AND = /^\\s*And (.*)$/\nconst RX_BUT = /^\\s*But (.*)$/\nconst RX_ASTERISK = /^\\s*\\* (.*)$/\nconst RX_DOCQUOTES = /^\\s*\"\"\"\\s*(.*)$/\nconst RX_DOCTICKS = /^\\s*```\\s*(.*)$/\nconst RX_DATATABLE = /^\\s*\\|\\s*(.*)\\|\\s*$/\n\n/**\n * Regular expressions and types for matching step keywords\n * @type {Array}\n * @private\n */\nconst RegStepTags = [\n  { regex: RX_GIVEN, type: 'given' },\n  { regex: RX_WHEN, type: 'when' },\n  { regex: RX_THEN, type: 'then' },\n  { regex: RX_AND, type: 'and', alt: 'when' },\n  { regex: RX_BUT, type: 'but', alt: 'when' },\n  { regex: RX_ASTERISK, type: 'and', alt: 'when' },\n]\n\n/**\n * Regular expressions and types for matching feature meta data keywords\n * @type {Array}\n * @private\n */\nconst featureMetaTags = [\n  { regex: RX_AS, key: 'perspective' },\n  { regex: RX_I_WANT, key: 'desire' },\n  { regex: RX_SO_THAT, key: 'reason' },\n  { regex: RX_IN_ORDER, key: 'reason' },\n]\n\n/*\n * Sanitizes the passed in text and joins the texts length\n * @function\n * @private\n * @param {string} text - Text to be sanitized\n *\n * @returns {string} - Sanitized text\n */\nconst sanitizeForId = text => {\n  const cleaned = text.trim().toLowerCase()\n    .replace(/ /g, '-')\n  return `${text.length}-${cleaned}`\n}\n\n/*\n * Extracts keywords from a text string\n * @function\n * @private\n * @param {string} line - Text content to extract the keyword from\n * @param {Object} regex - Regex object used for finding a keyword\n * @param {number} index - Current inject of the line being parsed\n *\n * @returns {string} - Found keyword text from the line argument\n */\nconst getRXMatch = (line, regex, index) => line.match(regex)[index].trim()\n\n/*\n * Helper factory function to build a feature object\n * @function\n * @private\n * @param {string} feature - Text containing the feature keyword and text\n * @param {number} text - The entire text of a feature file\n *\n * @returns {Object} - Parsed feature object\n */\nconst featureFactory = (feature, content, index) => {\n  return {\n    index,\n    content,\n    feature,\n    tags: [],\n    reason: [],\n    comments: [],\n    scenarios: [],\n    // The feature name should always be unique, so use that as a re-usable id\n    ...(feature && { uuid: sanitizeForId(feature) }),\n  }\n}\n\n/*\n * Helper factory function to build a scenario object\n * @function\n * @private\n * @param {string} scenario - Text containing the scenario keyword and text\n *\n * @returns {Object} - Parsed scenario object\n */\nconst scenarioFactory = (scenario, index) => {\n  return {\n    index,\n    scenario,\n    tags: [],\n    steps: [],\n    ...(scenario && { uuid: sanitizeForId(scenario) }),\n  }\n}\n\n/*\n * Helper factory function to build a background object\n * @function\n * @private\n * @param {string} scenario - Text containing the scenario keyword and text\n *\n * @returns {Object} - Parsed scenario object\n */\nconst backgroundFactory = (background, index) => {\n  return {\n    index,\n    steps: [],\n    background,\n    ...(background && { uuid: sanitizeForId(background) }),\n  }\n}\n\n/*\n * Helper factory function to build a step object\n * @function\n * @private\n * @param {string} type - The type of step definition\n * @param {string} step - Text containing the step text\n * @param {string} altType - The alternate type of the step definition ( And || But )\n *\n * @returns {Object} - Parsed step object\n */\nconst stepFactory = (type, step, altType, index) => {\n  const built = { step, type, uuid: sanitizeForId(`${type}-${step}`), index }\n  altType && (built.altType = altType)\n\n  // TODO: Investigate calling checkDocString and checkDataTable here\n  // For doc string and data table variables of steps\n  // Will need to pass in the full text\n  // Then pase from the current line down to the end of the doc string or data table\n\n  return built\n}\n\n/*\n * Helper function to add reason text to a feature when it exists\n * @function\n * @private\n * @param {Object} feature - Parse feature object\n * @param {string} reason - Text containing the reason from the parsed feature file\n *\n * @returns {void}\n */\nconst addReason = (feature, reason, index) => {\n  reason && feature.reason.push({ content: reason, index })\n}\n\n/**\n * Check for doc strings in the steps\n * The string should be passed to the step def as the last argument\n * Space inside the doc string should be left as is\n * @function\n * @private\n * @param {Object} step - Current step being parsed into an object\n * @param {string} line - Current line being parsed\n * @param {string} text - Full text content of the feature file\n *\n * @todo Implement doc string parsing\n *\n * @return {Object} Current step being parsed with the doc string added\n */\nconst checkDocString = (step, line, text) => {\n  // TODO: doc string parsing\n  // if(!RX_DOCQUOTES.test(line) || !RX_DOCTICKS.test(line)) return step\n\n  return step\n}\n\n/**\n * Check for a data table in the in the steps content\n * The string should be passed to the step def as the last argument\n * Each line of the data stable should be split in to arguments seperated by |\n * @function\n * @private\n * @param {Object} step - Current step being parsed into an object\n * @param {string} line - Current line being parsed\n * @param {string} text - Full text content of the feature file\n *\n * @todo Implement data table parsing\n *\n * @return {Object} Current step being parsed with the doc string added\n */\nconst checkDataTable = (step, line, text) => {\n  // TODO: data table parsing\n  // if(!RX_DATATABLE.test(line)) return step\n\n  return step\n}\n\n/**\n * Checks each step tag type, and adds it to current scenario when it exists\n * @function\n * @private\n * @param {Object} scenario - Parsed scenario object of the current scenario\n * @param {string} line - Current line being parsed\n *\n * @return {boolean} - True if a line was added to the current scenario object\n */\nconst checkStepTag = (scenario, line, index) => {\n  return RegStepTags.reduce((added, regTag) => {\n    // If the line was already added, just return\n    if (added) return added\n\n    // Check if the line is a step tag\n    const hasTag = regTag.regex.test(line)\n    // If if is, add the extracted line to the steps of the current scenario\n    hasTag &&\n      scenario.steps.push(\n        stepFactory(\n          regTag.type,\n          getRXMatch(line, regTag.regex, 1),\n          regTag.alt,\n          index\n        )\n      )\n\n    // Return if the line was added to the steps\n    return hasTag\n  }, false)\n}\n\n/**\n * Checks for feature descriptive content\n * @function\n * @private\n * @param {Object} feature - Current feature being parsed into an object\n * @param {string} line - Current line being parsed\n *\n * @return {boolean} - True if a line was added to the current feature object\n */\nconst featureMeta = (feature, line, index) => {\n  let metaAdded = false\n  featureMetaTags.reduce((added, regTag) => {\n    if (added) return added\n\n    const hasTag = regTag.regex.test(line)\n    if (!metaAdded && hasTag) metaAdded = true\n\n    return hasTag\n      ? regTag.key === 'reason'\n          ? addReason(feature, getRXMatch(line, regTag.regex, 0), index)\n          : (feature[regTag.key] = {\n              content: getRXMatch(line, regTag.regex, 0),\n              index,\n            })\n      : hasTag\n  }, false)\n\n  return metaAdded\n}\n\n/*\n * Checks for feature file meta-data\n * @function\n * @private\n * @param {Object} feature - Current feature being parsed into an object\n * @param {string} line - Current line being parsed\n *\n * @return {boolean} - True if a line was added to the current feature object\n */\nconst checkTag = (parent, feature, line, index) => {\n  if (!RX_TAG.test(line)) return false\n\n  // background can not have tags, so add them to the feature instead\n  const tagParent = parent.background ? feature : parent\n\n  const tags = getRXMatch(line, RX_TAG, 0)\n\n  // Join the tags with the tagParents current tags\n  tagParent.tags = (tagParent.tags || []).concat(tags.split(' '))\n\n  return true\n}\n\n/*\n * Checks for feature file comments\n * @function\n * @private\n * @param {Object} feature - Current feature being parsed into an object\n * @param {string} line - Current line being parsed\n * @param {number} index - Location of the current feature in the features group array\n *\n * @return {boolean} - True if a line was added to the current feature object\n */\nconst featureComment = (feature, line, index) => {\n  if (!RX_COMMENT.test(line)) return false\n\n  // const comment = getRXMatch(line, RX_COMMENT, 1)\n  // Don't use getRXMatch because we want the full white space\n  // Because comments are added globally and not by line\n  // This could cause some issues if the user starts using different white space settings\n  // But not much we can do about it\n  const comment = line.match(RX_COMMENT)[0]\n\n  feature.comments.push({ content: comment, index })\n\n  return true\n}\n\n/**\n * Check for new feature, or add feature text to current feature\n * @function\n * @private\n * @param {Array} featuresGroup - All Parsed features as an array\n * @param {Object} feature - Current feature being parsed into an object\n * @param {string} line - Current line being parsed\n * @param {string} content - Full text content of the feature file\n * @param {number} index - The current line number of the feature text content\n *\n * @return {Object} Current feature being parsed\n */\nconst ensureFeature = (featuresGroup, feature, line, content, index) => {\n  // Check for Feature: keyword text\n  if (!RX_FEATURE.test(line)) return feature\n\n  // Get the text from the line\n  const featureText = getRXMatch(line, RX_FEATURE, 1)\n\n  // If the text was not yet added, then add it\n  // Then ensure the feature was added to the full group\n  if (!feature.feature) {\n    feature.feature = featureText\n\n    // Ensure the index is added if needed\n    if (!feature.index) feature.index = index\n    if (!feature.uuid) feature.uuid = sanitizeForId(feature.feature)\n\n    !featuresGroup.includes(feature) && featuresGroup.push(feature)\n\n    return feature\n  }\n\n  // Otherwise create a new feature, with the feature text and content\n  return featureFactory(featureText, content, index)\n}\n\n/**\n * Check for new feature scenario, and add scenario to feature object\n * @function\n * @private\n * @param {Object} feature - Current feature being parsed into an object\n * @param {Object} scenario - Current scenario being parsed into an object\n * @param {string} line - Current line being parsed\n * @param {number} index - The current line number of the feature text content\n *\n * @return {Object} Current scenario being parsed\n */\nconst ensureScenario = (feature, scenario, line, index) => {\n  // Check for \"Scenario:\" or \"Example:\" keywords\n  if (!RX_SCENARIO.test(line) && !RX_EXAMPLE.test(line)) return scenario\n\n  // Check for \"Scenario:\", if not found then check for \"Example:\"\n  let scenarioText = getRXMatch(line, RX_SCENARIO, 1)\n  scenarioText = scenarioText || getRXMatch(line, RX_EXAMPLE, 1)\n\n  // Check if the scenario text was already added, and add it if needed\n  // Otherwise create a new scenario with the scenario text\n  !scenario.scenario\n    ? (scenario.scenario = scenarioText)\n    : (scenario = scenarioFactory(scenarioText, index))\n\n  // Ensure the line index is added\n  !scenario.index && (scenario.index = index)\n  // Add the uuid from the scenario text if it doesn't exist\n  !scenario.uuid && (scenario.uuid = sanitizeForId(scenario.scenario))\n\n  // Add the scenario if needed to the current feature\n  !feature.scenarios.includes(scenario) && feature.scenarios.push(scenario)\n\n  return scenario\n}\n\n/**\n * Check for background in a feature, These steps should run before all steps of a scenario\n * Should be added to each scenario, where a background exists in the feature\n * @function\n * @private\n * @param {Object} feature - Current feature being parsed into an object\n * @param {Object} scenario - Current scenario being parsed into an object\n * @param {string} line - Current line being parsed\n *\n * @return {Object} Current background being parsed\n */\nconst ensureBackground = (feature, background, line, index) => {\n  if (!RX_BACKGROUND.test(line)) return background\n\n  // Check for \"Scenario:\", if not found then check for \"Example:\"\n  const backgroundText = getRXMatch(line, RX_BACKGROUND, 1)\n\n  // Check if the background text was already added, and add it if needed\n  // Otherwise create a new background with the background text\n  !background.background\n    ? (background.background = backgroundText || '')\n    : (background = backgroundFactory(backgroundText, index))\n\n  // Ensure the line index is added\n  !background.index && (background.index = index)\n  // Add the uuid from the background text if it doesn't exist\n  !background.uuid && (background.uuid = sanitizeForId(background.background))\n\n  feature.background = background\n\n  return background\n}\n\n/**\n * Determine the active parent base on the nextLine to be evaluated\n * If a new parent is not found, then returns the current activeParent\n * @function\n * @private\n * @param {Object} activeParent - Current parent object to have properties added to it\n * @param {Object} feature - Feature model object\n * @param {Object} scenario - Scenario model object\n * @param {Object} background - Background model object\n * @param {string} nextLine - Next line of the text to be evaluated\n *\n * @returns {Object} - Found active parent based on the nextLine\n */\nconst setActiveParent = (\n  activeParent,\n  feature,\n  scenario,\n  background,\n  nextLine\n) => {\n  return RX_SCENARIO.test(nextLine) || RX_EXAMPLE.test(nextLine)\n    ? scenario\n    : RX_FEATURE.test(nextLine)\n      ? feature\n      : RX_BACKGROUND.test(nextLine)\n        ? background\n        : activeParent\n}\n\n/**\n * Parses a feature files text content into an object\n * @function\n * @public\n * @export\n * @param {string} text - Text content of a feature file\n *\n * @returns {Object} - Parsed feature file as an object\n */\nexport const parseFeature = text => {\n  const features = []\n  const lines = (text || '').toString().split(RX_NEWLINE)\n  let scenario = scenarioFactory(false)\n  let background = backgroundFactory(false)\n  let feature = featureFactory(false, text)\n  let activeParent = feature\n\n  /*\n   * Loop over each line of text, and compose the line with corresponding regex to find a match\n   */\n  return lines.reduce((featuresGroup, line, index) => {\n    /*\n     * Check for new feature, or parse the current features text\n     */\n    feature = ensureFeature(featuresGroup, feature, line, text, index)\n\n    /*\n     * Check for child content of the feature or activeParent and parse the line when matched\n     */\n    if (\n      featureComment(feature, line, index) ||\n      featureMeta(feature, line, index)\n    )\n      return featuresGroup\n\n    /*\n     * Check for new feature scenario, and add scenario to feature object\n     */\n    scenario = ensureScenario(feature, scenario, line, index)\n\n    /*\n     * Check for new feature scenario, and add scenario to feature object\n     */\n    background = ensureBackground(feature, background, line, index)\n\n    // Check for stepTags before check for the next active parent\n    // This way We don't add a step to the wrong parent\n    if (checkStepTag(activeParent, line, index)) return featuresGroup\n\n    /*\n     * Get the next line for tag reference checking\n     */\n    const nextLine = lines[index + 1]\n\n    /*\n     * Get the currently active parent based on the next line to be parsed\n     * This allows setting the active parent before the next iteration\n     */\n    activeParent = setActiveParent(\n      activeParent,\n      feature,\n      scenario,\n      background,\n      nextLine\n    )\n\n    // Check for tags after the next active parent has been set\n    checkTag(activeParent, feature, line, index)\n\n    return featuresGroup\n  }, features)\n}\n","\n/**\n * Parses definitions from text content by calling the steps.register function\n * @function\n * @public\n * @export\n * @param {string} text - Text content of a definitions file\n *\n * @returns {Object} - Parsed feature file as an object\n */\nexport const parseDefinition = function(text) {\n  const registered = this.steps.register([text])\n  return registered\n}","import { noOp } from '@keg-hub/jsutils'\nimport { testMethodFill } from './errors'\nimport { hasWindow, hasJasmine } from './globalObj'\n\n/**\n * Resolves a test method from the global scope\n * Returns a NOOP when getTestMethod.PARKIN_TEST_MODE is true\n * This allows testing the runner methods, without running the tests\n * @function\n * @private\n * @param {string} type - Name of test method to get from the global scope\n * @param {boolean} testMode - Allows testing the runner methods, without running the tests\n *\n * @returns {function} - Test method\n */\nexport const getTestMethod = (type, testMode) => {\n  // To write tests for the runner, we have to override the default test methods\n  // This allows testing the runner methods, without running the tests\n  return testMode ? noOp : global[type] || testMethodFill(type)\n}\n\n/**\n * Builds a custom jasmin reporter\n * Checks failed specs and sets all all specs in a suite to disable when found\n * @function\n * @private\n * @param {Object} jasmineEnv - The current jasmine environment\n *\n * @returns {Object} - Custom jasmine reporter\n */\nconst buildReporter = (jasmineEnv, testMode) => {\n  const suites = []\n  const jasmineDescribe = jasmineEnv.describe\n\n  jasmineEnv.describe = (...args) => {\n    const suite = jasmineDescribe.apply(null, args)\n    suites.push(suite)\n\n    return suite\n  }\n\n  return {\n    specDone: result => {\n      if (result.status !== 'failed') return\n\n      const suite = suites.find(suite =>\n        suite.children.find(spec => spec.result === result)\n      )\n      suite && suite.children.map(spec => spec.disable())\n    },\n  }\n}\n\n/**\n * Checks i jasmine is available on the global scope\n * If it is, then builds and adds a custom reporter to it\n * @function\n * @export\n *\n * @returns {Void}\n */\nexport const skipTestsOnFail = testMode => {\n  if (hasWindow || !hasJasmine) return\n\n  const jasmineEnv = global.jasmine.getEnv()\n  jasmineEnv.addReporter(buildReporter(jasmineEnv, testMode))\n}\n","import { parseFeature } from './parse'\nimport { getTestMethod, skipTestsOnFail } from './testMethods'\nimport { throwMissingSteps, throwMissingFeatureText } from './errors'\nimport {\n  isArr,\n  capitalize,\n  isObj,\n  isStr,\n  noOpObj,\n  eitherArr,\n} from '@keg-hub/jsutils'\n\n/**\n * Resolves and parses features based on the data type passed in\n * Ensures an array of parsed features is returned\n * @function\n * @public\n * @param {Object|Array<string|Object>|string} data - Feature content\n *\n * @returns {Array} - passed in data converted into parsed Features\n */\nconst resolveFeatures = data => {\n  return isStr(data)\n    ? parseFeature(data)\n    : isObj(data)\n      ? [data]\n      : isArr(data)\n        ? data.reduce(\n            (features, feature) => features.concat(resolveFeatures(feature)),\n            []\n          )\n        : throwMissingFeatureText()\n}\n\n/**\n * Calls the `it` global passing in a registered step function based on the step text\n * @function\n * @private\n * @param {Object} stepsInstance - Instance of the Steps class\n * @param {Object} step - Parsed Step mode object\n * @param {boolean} testMode - Allows testing the runner methods, without running the tests\n *\n * @returns {Void}\n */\nconst runStep = async (stepsInstance, step, testMode) => {\n  const test = getTestMethod('test', testMode)\n  // eslint-disable-next-line jest/no-test-callback\n  test(`${capitalize(step.type)} ${step.step}`, async done => {\n    await stepsInstance.resolve(step.step)\n    done()\n  })\n}\n\n/**\n * Loops through the passed in scenarios steps and calls runStep for each\n * @function\n * @private\n * @param {Object} stepsInstance - Instance of the Steps class\n * @param {Object} scenario - Parsed feature scenario object containing the steps to run\n * @param {boolean} testMode - Allows testing the runner methods, without running the tests\n *\n * @returns {Void}\n */\nconst runScenario = (stepsInstance, scenario, testMode) => {\n  const describe = getTestMethod('describe', testMode)\n\n  // Holder for the steps of each scenario\n  let responses = []\n  describe(`Scenario: ${scenario.scenario}`, () => {\n    // Map over the steps and call them\n    // Store the returned promise in the responses array\n    responses = scenario.steps.map(\n      async step => await runStep(stepsInstance, step, testMode)\n    )\n\n    // Ensure we resolve all promises inside the describe block\n    Promise.all(responses)\n  })\n\n  return responses\n}\n\n/**\n * @param {string} tags\n * @return {Array<string>?} A match of all words starting with '@', the tag indicator.\n * Returns false if input is invalid.\n */\nconst parseFeatureTags = tags => {\n  return isStr(tags) && tags.match(/[@]\\w*/g)\n}\n\n/**\n * @param {string?} name - name of item (feature|scenario) to check\n * @param {string | Array<string>} tags - tags of item (feature|scenario) to check\n * @param {string?} filterOptions.name - name filter\n * @param {string | Array<string>} filterOptions.tags - tags filter\n * @return {Boolean} - true if feature matches the filter options\n */\nconst itemMatch = (name = '', tags = [], filterOptions = {}) => {\n  const { name: filterName, tags: filterTags } = filterOptions\n\n  const parsedTags = isStr(filterTags)\n    ? parseFeatureTags(filterTags)\n    : eitherArr(filterTags, [])\n\n  const nameMatch = !filterName || name.includes(filterName)\n  const tagMatch =\n    !parsedTags.length ||\n    parsedTags.every(clientTag => tags.includes(clientTag))\n\n  return nameMatch && tagMatch\n}\n\n/**\n * Filters features and scenarios based on the passed in filterOptions\n * @function\n * @private\n * @param {Array} features - Features to be run\n * @param {Object} tags - Tags to filter which Features and scenarios will be run\n *  * @param {string?} filterOptions.name - name of feature\n * @param {string | Array<string>} filterOptions.tags - feature tags to match\n *\n * @returns {Array} - Filtered features that should be run\n */\nconst filterFeatures = (features, filterOptions = {}) => {\n  return features.reduce((filtered, feature) => {\n    const isMatchingFeature = itemMatch(\n      feature.feature,\n      feature.tags,\n      filterOptions\n    )\n    if (isMatchingFeature) {\n      filtered.push(feature)\n      return filtered\n    }\n\n    // check for matching scenarios, where scenarios inherit their parent feature's tags\n    const matchingScenarios = feature.scenarios.filter(scenario =>\n      itemMatch(\n        scenario.scenario,\n        [ ...(scenario.tags || []), ...(feature.tags || []) ],\n        filterOptions\n      )\n    )\n    if (matchingScenarios.length) {\n      filtered.push({\n        ...feature,\n        scenarios: matchingScenarios,\n      })\n    }\n    return filtered\n  }, [])\n}\n\n/**\n * Parses and runs the steps of a feature text string\n * Uses the registered steps of the passed in Steps class instance to evaluate the feature steps\n * @class\n * @public\n * @param {Object} stepsInstance - Instance of the Steps class\n * @param {Hooks} hooksInstance - instance of the Hooks class, storing the client's registered test callbacks\n *\n * @returns {Object} Instance of the Runner class\n */\nexport class Runner {\n  constructor(steps, hooks) {\n    !steps && throwMissingSteps()\n    !hooks && throwMissingHooks()\n\n    this.steps = steps\n    this.hooks = hooks\n  }\n\n  /**\n   * Gets the features to be run for a test\n   * @param {string|Array<Object>|Object} data - Feature data as a string or parsed Feature model\n   * @param {Object} options - Define how the steps are run\n   * @param {Array<string>? | string?} options.tags - Tags to filter which features or scenarios are run\n   * @param {string?} options.name - Name of feature\n   */\n  getFeatures = (data, options) => {\n    const features = resolveFeatures(data)\n    return filterFeatures(features, options)\n  }\n\n  /**\n   * Parses and runs the steps of a feature text string\n   * Matches each step to a registered steps of the Steps class instance\n   * @memberof Runner\n   * @function\n   * @public\n   * @param {string|Array<Object>|Object} data - Feature data as a string or parsed Feature model\n   * @param {Object} options - Define how the steps are run\n   * @param {Array<string>? | string?} options.tags - Tags to filter which features or scenarios are run\n   * @param {string?} options.name - Name of feature\n   *\n   * @returns {boolean} - whether any tests ran\n   */\n  run = async (data, options = noOpObj) => {\n    // Set if were running tests for Parkin, or external tests\n    // Only used for testing purposes\n    const testMode = this.run.PARKIN_TEST_MODE\n\n    // Setup step skip on failed\n    skipTestsOnFail(testMode)\n\n    const describe = getTestMethod('describe', testMode)\n    const beforeAll = getTestMethod('beforeAll', testMode)\n    const afterAll = getTestMethod('afterAll', testMode)\n    const beforeEach = getTestMethod('beforeEach', testMode)\n    const afterEach = getTestMethod('afterEach', testMode)\n\n    // Get all the features to be run\n    // Then filter them based on any options tags\n    const features = this.getFeatures(data, options)\n    if (!features.length) return false\n\n    // Ensures all tests resolve before ending by\n    // Using promises to resolve each feature / scenario / step\n    const promises = await features.map(async feature => {\n      let responses = []\n\n      beforeAll(this.hooks.getRegistered('beforeAll'))\n      afterAll(this.hooks.getRegistered('afterAll'))\n      beforeEach(this.hooks.getRegistered('beforeEach'))\n      afterEach(this.hooks.getRegistered('afterEach'))\n\n      // Map over the features scenarios and call their steps\n      // Store the returned promise in the responses array\n      describe(`Feature: ${feature.feature}`, () => {\n        responses = feature.scenarios.map(\n          async scenario => await runScenario(this.steps, scenario, testMode)\n        )\n\n        // Ensure we resolve all promises inside the describe block\n        Promise.all(responses)\n      })\n\n      return responses\n    })\n\n    // Ensure all promises are resolved before returning\n    await Promise.all(promises)\n\n    return true\n  }\n}\n","import { constants } from '../constants'\nimport { throwFeatureNotAnObj } from '../errors'\nimport { eitherArr, isObj, isArr, capitalize, exists } from '@keg-hub/jsutils'\n\nconst { FEATURE_META } = constants\n\n/**\n * Adds content to the assembled array based on the passed in index\n * If no index exists, then the content is added to the end\n * If the index already exists, then the content is spliced into the array at the index\n * @function\n * @private\n * @param {Array<String>} assembled - Array of strings converted from a feature model\n * @param {string} content - String to add to the assembled array\n * @param {number} index - Location in the assembled array where the content should be placed\n *\n * @return {void}\n */\nconst addContent = (assembled, content, index) => {\n  !exists(index)\n    ? assembled.push(content)\n    : exists(assembled[index])\n      ? assembled.splice(index, 0, content)\n      : (assembled[index] = content)\n}\n\n/**\n * Converts a array of tags into a string and adds them to the assembled array\n * @function\n * @private\n * @param {Array<String>} assembled - Array of strings converted from a feature model\n * @param {Array<String>} tags - Group of tags from a feature or scenario\n *\n * @return {void}\n */\nconst addTags = (assembled, tags, spacer = '') => {\n  isArr(tags) &&\n    tags.length &&\n    addContent(assembled, `${spacer}${tags.join(' ')}`)\n}\n\n/**\n * Converts a features meta data into strings and adds them to the assembled array\n * @function\n * @private\n * @param {Array<String>} assembled - Array of strings converted from a feature model\n * @param {Object} feature - Parsed feature model containing a scenarios array\n *\n * @return {void}\n */\nconst addMeta = (assembled, feature) => {\n  FEATURE_META.map(key => {\n    switch (key) {\n    case 'feature':\n      addContent(assembled, `Feature: ${feature[key]}`, feature.index)\n      break\n    case 'comments':\n      isArr(feature[key]) &&\n          feature[key].map(item =>\n            addContent(assembled, item.content, item.index)\n          )\n      break\n    case 'reason':\n      isArr(feature[key]) &&\n          feature[key].map(item =>\n            addContent(assembled, `  ${item.content}`, item.index)\n          )\n      break\n    case 'desire':\n    case 'perspective':\n      feature[key] &&\n          addContent(assembled, `  ${feature[key].content}`, feature[key].index)\n      break\n    }\n  })\n}\n\n/**\n * Converts a scenarios steps into strings and adds them to the assembled array\n * @function\n * @private\n * @param {Array<String>} assembled - Array of strings converted from a feature model\n * @param {Object} scenario - Parsed scenario model containing a steps array\n *\n * @return {void}\n */\nconst addSteps = (assembled, scenario) => {\n  isArr(scenario.steps) &&\n    scenario.steps.length &&\n    scenario.steps.map(step =>\n      addContent(\n        assembled,\n        `    ${capitalize(step.type)} ${step.step}`,\n        step.index\n      )\n    )\n}\n\n/**\n * Converts a features scenarios into strings and adds them to the assembled array\n * @function\n * @private\n * @param {Array<String>} assembled - Array of strings converted from a feature model\n * @param {Object} feature - Parsed feature model containing a scenarios array\n *\n * @return {void}\n */\nconst addScenarios = (assembled, feature) => {\n  feature.scenarios &&\n    feature.scenarios.map(scenario => {\n      addTags(assembled, scenario.tags, `  `)\n      addContent(assembled, `  Scenario: ${scenario.scenario}`, scenario.index)\n      addSteps(assembled, scenario)\n    })\n}\n\n/**\n * Checks the whitespace of adjacent lines to determine the whitespace of the comment\n * Uses the next line first, then the previous line if the next line does not exist\n * @function\n * @private\n * @param {Array<String>} assembled - Array of strings converted from a feature model\n * @param {string} line - Comment line to be formatted\n * @param {number} index - Position of the line within the assembled array\n *\n * @return {string} - Formatted comment line relative to it's adjacent lines\n */\nconst formatComment = (assembled, line, index) => {\n  const next = assembled[index + 1]\n  const prev = assembled[index - 1]\n  let compareLine = exists(next) ? next : prev\n\n  // If no line to compare with just return the comment\n  if (!compareLine) return `${line}\\n`\n\n  // Split on the comment char, so we have just the text of the comment\n  const comment = line.split('#').pop()\n\n  // Get the white space of the compose line\n  const whiteSpace = Array(\n    compareLine.length - compareLine.trimStart().length\n  ).join(' ')\n\n  // Add that to the comment and replace the comment char #\n  // This allows the comments to be spaced relative the the adjacent lines\n  // Must add an extra space after addSpace because whiteSpace is 1 space short\n  return `${whiteSpace} # ${comment}\\n`\n}\n\n/**\n * Converts the assembled array into a formatted feature string\n * Calls helper to format comment lines containing a #\n * Adds a line ending char at the end of each line => '\\n'\n * @function\n * @private\n * @param {Array<String>} assembled - Array of strings converted from a feature model\n *\n * @return {string} - Reassembled feature as a string\n */\nconst formatAssembled = assembled => {\n  // Use array.from to allow access to empty array position\n  // This ensures we can replace it with an empty string\n  return Array.from(assembled, (line, index) => {\n    // For any non-existing lines, add an empty space\n    // This can happen from empty parsed lines\n    // That have an index, but no content\n    return !exists(line)\n      ? '\\n'\n      : line.startsWith('#')\n        ? formatComment(assembled, line, index)\n        : `${line}\\n`\n  })\n    .join('')\n    .trim()\n}\n\n/**\n * Converts parsed feature models back into a formatted strings\n * @function\n * @public\n * @export\n * @param {Array|Object} toAssemble - Parsed feature model to be converted\n *\n * @return {Array<String>} - Reassembled features as an array of strings\n */\nexport const assembleFeature = toAssemble => {\n  return eitherArr(toAssemble, [toAssemble]).map(feature => {\n    let assembled = []\n    !isObj(feature) && throwFeatureNotAnObj(feature)\n\n    addTags(assembled, feature.tags)\n    addMeta(assembled, feature)\n    addScenarios(assembled, feature)\n\n    return formatAssembled(assembled)\n  })\n}\n","import { assembleFeature } from './feature'\n\nexport const assemble = {\n  feature: assembleFeature,\n}\n","import { Steps } from './steps'\nimport { Hooks } from './hooks'\nimport { Runner } from './runner'\nimport { assemble } from './assemble'\nimport { registerParamType } from './matcher'\nimport { parseFeature, parseDefinition } from './parse'\nimport { isObj, capitalize, noOpObj, exists, isFunc, eitherArr } from '@keg-hub/jsutils'\n\n/**\n * @typedef\n * Parkin#Given - Register Given step definitions\n * Parkin#When - Register When step definitions\n * Parkin#Then - Register Then step definitions\n * Parkin#And - Register And step definitions\n * Parkin#But - Register But step definitions\n * Parkin#assemble - Object containing assemble helper methods\n * Parkin#assemble#feature - Assemble feature models into feature text\n * Parkin#run - Run step definitions against feature\n * Parkin#parse - Object containing parse helper methods\n * Parkin#parse#feature - Parse feature file text into a feature object\n * Parkin#parse#definition - Parse definition file text into a step definition objects\n * Parkin#registerSteps - Register step definitions to be accessible when running features\n * Parkin#paramTypes - Object containing param type helper methods\n * Parkin#paramTypes#register - Register custom paramTypes for step definitions\n */\n\n/**\n * Main class for handling feature files in the browser\n * Use the Steps, Runner and parser to allow executing feature file tests\n * @class\n * @public\n * @param {Object} world - Holds configuration for the running test environment\n * @param {Object} steps - Object with step type keys containing step definitions\n *\n * @returns {Object} Instance of the Parkin class\n */\nexport class Parkin {\n  constructor(world, steps) {\n    isObj(world) && this.init(world, steps)\n  }\n\n  #isInit = false\n\n  init = (world = noOpObj, steps) => {\n    if (this.#isInit)\n      return console.warn(\n        `This instance of parkin has already been initialized!`\n      )\n\n    // Set isInit, so we can't re-initialized\n    this.#isInit = true\n\n    this.steps = new Steps(world)\n    this.hooks = new Hooks()\n    this.runner = new Runner(this.steps, this.hooks)\n\n    /**\n     * Runs the step definition methods matching the steps of a feature\n     * @memberof Parkin\n     * @alias instance&period;run\n     * @param {string|Array<Object>|Object} data - Feature data as a string or parsed Feature model\n     * @param {Object} options - options object\n     * @param {string?} options.name - optional name to filter features by\n     * @param {Array<string>} options.tags - optional tags to filter features by\n     * @function\n     * @public\n     *\n     * @returns {function} - Run tests method for executing a features steps\n     */\n    this.run = this.runner.run\n\n    /**\n     * Access parse object containing feature and definition parse methods\n     * @memberof Parkin\n     * @alias instance&period;parse\n     * @function\n     * @public\n     *\n     * @property {function} feature - Method to parse a feature string into an object\n     * @property {function} definition - Method to parse a definition string an object\n     */\n    this.parse = {\n      feature: parseFeature.bind(this),\n      definition: parseDefinition.bind(this)\n    }\n\n    /**\n     * Access assemble object containing feature assemble methods\n     * @memberof Parkin\n     * @alias instance&period;assemble\n     * @function\n     * @public\n     *\n     * @property {function} feature - Method to assemble a feature model into a string\n     */\n    this.assemble = assemble\n\n    /**\n     * Access paramTypes object containing the paramTypes register method\n     * <br>Allows registering custom paramTypes within registered step definitions\n     * @memberof Parkin\n     * @alias instance&period;paramTypes\n     * @function\n     * @public\n     * @example\n     * const PK = new Parkin()\n     * PK.paramTypes.register({ ...paramType model })\n     *\n     * @returns {Object} - paramTypes object container `register` param types method\n     */\n    this.paramTypes = { register: registerParamType }\n\n    // Register in steps passed in on initialization\n    isObj(steps) && this.registerSteps(steps)\n\n    /**\n     * Step Definition Register methods\n     * @memberof Parkin\n     * @alias instance&period;When\n     * @function\n     * @public\n     * @param {string} match - Text used to matched with a features step\n     * @param {function} method - Called when a features step matches the text param\n     * @param {Object} meta - Object describing the functionality of the step definition\n     * @example\n     * const PK = new Parkin()\n     * PK.Given(`Given step definition string || regex`, ()=> {}, {})\n     * PK.When(`When step definition string || regex`, ()=> {}, {})\n     * PK.Then(`Then step definition string || regex`, ()=> {}, {})\n     * PK.And(`And step definition string || regex`, ()=> {}, {})\n     * PK.But(`But step definition string || regex`, ()=> {}, {})\n     *\n     * @returns {void}\n     */\n    this.steps.types.map(type => {\n      this[capitalize(type)] = (matcher, method, meta) =>\n        this.steps.register(`_${type}`, type, matcher, method, meta)\n    })\n  }\n\n  /**\n   * Helper for registering step definitions after the Parkin class instance has ben created\n   * @memberof Parkin\n   * @alias instance&period;registerSteps\n   * @function\n   * @public\n   * @param {Object} steps - Object with step type keys containing step definitions\n   * @example\n   *   // Example steps object passed in as the first argument\n   *   const steps = {\n   *     given: {\n   *       // Key / Value pair of matcher text and corresponding function\n   *       `I goto page {url}`: () => {},\n   *       // Value can also be an array with a function and meta data (i.e. [function, meta] )\n   *       `I goto page {url}`: [() => {}, { //...definition meta data  }],\n   *     },\n   *     when: { ... },\n   *     then: { ... }\n   *   }\n   *\n   * @returns {void}\n   */\n  registerSteps = steps => {\n    // Loop the steps object\n    Object.entries(steps).map((type, typedSteps) =>\n      // Loop each step type ( Given, When, Then, But, And )\n      Object.entries(typedSteps).map((matcher, content) =>\n        // Register the step based by type with the Step class instance\n        this.steps[capitalize(type)](matcher, ...eitherArr(content, [content]))\n      )\n    )\n  }\n}\n\n// Also export a instance of the class\n// This allows us to re-use the same instance as a singleton\nexport const PKInstance = new Parkin()\n"],"names":["isArr","value","Array","isObj","obj","isFunc","func","deepFreeze","Object","prop","noOp","noOpObj","noPropObj","content","noPropArr","exists","isStr","str","equalsNaN","val","toStr","JSON","checkCall","method","isRegex","Boolean","RX_OPTIONAL","RX_ALT","RX_PARAMETER","RX_EXPRESSION","joinRegex","RX_ANY","RX_MATCH_REPLACE","RX_DOUBLE_QUOTED","RX_SINGLE_QUOTED","RX_FLOAT","RX_INT","testMethodFill","type","Error","throwMissingSteps","throwMissingFeatureText","throwNoMatchingStep","text","ReferenceError","throwParamTypeExists","name","throwFeatureNotAnObj","feature","typeModel","regexp","useForSnippets","transformer","arg","preferForRegexpMatch","__paramTypes","any","regex","word","isQuoted","undefined","float","result","parseFloat","int","parseInt","includes","string","trim","replace","getParamTypes","registerParamType","model","key","convertTypes","matches","transformers","map","item","i","paramType","asType","filter","matchRegex","definition","match","RegExp","slice","length","toAlternateRegex","optional","split","start","middle","end","getFullOptionalText","input","precedingWord","getWordEndingAt","index","getOptionalRegex","optionalText","getParamRegex","params","spec","source","getAlternateRegex","getMatchRegex","parseMatch","matchArr","getRegexParts","defMatcher","parameters","matchAll","optionals","alts","sortedExpressions","sort","matchA","matchB","constants","REGEX_VARIANT","EXPRESSION_VARIANT","STEP_TYPES","HOOK_TYPES","FEATURE_META","hasWindow","window","hasGlobal","global","hasJasmine","jasmine","resolveGlobalObj","err","escapeStr","runRegexCheck","matcher","testRx","replaceWith","test","regexStr","args","join","convertToRegex","paramTypes","isParameter","isOptional","push","checkAlternative","altIndexes","checkAnchors","final","startsWith","endsWith","extractParameters","stepMatcher","wordMatches","parts","expectedParamLength","part","reduce","state","textIndex","wordMatchIndex","substring","isWord","partMatch","wordMatch","indexOf","matchExpression","escaped","regexAlts","convertedRegex","found","converted","definitions","variant","globalObj","sanitize","step","toString","substr","charAt","getContent","capitalize","registerFromCall","internalType","tokens","uuid","tempRegister","parent","container","registerFromParse","DEF_TYPES","types","built","eitherArr","response","Function","joinAllSteps","instance","stepDefs","concat","Steps","constructor","world","list","_world","apply","self","register","Hooks","_registeredHooks","clientHookFn","RX_NEWLINE","RX_TAG","RX_COMMENT","RX_FEATURE","RX_AS","RX_I_WANT","RX_SO_THAT","RX_IN_ORDER","RX_SCENARIO","RX_EXAMPLE","RX_BACKGROUND","RX_GIVEN","RX_WHEN","RX_THEN","RX_AND","RX_BUT","RX_ASTERISK","RegStepTags","alt","featureMetaTags","sanitizeForId","cleaned","toLowerCase","getRXMatch","line","featureFactory","tags","reason","comments","scenarios","scenarioFactory","scenario","steps","backgroundFactory","background","stepFactory","altType","addReason","checkStepTag","added","regTag","hasTag","featureMeta","metaAdded","checkTag","tagParent","featureComment","comment","ensureFeature","featuresGroup","featureText","ensureScenario","scenarioText","ensureBackground","backgroundText","setActiveParent","activeParent","nextLine","parseFeature","features","lines","parseDefinition","registered","getTestMethod","testMode","buildReporter","jasmineEnv","suites","jasmineDescribe","describe","suite","specDone","status","find","children","disable","skipTestsOnFail","getEnv","addReporter","resolveFeatures","data","runStep","stepsInstance","done","resolve","runScenario","responses","parseFeatureTags","itemMatch","filterOptions","filterName","filterTags","parsedTags","nameMatch","tagMatch","every","clientTag","filterFeatures","filtered","isMatchingFeature","matchingScenarios","Runner","hooks","options","run","PARKIN_TEST_MODE","beforeAll","afterAll","beforeEach","afterEach","getFeatures","promises","getRegistered","Promise","all","throwMissingHooks","addContent","assembled","splice","addTags","spacer","addMeta","addSteps","addScenarios","formatComment","next","prev","compareLine","pop","whiteSpace","trimStart","formatAssembled","from","assembleFeature","toAssemble","assemble","Parkin","console","warn","runner","parse","bind","registerSteps","meta","entries","typedSteps","init","PKInstance"],"mappings":"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"}