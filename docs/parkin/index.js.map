{"version":3,"file":"index.js","sources":["../../../../repos/jsutils/build/esm/isArr-a4420764.js","../../../../repos/jsutils/build/esm/isObj-2a71d1af.js","../../../../repos/jsutils/build/esm/isFunc-40ceeef8.js","../../../../repos/jsutils/build/esm/deepFreeze-0437aacd.js","../../../../repos/jsutils/build/esm/match-61fbd7dc.js","../../../../repos/jsutils/build/esm/exists-bf542cb8.js","../../../../repos/jsutils/build/esm/isNum-cc6ad9ca.js","../../../../repos/jsutils/build/esm/isStr-481ce69b.js","../../../../repos/jsutils/build/esm/parseErrorMessage-0a52f8cc.js","../../../../repos/jsutils/build/esm/toStr-0e5fe94c.js","../../../../repos/jsutils/build/esm/joinRegex-b645166a.js","../../src/matcher/patterns.js","../../src/errors.js","../../src/matcher/paramTypes.js","../../src/matcher/regex.js","../../src/constants.js","../../src/matcher/expression.js","../../src/matcher/matcher.js","../../src/steps.js","../../src/hooks.js","../../src/parse/feature.js","../../src/parse/definition.js","../../src/parse/parse.js","../../src/testMethods.js","../../src/runner.js","../../src/assemble/feature.js","../../src/assemble/assemble.js","../../src/parkin.js"],"sourcesContent":["const isArr = value => Array.isArray(value);\n\nexport { isArr as i };\n//# sourceMappingURL=isArr-a4420764.js.map\n","const isObj = obj => typeof obj === 'object' && !Array.isArray(obj) && obj !== null;\n\nexport { isObj as i };\n//# sourceMappingURL=isObj-2a71d1af.js.map\n","const isFunc = func => typeof func === 'function';\n\nexport { isFunc as i };\n//# sourceMappingURL=isFunc-40ceeef8.js.map\n","import { i as isFunc } from './isFunc-40ceeef8.js';\n\nconst deepFreeze = obj => {\n  Object.freeze(obj);\n  Object.getOwnPropertyNames(obj).map(prop => {\n    obj.hasOwnProperty(prop) && obj[prop] !== null && (typeof obj[prop] === 'object' || isFunc(obj[prop])) && !Object.isFrozen(obj[prop]) && deepFreeze(obj[prop]);\n  });\n  return obj;\n};\n\nexport { deepFreeze as d };\n//# sourceMappingURL=deepFreeze-0437aacd.js.map\n","import { i as isArr } from './isArr-a4420764.js';\nimport { i as isFunc } from './isFunc-40ceeef8.js';\nimport { d as deepFreeze } from './deepFreeze-0437aacd.js';\nimport { t as typeOf } from './typeOf-8c86a991.js';\n\nconst noOp = () => {};\nconst noOpObj = Object.freeze({});\nconst noPropObj = deepFreeze({\n  content: {}\n});\nconst noPropArr = deepFreeze([]);\n\nconst match = (matchArg, ...args) => {\n  if (!args.length) return null;\n  for (let entry of args) {\n    if (!isArr(entry)) {\n      console.error(`Matching case must be an entry (a 2-element array). Found: ${typeOf(entry)}`, entry);\n      break;\n    }\n    const [caseValueOrPredicate, valueOnMatch] = entry;\n    if (isFunc(caseValueOrPredicate) && caseValueOrPredicate(matchArg)) return valueOnMatch;\n    if (caseValueOrPredicate === matchArg) return valueOnMatch;\n  }\n  return null;\n};\nmatch.default = () => true;\n\nexport { noOpObj as a, noPropObj as b, noPropArr as c, match as m, noOp as n };\n//# sourceMappingURL=match-61fbd7dc.js.map\n","const exists = value => value === value && value !== undefined && value !== null;\n\nexport { exists as e };\n//# sourceMappingURL=exists-bf542cb8.js.map\n","const equalsNaN = val => typeof val === 'number' && val != val;\n\nconst isNum = val => typeof val === 'number' && !equalsNaN(val);\n\nexport { equalsNaN as e, isNum as i };\n//# sourceMappingURL=isNum-cc6ad9ca.js.map\n","const isStr = str => typeof str === 'string';\n\nexport { isStr as i };\n//# sourceMappingURL=isStr-481ce69b.js.map\n","import { v as validate } from './validate-0eec5ac6.js';\nimport { i as isArr } from './isArr-a4420764.js';\nimport { i as isObj } from './isObj-2a71d1af.js';\nimport { i as isFunc } from './isFunc-40ceeef8.js';\nimport { h as hasOwn } from './hasOwn-deb5bbb8.js';\nimport { i as isStr } from './isStr-481ce69b.js';\nimport { i as isNum } from './isNum-cc6ad9ca.js';\nimport { d as deepClone } from './deepClone-8a68e415.js';\nimport { i as isEmpty } from './isEmpty-324adee6.js';\n\nconst checkCall = (method, ...params) => {\n  return isFunc(method) ? method(...params) : undefined;\n};\n\nconst complement = predicate => {\n  const [valid] = validate({\n    predicate\n  }, {\n    predicate: isFunc\n  });\n  return valid ? (...args) => !predicate(...args) : null;\n};\n\nconst eitherFunc = (func1, func2) => isFunc(func1) && func1 || func2;\n\nconst debounce = (func, wait = 250, immediate = false) => {\n  let timeout;\n  function wrapFunc(...args) {\n    if (!isFunc(func)) return null;\n    const context = this;\n    const later = () => {\n      timeout = null;\n      !immediate && func.apply(context, args);\n    };\n    const callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) return isFunc(func) && func.apply(context, args);\n  }\n  return wrapFunc;\n};\n\nconst doIt = (...args) => {\n  const params = args.slice();\n  const num = params.shift();\n  const bindTo = params.shift();\n  const cb = params.pop();\n  if (!isNum(num) || !isFunc(cb)) return [];\n  const doItAmount = new Array(num);\n  const responses = [];\n  for (let i = 0; i < doItAmount.length; i++) {\n    const data = cb.call(bindTo, i, ...params);\n    if (data === false) break;\n    responses.push(data);\n  }\n  return responses;\n};\n\nconst hasDomAccess = () => {\n  try {\n    return !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n  } catch (error) {\n    return false;\n  }\n};\n\nconst memorize = (func, getCacheKey, limit = 1) => {\n  if (!isFunc(func) || getCacheKey && !isFunc(getCacheKey)) return console.error('Error: Expected a function', func, getCacheKey);\n  let memorized = function () {\n    const cache = memorized.cache;\n    const key = getCacheKey ? getCacheKey.apply(this, arguments) : arguments[0];\n    if (hasOwn(cache, key)) return cache[key];\n    const result = func.apply(this, arguments);\n    isNum(limit) && Object.keys(cache).length < limit ? cache[key] = result : memorized.cache = {\n      [key]: result\n    };\n    return result;\n  };\n  memorized.cache = {};\n  memorized.destroy = () => {\n    getCacheKey = undefined;\n    memorized.cache = undefined;\n    memorized.destroy = undefined;\n    memorized = undefined;\n  };\n  return memorized;\n};\n\nconst runSeq = async (asyncFns = [], options = {}) => {\n  const [valid] = validate({\n    asyncFns\n  }, {\n    asyncFns: isArr\n  });\n  if (!valid) return [];\n  const {\n    cloneResults = false,\n    returnOriginal = true\n  } = options;\n  const results = [];\n  for (const fn of asyncFns) {\n    const result = isFunc(fn) ? await fn(results.length, cloneResults ? deepClone(results) : results) : returnOriginal ? fn : undefined;\n    results.push(result);\n  }\n  return results;\n};\n\nconst timedRun = async (fn, ...args) => {\n  const [valid] = validate({\n    fn\n  }, {\n    fn: isFunc\n  });\n  if (!valid) return [undefined, -1];\n  const startTime = new Date();\n  const result = await fn(...args);\n  return [result, new Date() - startTime];\n};\n\nconst throttle = (func, wait = 100) => {\n  let waiting = false;\n  return function (...args) {\n    if (waiting) return;\n    waiting = true;\n    func.apply(this, args);\n    return setTimeout(() => {\n      waiting = false;\n    }, wait);\n  };\n};\n\nconst throttleLast = (func, cb, wait = 100) => {\n  let throttleTimeout;\n  return function (...args) {\n    if (throttleTimeout) clearTimeout(throttleTimeout);\n    throttleTimeout = setTimeout(() => {\n      func.apply(this, args);\n      clearTimeout(throttleTimeout);\n    }, wait);\n    typeof cb === 'function' && cb();\n  };\n};\n\nconst limbo = promise => {\n  return !promise || !isFunc(promise.then) ? [new Error(`A promise or thenable is required as the first argument!`), null] : promise.then(data => [null, data]).catch(err => [err, undefined]);\n};\n\nconst uuid = a => a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid);\n\nconst parseErrorMessage = exception => {\n  return isStr(exception) && !isEmpty(exception) ? exception : isObj(exception) ? exception.message : null;\n};\n\nexport { complement as a, doIt as b, checkCall as c, debounce as d, eitherFunc as e, throttle as f, throttleLast as g, hasDomAccess as h, limbo as l, memorize as m, parseErrorMessage as p, runSeq as r, timedRun as t, uuid as u };\n//# sourceMappingURL=parseErrorMessage-0a52f8cc.js.map\n","import { i as isStr } from './isStr-481ce69b.js';\n\nconst toStr = val => val === null || val === undefined ? '' : isStr(val) ? val : JSON.stringify(val);\n\nexport { toStr as t };\n//# sourceMappingURL=toStr-0e5fe94c.js.map\n","import './validate-0eec5ac6.js';\nimport { i as isArr } from './isArr-a4420764.js';\nimport './match-61fbd7dc.js';\nimport { i as isStr } from './isStr-481ce69b.js';\n\nconst isRegex = val => Boolean(val && val instanceof RegExp);\n\nconst getRegexSource = maybeRx => isRegex(maybeRx) ? maybeRx.source : isStr(maybeRx) ? maybeRx : null;\n\nconst parseArgs = args => {\n  if (isArr(args[0])) return [args[0], args[1]];\n  const last = args[args.length - 1];\n  const options = isStr(last) ? last : undefined;\n  const expressions = options ? args.splice(0, args.length - 1) : args;\n  return [expressions, options];\n};\nconst joinRegex = (...args) => {\n  const [expressions, options] = parseArgs(args);\n  const source = expressions.reduce((joined, next) => {\n    const nextSource = getRegexSource(next);\n    return !nextSource ? joined : joined === '' ? nextSource : `${joined}|${nextSource}`;\n  }, '');\n  return new RegExp(`(${source})`, options);\n};\n\nexport { getRegexSource as g, isRegex as i, joinRegex as j };\n//# sourceMappingURL=joinRegex-b645166a.js.map\n","import { joinRegex } from '@keg-hub/jsutils'\n\nexport const RX_OPTIONAL = /\\w*\\([^)]*?\\)/\n\nexport const RX_ALT = /\\s*\\S*\\/\\S*\\s*/\n\nexport const RX_PARAMETER = /\\s*{(.*?)}\\s*/\n\nexport const RX_EXPRESSION = joinRegex(RX_PARAMETER, RX_OPTIONAL, 'g')\n\nexport const RX_ANY = /(.*)/\n\nexport const RX_MATCH_REPLACE = /{|}/g\n\nexport const RX_DOUBLE_QUOTED = /\"[^\"]+\"/\n\nexport const RX_SINGLE_QUOTED = /'[^']+'/\n\nexport const RX_FLOAT = /-?[0-9]+[.][0-9]+/\n\nexport const RX_INT = /-?[0-9]+/\n","/*\n * Helper method to use the a test method can not be found on the global scope\n * @function\n * @public\n * @export\n * @param {string} type - Name of test method to get from the global scope\n *\n * @returns {function} - Test method\n */\nexport const testMethodFill = type => {\n  /*\n   * Internal method that throws an error when a test method does not exist on the global scope\n   * @function\n   * @private\n   * @inner\n   *\n   * @returns {void}\n   */\n  return () => {\n    throw new Error(\n      `` +\n        `Test method ${type} does not exist on the global scope.\\n` +\n        `Please ensure ${type} exists before calling the run method!\\n`\n    )\n  }\n}\n\n/**\n * Throws an error when a Steps class instance is not passed to the runner class constructor\n * @function\n * @public\n * @export\n *\n * @returns {void}\n */\nexport const throwMissingSteps = () => {\n  throw new Error(\n    `Runner class constructor requires an instance of the Steps class`\n  )\n}\n\n/**\n * Throws an error when a Hooks class instance is not passed to the runner class constructor\n * @function\n * @public\n * @export\n *\n * @returns {void}\n */\nexport const throwMissingHooks = found => {\n  throw new Error(\n    `Runner class constructor requires an instance of the Hooks class. Found: ${found}`\n  )\n}\n\n/**\n * Throws an error when a feature text is not passed to the Runner class instance\n * @function\n * @public\n * @export\n *\n * @returns {void}\n */\nexport const throwMissingFeatureText = () => {\n  throw new Error(\n    `Runner class requires feature text when calling the run method`\n  )\n}\n\n/**\n * Throws an error when a feature step does not match a step definition\n * @function\n * @public\n * @export\n * @param {string} text - Text that does not match a registered step definition\n *\n * @returns {void}\n */\nexport const throwNoMatchingStep = text => {\n  throw new ReferenceError(text)\n}\n\n/**\n * Throws an error when a registering a param type that already exists\n * @function\n * @public\n * @export\n * @param {string} name - Name of the param type that is being registered\n *\n * @returns {void}\n */\nexport const throwParamTypeExists = () => {\n  throw new Error(`Cannot register param type \"${name}\". It already exists!`)\n}\n\n/**\n * Throws an error when a assembling a parsed feature, and no parsed feature object exists\n * @function\n * @public\n * @export\n * @param {*} feature - Argument that was passed instead of the parsed feature object\n *\n * @returns {void}\n */\nexport const throwFeatureNotAnObj = feature => {\n  throw new Error(\n    `Assemble feature requires an object matching the feature model spec!`,\n    feature\n  )\n}\n","import {\n  noOpObj,\n  toStr,\n  exists,\n  isQuoted,\n  checkCall,\n  equalsNaN,\n  joinRegex,\n} from '@keg-hub/jsutils'\n\nimport {\n  RX_ANY,\n  RX_FLOAT,\n  RX_INT,\n  RX_DOUBLE_QUOTED,\n  RX_SINGLE_QUOTED,\n} from './patterns'\n\nimport { throwParamTypeExists } from '../errors'\n\n/**\n * Default param type model used when registering param types\n * @type {Object}\n */\nconst typeModel = {\n  name: '',\n  regexp: '',\n  type: 'string',\n  useForSnippets: true,\n  transformer: arg => arg,\n  preferForRegexpMatch: false,\n}\n\n/**\n * Maps param types to function, for type conversion\n * Follows the default conversions for cucumber expressions\n * See https://cucumber.io/docs/cucumber/cucumber-expressions/\n * @type {Object}\n */\nconst __paramTypes = {\n  any: {\n    ...typeModel,\n    name: 'any',\n    regex: RX_ANY,\n  },\n  word: {\n    ...typeModel,\n    name: 'word',\n    regex: RX_ANY,\n    transformer: arg => (!isQuoted(arg) ? toStr(arg) : undefined),\n  },\n  float: {\n    ...typeModel,\n    name: 'float',\n    type: 'number',\n    regex: RX_FLOAT,\n    transformer: arg => {\n      const result = parseFloat(arg)\n      return equalsNaN(result) ? undefined : result\n    },\n  },\n  int: {\n    ...typeModel,\n    name: 'int',\n    type: 'number',\n    regex: RX_INT,\n    transformer: arg => {\n      const result = parseInt(arg)\n      return arg.includes('.') || equalsNaN(result) ? undefined : result\n    },\n  },\n  string: {\n    ...typeModel,\n    name: 'string',\n    regex: joinRegex(RX_DOUBLE_QUOTED, RX_SINGLE_QUOTED),\n    transformer: arg => {\n      return isQuoted(arg)\n        ? arg\n            .trim()\n            .replace(/^(\"|')/, '')\n            .replace(/(\"|')$/, '')\n        : undefined\n    },\n  },\n}\n\n/**\n * Get the registered __paramTypes\n * @function\n * @public\n * @export\n *\n * @return {Object} Registered param types\n */\nexport const getParamTypes = () => __paramTypes\n\n/**\n * Register custom types following the typeModel object\n * See https://cucumber.io/docs/cucumber/cucumber-expressions/ for more info\n * @function\n * @public\n * @export\n *\n * @return {Object} Registered param types\n */\nexport const registerParamType = (model = noOpObj, key = model.name) => {\n  __paramTypes[key]\n    ? throwParamTypeExists(key)\n    : (__paramTypes[key] = { ...typeModel, ...model })\n}\n\n/**\n * Converts the found matching values into the correct types\n * Using transformer methods of the matched paramType names\n * @function\n * @public\n * @export\n * @param {Array<string>} matches - All found dynamic arguments\n * @param {Array<function>} transformers - Matching paramTypes by index\n *\n * @returns {Array<*>} Matches converted into the correct type\n */\nexport const convertTypes = (matches, transformers) => {\n  return matches\n    .map((item, i) => {\n      const paramType = transformers[i]\n      if (!paramType) return item\n      const asType = checkCall(paramType.transformer, item)\n      return typeof asType === paramType.type ? asType : null\n    })\n    .filter(exists)\n}\n","import { noOpObj, getWordEndingAt } from '@keg-hub/jsutils'\nimport { getParamTypes } from './paramTypes'\n\nimport { RX_OPTIONAL, RX_ALT, RX_PARAMETER, RX_MATCH_REPLACE } from './patterns'\n\n/**\n * Finds a matching step definition from passed in regex\n * Then extracts the variables from the text to pass to the step definitions method\n * @function\n * @public\n * @export\n * @param {Object} step - Registered step definition\n * @param {string} text - Feature step text to compare with step definition text\n *\n * @returns {Object} Found matching step definition and matched arguments\n */\nexport const matchRegex = (step, text) => {\n  const match = text.match(new RegExp(step.match))\n\n  // Which is the original string\n  return match\n    ? { step, match: match.slice(1, match.length).filter(Boolean) }\n    : noOpObj\n}\n\n/**\n * Converts an optional expression into regex\n * @param {string} optional\n * @return {string} regex for an optional cucumber-expression\n * @example\n * toAlternateRegex('test(s)')\n * result: '(test|tests)'\n */\nexport const toAlternateRegex = optional => {\n  const split = optional.split(/(\\(|\\))/)\n\n  const [ start, , middle, , end ] = split\n\n  // no words outside of optional boundary\n  if (start === '' && end === '') return optional + '?'\n  else if (start === '') return `(${middle}|${middle}${end})`\n  else if (end === '') return `(${start}|${start}${middle})`\n  else return `(${start}${end}|${start}${middle}${end})`\n}\n\n/**\n * Gets the full text around an optional\n * @param {Array<string>} match result of optional regex match\n */\nconst getFullOptionalText = match => {\n  const text = match.input\n  const precedingWord = getWordEndingAt(text, match.index)\n  return precedingWord + match[0]\n}\n\n/**\n * Helper for `getParamRegex` to get the optional types regex\n * @param {Array<string>} match result of optional regex match\n * @return {string} the correct regex source text for an step definition\n * optional part. This regex will be used for matching values in the\n * feature step text.\n */\nconst getOptionalRegex = match => {\n  const optionalText = getFullOptionalText(match)\n  return toAlternateRegex(optionalText)\n}\n\n/**\n * Returns regex source for a given parameter type\n * @param {string} type - cucumber-expression parameter type: float, int, word, or string\n * @return {string} regex source text\n */\nexport const getParamRegex = type => {\n  const params = getParamTypes()\n  const spec = params[type] || params.any\n  return spec.regex.source\n}\n\n/**\n * Gets the right regex for an alternate part\n * @param {string} value the regex match's text\n * @return {string} regex source for an alternate part\n */\nexport const getAlternateRegex = value => {\n  return `(${value.trim().replace(/\\//g, '|')})`\n}\n\n/**\n * Helper for `parseMatch` that gets the right regex\n * for a step's dynamic part\n * @param {string} type - optional, alternate, or parameter\n * @param {string} match = regex match results\n */\nconst getMatchRegex = (type, match) => {\n  const [ val, paramType ] = match\n\n  switch (type) {\n  case 'parameter':\n    return new RegExp(getParamRegex(paramType))\n  case 'optional':\n    return new RegExp(getOptionalRegex(match))\n  case 'alternate':\n    return new RegExp(getAlternateRegex(val))\n  default:\n    return null\n  }\n}\n\n/**\n * Formats the regex match result into an object,\n * with some computed values\n * @param {Array} matchArr\n * @param {string} type\n */\nconst parseMatch = (matchArr, type = 'other') => {\n  const val = matchArr[0]\n\n  return {\n    text: val.trim(),\n    index: matchArr.index,\n    input: matchArr.input,\n    regex: getMatchRegex(type, matchArr),\n    type,\n    ...(type === 'parameter' && {\n      paramType: val.trim().replace(RX_MATCH_REPLACE, ''),\n    }),\n  }\n}\n\n/**\n * Extracts all the dynamic parts to a step definition's match text\n * @param {string} stepMatcher - step definition match text\n * @return {Array<Object>} array of matches. See `parseMatch` for the structure.\n * @example\n * const parts = getRegexParts('I eat {int} apple(s)')\n * result:\n * [\n *  { type: 'parameter', text: '{int}', regex: /-?[0-9]+/, paramType: 'int', ... } ,\n *  { type: 'optional', text: 'apple(s)', regex: /(apple|apples)/, ... } ,\n * ]\n */\nexport const getRegexParts = stepMatcher => {\n  const parameters = [\n    ...stepMatcher.matchAll(new RegExp(RX_PARAMETER, 'gi')),\n  ].map(match => parseMatch(match, 'parameter'))\n\n  const optionals = [\n    ...stepMatcher.matchAll(new RegExp(RX_OPTIONAL, 'gi')),\n  ].map(match => parseMatch(match, 'optional'))\n\n  const alts = [...stepMatcher.matchAll(new RegExp(RX_ALT, 'gi'))].map(match =>\n    parseMatch(match, 'alternate')\n  )\n\n  // sort matched expressions by their index in the text\n  const sortedExpressions = [ ...parameters, ...optionals, ...alts ].sort(\n    (matchA, matchB) => matchA.index - matchB.index\n  )\n\n  return sortedExpressions\n}\n","import { deepFreeze } from '@keg-hub/jsutils'\n\nexport const constants = deepFreeze({\n  REGEX_VARIANT: 'regex',\n  EXPRESSION_VARIANT: 'expression',\n  STEP_TYPES: [ 'given', 'when', 'then', 'and', 'but' ],\n  HOOK_TYPES: [ 'beforeAll', 'afterAll', 'beforeEach', 'afterEach' ],\n  FEATURE_META: [ 'feature', 'perspective', 'desire', 'reason', 'comments' ],\n})\n","import {\n  matchRegex,\n  getRegexParts,\n  getParamRegex,\n  toAlternateRegex,\n  getAlternateRegex,\n} from './regex'\n\nimport {\n  RX_OPTIONAL,\n  RX_ALT,\n  RX_EXPRESSION,\n  RX_MATCH_REPLACE,\n  RX_PARAMETER,\n} from './patterns'\n\nimport { noOpObj, isFunc } from '@keg-hub/jsutils'\nimport { getParamTypes, convertTypes } from './paramTypes'\n\nconst inBrowser = Boolean(typeof window !== 'undefined')\n\n/**\n * Escapes a string so it can be converted into a regular expression\n * @function\n * @private\n * @param {string} str - Step match text to be escaped\n *\n * @return {string} Escaped string to allow converting into a regular expression\n */\nconst escapeStr = str => {\n  return inBrowser\n    ? str.replace(/[|\\\\[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d')\n    : str\n}\n\n/**\n * Replace the passed in matcher string with the passed in replaceWith data based on the testRx\n * @function\n * @private\n * @param {string} match - Step match text from feature scenario\n * @param {string} testRx - Regular expression to find matching text within the matcher text\n * @param {string|function} replaceWith - Data to replace the matched data with\n *                                        Automatically called when it's function\n *\n * @return {string} match string with matched content replaced with regex\n */\nconst runRegexCheck = (matcher, testRx, replaceWith) => {\n  if (!testRx.test(matcher)) return matcher\n\n  // Set the default regex match\n  let regexStr = matcher\n  // Replace any expressions with regex, and convert the param types\n  matcher.replace(testRx, (...args) => {\n    const match = args[0].trim()\n    const [ start, ...end ] = regexStr.split(match)\n    const replace = isFunc(replaceWith) ? replaceWith(...args) : replaceWith\n    regexStr = `${start}${replace}${end.join(match)}`\n  })\n\n  return regexStr\n}\n\n/**\n * Find all expressions in the match string, and convert them into into regex\n * @function\n * @private\n * @param {string} match - Step match text from feature scenario\n *\n * @return {Object} { regex: match string with expression replaced, transformers: Array of transformer objects }\n */\nconst convertToRegex = match => {\n  const paramTypes = getParamTypes()\n  const transformers = []\n  const regex = runRegexCheck(match, RX_EXPRESSION, (val, ...args) => {\n    // Get the expression type\n    const type = val.trim().replace(RX_MATCH_REPLACE, '')\n    const isParameter = val.match(RX_PARAMETER)\n    const isOptional = val.match(RX_OPTIONAL)\n\n    // Add the transformer for the type to the transformers array\n    isParameter && transformers.push(paramTypes[type] || paramTypes.any)\n\n    // Return the regex\n    return isParameter\n      ? getParamRegex(type)\n      : isOptional\n        ? toAlternateRegex(val)\n        : val\n  })\n\n  return { regex, transformers }\n}\n\n/**\n * Find all alternate syntax in the match string, and convert them into into regex\n * @function\n * @private\n * @param {string} match - Step match text from feature scenario\n *\n * @return {string} match string with alternate syntax replaced\n */\nconst checkAlternative = match => {\n  const altIndexes = []\n  const regex = runRegexCheck(\n    match,\n    new RegExp(RX_ALT, 'g'),\n    // Use a non-capture group to allow matching, but don't include in the results (?:)\n    getAlternateRegex\n  )\n\n  return { regex, altIndexes }\n}\n\n/**\n * Adds regex anchors to the ends of the regex string, if it needs them\n * @param {string} str\n * @return {string} with anchors\n */\nconst checkAnchors = str => {\n  let final = str\n  if (!str.startsWith('^')) {\n    final = '^' + final\n  }\n  if (!str.endsWith('$')) {\n    final += '$'\n  }\n\n  return { regex: final }\n}\n\n/**\n * Extracts the dynamic cucumber-expression parameters from the text,\n * given the step matcher template and the fullMatchResults\n * @param {string} text\n * @param {RegExp} stepMatcher\n * @param {Array} wordMatches - matches for the {word} params\n */\nconst extractParameters = (text, stepMatcher, wordMatches) => {\n  // gets an array of each dynamic element of the step match text,\n  // including: params (e.g. {float}), optionals (e.g. test(s))\n  // and alternate text (e.g. required/optional)\n  const parts = getRegexParts(stepMatcher)\n\n  const expectedParamLength = parts.filter(part => part.type === 'parameter')\n    .length\n\n  // extract the params from the text, using the parts array\n  const result = parts.reduce(\n    (state, part) => {\n      const { params, textIndex, wordMatchIndex } = state\n\n      // look at the section of the text we haven't already evaluated\n      const substring = text.substring(textIndex)\n\n      const isWord = part.paramType === 'word'\n      const partMatch = substring.match(part.regex)\n      const wordMatch = {\n        0: wordMatches[wordMatchIndex],\n        index: substring.indexOf(wordMatches[wordMatchIndex]),\n      }\n\n      // if matching a param {word}, then use the wordMatch, because\n      // it contains all the {word} matches properly\n      const match = isWord ? wordMatch : partMatch\n      if (!match) return state\n\n      // add the matched parameter if the current part is a param and a match exists\n      part.type === 'parameter' && match && params.push(match[0])\n\n      return {\n        params,\n\n        // increment text index so that we don't reevaluate the same text in future iterations\n        textIndex: textIndex + (match && match.index + match[0].length),\n\n        // increment match index so we don't repeat a word in future iterations\n        wordMatchIndex: wordMatchIndex + (isWord && 1),\n      }\n    },\n    { params: [], textIndex: 0, wordMatchIndex: 0 }\n  )\n\n  return expectedParamLength === result.params.length ? result.params : null\n}\n\n/**\n * Finds a matching step definition from passed in expression text\n * Then extracts the variables from the text to pass to the step definitions method\n * Converts expression strings into regex then calls the matchRegex method\n * @function\n * @public\n * @export\n * @param {Object} step - Registered step definition\n * @param {string} text - Feature step text to compare with step definition text\n *\n * @returns {Object}\n * @returns {Object} Found matching step definition and matched arguments\n *  - form: { step, match: Array of Arguments to pass to step function }\n */\nexport const matchExpression = (step, text) => {\n  const escaped = escapeStr(step.match)\n  const { regex: regexAlts } = checkAlternative(escaped)\n  const { regex: convertedRegex, transformers } = convertToRegex(regexAlts)\n  const { regex: match } = checkAnchors(convertedRegex)\n\n  // Then call the regex matcher to get the content\n  const found = matchRegex({ ...step, match }, text)\n\n  // If no found step definition of match, return an empty object\n  if (!found || !found.step || !found.match) return noOpObj\n\n  // get all the parameters, without any type coercion\n  const params = extractParameters(text, step.match, found.match)\n  if (!params) return noOpObj\n\n  // Convert the found variables into their type based on the mapped transformers\n  const converted = convertTypes(params, transformers)\n\n  // If the conversion fails, and no variable or not enough variables are returned,\n  // Then assume the type does not match, so the step does not match.\n  // Otherwise return the matched step definition, and the converted variables\n  return converted.length !== params.length\n    ? noOpObj\n    : { step, match: converted }\n}\n","import { matchRegex } from './regex'\nimport { constants } from '../constants'\nimport { noOpObj } from '@keg-hub/jsutils'\nimport { matchExpression } from './expression'\n\nconst { REGEX_VARIANT } = constants\n\n/**\n * Finds a matching registered step definition from the passed in stepDefs and text\n * Treats all non-regex step variants as expressions\n * @function\n * @public\n * @export\n * @param {Array<Object>} stepDefs - All Registered step definitions\n * @param {string} text - Feature step text to compare with step definition text\n *\n * @returns {Object} Found matching step definition and matched arguments\n */\nexport const matcher = (stepDefs, text) => {\n  return stepDefs.reduce((found, step) => {\n    return found.match || !step.match\n      ? found\n      : step.variant !== REGEX_VARIANT\n        ? matchExpression(step, text)\n        : matchRegex(step, text)\n  }, noOpObj)\n}\n","import { matcher } from './matcher'\nimport { constants } from './constants'\nimport { throwNoMatchingStep } from './errors'\nimport { capitalize, eitherArr, isStr } from '@keg-hub/jsutils'\nconst { REGEX_VARIANT, EXPRESSION_VARIANT, STEP_TYPES } = constants\n\n/**\n * Sanitize the step definition text to be used as the name\n * @function\n * @private\n * @param {Object} step - Parsed step definition object\n *\n * @returns {string} Sanitized string version of the step definition text\n */\nconst sanitize = step => {\n  let name = step.match.toString()\n  if (name[0] === '^') name = name.substr(1)\n  if (name.charAt(name.length - 1) === '$') name = name.slice(0, -1)\n\n  return name.replace(/\\(\\?:([^\\|]+)+\\|+([^\\)]+)?\\)/, '$1')\n}\n\n/**\n * Builds the text content of a step definition call\n * @function\n * @private\n * @param {Object} step - Parsed step definition object\n * @param {string} step.type - Type of step definition this step belongs to\n * @param {string} step.match - Text used to match with a features step\n * @param {function} step.method - Called when a features step matches match property\n * @param {string} step.variant - Syntax used in the match property\n *\n * @returns {string} - Built text content of the step definition\n */\nconst getContent = step => {\n  const match =\n    step.variant === REGEX_VARIANT ? step.match.toString() : `\"${step.match}\"`\n\n  return `${capitalize(step.type)}(${match}, ${step.method.toString()})`\n}\n\n/**\n * Registers a step definition by type\n * @function\n * @private\n * @param {string} internalType - Internal references to the step definition type\n * @param {string} type - Type of step definition to search when matching\n * @param {string} match - Text used to match with a features step\n * @param {function} method - Called when a features step matches match property\n *\n * @returns {void}\n */\nconst registerFromCall = function (internalType, type, match, method) {\n  const step = {\n    type,\n    match,\n    method,\n    variant:\n      match.toString().indexOf('/') === 0 ? REGEX_VARIANT : EXPRESSION_VARIANT,\n  }\n\n  step.name = sanitize(step)\n  step.content = getContent(step)\n\n  this[internalType].push(step)\n\n  return step\n}\n\n/**\n * Registers a parsed step definition object\n * @function\n * @private\n * @param {Array|Object} definitions - Array of parsed definition objects\n *                                    Or a single parsed definition object\n *\n * @returns {void}\n */\nconst registerFromParse = function (definitions) {\n  // Loop over the passed in definitions\n  return eitherArr(definitions, [definitions]).map(definition => {\n    // Create a dynamic function calling the definition.content\n    // The definition.content should be a call to a global Given, When, Then method\n    // Which is injected from the Steps class instance ( this )\n    const step = Function(`return (Given, When, Then, And, But) => {\n        return ${definition.content}\n      }`)()(this.Given, this.When, this.Then, this.And, this.But)\n\n    // Merge the returned step with the initial definition\n    return { ...step, ...definition }\n  })\n}\n\n/**\n * Allows registering step definition matchs and functions\n * Which are used to map to steps of a parsed feature file\n * @class\n * @public\n * @param {Object} world - Holds configuration for the running test environment\n *\n * @returns {Object} Instance of the Steps class\n */\nexport class Steps {\n  /**\n   * Allowed step definition types\n   * @memberof Steps\n   * @type {Array}\n   * @private\n   */\n  types = STEP_TYPES\n\n  constructor(world) {\n    this._world = world || {}\n    const self = this\n    /**\n     * Creates helpers for registering step definitions by type\n     * @memberof Steps\n     * @function\n     * @public\n     * @param {string} match - Text used to matched with a features step\n     * @param {function} method - Function called when a features step text matches the text param\n     * @example\n     * const steps = new Steps({})\n     * steps.Given(`text`, ()=> {})\n     *\n     * @returns {void}\n     */\n    this.types.map(type => {\n      const internalType = `_${type}`\n      this[internalType] = []\n      this[capitalize(type)] = (match, method) => {\n        return self.register(internalType, type, match, method)\n      }\n    })\n  }\n\n  /**\n   * Finds a matching step definition from the passed in list and text can calls it\n   * This is the method the actually calls a step definition function\n   * @memberof Steps\n   * @function\n   * @public\n   * @param {Array<Object>} list - Group of registered step definition\n   * @param {string} text - Feature step text to compare with step definition text\n   *\n   * @returns {*} - Response from the step definition function\n   */\n  resolve = text => {\n    // Join all step types together when finding a match\n    // Cucumber treats all step definition types as the same when matching to step text\n    const list = this.types.reduce(\n      (stepDefs, type) => stepDefs.concat(this[`_${type}`]),\n      []\n    )\n\n    // Call the matcher to find a matching step definition\n    const { match, step } = matcher(list, text)\n\n    // If not step of match, then throw\n    // No matching step definition exists\n    if (!match || !step) return throwNoMatchingStep(text)\n\n    // Add the steps world to the match arguments\n    match.push(this._world)\n\n    // Call the step function passing the match array as arguments\n    return step.method(...match)\n  }\n\n  /**\n   * Registers a step definition by type based on passed in args\n   * @memberof Steps\n   * @function\n   * @public\n   * @param {Array} args - All arguments passed to the method\n   * @param {string|Array|Object} args.0 - Type of step definition to search when matching\n   *                                        Or an array of parsed definition objects\n   *                                        Or a single parsed definition object\n   * @param {string} args.1 - Text used to matched with a features step\n   * @param {function} args.2 - Function called when a features step text matches the text param\n   *\n   * @returns {void}\n   */\n  register = (...args) => {\n    return isStr(args[0])\n      ? registerFromCall.apply(this, args)\n      : registerFromParse.apply(this, args)\n  }\n\n  /**\n   * Clears out all registered step definitions for all types\n   * @memberof Steps\n   * @function\n   * @public\n   *\n   * @returns {void}\n   */\n  clear = () => {\n    this.types.map(type => (this[`_${type}`] = []))\n  }\n}\n","import { isFunc, noOp } from '@keg-hub/jsutils'\nimport { constants } from './constants'\n\nconst { HOOK_TYPES } = constants\n\n/**\n * Allows registering hook functions, which are then called when\n * the runner runs a feature\n * @class\n * @public\n * @returns {Object} Instance of the Hooks class\n */\nexport class Hooks {\n  /**\n   * Allowed hook types\n   * @memberof Hooks\n   * @type {Array}\n   * @private\n   */\n  types = HOOK_TYPES\n\n  constructor() {\n    this._registeredHooks = {}\n\n    /**\n     * Creates helpers for registering hooks\n     * @memberof Hooks\n     * @function\n     * @public\n     * @param {function} method - Function to be registered to the hook. They will be called when the runner runs a feature\n     * @example\n     * const hooks = new Hooks()\n     * hooks.beforeAll(() => setupEnvironment())\n     *\n     * @returns {void}\n     */\n    this.types.map(type => {\n      this[type] = clientHookFn => {\n        if (!isFunc(clientHookFn)) return\n        this._registeredHooks[type] = clientHookFn\n      }\n    })\n  }\n\n  /**\n   * @param {string} type\n   * @return {Function} the function registered to the hook type, or a noOp function by default\n   */\n  getRegistered = type => {\n    if (!this.types.includes(type))\n      throw new Error(\n        `Expected client hook type to be one of ', ${HOOK_TYPES.join(', ')}.\n         Found: ${type}`\n      )\n\n    return this._registeredHooks[type] || noOp\n  }\n}\n","import { uuid } from '@keg-hub/jsutils'\n\n/**\n * Regular expressions for matching feature file keywords\n * @type {object}\n */\nconst RX_NEWLINE = /\\r?\\n/g\nconst RX_TAG = /^\\s*@(.*)$/\nconst RX_COMMENT = /^\\s*#(.*)$/\nconst RX_FEATURE = /^\\s*Feature:(.*)$/\nconst RX_AS = /^\\s*As (.*)$/\nconst RX_I_WANT = /^\\s*I want (.*)$/\nconst RX_SO_THAT = /^\\s*So that (.*)$/\nconst RX_IN_ORDER = /^\\s*In order (.*)$/\nconst RX_SCENARIO = /^\\s*Scenario:(.*)$/\nconst RX_EXAMPLE = /^\\s*Example:(.*)$/\nconst RX_BACKGROUND = /^\\s*Background:(.*)$/\nconst RX_GIVEN = /^\\s*Given (.*)$/\nconst RX_WHEN = /^\\s*When(.*)$/\nconst RX_THEN = /^\\s*Then (.*)$/\nconst RX_AND = /^\\s*And (.*)$/\nconst RX_BUT = /^\\s*But (.*)$/\nconst RX_ASTERISK = /^\\s*\\* (.*)$/\nconst RX_DOCQUOTES = /^\\s*\"\"\"\\s*(.*)$/\nconst RX_DOCTICKS = /^\\s*```\\s*(.*)$/\nconst RX_DATATABLE = /^\\s*\\|\\s*(.*)\\|\\s*$/\n\n/**\n * Regular expressions and types for matching step keywords\n * @type {Array}\n * @private\n */\nconst RegStepTags = [\n  { regex: RX_GIVEN, type: 'given' },\n  { regex: RX_WHEN, type: 'when' },\n  { regex: RX_THEN, type: 'then' },\n  { regex: RX_AND, type: 'and', alt: 'when' },\n  { regex: RX_BUT, type: 'but', alt: 'when' },\n  { regex: RX_ASTERISK, type: 'and', alt: 'when' },\n]\n\n/**\n * Regular expressions and types for matching feature meta data keywords\n * @type {Array}\n * @private\n */\nconst featureMetaTags = [\n  { regex: RX_AS, key: 'perspective' },\n  { regex: RX_I_WANT, key: 'desire' },\n  { regex: RX_SO_THAT, key: 'reason' },\n  { regex: RX_IN_ORDER, key: 'reason' },\n]\n\n/*\n * Extracts keywords from a text string\n * @function\n * @private\n * @param {string} line - Text content to extract the keyword from\n * @param {Object} regex - Regex object used for finding a keyword\n * @param {number} index - Current inject of the line being parsed\n *\n * @returns {string} - Found keyword text from the line argument\n */\nconst getRXMatch = (line, regex, index) => line.match(regex)[index].trim()\n\n/*\n * Helper factory function to build a feature object\n * @function\n * @private\n * @param {string} feature - Text containing the feature keyword and text\n * @param {number} text - The entire text of a feature file\n *\n * @returns {Object} - Parsed feature object\n */\nconst featureFactory = (feature, content, index) => {\n  return {\n    index,\n    content,\n    feature,\n    tags: [],\n    reason: [],\n    uuid: uuid(),\n    comments: [],\n    scenarios: [],\n  }\n}\n\n/*\n * Helper factory function to build a scenario object\n * @function\n * @private\n * @param {string} scenario - Text containing the scenario keyword and text\n *\n * @returns {Object} - Parsed scenario object\n */\nconst scenarioFactory = (scenario, index) => {\n  return { scenario, uuid: uuid(), steps: [], index }\n}\n\n/*\n * Helper factory function to build a step object\n * @function\n * @private\n * @param {string} type - The type of step definition\n * @param {string} step - Text containing the step text\n * @param {string} altType - The alternate type of the step definition ( And || But )\n *\n * @returns {Object} - Parsed step object\n */\nconst stepFactory = (type, step, altType, index) => {\n  const built = { step, type, uuid: uuid(), index }\n  altType && (built.altType = altType)\n\n  // TODO: Investigate calling checkDocString and checkDataTable here\n  // For doc string and data table variables of steps\n  // Will need to pass in the full text\n  // Then pase from the current line down to the end of the doc string or data table\n\n  return built\n}\n\n/*\n * Helper function to add reason text to a feature when it exists\n * @function\n * @private\n * @param {Object} feature - Parse feature object\n * @param {string} reason - Text containing the reason from the parsed feature file\n *\n * @returns {void}\n */\nconst addReason = (feature, reason, index) => {\n  reason && feature.reason.push({ content: reason, index })\n}\n\n/**\n * Check for doc strings in the steps\n * The string should be passed to the step def as the last argument\n * Space inside the doc string should be left as is\n * @function\n * @private\n * @param {Object} step - Current step being parsed into an object\n * @param {string} line - Current line being parsed\n * @param {string} text - Full text content of the feature file\n *\n * @todo Implement doc string parsing\n *\n * @return {Object} Current step being parsed with the doc string added\n */\nconst checkDocString = (step, line, text) => {\n  // TODO: doc string parsing\n  // if(!RX_DOCQUOTES.test(line) || !RX_DOCTICKS.test(line)) return step\n\n  return step\n}\n\n/**\n * Check for a data table in the in the steps content\n * The string should be passed to the step def as the last argument\n * Each line of the data stable should be split in to arguments seperated by |\n * @function\n * @private\n * @param {Object} step - Current step being parsed into an object\n * @param {string} line - Current line being parsed\n * @param {string} text - Full text content of the feature file\n *\n * @todo Implement data table parsing\n *\n * @return {Object} Current step being parsed with the doc string added\n */\nconst checkDataTable = (step, line, text) => {\n  // TODO: data table parsing\n  // if(!RX_DATATABLE.test(line)) return step\n\n  return step\n}\n\n/**\n * Checks each step tag type, and adds it to current scenario when it exists\n * @function\n * @private\n * @param {Object} scenario - Parsed scenario object of the current scenario\n * @param {string} line - Current line being parsed\n *\n * @return {boolean} - True if a line was added to the current scenario object\n */\nconst checkStepTag = (scenario, line, index) => {\n  return RegStepTags.reduce((added, regTag) => {\n    // If the line was already added, just return\n    if (added) return added\n\n    // Check if the line is a step tag\n    const hasTag = regTag.regex.test(line)\n    // If if is, add the extracted line to the steps of the current scenario\n    hasTag &&\n      scenario.steps.push(\n        stepFactory(\n          regTag.type,\n          getRXMatch(line, regTag.regex, 1),\n          regTag.alt,\n          index\n        )\n      )\n\n    // Return if the line was added to the steps\n    return hasTag\n  }, false)\n}\n\n/**\n * Checks for feature descriptive content\n * @function\n * @private\n * @param {Object} feature - Current feature being parsed into an object\n * @param {string} line - Current line being parsed\n *\n * @return {boolean} - True if a line was added to the current feature object\n */\nconst featureMeta = (feature, line, index) => {\n  return featureMetaTags.reduce((added, regTag) => {\n    if (added) return added\n\n    const hasTag = regTag.regex.test(line)\n\n    return hasTag\n      ? regTag.key === 'reason'\n          ? addReason(feature, getRXMatch(line, regTag.regex, 0), index)\n          : (feature[regTag.key] = {\n              content: getRXMatch(line, regTag.regex, 0),\n              index,\n            })\n      : hasTag\n  }, false)\n}\n\n/*\n * Checks for feature file meta-data\n * @function\n * @private\n * @param {Object} feature - Current feature being parsed into an object\n * @param {string} line - Current line being parsed\n *\n * @return {boolean} - True if a line was added to the current feature object\n */\nconst featureTag = (feature, line, index) => {\n  if (!RX_TAG.test(line)) return false\n\n  const tags = getRXMatch(line, RX_TAG, 0)\n  feature.tags = feature.tags.concat(tags.split(' '))\n  // Tags must always come before the feature directive, so storing the index is not needed\n\n  return true\n}\n\n/*\n * Checks for feature file comments\n * @function\n * @private\n * @param {Object} feature - Current feature being parsed into an object\n * @param {string} line - Current line being parsed\n * @param {number} index - Location of the current feature in the features group array\n *\n * @return {boolean} - True if a line was added to the current feature object\n */\nconst featureComment = (feature, line, index) => {\n  if (!RX_COMMENT.test(line)) return false\n\n  // const comment = getRXMatch(line, RX_COMMENT, 1)\n  // Don't use getRXMatch because we want the full white space\n  // Because comments are added globally and not by line\n  // This could cause some issues if the user starts using different white space settings\n  // But not much we can do about it\n  const comment = line.match(RX_COMMENT)[0]\n\n  feature.comments.push({ content: comment, index })\n\n  return true\n}\n\n/**\n * Check for new feature, or add feature text to current feature\n * @function\n * @private\n * @param {Array} featuresGroup - All Parsed features as an array\n * @param {Object} feature - Current feature being parsed into an object\n * @param {string} line - Current line being parsed\n * @param {string} content - Full text content of the feature file\n * @param {number} index - The current line number of the feature text content\n *\n * @return {Object} Current feature being parsed\n */\nconst ensureFeature = (featuresGroup, feature, line, content, index) => {\n  // Check for Feature: keyword text\n  if (!RX_FEATURE.test(line)) return feature\n\n  // Get the text from the line\n  const featureText = getRXMatch(line, RX_FEATURE, 1)\n\n  // If the text was not yet added, then add it\n  // Then ensure the feature was added to the full group\n  if (!feature.feature) {\n    feature.feature = featureText\n\n    // Ensure the index is added if needed\n    if (!feature.index) feature.index = index\n\n    !featuresGroup.includes(feature) && featuresGroup.push(feature)\n\n    return feature\n  }\n\n  // Otherwise create a new feature, with the feature text and content\n  return featureFactory(featureText, content, index)\n}\n\n/**\n * Check for new feature scenario, and add scenario to feature object\n * @function\n * @private\n * @param {Object} feature - Current feature being parsed into an object\n * @param {Object} scenario - Current scenario being parsed into an object\n * @param {string} line - Current line being parsed\n * @param {number} index - The current line number of the feature text content\n *\n * @return {Object} Current scenario being parsed\n */\nconst ensureScenario = (feature, scenario, line, index) => {\n  // Check for \"Scenario:\" or \"Example:\" keywords\n  if (!RX_SCENARIO.test(line) && !RX_EXAMPLE.test(line)) return scenario\n\n  // Check for \"Scenario:\", if not found then check for \"Example:\"\n  let scenarioText = getRXMatch(line, RX_SCENARIO, 1)\n  scenarioText = scenarioText || getRXMatch(line, RX_EXAMPLE, 1)\n\n  // Check if the scenario text was already added, and add it if needed\n  // Otherwise create a new scenario with the scenario text\n  !scenario.scenario\n    ? (scenario.scenario = scenarioText)\n    : (scenario = scenarioFactory(scenarioText, index))\n\n  // Ensure the line index is added\n  !scenario.index && (scenario.index = index)\n\n  // Add the scenario if needed to the current feature\n  !feature.scenarios.includes(scenario) && feature.scenarios.push(scenario)\n\n  return scenario\n}\n\n/**\n * Check for background in a feature, These steps should run before all steps of a scenario\n * Should be added to each scenario, where a background exists in the feature\n * @function\n * @private\n * @param {Object} feature - Current feature being parsed into an object\n * @param {Object} scenario - Current scenario being parsed into an object\n * @param {string} line - Current line being parsed\n *\n * @todo Implement background parsing\n *\n * @return {Object} Current background being parsed\n */\nconst checkBackground = (feature, scenario, background, line) => {\n  // TODO: Implement background parsing\n  // if(!RX_BACKGROUND.test(line)) return background\n\n  return background\n}\n\n/*\n * Parses a feature files text content into an object\n * @function\n * @public\n * @export\n * @param {string} text - Text content of a feature file\n *\n * @returns {Object} - Parsed feature file as an object\n */\nexport const feature = text => {\n  const features = []\n  const lines = (text || '').toString().split(RX_NEWLINE)\n  let scenario = scenarioFactory(false)\n  let feature = featureFactory(false, text)\n\n  /*\n   * Loop over each line of text, and compose the line with corresponding regex to find a match\n   */\n  return lines.reduce((featuresGroup, line, index) => {\n    /*\n     * Check for new feature, or parse the current features text\n     */\n    feature = ensureFeature(featuresGroup, feature, line, text, index)\n\n    /*\n     * Check for new feature scenario, and add scenario to feature object\n     */\n    scenario = ensureScenario(feature, scenario, line, index)\n\n    /*\n     * Check for new feature scenario, and add scenario to feature object\n     */\n    // background = checkBackground(feature, scenario, background, line)\n\n    /*\n     * Check for feature and scenario content and parse the line when matched\n     */\n    featureTag(feature, line, index) ||\n      featureComment(feature, line, index) ||\n      featureMeta(feature, line, index) ||\n      checkStepTag(scenario, line, index)\n\n    return featuresGroup\n  }, features)\n}\n","import { constants } from '../constants'\nconst { REGEX_VARIANT, EXPRESSION_VARIANT } = constants\n\nconst NEWLINES_MATCH = /\\n|\\r|\\r\\n/\nconst COMMENT_MATCH = /\\/\\/.*/g\nconst MULTI_LINE_MATCH = /\\/\\*(.*\\n)*\\*\\//\nconst FIND_DEFINITION = new RegExp(\n  /(Given|When|Then)\\(('|\"|`|\\/)(.*)('|\"|`|\\/),/,\n  'gm'\n)\nconst NEXT_DEFINITION = new RegExp(/(Given|When|Then|And|But)\\(/, 'g')\n\n/*\n * Parses the definition.input, to extract out a definitions method content\n * @function\n * @private\n * @param {Array} definition - Matching response from FIND_DEFINITION regex\n *\n * @return {string} - Valid Javascript definition call as text\n */\nconst getContent = definition => {\n  // Get all content after the definition call\n  // Example => Given('some description', () => { ... })\n  //   * Removed => \"Given('some description',\"\n  //   * content === \"() => { ... })\"\n  //     * NOTE - This is a NON-VALID javascript due to the trailing )\n  const content = definition.input.split(definition[0]).pop()\n\n  // Use regex to look for other definition calls (Given,When,Then)\n  // in the remaining content after the definition call is removed\n  const found = NEXT_DEFINITION.exec(content)\n\n  // If another definition call\n  //   * Is not found - Join the content with the removed definition call from above\n  //   * Is found - Split content at the next definition call\n  //                Then return the first item from the split array\n  //                This gives us all the content of the method for a definition\n  // * NOTE - returns VALID javascript as text\n  const parsedContent = !found\n    ? `${definition[0].trim()} ${content.trim()}`\n    : `${definition[0].trim()}${content.split(found[0].trim()).shift()}`\n\n  // Removed any empty lines from the parsedContent\n  return parsedContent\n    .split(`\\n`)\n    .filter(line => line)\n    .join(`\\n`)\n}\n\n/*\n * @todo - Improve comment stripping\n * Very simple comment stripper, that only gets rid of `//` and /* ... *\\/\n * Does not cover all used cases, and most likely will fail on edge cases\n * @function\n * @private\n * @param {string} text - Definition text to strip comments from\n *\n * @return {string} - Passed in text with comments stripped\n */\nconst stripComments = text => {\n  return text\n    .trim()\n    .split(NEWLINES_MATCH)\n    .filter(line => !COMMENT_MATCH.test(line.trim()))\n    .join(`\\n`)\n    .replace(MULTI_LINE_MATCH, '')\n}\n\n/*\n * Parses a step definition file, and converts it into an object\n * Extracts each definition in a file into its own object\n * @function\n * @public\n * @export\n * @param {string} text - Full Definition file text\n *\n * @return {Array} - All parsed definition calls as objects\n */\nexport const definition = text => {\n  return Array.from(\n    // Strip all comments from the text, and find all matching definition calls\n    stripComments(text).matchAll(FIND_DEFINITION),\n    // For each found definition call, build the parsed definition object\n    definition => {\n      // Extract the content from the matching definition\n      const [ _, type, identifier, match ] = definition\n\n      // All regex variants start with /, so use that to set the variant to regex of expression\n      const variant = identifier === `/` ? REGEX_VARIANT : EXPRESSION_VARIANT\n\n      // Build and return the parsed definition object\n      return {\n        match,\n        variant,\n        type: type.toLowerCase(),\n        content: getContent(definition),\n      }\n    }\n  )\n}\n","import { feature } from './feature'\nimport { definition } from './definition'\n\nexport const parse = {\n  feature,\n  definition,\n}\n","import { noOp } from '@keg-hub/jsutils'\nimport { testMethodFill } from './errors'\n\nconst inBrowser = Boolean(typeof window !== 'undefined')\nconst HAS_JASMINE = Boolean(\n  typeof global !== 'undefined' && typeof global.jasmine !== 'undefined'\n)\n\n/**\n * Resolves a test method from the global scope\n * Returns a NOOP when getTestMethod.PARKIN_TEST_MODE is true\n * This allows testing the runner methods, without running the tests\n * @function\n * @private\n * @param {string} type - Name of test method to get from the global scope\n * @param {boolean} testMode - Allows testing the runner methods, without running the tests\n *\n * @returns {function} - Test method\n */\nexport const getTestMethod = (type, testMode) => {\n  // To write tests for the runner, we have to override the default test methods\n  // This allows testing the runner methods, without running the tests\n  return testMode ? noOp : global[type] || testMethodFill(type)\n}\n\n/**\n * Builds a custom jasmin reporter\n * Checks failed specs and sets all all specs in a suite to disable when found\n * @function\n * @private\n * @param {Object} jasmineEnv - The current jasmine environment\n *\n * @returns {Object} - Custom jasmine reporter\n */\nconst buildReporter = (jasmineEnv, testMode) => {\n  const suites = []\n  const jasmineDescribe = jasmineEnv.describe\n\n  jasmineEnv.describe = (...args) => {\n    const suite = jasmineDescribe.apply(null, args)\n    suites.push(suite)\n  }\n\n  return {\n    specDone: result => {\n      if (result.status !== 'failed') return\n\n      const suite = suites.find(suite =>\n        suite.children.find(spec => spec.result === result)\n      )\n      suite && suite.children.map(spec => spec.disable())\n    },\n  }\n}\n\n/**\n * Checks i jasmine is available on the global scope\n * If it is, then builds and adds a custom reporter to it\n * @function\n * @export\n *\n * @returns {Void}\n */\nexport const skipTestsOnFail = testMode => {\n  if (inBrowser || !HAS_JASMINE) return\n\n  const jasmineEnv = global.jasmine.getEnv()\n  jasmineEnv.addReporter(buildReporter(jasmineEnv, testMode))\n}\n","import { parse } from './parse'\nimport { getTestMethod, skipTestsOnFail } from './testMethods'\nimport { throwMissingSteps, throwMissingFeatureText } from './errors'\nimport {\n  isArr,\n  capitalize,\n  isObj,\n  isStr,\n  noOpObj,\n  eitherArr,\n} from '@keg-hub/jsutils'\n\n/**\n * Resolves and parses features based on the data type passed in\n * Ensures an array of parsed features is returned\n * @function\n * @public\n * @param {Object|Array<string|Object>|string} data - Feature content\n *\n * @returns {Array} - passed in data converted into parsed Features\n */\nconst resolveFeatures = data => {\n  return isStr(data)\n    ? parse.feature(data)\n    : isObj(data)\n      ? [data]\n      : isArr(data)\n        ? data.reduce(\n            (features, feature) => features.concat(resolveFeatures(feature)),\n            []\n          )\n        : throwMissingFeatureText()\n}\n\n/**\n * Calls the `it` global passing in a registered step function based on the step text\n * @function\n * @private\n * @param {Object} stepsInstance - Instance of the Steps class\n * @param {Object} step - Parsed Step mode object\n * @param {boolean} testMode - Allows testing the runner methods, without running the tests\n *\n * @returns {Void}\n */\nconst runStep = async (stepsInstance, step, testMode) => {\n  const test = getTestMethod('test', testMode)\n  // eslint-disable-next-line jest/no-test-callback\n  test(`${capitalize(step.type)} ${step.step}`, async done => {\n    await stepsInstance.resolve(step.step)\n    done()\n  })\n}\n\n/**\n * Loops through the passed in scenarios steps and calls runStep for each\n * @function\n * @private\n * @param {Object} stepsInstance - Instance of the Steps class\n * @param {Object} scenario - Parsed feature scenario object containing the steps to run\n * @param {boolean} testMode - Allows testing the runner methods, without running the tests\n *\n * @returns {Void}\n */\nconst runScenario = (stepsInstance, scenario, testMode) => {\n  const describe = getTestMethod('describe', testMode)\n\n  // Holder for the steps of each scenario\n  let responses = []\n  describe(`Scenario: ${scenario.scenario}`, () => {\n    // Map over the steps and call them\n    // Store the returned promise in the responses array\n    responses = scenario.steps.map(\n      async step => await runStep(stepsInstance, step, testMode)\n    )\n\n    // Ensure we resolve all promises inside the describe block\n    Promise.all(responses)\n  })\n\n  return responses\n}\n\n/**\n * @param {string} tags\n * @return {Array<string>?} A match of all words starting with '@', the tag indicator.\n * Returns false if input is invalid.\n */\nconst parseFeatureTags = tags => {\n  return isStr(tags) && tags.match(/[@]\\w*/g)\n}\n\n/**\n * @param {string?} name - name of item (feature|scenario) to check\n * @param {string | Array<string>} tags - tags of item (feature|scenario) to check\n * @param {string?} filterOptions.name - name filter\n * @param {string | Array<string>} filterOptions.tags - tags filter\n * @return {Boolean} - true if feature matches the filter options\n */\nconst itemMatch = (name = '', tags = [], filterOptions = {}) => {\n  const { name: filterName, tags: filterTags } = filterOptions\n\n  const parsedTags = isStr(filterTags)\n    ? parseFeatureTags(filterTags)\n    : eitherArr(filterTags, [])\n\n  const nameMatch = !filterName || name.includes(filterName)\n  const tagMatch =\n    !parsedTags.length ||\n    parsedTags.every(clientTag => tags.includes(clientTag))\n\n  return nameMatch && tagMatch\n}\n\n/**\n * Filters features and scenarios based on the passed in filterOptions\n * @function\n * @private\n * @param {Array} features - Features to be run\n * @param {Object} tags - Tags to filter which Features and scenarios will be run\n *  * @param {string?} filterOptions.name - name of feature\n * @param {string | Array<string>} filterOptions.tags - feature tags to match\n *\n * @returns {Array} - Filtered features that should be run\n */\nconst filterFeatures = (features, filterOptions = {}) => {\n  return features.reduce((filtered, feature) => {\n    const isMatchingFeature = itemMatch(\n      feature.feature,\n      feature.tags,\n      filterOptions\n    )\n    if (isMatchingFeature) {\n      filtered.push(feature)\n      return filtered\n    }\n\n    // check for matching scenarios, where scenarios inherit their parent feature's tags\n    const matchingScenarios = feature.scenarios.filter(scenario =>\n      itemMatch(\n        scenario.scenario,\n        [ ...(scenario.tags || []), ...(feature.tags || []) ],\n        filterOptions\n      )\n    )\n    if (matchingScenarios.length) {\n      filtered.push({\n        ...feature,\n        scenarios: matchingScenarios,\n      })\n    }\n    return filtered\n  }, [])\n}\n\n/**\n * Parses and runs the steps of a feature text string\n * Uses the registered steps of the passed in Steps class instance to evaluate the feature steps\n * @class\n * @public\n * @param {Object} stepsInstance - Instance of the Steps class\n * @param {Hooks} hooksInstance - instance of the Hooks class, storing the client's registered test callbacks\n *\n * @returns {Object} Instance of the Runner class\n */\nexport class Runner {\n  constructor(steps, hooks) {\n    !steps && throwMissingSteps()\n    !hooks && throwMissingHooks()\n\n    this.steps = steps\n    this.hooks = hooks\n  }\n\n  /**\n   * Gets the features to be run for a test\n   * @param {string|Array<Object>|Object} data - Feature data as a string or parsed Feature model\n   * @param {Object} options - Define how the steps are run\n   * @param {Array<string>? | string?} options.tags - Tags to filter which features or scenarios are run\n   * @param {string?} options.name - Name of feature\n   */\n  getFeatures = (data, options) => {\n    const features = resolveFeatures(data)\n    return filterFeatures(features, options)\n  }\n\n  /**\n   * Parses and runs the steps of a feature text string\n   * Matches each step to a registered steps of the Steps class instance\n   * @memberof Runner\n   * @function\n   * @public\n   * @param {string|Array<Object>|Object} data - Feature data as a string or parsed Feature model\n   * @param {Object} options - Define how the steps are run\n   * @param {Array<string>? | string?} options.tags - Tags to filter which features or scenarios are run\n   * @param {string?} options.name - Name of feature\n   *\n   * @returns {boolean} - whether any tests ran\n   */\n  run = async (data, options = noOpObj) => {\n    // Set if were running tests for Parkin, or external tests\n    // Only used for testing purposes\n    const testMode = this.run.PARKIN_TEST_MODE\n\n    // Setup step skip on failed\n    skipTestsOnFail(testMode)\n\n    const describe = getTestMethod('describe', testMode)\n    const beforeAll = getTestMethod('beforeAll', testMode)\n    const afterAll = getTestMethod('afterAll', testMode)\n    const beforeEach = getTestMethod('beforeEach', testMode)\n    const afterEach = getTestMethod('afterEach', testMode)\n\n    // Get all the features to be run\n    // Then filter them based on any options tags\n    const features = this.getFeatures(data, options)\n    if (!features.length) return false\n\n    // Ensures all tests resolve before ending by\n    // Using promises to resolve each feature / scenario / step\n    const promises = await features.map(async feature => {\n      let responses = []\n\n      beforeAll(this.hooks.getRegistered('beforeAll'))\n      afterAll(this.hooks.getRegistered('afterAll'))\n      beforeEach(this.hooks.getRegistered('beforeEach'))\n      afterEach(this.hooks.getRegistered('afterEach'))\n\n      // Map over the features scenarios and call their steps\n      // Store the returned promise in the responses array\n      describe(`Feature: ${feature.feature}`, () => {\n        responses = feature.scenarios.map(\n          async scenario => await runScenario(this.steps, scenario, testMode)\n        )\n\n        // Ensure we resolve all promises inside the describe block\n        Promise.all(responses)\n      })\n\n      return responses\n    })\n\n    // Ensure all promises are resolved before returning\n    await Promise.all(promises)\n\n    return true\n  }\n}\n","import { constants } from '../constants'\nimport { throwFeatureNotAnObj } from '../errors'\nimport { eitherArr, isObj, isArr, capitalize, exists } from '@keg-hub/jsutils'\n\nconst { FEATURE_META } = constants\n\n/**\n * Adds content to the assembled array based on the passed in index\n * If no index exists, then the content is added to the end\n * If the index already exists, then the content is spliced into the array at the index\n * @function\n * @private\n * @param {Array<String>} assembled - Array of strings converted from a feature model\n * @param {string} content - String to add to the assembled array\n * @param {number} index - Location in the assembled array where the content should be placed\n *\n * @return {void}\n */\nconst addContent = (assembled, content, index) => {\n  !exists(index)\n    ? assembled.push(content)\n    : exists(assembled[index])\n      ? assembled.splice(index, 0, content)\n      : (assembled[index] = content)\n}\n\n/**\n * Converts a array of tags into a string and adds them to the assembled array\n * @function\n * @private\n * @param {Array<String>} assembled - Array of strings converted from a feature model\n * @param {Array<String>} tags - Group of tags from a feature or scenario\n *\n * @return {void}\n */\nconst addTags = (assembled, tags, spacer = '') => {\n  isArr(tags) &&\n    tags.length &&\n    addContent(assembled, `${spacer}${tags.join(' ')}`)\n}\n\n/**\n * Converts a features meta data into strings and adds them to the assembled array\n * @function\n * @private\n * @param {Array<String>} assembled - Array of strings converted from a feature model\n * @param {Object} feature - Parsed feature model containing a scenarios array\n *\n * @return {void}\n */\nconst addMeta = (assembled, feature) => {\n  FEATURE_META.map(key => {\n    switch (key) {\n    case 'feature':\n      addContent(assembled, `Feature: ${feature[key]}`, feature.index)\n      break\n    case 'comments':\n      isArr(feature[key]) &&\n          feature[key].map(item =>\n            addContent(assembled, item.content, item.index)\n          )\n      break\n    case 'reason':\n      isArr(feature[key]) &&\n          feature[key].map(item =>\n            addContent(assembled, `  ${item.content}`, item.index)\n          )\n      break\n    case 'desire':\n    case 'perspective':\n      feature[key] &&\n          addContent(assembled, `  ${feature[key].content}`, feature[key].index)\n      break\n    }\n  })\n}\n\n/**\n * Converts a scenarios steps into strings and adds them to the assembled array\n * @function\n * @private\n * @param {Array<String>} assembled - Array of strings converted from a feature model\n * @param {Object} scenario - Parsed scenario model containing a steps array\n *\n * @return {void}\n */\nconst addSteps = (assembled, scenario) => {\n  isArr(scenario.steps) &&\n    scenario.steps.length &&\n    scenario.steps.map(step =>\n      addContent(\n        assembled,\n        `    ${capitalize(step.type)} ${step.step}`,\n        step.index\n      )\n    )\n}\n\n/**\n * Converts a features scenarios into strings and adds them to the assembled array\n * @function\n * @private\n * @param {Array<String>} assembled - Array of strings converted from a feature model\n * @param {Object} feature - Parsed feature model containing a scenarios array\n *\n * @return {void}\n */\nconst addScenarios = (assembled, feature) => {\n  feature.scenarios &&\n    feature.scenarios.map(scenario => {\n      addTags(assembled, scenario.tags, `  `)\n      addContent(assembled, `  Scenario: ${scenario.scenario}`, scenario.index)\n      addSteps(assembled, scenario)\n    })\n}\n\n/**\n * Checks the whitespace of adjacent lines to determine the whitespace of the comment\n * Uses the next line first, then the previous line if the next line does not exist\n * @function\n * @private\n * @param {Array<String>} assembled - Array of strings converted from a feature model\n * @param {string} line - Comment line to be formatted\n * @param {number} index - Position of the line within the assembled array\n *\n * @return {string} - Formatted comment line relative to it's adjacent lines\n */\nconst formatComment = (assembled, line, index) => {\n  const next = assembled[index + 1]\n  const prev = assembled[index - 1]\n  let compareLine = exists(next) ? next : prev\n\n  // If no line to compare with just return the comment\n  if (!compareLine) return `${line}\\n`\n\n  // Split on the comment char, so we have just the text of the comment\n  const comment = line.split('#').pop()\n\n  // Get the white space of the compose line\n  const whiteSpace = Array(\n    compareLine.length - compareLine.trimStart().length\n  ).join(' ')\n\n  // Add that to the comment and replace the comment char #\n  // This allows the comments to be spaced relative the the adjacent lines\n  // Must add an extra space after addSpace because whiteSpace is 1 space short\n  return `${whiteSpace} # ${comment}\\n`\n}\n\n/**\n * Converts the assembled array into a formatted feature string\n * Calls helper to format comment lines containing a #\n * Adds a line ending char at the end of each line => '\\n'\n * @function\n * @private\n * @param {Array<String>} assembled - Array of strings converted from a feature model\n *\n * @return {string} - Reassembled feature as a string\n */\nconst formatAssembled = assembled => {\n  // Use array.from to allow access to empty array position\n  // This ensures we can replace it with an empty string\n  return Array.from(assembled, (line, index) => {\n    // For any non-existing lines, add an empty space\n    // This can happen from empty parsed lines\n    // That have an index, but no content\n    return !exists(line)\n      ? '\\n'\n      : line.startsWith('#')\n        ? formatComment(assembled, line, index)\n        : `${line}\\n`\n  })\n    .join('')\n    .trim()\n}\n\n/**\n * Converts parsed feature models back into a formatted strings\n * @function\n * @public\n * @export\n * @param {Array|Object} toAssemble - Parsed feature model to be converted\n *\n * @return {Array<String>} - Reassembled features as an array of strings\n */\nexport const assembleFeature = toAssemble => {\n  return eitherArr(toAssemble, [toAssemble]).map(feature => {\n    let assembled = []\n    !isObj(feature) && throwFeatureNotAnObj(feature)\n\n    addTags(assembled, feature.tags)\n    addMeta(assembled, feature)\n    addScenarios(assembled, feature)\n\n    return formatAssembled(assembled)\n  })\n}\n","import { assembleFeature } from './feature'\n\nexport const assemble = {\n  feature: assembleFeature,\n}\n","import { Steps } from './steps'\nimport { Hooks } from './hooks'\nimport { parse } from './parse'\nimport { Runner } from './runner'\nimport { assemble } from './assemble'\nimport { registerParamType } from './matcher'\nimport { isObj, capitalize } from '@keg-hub/jsutils'\n\n/**\n * @typedef\n * Parkin#Given - Register Given step definitions\n * Parkin#When - Register When step definitions\n * Parkin#Then - Register Then step definitions\n * Parkin#And - Register And step definitions\n * Parkin#But - Register But step definitions\n * Parkin#assemble - Object containing assemble helper methods\n * Parkin#assemble#feature - Assemble feature models into feature text\n * Parkin#run - Run step definitions against feature\n * Parkin#parse - Object containing parse helper methods\n * Parkin#parse#feature - Parse feature file text into a feature object\n * Parkin#parse#definition - Parse definition file text into a step definition objects\n * Parkin#registerSteps - Register step definitions to be accessible when running features\n * Parkin#paramTypes - Object containing param type helper methods\n * Parkin#paramTypes#register - Register custom paramTypes for step definitions\n */\n\n/**\n * Main class for handling feature files in the browser\n * Use the Steps, Runner and parser to allow executing feature file tests\n * @class\n * @public\n * @param {Object} world - Holds configuration for the running test environment\n * @param {Object} steps - Object with step type keys containing step definitions\n *\n * @returns {Object} Instance of the Parkin class\n */\nexport class Parkin {\n  constructor(world, steps) {\n    this.steps = new Steps(world)\n    this.hooks = new Hooks()\n    this.runner = new Runner(this.steps, this.hooks)\n\n    /**\n     * Runs the step definition methods matching the steps of a feature\n     * @memberof Parkin\n     * @alias instance&period;run\n     * @param {string|Array<Object>|Object} data - Feature data as a string or parsed Feature model\n     * @param {Object} options - options object\n     * @param {string?} options.name - optional name to filter features by\n     * @param {Array<string>} options.tags - optional tags to filter features by\n     * @function\n     * @public\n     *\n     * @returns {function} - Run tests method for executing a features steps\n     */\n    this.run = this.runner.run\n\n    /**\n     * Access parse object containing feature and definition parse methods\n     * @memberof Parkin\n     * @alias instance&period;parse\n     * @function\n     * @public\n     *\n     * @property {function} feature - Method to parse a feature string into an object\n     * @property {function} definition - Method to parse a definition string an object\n     */\n    this.parse = parse\n\n    /**\n     * Access assemble object containing feature assemble methods\n     * @memberof Parkin\n     * @alias instance&period;assemble\n     * @function\n     * @public\n     *\n     * @property {function} feature - Method to assemble a feature model into a string\n     */\n    this.assemble = assemble\n\n    /**\n     * Access paramTypes object containing the paramTypes register method\n     * <br>Allows registering custom paramTypes within registered step definitions\n     * @memberof Parkin\n     * @alias instance&period;paramTypes\n     * @function\n     * @public\n     * @example\n     * const PK = new Parkin()\n     * PK.paramTypes.register({ ...paramType model })\n     *\n     * @returns {Object} - paramTypes object container `register` param types method\n     */\n    this.paramTypes = { register: registerParamType }\n\n    // Register in steps passed in on initialization\n    isObj(steps) && this.registerSteps(steps)\n\n    /**\n     * Step Definition Register methods\n     * @memberof Parkin\n     * @alias instance&period;When\n     * @function\n     * @public\n     * @param {string} match - Text used to matched with a features step\n     * @param {function} method - Called when a features step matches the text param\n     * @example\n     *\n     * @example\n     * const PK = new Parkin()\n     * PK.Given(`Given step definition matching string || regex`, ()=> {})\n     * PK.When(`When step definition matching string || regex`, ()=> {})\n     * PK.Then(`Then step definition matching string || regex`, ()=> {})\n     * PK.And(`And step definition matching string || regex`, ()=> {})\n     * PK.But(`But tep definition matching string || regex`, ()=> {})\n     *\n     * @returns {void}\n     */\n    this.steps.types.map(type => {\n      this[capitalize(type)] = (matcher, method) =>\n        this.steps.register(`_${type}`, type, matcher, method)\n    })\n  }\n\n  /**\n   * Helper for registering step definitions after the Parkin class instance has ben created\n   * @memberof Parkin\n   * @alias instance&period;registerSteps\n   * @function\n   * @public\n   * @param {Object} steps - Object with step type keys containing step definitions\n   * @example\n   *   // Example steps object passed in as the first argument\n   *   const steps = {\n   *     given: {\n   *       // Key / Value pair of matcher text and corresponding function\n   *       `I goto page {url}`: () => {},\n   *     },\n   *     when: { ... },\n   *     then: { ... }\n   *   }\n   *\n   * @returns {void}\n   */\n  registerSteps = steps => {\n    // Loop the steps object\n    Object.entries(steps).map((type, typedSteps) =>\n      // Loop each step type ( Given, When, Then )\n      Object.entries(typedSteps).map((matcher, method) =>\n        // Register the step based by type with the Step class instance\n        this.steps[capitalize(type)](matcher, method)\n      )\n    )\n  }\n}\n"],"names":["isArr","value","Array","isObj","obj","isFunc","func","deepFreeze","Object","prop","noOp","noOpObj","noPropObj","content","noPropArr","exists","equalsNaN","val","isStr","str","checkCall","method","toStr","JSON","isRegex","Boolean","RX_OPTIONAL","RX_ALT","RX_PARAMETER","RX_EXPRESSION","joinRegex","RX_ANY","RX_MATCH_REPLACE","RX_DOUBLE_QUOTED","RX_SINGLE_QUOTED","RX_FLOAT","RX_INT","testMethodFill","type","Error","throwMissingSteps","throwMissingFeatureText","throwNoMatchingStep","text","ReferenceError","throwParamTypeExists","name","throwFeatureNotAnObj","feature","typeModel","regexp","useForSnippets","transformer","arg","preferForRegexpMatch","__paramTypes","any","regex","word","isQuoted","undefined","float","result","parseFloat","int","parseInt","includes","string","trim","replace","getParamTypes","registerParamType","model","key","convertTypes","matches","transformers","map","item","i","paramType","asType","filter","matchRegex","step","match","RegExp","slice","length","toAlternateRegex","optional","split","start","middle","end","getFullOptionalText","input","precedingWord","getWordEndingAt","index","getOptionalRegex","optionalText","getParamRegex","params","spec","source","getAlternateRegex","getMatchRegex","parseMatch","matchArr","getRegexParts","stepMatcher","parameters","matchAll","optionals","alts","sortedExpressions","sort","matchA","matchB","constants","REGEX_VARIANT","EXPRESSION_VARIANT","STEP_TYPES","HOOK_TYPES","FEATURE_META","inBrowser","window","escapeStr","runRegexCheck","matcher","testRx","replaceWith","test","regexStr","args","join","convertToRegex","paramTypes","isParameter","isOptional","push","checkAlternative","altIndexes","checkAnchors","final","startsWith","endsWith","extractParameters","wordMatches","parts","expectedParamLength","part","reduce","state","textIndex","wordMatchIndex","substring","isWord","partMatch","wordMatch","indexOf","matchExpression","escaped","regexAlts","convertedRegex","found","converted","stepDefs","variant","sanitize","toString","substr","charAt","getContent","capitalize","registerFromCall","internalType","registerFromParse","definitions","eitherArr","definition","Function","Given","When","Then","And","But","Steps","constructor","world","list","types","concat","_world","apply","self","register","Hooks","_registeredHooks","clientHookFn","RX_NEWLINE","RX_TAG","RX_COMMENT","RX_FEATURE","RX_AS","RX_I_WANT","RX_SO_THAT","RX_IN_ORDER","RX_SCENARIO","RX_EXAMPLE","RX_GIVEN","RX_WHEN","RX_THEN","RX_AND","RX_BUT","RX_ASTERISK","RegStepTags","alt","featureMetaTags","getRXMatch","line","featureFactory","tags","reason","uuid","comments","scenarios","scenarioFactory","scenario","steps","stepFactory","altType","built","addReason","checkStepTag","added","regTag","hasTag","featureMeta","featureTag","featureComment","comment","ensureFeature","featuresGroup","featureText","ensureScenario","scenarioText","features","lines","NEWLINES_MATCH","COMMENT_MATCH","MULTI_LINE_MATCH","FIND_DEFINITION","NEXT_DEFINITION","pop","exec","parsedContent","shift","stripComments","from","_","identifier","toLowerCase","parse","HAS_JASMINE","global","jasmine","getTestMethod","testMode","buildReporter","jasmineEnv","suites","jasmineDescribe","describe","suite","specDone","status","find","children","disable","skipTestsOnFail","getEnv","addReporter","resolveFeatures","data","runStep","stepsInstance","done","resolve","runScenario","responses","parseFeatureTags","itemMatch","filterOptions","filterName","filterTags","parsedTags","nameMatch","tagMatch","every","clientTag","filterFeatures","filtered","isMatchingFeature","matchingScenarios","Runner","hooks","options","run","PARKIN_TEST_MODE","beforeAll","afterAll","beforeEach","afterEach","getFeatures","promises","getRegistered","Promise","all","throwMissingHooks","addContent","assembled","splice","addTags","spacer","addMeta","addSteps","addScenarios","formatComment","next","prev","compareLine","whiteSpace","trimStart","formatAssembled","assembleFeature","toAssemble","assemble","Parkin","entries","typedSteps","runner","registerSteps"],"mappings":"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"}